{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { SetUtils } from '../../../../mol-util/set';\nimport { UniqueArray } from '../../../../mol-data/generic';\nimport { sortArray } from '../../../../mol-data/util';\nimport { CifWriter } from '../../../../mol-io/writer/cif';\nimport { MmcifFormat } from '../../../../mol-model-formats/structure/mmcif';\nimport { getCifFieldType } from '../../../../mol-io/reader/cif';\nexport function getModelMmCifCategory(model, name) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  return model.sourceData.data.db[name];\n}\nexport function getUniqueResidueNamesFromStructures(structures) {\n  return SetUtils.unionMany.apply(SetUtils, structures.map(function (s) {\n    return s.uniqueResidueNames;\n  }));\n}\nexport function getUniqueEntityIdsFromStructures(structures) {\n  if (structures.length === 0) return new Set();\n  var names = structures[0].model.entities.data.id;\n  return new Set(getUniqueEntityIndicesFromStructures(structures).map(function (i) {\n    return names.value(i);\n  }));\n}\nexport function getUniqueEntityIndicesFromStructures(structures) {\n  if (structures.length === 0) return [];\n  if (structures.length === 1) return structures[0].entityIndices;\n  var ret = UniqueArray.create();\n\n  for (var _i = 0, structures_1 = structures; _i < structures_1.length; _i++) {\n    var s = structures_1[_i];\n\n    for (var _a = 0, _b = s.entityIndices; _a < _b.length; _a++) {\n      var e = _b[_a];\n      UniqueArray.add(ret, e, e);\n    }\n  }\n\n  sortArray(ret.array);\n  return ret.array;\n}\nexport function copy_mmCif_category(name, condition) {\n  return {\n    name: name,\n    instance: function (_a) {\n      var structures = _a.structures;\n      if (condition && !condition(structures[0])) return CifWriter.Category.Empty;\n      var model = structures[0].model;\n      if (!MmcifFormat.is(model.sourceData)) return CifWriter.Category.Empty;\n      var table = model.sourceData.data.db[name];\n      if (!table || !table._rowCount) return CifWriter.Category.Empty;\n      return CifWriter.Category.ofTable(table);\n    }\n  };\n}\nexport function copy_source_mmCifCategory(encoder, ctx, category) {\n  if (!MmcifFormat.is(ctx.firstModel.sourceData)) return;\n  var fs = CifWriter.fields();\n\n  if (encoder.isBinary) {\n    for (var _i = 0, _a = category.fieldNames; _i < _a.length; _i++) {\n      var f = _a[_i]; // TODO: this could be optimized\n\n      var field = classifyField(f, category.getField(f));\n      fs.add(field);\n    }\n  } else {\n    var _loop_1 = function (f) {\n      var field = category.getField(f);\n      fs.str(f, function (row) {\n        return field.str(row);\n      });\n    };\n\n    for (var _b = 0, _c = category.fieldNames; _b < _c.length; _b++) {\n      var f = _c[_b];\n\n      _loop_1(f);\n    }\n  }\n\n  var fields = fs.getFields();\n  return {\n    name: category.name,\n    instance: function () {\n      return {\n        fields: fields,\n        source: [{\n          data: void 0,\n          rowCount: category.rowCount\n        }]\n      };\n    }\n  };\n}\n\nfunction classifyField(name, field) {\n  var type = getCifFieldType(field);\n\n  if (type['@type'] === 'str') {\n    return {\n      name: name,\n      type: 0\n      /* Str */\n      ,\n      value: field.str,\n      valueKind: field.valueKind\n    };\n  } else if (type['@type'] === 'float') {\n    return CifWriter.Field.float(name, field.float, {\n      valueKind: field.valueKind,\n      typedArray: Float64Array\n    });\n  } else {\n    return CifWriter.Field.int(name, field.int, {\n      valueKind: field.valueKind,\n      typedArray: Int32Array\n    });\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model/structure/export/categories/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { SetUtils } from '../../../../mol-util/set';\r\nimport { UniqueArray } from '../../../../mol-data/generic';\r\nimport { sortArray } from '../../../../mol-data/util';\r\nimport { CifWriter } from '../../../../mol-io/writer/cif';\r\nimport { MmcifFormat } from '../../../../mol-model-formats/structure/mmcif';\r\nimport { getCifFieldType } from '../../../../mol-io/reader/cif';\r\nexport function getModelMmCifCategory(model, name) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    return model.sourceData.data.db[name];\r\n}\r\nexport function getUniqueResidueNamesFromStructures(structures) {\r\n    return SetUtils.unionMany.apply(SetUtils, structures.map(function (s) { return s.uniqueResidueNames; }));\r\n}\r\nexport function getUniqueEntityIdsFromStructures(structures) {\r\n    if (structures.length === 0)\r\n        return new Set();\r\n    var names = structures[0].model.entities.data.id;\r\n    return new Set(getUniqueEntityIndicesFromStructures(structures).map(function (i) { return names.value(i); }));\r\n}\r\nexport function getUniqueEntityIndicesFromStructures(structures) {\r\n    if (structures.length === 0)\r\n        return [];\r\n    if (structures.length === 1)\r\n        return structures[0].entityIndices;\r\n    var ret = UniqueArray.create();\r\n    for (var _i = 0, structures_1 = structures; _i < structures_1.length; _i++) {\r\n        var s = structures_1[_i];\r\n        for (var _a = 0, _b = s.entityIndices; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            UniqueArray.add(ret, e, e);\r\n        }\r\n    }\r\n    sortArray(ret.array);\r\n    return ret.array;\r\n}\r\nexport function copy_mmCif_category(name, condition) {\r\n    return {\r\n        name: name,\r\n        instance: function (_a) {\r\n            var structures = _a.structures;\r\n            if (condition && !condition(structures[0]))\r\n                return CifWriter.Category.Empty;\r\n            var model = structures[0].model;\r\n            if (!MmcifFormat.is(model.sourceData))\r\n                return CifWriter.Category.Empty;\r\n            var table = model.sourceData.data.db[name];\r\n            if (!table || !table._rowCount)\r\n                return CifWriter.Category.Empty;\r\n            return CifWriter.Category.ofTable(table);\r\n        }\r\n    };\r\n}\r\nexport function copy_source_mmCifCategory(encoder, ctx, category) {\r\n    if (!MmcifFormat.is(ctx.firstModel.sourceData))\r\n        return;\r\n    var fs = CifWriter.fields();\r\n    if (encoder.isBinary) {\r\n        for (var _i = 0, _a = category.fieldNames; _i < _a.length; _i++) {\r\n            var f = _a[_i];\r\n            // TODO: this could be optimized\r\n            var field = classifyField(f, category.getField(f));\r\n            fs.add(field);\r\n        }\r\n    }\r\n    else {\r\n        var _loop_1 = function (f) {\r\n            var field = category.getField(f);\r\n            fs.str(f, function (row) { return field.str(row); });\r\n        };\r\n        for (var _b = 0, _c = category.fieldNames; _b < _c.length; _b++) {\r\n            var f = _c[_b];\r\n            _loop_1(f);\r\n        }\r\n    }\r\n    var fields = fs.getFields();\r\n    return {\r\n        name: category.name,\r\n        instance: function () {\r\n            return { fields: fields, source: [{ data: void 0, rowCount: category.rowCount }] };\r\n        }\r\n    };\r\n}\r\nfunction classifyField(name, field) {\r\n    var type = getCifFieldType(field);\r\n    if (type['@type'] === 'str') {\r\n        return { name: name, type: 0 /* Str */, value: field.str, valueKind: field.valueKind };\r\n    }\r\n    else if (type['@type'] === 'float') {\r\n        return CifWriter.Field.float(name, field.float, { valueKind: field.valueKind, typedArray: Float64Array });\r\n    }\r\n    else {\r\n        return CifWriter.Field.int(name, field.int, { valueKind: field.valueKind, typedArray: Int32Array });\r\n    }\r\n}\r\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}