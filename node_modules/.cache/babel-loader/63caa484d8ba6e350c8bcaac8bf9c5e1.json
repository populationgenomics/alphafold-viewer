{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { IntraUnitBonds } from './data';\nimport { IntAdjacencyGraph } from '../../../../../mol-math/graph';\nimport { getElementIdx, MetalsSet, getElementThreshold, isHydrogen, getElementPairThreshold, DefaultBondComputationProps } from './common';\nimport { SortedArray } from '../../../../../mol-data/int';\nimport { getIntraBondOrderFromTable } from '../../../model/properties/atomic/bonds';\nimport { IndexPairBonds } from '../../../../../mol-model-formats/structure/property/bonds/index-pair';\nimport { ComponentBond } from '../../../../../mol-model-formats/structure/property/bonds/chem_comp';\nimport { StructConn } from '../../../../../mol-model-formats/structure/property/bonds/struct_conn';\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\nimport { equalEps } from '../../../../../mol-math/linear-algebra/3d/common';\nimport { Model } from '../../../model/model';\n\nfunction getGraph(atomA, atomB, _order, _flags, atomCount, canRemap) {\n  var builder = new IntAdjacencyGraph.EdgeBuilder(atomCount, atomA, atomB);\n  var flags = new Uint16Array(builder.slotCount);\n  var order = new Int8Array(builder.slotCount);\n\n  for (var i = 0, _i = builder.edgeCount; i < _i; i++) {\n    builder.addNextEdge();\n    builder.assignProperty(flags, _flags[i]);\n    builder.assignProperty(order, _order[i]);\n  }\n\n  return builder.createGraph({\n    flags: flags,\n    order: order\n  }, {\n    canRemap: canRemap\n  });\n}\n\nvar tmpDistVecA = Vec3();\nvar tmpDistVecB = Vec3();\n\nfunction getDistance(unit, indexA, indexB) {\n  unit.conformation.position(indexA, tmpDistVecA);\n  unit.conformation.position(indexB, tmpDistVecB);\n  return Vec3.distance(tmpDistVecA, tmpDistVecB);\n}\n\nvar __structConnAdded = new Set();\n\nfunction findIndexPairBonds(unit) {\n  var indexPairs = IndexPairBonds.Provider.get(unit.model);\n  var atoms = unit.elements;\n  var type_symbol = unit.model.atomicHierarchy.atoms.type_symbol;\n  var atomCount = unit.elements.length;\n  var maxDistance = indexPairs.maxDistance;\n  var _a = indexPairs.bonds,\n      offset = _a.offset,\n      b = _a.b,\n      _b = _a.edgeProps,\n      order = _b.order,\n      distance = _b.distance,\n      flag = _b.flag;\n  var sourceIndex = unit.model.atomicHierarchy.atomSourceIndex;\n  var invertedIndex = Model.getInvertedAtomSourceIndex(unit.model).invertedIndex;\n  var atomA = [];\n  var atomB = [];\n  var flags = [];\n  var orders = [];\n\n  for (var _aI = 0; _aI < atomCount; _aI++) {\n    var aI = atoms[_aI];\n    var isHa = type_symbol.value(aI) === 'H';\n    var srcA = sourceIndex.value(aI);\n\n    for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {\n      var bI = invertedIndex[b[i]];\n      if (aI >= bI) continue;\n\n      var _bI = SortedArray.indexOf(unit.elements, bI);\n\n      if (_bI < 0) continue;\n      if (isHa && type_symbol.value(bI) === 'H') continue;\n      var d = distance[i];\n      var dist = getDistance(unit, aI, bI);\n\n      if (d !== -1 && equalEps(dist, d, 0.5) || dist < maxDistance) {\n        atomA[atomA.length] = _aI;\n        atomB[atomB.length] = _bI;\n        orders[orders.length] = order[i];\n        flags[flags.length] = flag[i];\n      }\n    }\n  }\n\n  return getGraph(atomA, atomB, orders, flags, atomCount, false);\n}\n\nfunction findBonds(unit, props) {\n  var maxRadius = props.maxRadius;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n  var atomCount = unit.elements.length;\n  var atoms = unit.elements,\n      residueIndex = unit.residueIndex,\n      chainIndex = unit.chainIndex;\n  var _b = unit.model.atomicHierarchy.atoms,\n      type_symbol = _b.type_symbol,\n      label_atom_id = _b.label_atom_id,\n      label_alt_id = _b.label_alt_id,\n      label_comp_id = _b.label_comp_id;\n  var label_seq_id = unit.model.atomicHierarchy.residues.label_seq_id;\n  var index = unit.model.atomicHierarchy.index;\n  var byEntityKey = unit.model.sequence.byEntityKey;\n  var query3d = unit.lookup3d;\n  var structConn = StructConn.Provider.get(unit.model);\n  var component = ComponentBond.Provider.get(unit.model);\n  var structConnExhaustive = StructConn.isExhaustive(unit.model);\n  var atomA = [];\n  var atomB = [];\n  var flags = [];\n  var order = [];\n  var lastResidue = -1;\n  var componentMap = void 0;\n  var isWatery = true,\n      isDictionaryBased = true,\n      isSequenced = true;\n  var structConnAdded = __structConnAdded;\n\n  for (var _aI = 0; _aI < atomCount; _aI++) {\n    var aI = atoms[_aI];\n    var elemA = type_symbol.value(aI);\n    if (isWatery && (elemA !== 'H' || elemA !== 'O')) isWatery = false;\n    var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);\n    var hasStructConn = false;\n\n    if (structConnEntries) {\n      for (var _c = 0, structConnEntries_1 = structConnEntries; _c < structConnEntries_1.length; _c++) {\n        var se = structConnEntries_1[_c];\n        var partnerA = se.partnerA,\n            partnerB = se.partnerB; // symmetry must be the same for intra-unit bonds\n\n        if (partnerA.symmetry !== partnerB.symmetry) continue;\n        var p = partnerA.atomIndex === aI ? partnerB : partnerA;\n\n        var _bI = SortedArray.indexOf(unit.elements, p.atomIndex);\n\n        if (_bI < 0 || atoms[_bI] < aI) continue;\n        atomA[atomA.length] = _aI;\n        atomB[atomB.length] = _bI;\n        flags[flags.length] = se.flags;\n        order[order.length] = se.order;\n        if (!hasStructConn) structConnAdded.clear();\n        hasStructConn = true;\n        structConnAdded.add(_bI);\n      }\n    }\n\n    if (structConnExhaustive) continue;\n    var raI = residueIndex[aI];\n    var seqIdA = label_seq_id.value(raI);\n    var compId = label_comp_id.value(aI);\n\n    if (!props.forceCompute && raI !== lastResidue) {\n      if (!!component && component.entries.has(compId)) {\n        var entitySeq = byEntityKey[index.getEntityFromChain(chainIndex[aI])];\n\n        if (entitySeq && entitySeq.sequence.microHet.has(seqIdA)) {\n          // compute for sequence positions with micro-heterogeneity\n          componentMap = void 0;\n        } else {\n          componentMap = component.entries.get(compId).map;\n        }\n      } else {\n        componentMap = void 0;\n      }\n    }\n\n    lastResidue = raI;\n    var aeI = getElementIdx(elemA);\n    var atomIdA = label_atom_id.value(aI);\n    var componentPairs = componentMap ? componentMap.get(atomIdA) : void 0;\n\n    var _d = query3d.find(x[aI], y[aI], z[aI], maxRadius),\n        indices = _d.indices,\n        count = _d.count,\n        squaredDistances = _d.squaredDistances;\n\n    var isHa = isHydrogen(aeI);\n    var thresholdA = getElementThreshold(aeI);\n    var altA = label_alt_id.value(aI);\n    var metalA = MetalsSet.has(aeI);\n\n    for (var ni = 0; ni < count; ni++) {\n      var _bI = indices[ni];\n      if (hasStructConn && structConnAdded.has(_bI)) continue;\n      var bI = atoms[_bI];\n      if (bI <= aI) continue;\n      var altB = label_alt_id.value(bI);\n      if (altA && altB && altA !== altB) continue;\n      var beI = getElementIdx(type_symbol.value(bI));\n      var isHb = isHydrogen(beI);\n      if (isHa && isHb) continue;\n      var isMetal = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);\n      var rbI = residueIndex[bI]; // handle \"component dictionary\" bonds.\n\n      if (raI === rbI && componentPairs) {\n        var e = componentPairs.get(label_atom_id.value(bI));\n\n        if (e) {\n          atomA[atomA.length] = _aI;\n          atomB[atomB.length] = _bI;\n          order[order.length] = e.order;\n          var flag = e.flags;\n\n          if (isMetal) {\n            if (flag | 1\n            /* Covalent */\n            ) flag ^= 1\n            /* Covalent */\n            ;\n            flag |= 2\n            /* MetallicCoordination */\n            ;\n          }\n\n          flags[flags.length] = flag;\n        }\n\n        continue;\n      }\n\n      var dist = Math.sqrt(squaredDistances[ni]);\n      if (dist === 0) continue;\n      var thresholdAB = getElementPairThreshold(aeI, beI);\n      var pairingThreshold = thresholdAB > 0 ? thresholdAB : beI < 0 ? thresholdA : (thresholdA + getElementThreshold(beI)) / 1.95; // not sure if avg or min but max is too big\n\n      if (dist <= pairingThreshold) {\n        atomA[atomA.length] = _aI;\n        atomB[atomB.length] = _bI;\n        order[order.length] = getIntraBondOrderFromTable(compId, atomIdA, label_atom_id.value(bI));\n        flags[flags.length] = (isMetal ? 2\n        /* MetallicCoordination */\n        : 1\n        /* Covalent */\n        ) | 32\n        /* Computed */\n        ;\n        var seqIdB = label_seq_id.value(rbI);\n        if (seqIdA === seqIdB) isDictionaryBased = false;\n        if (Math.abs(seqIdA - seqIdB) > 1) isSequenced = false;\n      }\n    }\n  }\n\n  var canRemap = isWatery || isDictionaryBased && isSequenced;\n  return getGraph(atomA, atomB, order, flags, atomCount, canRemap);\n}\n\nfunction computeIntraUnitBonds(unit, props) {\n  var p = __assign(__assign({}, DefaultBondComputationProps), props);\n\n  if (p.noCompute || Model.isCoarseGrained(unit.model)) {\n    // TODO add function that only adds bonds defined in structConn of chemCompBond\n    //      and avoid using unit.lookup\n    return IntraUnitBonds.Empty;\n  }\n\n  if (!p.forceCompute && IndexPairBonds.Provider.get(unit.model)) {\n    return findIndexPairBonds(unit);\n  } else {\n    return findBonds(unit, p);\n  }\n}\n\nexport { computeIntraUnitBonds };","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/structure/unit/bonds/intra-compute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { IntraUnitBonds } from './data';\r\nimport { IntAdjacencyGraph } from '../../../../../mol-math/graph';\r\nimport { getElementIdx, MetalsSet, getElementThreshold, isHydrogen, getElementPairThreshold, DefaultBondComputationProps } from './common';\r\nimport { SortedArray } from '../../../../../mol-data/int';\r\nimport { getIntraBondOrderFromTable } from '../../../model/properties/atomic/bonds';\r\nimport { IndexPairBonds } from '../../../../../mol-model-formats/structure/property/bonds/index-pair';\r\nimport { ComponentBond } from '../../../../../mol-model-formats/structure/property/bonds/chem_comp';\r\nimport { StructConn } from '../../../../../mol-model-formats/structure/property/bonds/struct_conn';\r\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\r\nimport { equalEps } from '../../../../../mol-math/linear-algebra/3d/common';\r\nimport { Model } from '../../../model/model';\r\nfunction getGraph(atomA, atomB, _order, _flags, atomCount, canRemap) {\r\n    var builder = new IntAdjacencyGraph.EdgeBuilder(atomCount, atomA, atomB);\r\n    var flags = new Uint16Array(builder.slotCount);\r\n    var order = new Int8Array(builder.slotCount);\r\n    for (var i = 0, _i = builder.edgeCount; i < _i; i++) {\r\n        builder.addNextEdge();\r\n        builder.assignProperty(flags, _flags[i]);\r\n        builder.assignProperty(order, _order[i]);\r\n    }\r\n    return builder.createGraph({ flags: flags, order: order }, { canRemap: canRemap });\r\n}\r\nvar tmpDistVecA = Vec3();\r\nvar tmpDistVecB = Vec3();\r\nfunction getDistance(unit, indexA, indexB) {\r\n    unit.conformation.position(indexA, tmpDistVecA);\r\n    unit.conformation.position(indexB, tmpDistVecB);\r\n    return Vec3.distance(tmpDistVecA, tmpDistVecB);\r\n}\r\nvar __structConnAdded = new Set();\r\nfunction findIndexPairBonds(unit) {\r\n    var indexPairs = IndexPairBonds.Provider.get(unit.model);\r\n    var atoms = unit.elements;\r\n    var type_symbol = unit.model.atomicHierarchy.atoms.type_symbol;\r\n    var atomCount = unit.elements.length;\r\n    var maxDistance = indexPairs.maxDistance;\r\n    var _a = indexPairs.bonds, offset = _a.offset, b = _a.b, _b = _a.edgeProps, order = _b.order, distance = _b.distance, flag = _b.flag;\r\n    var sourceIndex = unit.model.atomicHierarchy.atomSourceIndex;\r\n    var invertedIndex = Model.getInvertedAtomSourceIndex(unit.model).invertedIndex;\r\n    var atomA = [];\r\n    var atomB = [];\r\n    var flags = [];\r\n    var orders = [];\r\n    for (var _aI = 0; _aI < atomCount; _aI++) {\r\n        var aI = atoms[_aI];\r\n        var isHa = type_symbol.value(aI) === 'H';\r\n        var srcA = sourceIndex.value(aI);\r\n        for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {\r\n            var bI = invertedIndex[b[i]];\r\n            if (aI >= bI)\r\n                continue;\r\n            var _bI = SortedArray.indexOf(unit.elements, bI);\r\n            if (_bI < 0)\r\n                continue;\r\n            if (isHa && type_symbol.value(bI) === 'H')\r\n                continue;\r\n            var d = distance[i];\r\n            var dist = getDistance(unit, aI, bI);\r\n            if ((d !== -1 && equalEps(dist, d, 0.5)) || dist < maxDistance) {\r\n                atomA[atomA.length] = _aI;\r\n                atomB[atomB.length] = _bI;\r\n                orders[orders.length] = order[i];\r\n                flags[flags.length] = flag[i];\r\n            }\r\n        }\r\n    }\r\n    return getGraph(atomA, atomB, orders, flags, atomCount, false);\r\n}\r\nfunction findBonds(unit, props) {\r\n    var maxRadius = props.maxRadius;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    var atomCount = unit.elements.length;\r\n    var atoms = unit.elements, residueIndex = unit.residueIndex, chainIndex = unit.chainIndex;\r\n    var _b = unit.model.atomicHierarchy.atoms, type_symbol = _b.type_symbol, label_atom_id = _b.label_atom_id, label_alt_id = _b.label_alt_id, label_comp_id = _b.label_comp_id;\r\n    var label_seq_id = unit.model.atomicHierarchy.residues.label_seq_id;\r\n    var index = unit.model.atomicHierarchy.index;\r\n    var byEntityKey = unit.model.sequence.byEntityKey;\r\n    var query3d = unit.lookup3d;\r\n    var structConn = StructConn.Provider.get(unit.model);\r\n    var component = ComponentBond.Provider.get(unit.model);\r\n    var structConnExhaustive = StructConn.isExhaustive(unit.model);\r\n    var atomA = [];\r\n    var atomB = [];\r\n    var flags = [];\r\n    var order = [];\r\n    var lastResidue = -1;\r\n    var componentMap = void 0;\r\n    var isWatery = true, isDictionaryBased = true, isSequenced = true;\r\n    var structConnAdded = __structConnAdded;\r\n    for (var _aI = 0; _aI < atomCount; _aI++) {\r\n        var aI = atoms[_aI];\r\n        var elemA = type_symbol.value(aI);\r\n        if (isWatery && (elemA !== 'H' || elemA !== 'O'))\r\n            isWatery = false;\r\n        var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);\r\n        var hasStructConn = false;\r\n        if (structConnEntries) {\r\n            for (var _c = 0, structConnEntries_1 = structConnEntries; _c < structConnEntries_1.length; _c++) {\r\n                var se = structConnEntries_1[_c];\r\n                var partnerA = se.partnerA, partnerB = se.partnerB;\r\n                // symmetry must be the same for intra-unit bonds\r\n                if (partnerA.symmetry !== partnerB.symmetry)\r\n                    continue;\r\n                var p = partnerA.atomIndex === aI ? partnerB : partnerA;\r\n                var _bI = SortedArray.indexOf(unit.elements, p.atomIndex);\r\n                if (_bI < 0 || atoms[_bI] < aI)\r\n                    continue;\r\n                atomA[atomA.length] = _aI;\r\n                atomB[atomB.length] = _bI;\r\n                flags[flags.length] = se.flags;\r\n                order[order.length] = se.order;\r\n                if (!hasStructConn)\r\n                    structConnAdded.clear();\r\n                hasStructConn = true;\r\n                structConnAdded.add(_bI);\r\n            }\r\n        }\r\n        if (structConnExhaustive)\r\n            continue;\r\n        var raI = residueIndex[aI];\r\n        var seqIdA = label_seq_id.value(raI);\r\n        var compId = label_comp_id.value(aI);\r\n        if (!props.forceCompute && raI !== lastResidue) {\r\n            if (!!component && component.entries.has(compId)) {\r\n                var entitySeq = byEntityKey[index.getEntityFromChain(chainIndex[aI])];\r\n                if (entitySeq && entitySeq.sequence.microHet.has(seqIdA)) {\r\n                    // compute for sequence positions with micro-heterogeneity\r\n                    componentMap = void 0;\r\n                }\r\n                else {\r\n                    componentMap = component.entries.get(compId).map;\r\n                }\r\n            }\r\n            else {\r\n                componentMap = void 0;\r\n            }\r\n        }\r\n        lastResidue = raI;\r\n        var aeI = getElementIdx(elemA);\r\n        var atomIdA = label_atom_id.value(aI);\r\n        var componentPairs = componentMap ? componentMap.get(atomIdA) : void 0;\r\n        var _d = query3d.find(x[aI], y[aI], z[aI], maxRadius), indices = _d.indices, count = _d.count, squaredDistances = _d.squaredDistances;\r\n        var isHa = isHydrogen(aeI);\r\n        var thresholdA = getElementThreshold(aeI);\r\n        var altA = label_alt_id.value(aI);\r\n        var metalA = MetalsSet.has(aeI);\r\n        for (var ni = 0; ni < count; ni++) {\r\n            var _bI = indices[ni];\r\n            if (hasStructConn && structConnAdded.has(_bI))\r\n                continue;\r\n            var bI = atoms[_bI];\r\n            if (bI <= aI)\r\n                continue;\r\n            var altB = label_alt_id.value(bI);\r\n            if (altA && altB && altA !== altB)\r\n                continue;\r\n            var beI = getElementIdx(type_symbol.value(bI));\r\n            var isHb = isHydrogen(beI);\r\n            if (isHa && isHb)\r\n                continue;\r\n            var isMetal = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);\r\n            var rbI = residueIndex[bI];\r\n            // handle \"component dictionary\" bonds.\r\n            if (raI === rbI && componentPairs) {\r\n                var e = componentPairs.get(label_atom_id.value(bI));\r\n                if (e) {\r\n                    atomA[atomA.length] = _aI;\r\n                    atomB[atomB.length] = _bI;\r\n                    order[order.length] = e.order;\r\n                    var flag = e.flags;\r\n                    if (isMetal) {\r\n                        if (flag | 1 /* Covalent */)\r\n                            flag ^= 1 /* Covalent */;\r\n                        flag |= 2 /* MetallicCoordination */;\r\n                    }\r\n                    flags[flags.length] = flag;\r\n                }\r\n                continue;\r\n            }\r\n            var dist = Math.sqrt(squaredDistances[ni]);\r\n            if (dist === 0)\r\n                continue;\r\n            var thresholdAB = getElementPairThreshold(aeI, beI);\r\n            var pairingThreshold = thresholdAB > 0\r\n                ? thresholdAB\r\n                : beI < 0\r\n                    ? thresholdA\r\n                    : (thresholdA + getElementThreshold(beI)) / 1.95; // not sure if avg or min but max is too big\r\n            if (dist <= pairingThreshold) {\r\n                atomA[atomA.length] = _aI;\r\n                atomB[atomB.length] = _bI;\r\n                order[order.length] = getIntraBondOrderFromTable(compId, atomIdA, label_atom_id.value(bI));\r\n                flags[flags.length] = (isMetal ? 2 /* MetallicCoordination */ : 1 /* Covalent */) | 32 /* Computed */;\r\n                var seqIdB = label_seq_id.value(rbI);\r\n                if (seqIdA === seqIdB)\r\n                    isDictionaryBased = false;\r\n                if (Math.abs(seqIdA - seqIdB) > 1)\r\n                    isSequenced = false;\r\n            }\r\n        }\r\n    }\r\n    var canRemap = isWatery || (isDictionaryBased && isSequenced);\r\n    return getGraph(atomA, atomB, order, flags, atomCount, canRemap);\r\n}\r\nfunction computeIntraUnitBonds(unit, props) {\r\n    var p = __assign(__assign({}, DefaultBondComputationProps), props);\r\n    if (p.noCompute || Model.isCoarseGrained(unit.model)) {\r\n        // TODO add function that only adds bonds defined in structConn of chemCompBond\r\n        //      and avoid using unit.lookup\r\n        return IntraUnitBonds.Empty;\r\n    }\r\n    if (!p.forceCompute && IndexPairBonds.Provider.get(unit.model)) {\r\n        return findIndexPairBonds(unit);\r\n    }\r\n    else {\r\n        return findBonds(unit, p);\r\n    }\r\n}\r\nexport { computeIntraUnitBonds };\r\n//# sourceMappingURL=intra-compute.js.map"]},"metadata":{},"sourceType":"module"}