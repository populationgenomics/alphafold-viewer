{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __assign } from \"tslib\";\nimport { StateTree } from '../tree/immutable';\nimport { StateObjectCell, StateObjectSelector, StateObjectRef } from '../object';\nimport { StateTransform } from '../transform';\nimport { produce } from 'immer';\nexport { StateBuilder };\nvar StateBuilder;\n\n(function (StateBuilder) {\n  function buildTree(state) {\n    if (!state.state || state.state.tree === state.editInfo.sourceTree) {\n      return state.tree.asImmutable();\n    } // The tree has changed in the meantime, we need to reapply the changes!\n\n\n    var tree = state.state.tree.asTransient();\n\n    for (var _i = 0, _a = state.actions; _i < _a.length; _i++) {\n      var a = _a[_i];\n\n      switch (a.kind) {\n        case 'add':\n          tree.add(a.transform);\n          break;\n\n        case 'update':\n          tree.setParams(a.ref, a.params);\n          break;\n\n        case 'delete':\n          tree.remove(a.ref);\n          break;\n\n        case 'insert':\n          {\n            var children = tree.children.get(a.ref).toArray();\n            tree.add(a.transform);\n\n            for (var _b = 0, children_1 = children; _b < children_1.length; _b++) {\n              var c = children_1[_b];\n              tree.changeParent(c, a.transform.ref);\n            }\n\n            break;\n          }\n      }\n    }\n\n    state.editInfo.sourceTree = state.tree;\n    return tree.asImmutable();\n  }\n\n  function is(obj) {\n    return !!obj && typeof obj.getTree === 'function';\n  }\n\n  StateBuilder.is = is;\n\n  function isTo(obj) {\n    return !!obj && typeof obj.getTree === 'function' && typeof obj.ref === 'string';\n  }\n\n  StateBuilder.isTo = isTo; // type ToFromCell<C extends StateObjectCell> = C extends StateObjectCell<infer A, StateTransform<infer T extends StateTransformer>> ? To<A, any>: never\n\n  var Root =\n  /** @class */\n  function () {\n    function Root(tree, state) {\n      this.state = {\n        state: state,\n        tree: tree.asTransient(),\n        actions: [],\n        editInfo: {\n          applied: false,\n          sourceTree: tree,\n          count: 0,\n          lastUpdate: void 0\n        }\n      };\n    }\n\n    Object.defineProperty(Root.prototype, \"editInfo\", {\n      get: function () {\n        return this.state.editInfo;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Root.prototype, \"currentTree\", {\n      get: function () {\n        return this.state.tree;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    Root.prototype.to = function (refOrCellOrSelector) {\n      var ref = typeof refOrCellOrSelector === 'string' ? refOrCellOrSelector : StateObjectCell.is(refOrCellOrSelector) ? refOrCellOrSelector.transform.ref : refOrCellOrSelector.ref;\n      return new To(this.state, ref, this);\n    };\n\n    Root.prototype.toRoot = function () {\n      return new To(this.state, this.state.tree.root.ref, this);\n    };\n\n    Root.prototype.delete = function (obj) {\n      var ref = StateObjectRef.resolveRef(obj);\n      if (!ref || !this.state.tree.transforms.has(ref)) return this;\n      this.editInfo.count++;\n      this.state.tree.remove(ref);\n      this.state.actions.push({\n        kind: 'delete',\n        ref: ref\n      });\n      return this;\n    };\n\n    Root.prototype.getTree = function () {\n      return buildTree(this.state);\n    };\n\n    Root.prototype.commit = function (options) {\n      if (!this.state.state) throw new Error('Cannot commit template tree');\n      return this.state.state.runTask(this.state.state.updateTree(this, options));\n    };\n\n    return Root;\n  }();\n\n  StateBuilder.Root = Root;\n\n  var To =\n  /** @class */\n  function () {\n    function To(state, ref, root) {\n      this.state = state;\n      this.root = root;\n      this.ref = ref;\n\n      if (!this.state.tree.transforms.has(ref)) {\n        throw new Error(\"Could not find node '\" + ref + \"'.\");\n      }\n    }\n\n    Object.defineProperty(To.prototype, \"editInfo\", {\n      get: function () {\n        return this.state.editInfo;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(To.prototype, \"selector\", {\n      get: function () {\n        return new StateObjectSelector(this.ref, this.state.state);\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    To.prototype.getApplyRoot = function () {\n      return StateTree.getDecoratorRoot(this.state.tree, this.ref);\n    };\n    /**\r\n     * Apply the transformed to the parent node\r\n     * If no params are specified (params <- undefined), default params are lazily resolved.\r\n     */\n\n\n    To.prototype.apply = function (tr, params, options) {\n      if (tr.definition.isDecorator) {\n        return this.insert(tr, params, options);\n      }\n\n      var applyRoot = this.getApplyRoot();\n      var t = tr.apply(applyRoot, params, options);\n      this.state.tree.add(t);\n      this.editInfo.count++;\n      this.editInfo.lastUpdate = t.ref;\n      this.state.actions.push({\n        kind: 'add',\n        transform: t\n      });\n      return new To(this.state, t.ref, this.root);\n    };\n    /**\r\n     * If the ref is present, the transform is applied.\r\n     * Otherwise a transform with the specifed ref is created.\r\n     */\n\n\n    To.prototype.applyOrUpdate = function (ref, tr, params, options) {\n      if (this.state.tree.transforms.has(ref)) {\n        var to = this.to(ref);\n        if (params) to.update(params);\n        return to;\n      } else {\n        return this.apply(tr, params, __assign(__assign({}, options), {\n          ref: ref\n        }));\n      }\n    };\n    /**\r\n     * Apply the transformed to the parent node\r\n     * If no params are specified (params <- undefined), default params are lazily resolved.\r\n     * The transformer cannot be a decorator to be able to use this.\r\n     */\n\n\n    To.prototype.applyOrUpdateTagged = function (tags, tr, params, options) {\n      if (tr.definition.isDecorator) {\n        throw new Error(\"Can't use applyOrUpdateTagged on decorator transformers.\");\n      }\n\n      var applyRoot = this.getApplyRoot();\n      var children = this.state.tree.children.get(applyRoot).values();\n\n      while (true) {\n        var child = children.next();\n        if (child.done) break;\n        var tr_1 = this.state.tree.transforms.get(child.value);\n\n        if (tr_1 && StateTransform.hasTags(tr_1, tags)) {\n          var to = this.to(child.value);\n          to.updateTagged(params, tagsUnion(tr_1.tags, tags, options && options.tags));\n          return to;\n        }\n      }\n\n      var t = tr.apply(applyRoot, params, __assign(__assign({}, options), {\n        tags: tagsUnion(tags, options && options.tags)\n      }));\n      this.state.tree.add(t);\n      this.editInfo.count++;\n      this.editInfo.lastUpdate = t.ref;\n      this.state.actions.push({\n        kind: 'add',\n        transform: t\n      });\n      return new To(this.state, t.ref, this.root);\n    };\n    /**\r\n     * A helper to greate a group-like state object and keep the current type.\r\n     */\n\n\n    To.prototype.group = function (tr, params, options) {\n      return this.apply(tr, params, options);\n    };\n    /**\r\n     * Inserts a new transform that does not change the object type and move the original children to it.\r\n     */\n\n\n    To.prototype.insert = function (tr, params, options) {\n      // cache the children\n      var children = this.state.tree.children.get(this.ref).toArray(); // add the new node\n\n      var t = tr.apply(this.ref, params, options);\n      this.state.tree.add(t); // move the original children to the new node\n\n      for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\n        var c = children_2[_i];\n        this.state.tree.changeParent(c, t.ref);\n      }\n\n      this.editInfo.count++;\n      this.editInfo.lastUpdate = t.ref;\n      this.state.actions.push({\n        kind: 'insert',\n        ref: this.ref,\n        transform: t\n      });\n      return new To(this.state, t.ref, this.root);\n    };\n\n    To.prototype.updateTagged = function (params, tags) {\n      if (this.state.tree.setParams(this.ref, params) || this.state.tree.setTags(this.ref, tags)) {\n        this.editInfo.count++;\n        this.editInfo.lastUpdate = this.ref;\n        this.state.actions.push({\n          kind: 'update',\n          ref: this.ref,\n          params: params\n        });\n      }\n    };\n\n    To.prototype.update = function (paramsOrTransformer, provider) {\n      var params;\n\n      if (provider) {\n        var old = this.state.tree.transforms.get(this.ref);\n        params = produce(old.params, provider);\n      } else {\n        params = typeof paramsOrTransformer === 'function' ? produce(this.state.tree.transforms.get(this.ref).params, paramsOrTransformer) : paramsOrTransformer;\n      }\n\n      if (this.state.tree.setParams(this.ref, params)) {\n        this.editInfo.count++;\n        this.editInfo.lastUpdate = this.ref;\n        this.state.actions.push({\n          kind: 'update',\n          ref: this.ref,\n          params: params\n        });\n      }\n\n      return this.root;\n    };\n\n    To.prototype.to = function (ref) {\n      return this.root.to(ref);\n    };\n\n    To.prototype.toRoot = function () {\n      return this.root.toRoot();\n    };\n\n    To.prototype.delete = function (ref) {\n      return this.root.delete(ref);\n    };\n\n    To.prototype.getTree = function () {\n      return buildTree(this.state);\n    };\n    /** Returns selector to this node. */\n\n\n    To.prototype.commit = function (options) {\n      if (!this.state.state) throw new Error('Cannot commit template tree');\n      return this.state.state.runTask(this.state.state.updateTree(this, options));\n    };\n\n    return To;\n  }();\n\n  StateBuilder.To = To;\n})(StateBuilder || (StateBuilder = {}));\n\nfunction tagsUnion() {\n  var arrays = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arrays[_i] = arguments[_i];\n  }\n\n  var set = void 0;\n  var ret = [];\n\n  for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\n    var xs = arrays_1[_a];\n    if (!xs) continue;\n    if (!set) set = new Set();\n\n    if (typeof xs === 'string') {\n      if (set.has(xs)) continue;\n      set.add(xs);\n      ret.push(xs);\n    } else {\n      for (var _b = 0, xs_1 = xs; _b < xs_1.length; _b++) {\n        var x = xs_1[_b];\n        if (set.has(x)) continue;\n        set.add(x);\n        ret.push(x);\n      }\n    }\n  }\n\n  return ret;\n}","map":{"version":3,"sources":["../../../src/mol-state/state/builder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { StateTree } from '../tree/immutable';\r\nimport { StateObjectCell, StateObjectSelector, StateObjectRef } from '../object';\r\nimport { StateTransform } from '../transform';\r\nimport { produce } from 'immer';\r\nexport { StateBuilder };\r\nvar StateBuilder;\r\n(function (StateBuilder) {\r\n    function buildTree(state) {\r\n        if (!state.state || state.state.tree === state.editInfo.sourceTree) {\r\n            return state.tree.asImmutable();\r\n        }\r\n        // The tree has changed in the meantime, we need to reapply the changes!\r\n        var tree = state.state.tree.asTransient();\r\n        for (var _i = 0, _a = state.actions; _i < _a.length; _i++) {\r\n            var a = _a[_i];\r\n            switch (a.kind) {\r\n                case 'add':\r\n                    tree.add(a.transform);\r\n                    break;\r\n                case 'update':\r\n                    tree.setParams(a.ref, a.params);\r\n                    break;\r\n                case 'delete':\r\n                    tree.remove(a.ref);\r\n                    break;\r\n                case 'insert': {\r\n                    var children = tree.children.get(a.ref).toArray();\r\n                    tree.add(a.transform);\r\n                    for (var _b = 0, children_1 = children; _b < children_1.length; _b++) {\r\n                        var c = children_1[_b];\r\n                        tree.changeParent(c, a.transform.ref);\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        state.editInfo.sourceTree = state.tree;\r\n        return tree.asImmutable();\r\n    }\r\n    function is(obj) {\r\n        return !!obj && typeof obj.getTree === 'function';\r\n    }\r\n    StateBuilder.is = is;\r\n    function isTo(obj) {\r\n        return !!obj && typeof obj.getTree === 'function' && typeof obj.ref === 'string';\r\n    }\r\n    StateBuilder.isTo = isTo;\r\n    // type ToFromCell<C extends StateObjectCell> = C extends StateObjectCell<infer A, StateTransform<infer T extends StateTransformer>> ? To<A, any>: never\r\n    var Root = /** @class */ (function () {\r\n        function Root(tree, state) {\r\n            this.state = { state: state, tree: tree.asTransient(), actions: [], editInfo: { applied: false, sourceTree: tree, count: 0, lastUpdate: void 0 } };\r\n        }\r\n        Object.defineProperty(Root.prototype, \"editInfo\", {\r\n            get: function () { return this.state.editInfo; },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Root.prototype, \"currentTree\", {\r\n            get: function () { return this.state.tree; },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Root.prototype.to = function (refOrCellOrSelector) {\r\n            var ref = typeof refOrCellOrSelector === 'string'\r\n                ? refOrCellOrSelector\r\n                : StateObjectCell.is(refOrCellOrSelector)\r\n                    ? refOrCellOrSelector.transform.ref\r\n                    : refOrCellOrSelector.ref;\r\n            return new To(this.state, ref, this);\r\n        };\r\n        Root.prototype.toRoot = function () { return new To(this.state, this.state.tree.root.ref, this); };\r\n        Root.prototype.delete = function (obj) {\r\n            var ref = StateObjectRef.resolveRef(obj);\r\n            if (!ref || !this.state.tree.transforms.has(ref))\r\n                return this;\r\n            this.editInfo.count++;\r\n            this.state.tree.remove(ref);\r\n            this.state.actions.push({ kind: 'delete', ref: ref });\r\n            return this;\r\n        };\r\n        Root.prototype.getTree = function () { return buildTree(this.state); };\r\n        Root.prototype.commit = function (options) {\r\n            if (!this.state.state)\r\n                throw new Error('Cannot commit template tree');\r\n            return this.state.state.runTask(this.state.state.updateTree(this, options));\r\n        };\r\n        return Root;\r\n    }());\r\n    StateBuilder.Root = Root;\r\n    var To = /** @class */ (function () {\r\n        function To(state, ref, root) {\r\n            this.state = state;\r\n            this.root = root;\r\n            this.ref = ref;\r\n            if (!this.state.tree.transforms.has(ref)) {\r\n                throw new Error(\"Could not find node '\" + ref + \"'.\");\r\n            }\r\n        }\r\n        Object.defineProperty(To.prototype, \"editInfo\", {\r\n            get: function () { return this.state.editInfo; },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(To.prototype, \"selector\", {\r\n            get: function () { return new StateObjectSelector(this.ref, this.state.state); },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        To.prototype.getApplyRoot = function () {\r\n            return StateTree.getDecoratorRoot(this.state.tree, this.ref);\r\n        };\r\n        /**\r\n         * Apply the transformed to the parent node\r\n         * If no params are specified (params <- undefined), default params are lazily resolved.\r\n         */\r\n        To.prototype.apply = function (tr, params, options) {\r\n            if (tr.definition.isDecorator) {\r\n                return this.insert(tr, params, options);\r\n            }\r\n            var applyRoot = this.getApplyRoot();\r\n            var t = tr.apply(applyRoot, params, options);\r\n            this.state.tree.add(t);\r\n            this.editInfo.count++;\r\n            this.editInfo.lastUpdate = t.ref;\r\n            this.state.actions.push({ kind: 'add', transform: t });\r\n            return new To(this.state, t.ref, this.root);\r\n        };\r\n        /**\r\n         * If the ref is present, the transform is applied.\r\n         * Otherwise a transform with the specifed ref is created.\r\n         */\r\n        To.prototype.applyOrUpdate = function (ref, tr, params, options) {\r\n            if (this.state.tree.transforms.has(ref)) {\r\n                var to = this.to(ref);\r\n                if (params)\r\n                    to.update(params);\r\n                return to;\r\n            }\r\n            else {\r\n                return this.apply(tr, params, __assign(__assign({}, options), { ref: ref }));\r\n            }\r\n        };\r\n        /**\r\n         * Apply the transformed to the parent node\r\n         * If no params are specified (params <- undefined), default params are lazily resolved.\r\n         * The transformer cannot be a decorator to be able to use this.\r\n         */\r\n        To.prototype.applyOrUpdateTagged = function (tags, tr, params, options) {\r\n            if (tr.definition.isDecorator) {\r\n                throw new Error(\"Can't use applyOrUpdateTagged on decorator transformers.\");\r\n            }\r\n            var applyRoot = this.getApplyRoot();\r\n            var children = this.state.tree.children.get(applyRoot).values();\r\n            while (true) {\r\n                var child = children.next();\r\n                if (child.done)\r\n                    break;\r\n                var tr_1 = this.state.tree.transforms.get(child.value);\r\n                if (tr_1 && StateTransform.hasTags(tr_1, tags)) {\r\n                    var to = this.to(child.value);\r\n                    to.updateTagged(params, tagsUnion(tr_1.tags, tags, options && options.tags));\r\n                    return to;\r\n                }\r\n            }\r\n            var t = tr.apply(applyRoot, params, __assign(__assign({}, options), { tags: tagsUnion(tags, options && options.tags) }));\r\n            this.state.tree.add(t);\r\n            this.editInfo.count++;\r\n            this.editInfo.lastUpdate = t.ref;\r\n            this.state.actions.push({ kind: 'add', transform: t });\r\n            return new To(this.state, t.ref, this.root);\r\n        };\r\n        /**\r\n         * A helper to greate a group-like state object and keep the current type.\r\n         */\r\n        To.prototype.group = function (tr, params, options) {\r\n            return this.apply(tr, params, options);\r\n        };\r\n        /**\r\n         * Inserts a new transform that does not change the object type and move the original children to it.\r\n         */\r\n        To.prototype.insert = function (tr, params, options) {\r\n            // cache the children\r\n            var children = this.state.tree.children.get(this.ref).toArray();\r\n            // add the new node\r\n            var t = tr.apply(this.ref, params, options);\r\n            this.state.tree.add(t);\r\n            // move the original children to the new node\r\n            for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {\r\n                var c = children_2[_i];\r\n                this.state.tree.changeParent(c, t.ref);\r\n            }\r\n            this.editInfo.count++;\r\n            this.editInfo.lastUpdate = t.ref;\r\n            this.state.actions.push({ kind: 'insert', ref: this.ref, transform: t });\r\n            return new To(this.state, t.ref, this.root);\r\n        };\r\n        To.prototype.updateTagged = function (params, tags) {\r\n            if (this.state.tree.setParams(this.ref, params) || this.state.tree.setTags(this.ref, tags)) {\r\n                this.editInfo.count++;\r\n                this.editInfo.lastUpdate = this.ref;\r\n                this.state.actions.push({ kind: 'update', ref: this.ref, params: params });\r\n            }\r\n        };\r\n        To.prototype.update = function (paramsOrTransformer, provider) {\r\n            var params;\r\n            if (provider) {\r\n                var old = this.state.tree.transforms.get(this.ref);\r\n                params = produce(old.params, provider);\r\n            }\r\n            else {\r\n                params = typeof paramsOrTransformer === 'function'\r\n                    ? produce(this.state.tree.transforms.get(this.ref).params, paramsOrTransformer)\r\n                    : paramsOrTransformer;\r\n            }\r\n            if (this.state.tree.setParams(this.ref, params)) {\r\n                this.editInfo.count++;\r\n                this.editInfo.lastUpdate = this.ref;\r\n                this.state.actions.push({ kind: 'update', ref: this.ref, params: params });\r\n            }\r\n            return this.root;\r\n        };\r\n        To.prototype.to = function (ref) { return this.root.to(ref); };\r\n        To.prototype.toRoot = function () { return this.root.toRoot(); };\r\n        To.prototype.delete = function (ref) { return this.root.delete(ref); };\r\n        To.prototype.getTree = function () { return buildTree(this.state); };\r\n        /** Returns selector to this node. */\r\n        To.prototype.commit = function (options) {\r\n            if (!this.state.state)\r\n                throw new Error('Cannot commit template tree');\r\n            return this.state.state.runTask(this.state.state.updateTree(this, options));\r\n        };\r\n        return To;\r\n    }());\r\n    StateBuilder.To = To;\r\n})(StateBuilder || (StateBuilder = {}));\r\nfunction tagsUnion() {\r\n    var arrays = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        arrays[_i] = arguments[_i];\r\n    }\r\n    var set = void 0;\r\n    var ret = [];\r\n    for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {\r\n        var xs = arrays_1[_a];\r\n        if (!xs)\r\n            continue;\r\n        if (!set)\r\n            set = new Set();\r\n        if (typeof xs === 'string') {\r\n            if (set.has(xs))\r\n                continue;\r\n            set.add(xs);\r\n            ret.push(xs);\r\n        }\r\n        else {\r\n            for (var _b = 0, xs_1 = xs; _b < xs_1.length; _b++) {\r\n                var x = xs_1[_b];\r\n                if (set.has(x))\r\n                    continue;\r\n                set.add(x);\r\n                ret.push(x);\r\n            }\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n//# sourceMappingURL=builder.js.map"]},"metadata":{},"sourceType":"module"}