{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\"; // adapted from three.js, MIT License Copyright 2010-2018 three.js authors\n\nimport { Vec3 } from '../../mol-math/linear-algebra';\nexport var DefaultCylinderProps = {\n  radiusTop: 1,\n  radiusBottom: 1,\n  height: 1,\n  radialSegments: 8,\n  heightSegments: 1,\n  topCap: false,\n  bottomCap: false,\n  thetaStart: 0.0,\n  thetaLength: Math.PI * 2\n};\nexport function Cylinder(props) {\n  var _a = __assign(__assign({}, DefaultCylinderProps), props),\n      radiusTop = _a.radiusTop,\n      radiusBottom = _a.radiusBottom,\n      height = _a.height,\n      radialSegments = _a.radialSegments,\n      heightSegments = _a.heightSegments,\n      topCap = _a.topCap,\n      bottomCap = _a.bottomCap,\n      thetaStart = _a.thetaStart,\n      thetaLength = _a.thetaLength; // buffers\n\n\n  var indices = [];\n  var vertices = [];\n  var normals = []; // helper variables\n\n  var index = 0;\n  var indexArray = [];\n  var halfHeight = height / 2; // generate geometry\n\n  generateTorso();\n  if (topCap && radiusTop > 0) generateCap(true);\n  if (bottomCap && radiusBottom > 0) generateCap(false);\n  return {\n    vertices: new Float32Array(vertices),\n    normals: new Float32Array(normals),\n    indices: new Uint32Array(indices)\n  };\n\n  function generateTorso() {\n    var normal = Vec3.zero(); // this will be used to calculate the normal\n\n    var slope = (radiusBottom - radiusTop) / height; // generate vertices, normals and uvs\n\n    for (var y = 0; y <= heightSegments; ++y) {\n      var indexRow = [];\n      var v = y / heightSegments; // calculate the radius of the current row\n\n      var radius = v * (radiusBottom - radiusTop) + radiusTop;\n\n      for (var x = 0; x <= radialSegments; ++x) {\n        var u = x / radialSegments;\n        var theta = u * thetaLength + thetaStart;\n        var sinTheta = Math.sin(theta);\n        var cosTheta = Math.cos(theta); // vertex\n\n        vertices.push(radius * sinTheta, -v * height + halfHeight, radius * cosTheta); // normal\n\n        Vec3.normalize(normal, Vec3.set(normal, sinTheta, slope, cosTheta));\n        normals.push.apply(normals, normal); // save index of vertex in respective row\n\n        indexRow.push(index++);\n      } // now save vertices of the row in our index array\n\n\n      indexArray.push(indexRow);\n    } // generate indices\n\n\n    for (var x = 0; x < radialSegments; ++x) {\n      for (var y = 0; y < heightSegments; ++y) {\n        // we use the index array to access the correct indices\n        var a = indexArray[y][x];\n        var b = indexArray[y + 1][x];\n        var c = indexArray[y + 1][x + 1];\n        var d = indexArray[y][x + 1]; // faces\n\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n  }\n\n  function generateCap(top) {\n    var radius = top === true ? radiusTop : radiusBottom;\n    var sign = top === true ? 1 : -1; // save the index of the first center vertex\n\n    var centerIndexStart = index; // first we generate the center vertex data of the cap.\n    // because the geometry needs one set of uvs per face,\n    // we must generate a center vertex per face/segment\n\n    for (var x = 1; x <= radialSegments; ++x) {\n      // vertex\n      vertices.push(0, halfHeight * sign, 0); // normal\n\n      normals.push(0, sign, 0); // increase index\n\n      ++index;\n    } // save the index of the last center vertex\n\n\n    var centerIndexEnd = index; // now we generate the surrounding vertices, normals and uvs\n\n    for (var x = 0; x <= radialSegments; ++x) {\n      var u = x / radialSegments;\n      var theta = u * thetaLength + thetaStart;\n      var cosTheta = Math.cos(theta);\n      var sinTheta = Math.sin(theta); // vertex\n\n      vertices.push(radius * sinTheta, halfHeight * sign, radius * cosTheta); // normal\n\n      normals.push(0, sign, 0); // increase index\n\n      ++index;\n    } // generate indices\n\n\n    for (var x = 0; x < radialSegments; ++x) {\n      var c = centerIndexStart + x;\n      var i = centerIndexEnd + x;\n\n      if (top === true) {\n        indices.push(i, i + 1, c); // face top\n      } else {\n        indices.push(i + 1, i, c); // face bottom\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../src/mol-geo/primitive/cylinder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\n// adapted from three.js, MIT License Copyright 2010-2018 three.js authors\r\nimport { Vec3 } from '../../mol-math/linear-algebra';\r\nexport var DefaultCylinderProps = {\r\n    radiusTop: 1,\r\n    radiusBottom: 1,\r\n    height: 1,\r\n    radialSegments: 8,\r\n    heightSegments: 1,\r\n    topCap: false,\r\n    bottomCap: false,\r\n    thetaStart: 0.0,\r\n    thetaLength: Math.PI * 2\r\n};\r\nexport function Cylinder(props) {\r\n    var _a = __assign(__assign({}, DefaultCylinderProps), props), radiusTop = _a.radiusTop, radiusBottom = _a.radiusBottom, height = _a.height, radialSegments = _a.radialSegments, heightSegments = _a.heightSegments, topCap = _a.topCap, bottomCap = _a.bottomCap, thetaStart = _a.thetaStart, thetaLength = _a.thetaLength;\r\n    // buffers\r\n    var indices = [];\r\n    var vertices = [];\r\n    var normals = [];\r\n    // helper variables\r\n    var index = 0;\r\n    var indexArray = [];\r\n    var halfHeight = height / 2;\r\n    // generate geometry\r\n    generateTorso();\r\n    if (topCap && radiusTop > 0)\r\n        generateCap(true);\r\n    if (bottomCap && radiusBottom > 0)\r\n        generateCap(false);\r\n    return {\r\n        vertices: new Float32Array(vertices),\r\n        normals: new Float32Array(normals),\r\n        indices: new Uint32Array(indices)\r\n    };\r\n    function generateTorso() {\r\n        var normal = Vec3.zero();\r\n        // this will be used to calculate the normal\r\n        var slope = (radiusBottom - radiusTop) / height;\r\n        // generate vertices, normals and uvs\r\n        for (var y = 0; y <= heightSegments; ++y) {\r\n            var indexRow = [];\r\n            var v = y / heightSegments;\r\n            // calculate the radius of the current row\r\n            var radius = v * (radiusBottom - radiusTop) + radiusTop;\r\n            for (var x = 0; x <= radialSegments; ++x) {\r\n                var u = x / radialSegments;\r\n                var theta = u * thetaLength + thetaStart;\r\n                var sinTheta = Math.sin(theta);\r\n                var cosTheta = Math.cos(theta);\r\n                // vertex\r\n                vertices.push(radius * sinTheta, -v * height + halfHeight, radius * cosTheta);\r\n                // normal\r\n                Vec3.normalize(normal, Vec3.set(normal, sinTheta, slope, cosTheta));\r\n                normals.push.apply(normals, normal);\r\n                // save index of vertex in respective row\r\n                indexRow.push(index++);\r\n            }\r\n            // now save vertices of the row in our index array\r\n            indexArray.push(indexRow);\r\n        }\r\n        // generate indices\r\n        for (var x = 0; x < radialSegments; ++x) {\r\n            for (var y = 0; y < heightSegments; ++y) {\r\n                // we use the index array to access the correct indices\r\n                var a = indexArray[y][x];\r\n                var b = indexArray[y + 1][x];\r\n                var c = indexArray[y + 1][x + 1];\r\n                var d = indexArray[y][x + 1];\r\n                // faces\r\n                indices.push(a, b, d);\r\n                indices.push(b, c, d);\r\n            }\r\n        }\r\n    }\r\n    function generateCap(top) {\r\n        var radius = (top === true) ? radiusTop : radiusBottom;\r\n        var sign = (top === true) ? 1 : -1;\r\n        // save the index of the first center vertex\r\n        var centerIndexStart = index;\r\n        // first we generate the center vertex data of the cap.\r\n        // because the geometry needs one set of uvs per face,\r\n        // we must generate a center vertex per face/segment\r\n        for (var x = 1; x <= radialSegments; ++x) {\r\n            // vertex\r\n            vertices.push(0, halfHeight * sign, 0);\r\n            // normal\r\n            normals.push(0, sign, 0);\r\n            // increase index\r\n            ++index;\r\n        }\r\n        // save the index of the last center vertex\r\n        var centerIndexEnd = index;\r\n        // now we generate the surrounding vertices, normals and uvs\r\n        for (var x = 0; x <= radialSegments; ++x) {\r\n            var u = x / radialSegments;\r\n            var theta = u * thetaLength + thetaStart;\r\n            var cosTheta = Math.cos(theta);\r\n            var sinTheta = Math.sin(theta);\r\n            // vertex\r\n            vertices.push(radius * sinTheta, halfHeight * sign, radius * cosTheta);\r\n            // normal\r\n            normals.push(0, sign, 0);\r\n            // increase index\r\n            ++index;\r\n        }\r\n        // generate indices\r\n        for (var x = 0; x < radialSegments; ++x) {\r\n            var c = centerIndexStart + x;\r\n            var i = centerIndexEnd + x;\r\n            if (top === true) {\r\n                indices.push(i, i + 1, c); // face top\r\n            }\r\n            else {\r\n                indices.push(i + 1, i, c); // face bottom\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=cylinder.js.map"]},"metadata":{},"sourceType":"module"}