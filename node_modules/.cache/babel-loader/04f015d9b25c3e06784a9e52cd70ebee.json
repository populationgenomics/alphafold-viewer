{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\nimport { transformPositionArray, createGroupMapping } from '../../util';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { createSizes } from '../size-data';\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\nimport { LinesBuilder } from './lines-builder';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { hashFnv32a } from '../../../mol-data/util';\nimport { createEmptyClipping } from '../clipping-data';\nexport var Lines;\n\n(function (Lines) {\n  function create(mappings, indices, groups, starts, ends, lineCount, lines) {\n    return lines ? update(mappings, indices, groups, starts, ends, lineCount, lines) : fromArrays(mappings, indices, groups, starts, ends, lineCount);\n  }\n\n  Lines.create = create;\n\n  function createEmpty(lines) {\n    var mb = lines ? lines.mappingBuffer.ref.value : new Float32Array(0);\n    var ib = lines ? lines.indexBuffer.ref.value : new Uint32Array(0);\n    var gb = lines ? lines.groupBuffer.ref.value : new Float32Array(0);\n    var sb = lines ? lines.startBuffer.ref.value : new Float32Array(0);\n    var eb = lines ? lines.endBuffer.ref.value : new Float32Array(0);\n    return create(mb, ib, gb, sb, eb, 0, lines);\n  }\n\n  Lines.createEmpty = createEmpty;\n\n  function fromMesh(mesh, lines) {\n    var vb = mesh.vertexBuffer.ref.value;\n    var ib = mesh.indexBuffer.ref.value;\n    var gb = mesh.groupBuffer.ref.value;\n    var builder = LinesBuilder.create(mesh.triangleCount * 3, mesh.triangleCount / 10, lines); // TODO avoid duplicate lines\n\n    for (var i = 0, il = mesh.triangleCount * 3; i < il; i += 3) {\n      var i0 = ib[i],\n          i1 = ib[i + 1],\n          i2 = ib[i + 2];\n      var x0 = vb[i0 * 3],\n          y0 = vb[i0 * 3 + 1],\n          z0 = vb[i0 * 3 + 2];\n      var x1 = vb[i1 * 3],\n          y1 = vb[i1 * 3 + 1],\n          z1 = vb[i1 * 3 + 2];\n      var x2 = vb[i2 * 3],\n          y2 = vb[i2 * 3 + 1],\n          z2 = vb[i2 * 3 + 2];\n      builder.add(x0, y0, z0, x1, y1, z1, gb[i0]);\n      builder.add(x0, y0, z0, x2, y2, z2, gb[i0]);\n      builder.add(x1, y1, z1, x2, y2, z2, gb[i1]);\n    }\n\n    return builder.getLines();\n  }\n\n  Lines.fromMesh = fromMesh;\n\n  function hashCode(lines) {\n    return hashFnv32a([lines.lineCount, lines.mappingBuffer.ref.version, lines.indexBuffer.ref.version, lines.groupBuffer.ref.version, lines.startBuffer.ref.version, lines.endBuffer.ref.version]);\n  }\n\n  function fromArrays(mappings, indices, groups, starts, ends, lineCount) {\n    var boundingSphere = Sphere3D();\n    var groupMapping;\n    var currentHash = -1;\n    var currentGroup = -1;\n    var lines = {\n      kind: 'lines',\n      lineCount: lineCount,\n      mappingBuffer: ValueCell.create(mappings),\n      indexBuffer: ValueCell.create(indices),\n      groupBuffer: ValueCell.create(groups),\n      startBuffer: ValueCell.create(starts),\n      endBuffer: ValueCell.create(ends),\n\n      get boundingSphere() {\n        var newHash = hashCode(lines);\n\n        if (newHash !== currentHash) {\n          var s = calculateInvariantBoundingSphere(lines.startBuffer.ref.value, lines.lineCount * 4, 4);\n          var e = calculateInvariantBoundingSphere(lines.endBuffer.ref.value, lines.lineCount * 4, 4);\n          Sphere3D.expandBySphere(boundingSphere, s, e);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      },\n\n      get groupMapping() {\n        if (lines.groupBuffer.ref.version !== currentGroup) {\n          groupMapping = createGroupMapping(lines.groupBuffer.ref.value, lines.lineCount, 4);\n          currentGroup = lines.groupBuffer.ref.version;\n        }\n\n        return groupMapping;\n      },\n\n      setBoundingSphere: function (sphere) {\n        Sphere3D.copy(boundingSphere, sphere);\n        currentHash = hashCode(lines);\n      }\n    };\n    return lines;\n  }\n\n  function update(mappings, indices, groups, starts, ends, lineCount, lines) {\n    if (lineCount > lines.lineCount) {\n      ValueCell.update(lines.mappingBuffer, mappings);\n      ValueCell.update(lines.indexBuffer, indices);\n    }\n\n    lines.lineCount = lineCount;\n    ValueCell.update(lines.groupBuffer, groups);\n    ValueCell.update(lines.startBuffer, starts);\n    ValueCell.update(lines.endBuffer, ends);\n    return lines;\n  }\n\n  function transform(lines, t) {\n    var start = lines.startBuffer.ref.value;\n    transformPositionArray(t, start, 0, lines.lineCount * 4);\n    ValueCell.update(lines.startBuffer, start);\n    var end = lines.endBuffer.ref.value;\n    transformPositionArray(t, end, 0, lines.lineCount * 4);\n    ValueCell.update(lines.endBuffer, end);\n  }\n\n  Lines.transform = transform; //\n\n  Lines.Params = __assign(__assign({}, BaseGeometry.Params), {\n    sizeFactor: PD.Numeric(3, {\n      min: 0,\n      max: 10,\n      step: 0.1\n    }),\n    lineSizeAttenuation: PD.Boolean(false)\n  });\n  Lines.Utils = {\n    Params: Lines.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: BaseGeometry.createRenderableState,\n    updateRenderableState: BaseGeometry.updateRenderableState,\n    createPositionIterator: createPositionIterator\n  };\n\n  function createPositionIterator(lines, transform) {\n    var groupCount = lines.lineCount * 4;\n    var instanceCount = transform.instanceCount.ref.value;\n    var location = PositionLocation();\n    var p = location.position;\n    var s = lines.startBuffer.ref.value;\n    var e = lines.endBuffer.ref.value;\n    var m = transform.aTransform.ref.value;\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var v = groupIndex % 4 === 0 ? s : e;\n\n      if (instanceIndex < 0) {\n        Vec3.fromArray(p, v, groupIndex * 3);\n      } else {\n        Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\n      }\n\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 2, getLocation);\n  }\n\n  function createValues(lines, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = createPositionIterator(lines, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var size = createSizes(locationIt, theme.size);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: lines.lineCount * 2 * 3,\n      vertexCount: lines.lineCount * 4,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      aMapping: lines.mappingBuffer,\n      aGroup: lines.groupBuffer,\n      aStart: lines.startBuffer,\n      aEnd: lines.endBuffer,\n      elements: lines.indexBuffer,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), size), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), {\n      uSizeFactor: ValueCell.create(props.sizeFactor),\n      dLineSizeAttenuation: ValueCell.create(props.lineSizeAttenuation),\n      dDoubleSided: ValueCell.create(true),\n      dFlipSided: ValueCell.create(false)\n    });\n  }\n\n  function createValuesSimple(lines, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Lines.Params)), props);\n\n    return createValues(lines, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\n    ValueCell.updateIfChanged(values.dLineSizeAttenuation, props.lineSizeAttenuation);\n  }\n\n  function updateBoundingSphere(values, lines) {\n    var invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n})(Lines || (Lines = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/lines/lines.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { transformPositionArray, createGroupMapping } from '../../util';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { createSizes } from '../size-data';\r\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\r\nimport { LinesBuilder } from './lines-builder';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { hashFnv32a } from '../../../mol-data/util';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nexport var Lines;\r\n(function (Lines) {\r\n    function create(mappings, indices, groups, starts, ends, lineCount, lines) {\r\n        return lines ?\r\n            update(mappings, indices, groups, starts, ends, lineCount, lines) :\r\n            fromArrays(mappings, indices, groups, starts, ends, lineCount);\r\n    }\r\n    Lines.create = create;\r\n    function createEmpty(lines) {\r\n        var mb = lines ? lines.mappingBuffer.ref.value : new Float32Array(0);\r\n        var ib = lines ? lines.indexBuffer.ref.value : new Uint32Array(0);\r\n        var gb = lines ? lines.groupBuffer.ref.value : new Float32Array(0);\r\n        var sb = lines ? lines.startBuffer.ref.value : new Float32Array(0);\r\n        var eb = lines ? lines.endBuffer.ref.value : new Float32Array(0);\r\n        return create(mb, ib, gb, sb, eb, 0, lines);\r\n    }\r\n    Lines.createEmpty = createEmpty;\r\n    function fromMesh(mesh, lines) {\r\n        var vb = mesh.vertexBuffer.ref.value;\r\n        var ib = mesh.indexBuffer.ref.value;\r\n        var gb = mesh.groupBuffer.ref.value;\r\n        var builder = LinesBuilder.create(mesh.triangleCount * 3, mesh.triangleCount / 10, lines);\r\n        // TODO avoid duplicate lines\r\n        for (var i = 0, il = mesh.triangleCount * 3; i < il; i += 3) {\r\n            var i0 = ib[i], i1 = ib[i + 1], i2 = ib[i + 2];\r\n            var x0 = vb[i0 * 3], y0 = vb[i0 * 3 + 1], z0 = vb[i0 * 3 + 2];\r\n            var x1 = vb[i1 * 3], y1 = vb[i1 * 3 + 1], z1 = vb[i1 * 3 + 2];\r\n            var x2 = vb[i2 * 3], y2 = vb[i2 * 3 + 1], z2 = vb[i2 * 3 + 2];\r\n            builder.add(x0, y0, z0, x1, y1, z1, gb[i0]);\r\n            builder.add(x0, y0, z0, x2, y2, z2, gb[i0]);\r\n            builder.add(x1, y1, z1, x2, y2, z2, gb[i1]);\r\n        }\r\n        return builder.getLines();\r\n    }\r\n    Lines.fromMesh = fromMesh;\r\n    function hashCode(lines) {\r\n        return hashFnv32a([\r\n            lines.lineCount, lines.mappingBuffer.ref.version, lines.indexBuffer.ref.version,\r\n            lines.groupBuffer.ref.version, lines.startBuffer.ref.version, lines.endBuffer.ref.version\r\n        ]);\r\n    }\r\n    function fromArrays(mappings, indices, groups, starts, ends, lineCount) {\r\n        var boundingSphere = Sphere3D();\r\n        var groupMapping;\r\n        var currentHash = -1;\r\n        var currentGroup = -1;\r\n        var lines = {\r\n            kind: 'lines',\r\n            lineCount: lineCount,\r\n            mappingBuffer: ValueCell.create(mappings),\r\n            indexBuffer: ValueCell.create(indices),\r\n            groupBuffer: ValueCell.create(groups),\r\n            startBuffer: ValueCell.create(starts),\r\n            endBuffer: ValueCell.create(ends),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(lines);\r\n                if (newHash !== currentHash) {\r\n                    var s = calculateInvariantBoundingSphere(lines.startBuffer.ref.value, lines.lineCount * 4, 4);\r\n                    var e = calculateInvariantBoundingSphere(lines.endBuffer.ref.value, lines.lineCount * 4, 4);\r\n                    Sphere3D.expandBySphere(boundingSphere, s, e);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n            get groupMapping() {\r\n                if (lines.groupBuffer.ref.version !== currentGroup) {\r\n                    groupMapping = createGroupMapping(lines.groupBuffer.ref.value, lines.lineCount, 4);\r\n                    currentGroup = lines.groupBuffer.ref.version;\r\n                }\r\n                return groupMapping;\r\n            },\r\n            setBoundingSphere: function (sphere) {\r\n                Sphere3D.copy(boundingSphere, sphere);\r\n                currentHash = hashCode(lines);\r\n            }\r\n        };\r\n        return lines;\r\n    }\r\n    function update(mappings, indices, groups, starts, ends, lineCount, lines) {\r\n        if (lineCount > lines.lineCount) {\r\n            ValueCell.update(lines.mappingBuffer, mappings);\r\n            ValueCell.update(lines.indexBuffer, indices);\r\n        }\r\n        lines.lineCount = lineCount;\r\n        ValueCell.update(lines.groupBuffer, groups);\r\n        ValueCell.update(lines.startBuffer, starts);\r\n        ValueCell.update(lines.endBuffer, ends);\r\n        return lines;\r\n    }\r\n    function transform(lines, t) {\r\n        var start = lines.startBuffer.ref.value;\r\n        transformPositionArray(t, start, 0, lines.lineCount * 4);\r\n        ValueCell.update(lines.startBuffer, start);\r\n        var end = lines.endBuffer.ref.value;\r\n        transformPositionArray(t, end, 0, lines.lineCount * 4);\r\n        ValueCell.update(lines.endBuffer, end);\r\n    }\r\n    Lines.transform = transform;\r\n    //\r\n    Lines.Params = __assign(__assign({}, BaseGeometry.Params), { sizeFactor: PD.Numeric(3, { min: 0, max: 10, step: 0.1 }), lineSizeAttenuation: PD.Boolean(false) });\r\n    Lines.Utils = {\r\n        Params: Lines.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: BaseGeometry.createRenderableState,\r\n        updateRenderableState: BaseGeometry.updateRenderableState,\r\n        createPositionIterator: createPositionIterator\r\n    };\r\n    function createPositionIterator(lines, transform) {\r\n        var groupCount = lines.lineCount * 4;\r\n        var instanceCount = transform.instanceCount.ref.value;\r\n        var location = PositionLocation();\r\n        var p = location.position;\r\n        var s = lines.startBuffer.ref.value;\r\n        var e = lines.endBuffer.ref.value;\r\n        var m = transform.aTransform.ref.value;\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var v = groupIndex % 4 === 0 ? s : e;\r\n            if (instanceIndex < 0) {\r\n                Vec3.fromArray(p, v, groupIndex * 3);\r\n            }\r\n            else {\r\n                Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\r\n            }\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 2, getLocation);\r\n    }\r\n    function createValues(lines, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = createPositionIterator(lines, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var size = createSizes(locationIt, theme.size);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: lines.lineCount * 2 * 3, vertexCount: lines.lineCount * 4, groupCount: groupCount, instanceCount: instanceCount };\r\n        var invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ aMapping: lines.mappingBuffer, aGroup: lines.groupBuffer, aStart: lines.startBuffer, aEnd: lines.endBuffer, elements: lines.indexBuffer, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), size), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), { uSizeFactor: ValueCell.create(props.sizeFactor), dLineSizeAttenuation: ValueCell.create(props.lineSizeAttenuation), dDoubleSided: ValueCell.create(true), dFlipSided: ValueCell.create(false) });\r\n    }\r\n    function createValuesSimple(lines, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Lines.Params)), props);\r\n        return createValues(lines, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\r\n        ValueCell.updateIfChanged(values.dLineSizeAttenuation, props.lineSizeAttenuation);\r\n    }\r\n    function updateBoundingSphere(values, lines) {\r\n        var invariantBoundingSphere = Sphere3D.clone(lines.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n})(Lines || (Lines = {}));\r\n//# sourceMappingURL=lines.js.map"]},"metadata":{},"sourceType":"module"}