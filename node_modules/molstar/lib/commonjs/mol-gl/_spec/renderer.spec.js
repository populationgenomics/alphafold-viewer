"use strict";
/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var gl_shim_1 = require("./gl.shim");
var camera_1 = require("../../mol-canvas3d/camera");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
var mol_util_1 = require("../../mol-util");
var renderer_1 = require("../renderer");
var color_data_1 = require("../../mol-geo/geometry/color-data");
var size_data_1 = require("../../mol-geo/geometry/size-data");
var context_1 = require("../webgl/context");
var render_object_1 = require("../render-object");
var scene_1 = require("../scene");
var marker_data_1 = require("../../mol-geo/geometry/marker-data");
var array_1 = require("../../mol-util/array");
var color_1 = require("../../mol-util/color");
var geometry_1 = require("../../mol-math/geometry");
var overpaint_data_1 = require("../../mol-geo/geometry/overpaint-data");
var transparency_data_1 = require("../../mol-geo/geometry/transparency-data");
var clipping_data_1 = require("../../mol-geo/geometry/clipping-data");
function createRenderer(gl) {
    var ctx = (0, context_1.createContext)(gl);
    var camera = new camera_1.Camera({
        position: linear_algebra_1.Vec3.create(0, 0, 50)
    });
    var renderer = renderer_1.Renderer.create(ctx);
    return { ctx: ctx, camera: camera, renderer: renderer };
}
function createPoints() {
    var aPosition = mol_util_1.ValueCell.create(new Float32Array([0, -1, 0, -1, 0, 0, 1, 1, 0]));
    var aGroup = mol_util_1.ValueCell.create((0, array_1.fillSerial)(new Float32Array(3)));
    var aInstance = mol_util_1.ValueCell.create((0, array_1.fillSerial)(new Float32Array(1)));
    var color = (0, color_data_1.createValueColor)((0, color_1.Color)(0xFF0000));
    var size = (0, size_data_1.createValueSize)(1);
    var marker = (0, marker_data_1.createEmptyMarkers)();
    var overpaint = (0, overpaint_data_1.createEmptyOverpaint)();
    var transparency = (0, transparency_data_1.createEmptyTransparency)();
    var clipping = (0, clipping_data_1.createEmptyClipping)();
    var aTransform = mol_util_1.ValueCell.create(new Float32Array(16));
    var m4 = linear_algebra_1.Mat4.identity();
    linear_algebra_1.Mat4.toArray(m4, aTransform.ref.value, 0);
    var transform = mol_util_1.ValueCell.create(new Float32Array(aTransform.ref.value));
    var extraTransform = mol_util_1.ValueCell.create(new Float32Array(aTransform.ref.value));
    var boundingSphere = mol_util_1.ValueCell.create(geometry_1.Sphere3D.create(linear_algebra_1.Vec3.zero(), 2));
    var invariantBoundingSphere = mol_util_1.ValueCell.create(geometry_1.Sphere3D.create(linear_algebra_1.Vec3.zero(), 2));
    var values = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({ aPosition: aPosition, aGroup: aGroup, aTransform: aTransform, aInstance: aInstance }, color), marker), size), overpaint), transparency), clipping), { uAlpha: mol_util_1.ValueCell.create(1.0), uVertexCount: mol_util_1.ValueCell.create(3), uInstanceCount: mol_util_1.ValueCell.create(1), uGroupCount: mol_util_1.ValueCell.create(3), uInvariantBoundingSphere: mol_util_1.ValueCell.create(linear_algebra_1.Vec4.ofSphere(invariantBoundingSphere.ref.value)), alpha: mol_util_1.ValueCell.create(1.0), drawCount: mol_util_1.ValueCell.create(3), instanceCount: mol_util_1.ValueCell.create(1), matrix: mol_util_1.ValueCell.create(m4), transform: transform, extraTransform: extraTransform, hasReflection: mol_util_1.ValueCell.create(false), boundingSphere: boundingSphere, invariantBoundingSphere: invariantBoundingSphere, uSizeFactor: mol_util_1.ValueCell.create(1), dPointSizeAttenuation: mol_util_1.ValueCell.create(true), dPointStyle: mol_util_1.ValueCell.create('square') });
    var state = {
        disposed: false,
        visible: true,
        alphaFactor: 1,
        pickable: true,
        colorOnly: false,
        opaque: true,
        writeDepth: true,
        noClip: false,
    };
    return (0, render_object_1.createRenderObject)('points', values, state, -1);
}
describe('renderer', function () {
    it('basic', function () {
        var _a = [32, 32], width = _a[0], height = _a[1];
        var gl = (0, gl_shim_1.createGl)(width, height, { preserveDrawingBuffer: true });
        var _b = createRenderer(gl), ctx = _b.ctx, renderer = _b.renderer;
        expect(ctx.gl.canvas.width).toBe(32);
        expect(ctx.gl.canvas.height).toBe(32);
        expect(ctx.stats.resourceCounts.attribute).toBe(0);
        expect(ctx.stats.resourceCounts.texture).toBe(0);
        expect(ctx.stats.resourceCounts.vertexArray).toBe(0);
        expect(ctx.stats.resourceCounts.program).toBe(0);
        expect(ctx.stats.resourceCounts.shader).toBe(0);
        renderer.setViewport(0, 0, 64, 48);
        expect(ctx.gl.getParameter(ctx.gl.VIEWPORT)[2]).toBe(64);
        expect(ctx.gl.getParameter(ctx.gl.VIEWPORT)[3]).toBe(48);
    });
    it('points', function () { return (0, tslib_1.__awaiter)(void 0, void 0, void 0, function () {
        var _a, width, height, gl, ctx, scene, points;
        return (0, tslib_1.__generator)(this, function (_b) {
            _a = [32, 32], width = _a[0], height = _a[1];
            gl = (0, gl_shim_1.createGl)(width, height, { preserveDrawingBuffer: true });
            ctx = createRenderer(gl).ctx;
            scene = scene_1.Scene.create(ctx);
            points = createPoints();
            scene.add(points);
            scene.commit();
            expect(ctx.stats.resourceCounts.attribute).toBe(ctx.isWebGL2 ? 4 : 5);
            expect(ctx.stats.resourceCounts.texture).toBe(7);
            expect(ctx.stats.resourceCounts.vertexArray).toBe(8);
            expect(ctx.stats.resourceCounts.program).toBe(8);
            expect(ctx.stats.resourceCounts.shader).toBe(16);
            scene.remove(points);
            scene.commit();
            expect(ctx.stats.resourceCounts.attribute).toBe(0);
            expect(ctx.stats.resourceCounts.texture).toBe(0);
            expect(ctx.stats.resourceCounts.vertexArray).toBe(0);
            expect(ctx.stats.resourceCounts.program).toBe(8);
            expect(ctx.stats.resourceCounts.shader).toBe(16);
            ctx.resources.destroy();
            expect(ctx.stats.resourceCounts.program).toBe(0);
            expect(ctx.stats.resourceCounts.shader).toBe(0);
            return [2 /*return*/];
        });
    }); });
});
//# sourceMappingURL=renderer.spec.js.map