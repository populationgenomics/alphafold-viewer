{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { substringStartsWith } from '../../../mol-util/string';\nimport { CifCategory } from '../../../mol-io/reader/cif';\nimport { Tokenizer } from '../../../mol-io/reader/common/text/tokenizer';\nimport { parseCryst1, parseRemark350, parseMtrix } from './assembly';\nimport { parseHelix, parseSheet } from './secondary-structure';\nimport { parseCmpnd, parseHetnam } from './entity';\nimport { ComponentBuilder } from '../common/component';\nimport { EntityBuilder } from '../common/entity';\nimport { Column } from '../../../mol-data/db';\nimport { getMoleculeType } from '../../../mol-model/structure/model/types';\nimport { getAtomSiteTemplate, addAtom, getAtomSite } from './atom-site';\nimport { addAnisotropic, getAnisotropicTemplate, getAnisotropic } from './anisotropic';\nimport { parseConect } from './conect';\nimport { isDebugMode } from '../../../mol-util/debug';\nexport function pdbToMmCif(pdb) {\n  return __awaiter(this, void 0, void 0, function () {\n    var lines, data, indices, tokenizer, isPdbqt, atomCount, anisotropicCount, i, _i, s, e, atomSite, anisotropic, entityBuilder, helperCategories, heteroNames, modelNum, modelStr, conectRange, i, _i, s, e, j, j, j, j, j, j, j, seqIds, atomIds, compIds, asymIds, componentBuilder, i, il, compId, moleculeType, atom_site, categories, _a, helperCategories_1, c;\n\n    return __generator(this, function (_b) {\n      lines = pdb.lines;\n      data = lines.data, indices = lines.indices;\n      tokenizer = Tokenizer(data);\n      isPdbqt = !!pdb.isPdbqt;\n      atomCount = 0;\n      anisotropicCount = 0;\n\n      for (i = 0, _i = lines.count; i < _i; i++) {\n        s = indices[2 * i], e = indices[2 * i + 1];\n\n        switch (data[s]) {\n          case 'A':\n            if (substringStartsWith(data, s, e, 'ATOM  ')) atomCount++;else if (substringStartsWith(data, s, e, 'ANISOU')) anisotropicCount++;\n            break;\n\n          case 'H':\n            if (substringStartsWith(data, s, e, 'HETATM')) atomCount++;\n            break;\n        }\n      }\n\n      atomSite = getAtomSiteTemplate(data, atomCount);\n      anisotropic = getAnisotropicTemplate(data, anisotropicCount);\n      entityBuilder = new EntityBuilder();\n      helperCategories = [];\n      heteroNames = [];\n      modelNum = 0, modelStr = '';\n      conectRange = undefined;\n\n      for (i = 0, _i = lines.count; i < _i; i++) {\n        s = indices[2 * i], e = indices[2 * i + 1];\n\n        switch (data[s]) {\n          case 'A':\n            if (substringStartsWith(data, s, e, 'ATOM  ')) {\n              if (!modelNum) {\n                modelNum++;\n                modelStr = '' + modelNum;\n              }\n\n              addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);\n            } else if (substringStartsWith(data, s, e, 'ANISOU')) {\n              addAnisotropic(anisotropic, modelStr, tokenizer, s, e);\n            }\n\n            break;\n\n          case 'C':\n            if (substringStartsWith(data, s, e, 'CRYST1')) {\n              helperCategories.push.apply(helperCategories, parseCryst1(pdb.id || '?', data.substring(s, e)));\n            } else if (substringStartsWith(data, s, e, 'CONECT')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'CONECT')) break;\n                j++;\n              }\n\n              if (conectRange) {\n                if (isDebugMode) {\n                  console.log('only single CONECT block allowed, ignoring others');\n                }\n              } else {\n                conectRange = [i, j];\n              }\n\n              i = j - 1;\n            } else if (substringStartsWith(data, s, e, 'COMPND')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'COMPND')) break;\n                j++;\n              }\n\n              entityBuilder.setCompounds(parseCmpnd(lines, i, j));\n              i = j - 1;\n            }\n\n            break;\n\n          case 'H':\n            if (substringStartsWith(data, s, e, 'HETATM')) {\n              if (!modelNum) {\n                modelNum++;\n                modelStr = '' + modelNum;\n              }\n\n              addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);\n            } else if (substringStartsWith(data, s, e, 'HELIX')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'HELIX')) break;\n                j++;\n              }\n\n              helperCategories.push(parseHelix(lines, i, j));\n              i = j - 1;\n            } else if (substringStartsWith(data, s, e, 'HETNAM')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'HETNAM')) break;\n                j++;\n              }\n\n              heteroNames.push.apply(heteroNames, Array.from(parseHetnam(lines, i, j).entries()));\n              i = j - 1;\n            }\n\n            break;\n\n          case 'M':\n            if (substringStartsWith(data, s, e, 'MODEL ')) {\n              modelNum++;\n              modelStr = '' + modelNum;\n            }\n\n            if (substringStartsWith(data, s, e, 'MTRIX')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'MTRIX')) break;\n                j++;\n              }\n\n              helperCategories.push.apply(helperCategories, parseMtrix(lines, i, j));\n              i = j - 1;\n            } // TODO: MODRES records => pdbx_struct_mod_residue\n\n\n            break;\n\n          case 'O':\n            // TODO: ORIGX record => cif.database_PDB_matrix.origx, cif.database_PDB_matrix.origx_vector\n            break;\n\n          case 'R':\n            if (substringStartsWith(data, s, e, 'REMARK 350')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'REMARK 350')) break;\n                j++;\n              }\n\n              helperCategories.push.apply(helperCategories, parseRemark350(lines, i, j));\n              i = j - 1;\n            }\n\n            break;\n\n          case 'S':\n            if (substringStartsWith(data, s, e, 'SHEET')) {\n              j = i + 1;\n\n              while (true) {\n                s = indices[2 * j];\n                e = indices[2 * j + 1];\n                if (!substringStartsWith(data, s, e, 'SHEET')) break;\n                j++;\n              }\n\n              helperCategories.push(parseSheet(lines, i, j));\n              i = j - 1;\n            } // TODO: SCALE record => cif.atom_sites.fract_transf_matrix, cif.atom_sites.fract_transf_vector\n\n\n            break;\n        }\n      }\n\n      seqIds = Column.ofIntTokens(atomSite.auth_seq_id);\n      atomIds = Column.ofStringTokens(atomSite.auth_atom_id);\n      compIds = Column.ofStringTokens(atomSite.auth_comp_id);\n      asymIds = Column.ofStringTokens(atomSite.auth_asym_id);\n      componentBuilder = new ComponentBuilder(seqIds, atomIds);\n      componentBuilder.setNames(heteroNames);\n      entityBuilder.setNames(heteroNames);\n\n      for (i = 0, il = compIds.rowCount; i < il; ++i) {\n        compId = compIds.value(i);\n        moleculeType = getMoleculeType(componentBuilder.add(compId, i).type, compId);\n        atomSite.label_entity_id[i] = entityBuilder.getEntityId(compId, moleculeType, asymIds.value(i));\n      }\n\n      atom_site = getAtomSite(atomSite);\n      if (!isPdbqt) delete atom_site.partial_charge;\n\n      if (conectRange) {\n        helperCategories.push(parseConect(lines, conectRange[0], conectRange[1], atom_site));\n      }\n\n      categories = {\n        entity: CifCategory.ofTable('entity', entityBuilder.getEntityTable()),\n        chem_comp: CifCategory.ofTable('chem_comp', componentBuilder.getChemCompTable()),\n        atom_site: CifCategory.ofFields('atom_site', atom_site),\n        atom_site_anisotrop: CifCategory.ofFields('atom_site_anisotrop', getAnisotropic(anisotropic))\n      };\n\n      for (_a = 0, helperCategories_1 = helperCategories; _a < helperCategories_1.length; _a++) {\n        c = helperCategories_1[_a];\n        categories[c.name] = c;\n      }\n\n      return [2\n      /*return*/\n      , {\n        header: pdb.id || 'PDB',\n        categoryNames: Object.keys(categories),\n        categories: categories\n      }];\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/pdb/to-cif.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { substringStartsWith } from '../../../mol-util/string';\r\nimport { CifCategory } from '../../../mol-io/reader/cif';\r\nimport { Tokenizer } from '../../../mol-io/reader/common/text/tokenizer';\r\nimport { parseCryst1, parseRemark350, parseMtrix } from './assembly';\r\nimport { parseHelix, parseSheet } from './secondary-structure';\r\nimport { parseCmpnd, parseHetnam } from './entity';\r\nimport { ComponentBuilder } from '../common/component';\r\nimport { EntityBuilder } from '../common/entity';\r\nimport { Column } from '../../../mol-data/db';\r\nimport { getMoleculeType } from '../../../mol-model/structure/model/types';\r\nimport { getAtomSiteTemplate, addAtom, getAtomSite } from './atom-site';\r\nimport { addAnisotropic, getAnisotropicTemplate, getAnisotropic } from './anisotropic';\r\nimport { parseConect } from './conect';\r\nimport { isDebugMode } from '../../../mol-util/debug';\r\nexport function pdbToMmCif(pdb) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var lines, data, indices, tokenizer, isPdbqt, atomCount, anisotropicCount, i, _i, s, e, atomSite, anisotropic, entityBuilder, helperCategories, heteroNames, modelNum, modelStr, conectRange, i, _i, s, e, j, j, j, j, j, j, j, seqIds, atomIds, compIds, asymIds, componentBuilder, i, il, compId, moleculeType, atom_site, categories, _a, helperCategories_1, c;\r\n        return __generator(this, function (_b) {\r\n            lines = pdb.lines;\r\n            data = lines.data, indices = lines.indices;\r\n            tokenizer = Tokenizer(data);\r\n            isPdbqt = !!pdb.isPdbqt;\r\n            atomCount = 0;\r\n            anisotropicCount = 0;\r\n            for (i = 0, _i = lines.count; i < _i; i++) {\r\n                s = indices[2 * i], e = indices[2 * i + 1];\r\n                switch (data[s]) {\r\n                    case 'A':\r\n                        if (substringStartsWith(data, s, e, 'ATOM  '))\r\n                            atomCount++;\r\n                        else if (substringStartsWith(data, s, e, 'ANISOU'))\r\n                            anisotropicCount++;\r\n                        break;\r\n                    case 'H':\r\n                        if (substringStartsWith(data, s, e, 'HETATM'))\r\n                            atomCount++;\r\n                        break;\r\n                }\r\n            }\r\n            atomSite = getAtomSiteTemplate(data, atomCount);\r\n            anisotropic = getAnisotropicTemplate(data, anisotropicCount);\r\n            entityBuilder = new EntityBuilder();\r\n            helperCategories = [];\r\n            heteroNames = [];\r\n            modelNum = 0, modelStr = '';\r\n            conectRange = undefined;\r\n            for (i = 0, _i = lines.count; i < _i; i++) {\r\n                s = indices[2 * i], e = indices[2 * i + 1];\r\n                switch (data[s]) {\r\n                    case 'A':\r\n                        if (substringStartsWith(data, s, e, 'ATOM  ')) {\r\n                            if (!modelNum) {\r\n                                modelNum++;\r\n                                modelStr = '' + modelNum;\r\n                            }\r\n                            addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);\r\n                        }\r\n                        else if (substringStartsWith(data, s, e, 'ANISOU')) {\r\n                            addAnisotropic(anisotropic, modelStr, tokenizer, s, e);\r\n                        }\r\n                        break;\r\n                    case 'C':\r\n                        if (substringStartsWith(data, s, e, 'CRYST1')) {\r\n                            helperCategories.push.apply(helperCategories, parseCryst1(pdb.id || '?', data.substring(s, e)));\r\n                        }\r\n                        else if (substringStartsWith(data, s, e, 'CONECT')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'CONECT'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            if (conectRange) {\r\n                                if (isDebugMode) {\r\n                                    console.log('only single CONECT block allowed, ignoring others');\r\n                                }\r\n                            }\r\n                            else {\r\n                                conectRange = [i, j];\r\n                            }\r\n                            i = j - 1;\r\n                        }\r\n                        else if (substringStartsWith(data, s, e, 'COMPND')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'COMPND'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            entityBuilder.setCompounds(parseCmpnd(lines, i, j));\r\n                            i = j - 1;\r\n                        }\r\n                        break;\r\n                    case 'H':\r\n                        if (substringStartsWith(data, s, e, 'HETATM')) {\r\n                            if (!modelNum) {\r\n                                modelNum++;\r\n                                modelStr = '' + modelNum;\r\n                            }\r\n                            addAtom(atomSite, modelStr, tokenizer, s, e, isPdbqt);\r\n                        }\r\n                        else if (substringStartsWith(data, s, e, 'HELIX')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'HELIX'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            helperCategories.push(parseHelix(lines, i, j));\r\n                            i = j - 1;\r\n                        }\r\n                        else if (substringStartsWith(data, s, e, 'HETNAM')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'HETNAM'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            heteroNames.push.apply(heteroNames, Array.from(parseHetnam(lines, i, j).entries()));\r\n                            i = j - 1;\r\n                        }\r\n                        break;\r\n                    case 'M':\r\n                        if (substringStartsWith(data, s, e, 'MODEL ')) {\r\n                            modelNum++;\r\n                            modelStr = '' + modelNum;\r\n                        }\r\n                        if (substringStartsWith(data, s, e, 'MTRIX')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'MTRIX'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            helperCategories.push.apply(helperCategories, parseMtrix(lines, i, j));\r\n                            i = j - 1;\r\n                        }\r\n                        // TODO: MODRES records => pdbx_struct_mod_residue\r\n                        break;\r\n                    case 'O':\r\n                        // TODO: ORIGX record => cif.database_PDB_matrix.origx, cif.database_PDB_matrix.origx_vector\r\n                        break;\r\n                    case 'R':\r\n                        if (substringStartsWith(data, s, e, 'REMARK 350')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'REMARK 350'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            helperCategories.push.apply(helperCategories, parseRemark350(lines, i, j));\r\n                            i = j - 1;\r\n                        }\r\n                        break;\r\n                    case 'S':\r\n                        if (substringStartsWith(data, s, e, 'SHEET')) {\r\n                            j = i + 1;\r\n                            while (true) {\r\n                                s = indices[2 * j];\r\n                                e = indices[2 * j + 1];\r\n                                if (!substringStartsWith(data, s, e, 'SHEET'))\r\n                                    break;\r\n                                j++;\r\n                            }\r\n                            helperCategories.push(parseSheet(lines, i, j));\r\n                            i = j - 1;\r\n                        }\r\n                        // TODO: SCALE record => cif.atom_sites.fract_transf_matrix, cif.atom_sites.fract_transf_vector\r\n                        break;\r\n                }\r\n            }\r\n            seqIds = Column.ofIntTokens(atomSite.auth_seq_id);\r\n            atomIds = Column.ofStringTokens(atomSite.auth_atom_id);\r\n            compIds = Column.ofStringTokens(atomSite.auth_comp_id);\r\n            asymIds = Column.ofStringTokens(atomSite.auth_asym_id);\r\n            componentBuilder = new ComponentBuilder(seqIds, atomIds);\r\n            componentBuilder.setNames(heteroNames);\r\n            entityBuilder.setNames(heteroNames);\r\n            for (i = 0, il = compIds.rowCount; i < il; ++i) {\r\n                compId = compIds.value(i);\r\n                moleculeType = getMoleculeType(componentBuilder.add(compId, i).type, compId);\r\n                atomSite.label_entity_id[i] = entityBuilder.getEntityId(compId, moleculeType, asymIds.value(i));\r\n            }\r\n            atom_site = getAtomSite(atomSite);\r\n            if (!isPdbqt)\r\n                delete atom_site.partial_charge;\r\n            if (conectRange) {\r\n                helperCategories.push(parseConect(lines, conectRange[0], conectRange[1], atom_site));\r\n            }\r\n            categories = {\r\n                entity: CifCategory.ofTable('entity', entityBuilder.getEntityTable()),\r\n                chem_comp: CifCategory.ofTable('chem_comp', componentBuilder.getChemCompTable()),\r\n                atom_site: CifCategory.ofFields('atom_site', atom_site),\r\n                atom_site_anisotrop: CifCategory.ofFields('atom_site_anisotrop', getAnisotropic(anisotropic))\r\n            };\r\n            for (_a = 0, helperCategories_1 = helperCategories; _a < helperCategories_1.length; _a++) {\r\n                c = helperCategories_1[_a];\r\n                categories[c.name] = c;\r\n            }\r\n            return [2 /*return*/, {\r\n                    header: pdb.id || 'PDB',\r\n                    categoryNames: Object.keys(categories),\r\n                    categories: categories\r\n                }];\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=to-cif.js.map"]},"metadata":{},"sourceType":"module"}