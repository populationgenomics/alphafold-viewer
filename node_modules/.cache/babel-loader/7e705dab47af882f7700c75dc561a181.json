{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { getProteinOneLetterCode, getRnaOneLetterCode, getDnaOneLetterCode } from './constants';\nimport { Column } from '../../mol-data/db';\nvar Sequence;\n\n(function (Sequence) {\n  function getSequenceString(seq) {\n    var array = seq.code.toArray();\n    return (array instanceof Array ? array : Array.from(array)).join('');\n  }\n\n  Sequence.getSequenceString = getSequenceString;\n\n  function determineKind(names) {\n    for (var i = 0, _i = Math.min(names.rowCount, 10); i < _i; i++) {\n      var name_1 = names.value(i) || '';\n      if (getProteinOneLetterCode(name_1) !== 'X') return \"protein\"\n      /* Protein */\n      ;\n      if (getRnaOneLetterCode(name_1) !== 'X') return \"RNA\"\n      /* RNA */\n      ;\n      if (getDnaOneLetterCode(name_1) !== 'X') return \"DNA\"\n      /* DNA */\n      ;\n    }\n\n    return \"generic\"\n    /* Generic */\n    ;\n  }\n\n  function codeProvider(kind, map) {\n    var code;\n\n    switch (kind) {\n      case \"protein\"\n      /* Protein */\n      :\n        code = getProteinOneLetterCode;\n        break;\n\n      case \"DNA\"\n      /* DNA */\n      :\n        code = getDnaOneLetterCode;\n        break;\n\n      case \"RNA\"\n      /* RNA */\n      :\n        code = getRnaOneLetterCode;\n        break;\n\n      case \"generic\"\n      /* Generic */\n      :\n        code = function () {\n          return 'X';\n        };\n\n        break;\n\n      default:\n        throw new Error(\"unknown kind '\" + kind + \"'\");\n    }\n\n    if (map && map.size > 0) {\n      return function (name) {\n        var ret = code(name);\n        if (ret !== 'X' || !map.has(name)) return ret;\n        return code(map.get(name));\n      };\n    }\n\n    return code;\n  }\n\n  function ofResidueNames(compId, seqId) {\n    if (seqId.rowCount === 0) throw new Error('cannot be empty');\n    var kind = determineKind(compId);\n    return new ResidueNamesImpl(kind, compId, seqId);\n  }\n\n  Sequence.ofResidueNames = ofResidueNames;\n\n  var ResidueNamesImpl =\n  /** @class */\n  function () {\n    function ResidueNamesImpl(kind, compId, seqId) {\n      this.kind = kind;\n      this.microHet = new Map();\n      var codeFromName = codeProvider(kind);\n      var codes = [];\n      var compIds = [];\n      var seqIds = [];\n      var microHet = new Map();\n      var idx = 0;\n      var indexMap = new Map();\n\n      for (var i = 0, il = seqId.rowCount; i < il; ++i) {\n        var seq_id = seqId.value(i);\n\n        if (!indexMap.has(seq_id)) {\n          indexMap.set(seq_id, idx);\n          var comp_id = compId.value(i);\n          compIds[idx] = comp_id;\n          seqIds[idx] = seq_id;\n          codes[idx] = codeFromName(comp_id);\n          idx += 1;\n        } else {\n          // micro-heterogeneity\n          if (!microHet.has(seq_id)) {\n            microHet.set(seq_id, [compIds[indexMap.get(seq_id)], compId.value(i)]);\n          } else {\n            microHet.get(seq_id).push(compId.value(i));\n          }\n        }\n      }\n\n      var labels = [];\n\n      for (var i = 0, il = idx; i < il; ++i) {\n        var mh = microHet.get(seqIds[i]);\n\n        if (mh) {\n          var l = mh.map(function (id) {\n            var c = codeFromName(id);\n            return c === 'X' ? id : c;\n          });\n          labels[i] = \"(\" + l.join('|') + \")\";\n        } else {\n          labels[i] = codes[i] === 'X' ? compIds[i] : codes[i];\n        }\n      }\n\n      this.length = idx;\n      this.code = Column.ofStringArray(codes);\n      this.compId = Column.ofStringArray(compIds);\n      this.seqId = Column.ofIntArray(seqIds);\n      this.label = Column.ofStringArray(labels);\n      this.microHet = microHet;\n      this.indexMap = indexMap;\n    }\n\n    ResidueNamesImpl.prototype.index = function (seqId) {\n      return this.indexMap.get(seqId);\n    };\n\n    return ResidueNamesImpl;\n  }();\n\n  function ofSequenceRanges(seqIdBegin, seqIdEnd) {\n    var kind = \"generic\"\n    /* Generic */\n    ;\n    return new SequenceRangesImpl(kind, seqIdBegin, seqIdEnd);\n  }\n\n  Sequence.ofSequenceRanges = ofSequenceRanges;\n\n  var SequenceRangesImpl =\n  /** @class */\n  function () {\n    function SequenceRangesImpl(kind, seqIdStart, seqIdEnd) {\n      this.kind = kind;\n      this.seqIdStart = seqIdStart;\n      this.seqIdEnd = seqIdEnd;\n      this.microHet = new Map();\n      var maxSeqId = 0,\n          minSeqId = Number.MAX_SAFE_INTEGER;\n\n      for (var i = 0, _i = this.seqIdStart.rowCount; i < _i; i++) {\n        var idStart = this.seqIdStart.value(i);\n        var idEnd = this.seqIdEnd.value(i);\n        if (idStart < minSeqId) minSeqId = idStart;\n        if (maxSeqId < idEnd) maxSeqId = idEnd;\n      }\n\n      var count = maxSeqId - minSeqId + 1;\n      this.code = Column.ofConst('X', count, Column.Schema.str);\n      this.label = Column.ofConst('', count, Column.Schema.str);\n      this.seqId = Column.ofLambda({\n        value: function (row) {\n          return row + minSeqId + 1;\n        },\n        rowCount: count,\n        schema: Column.Schema.int\n      });\n      this.compId = Column.ofConst('', count, Column.Schema.str);\n      this.length = count;\n      this.minSeqId = minSeqId;\n    }\n\n    SequenceRangesImpl.prototype.index = function (seqId) {\n      return seqId - this.minSeqId;\n    };\n\n    return SequenceRangesImpl;\n  }();\n})(Sequence || (Sequence = {}));\n\nexport { Sequence };","map":{"version":3,"sources":["../../../src/mol-model/sequence/sequence.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { getProteinOneLetterCode, getRnaOneLetterCode, getDnaOneLetterCode } from './constants';\r\nimport { Column } from '../../mol-data/db';\r\nvar Sequence;\r\n(function (Sequence) {\r\n    function getSequenceString(seq) {\r\n        var array = seq.code.toArray();\r\n        return (array instanceof Array ? array : Array.from(array)).join('');\r\n    }\r\n    Sequence.getSequenceString = getSequenceString;\r\n    function determineKind(names) {\r\n        for (var i = 0, _i = Math.min(names.rowCount, 10); i < _i; i++) {\r\n            var name_1 = names.value(i) || '';\r\n            if (getProteinOneLetterCode(name_1) !== 'X')\r\n                return \"protein\" /* Protein */;\r\n            if (getRnaOneLetterCode(name_1) !== 'X')\r\n                return \"RNA\" /* RNA */;\r\n            if (getDnaOneLetterCode(name_1) !== 'X')\r\n                return \"DNA\" /* DNA */;\r\n        }\r\n        return \"generic\" /* Generic */;\r\n    }\r\n    function codeProvider(kind, map) {\r\n        var code;\r\n        switch (kind) {\r\n            case \"protein\" /* Protein */:\r\n                code = getProteinOneLetterCode;\r\n                break;\r\n            case \"DNA\" /* DNA */:\r\n                code = getDnaOneLetterCode;\r\n                break;\r\n            case \"RNA\" /* RNA */:\r\n                code = getRnaOneLetterCode;\r\n                break;\r\n            case \"generic\" /* Generic */:\r\n                code = function () { return 'X'; };\r\n                break;\r\n            default: throw new Error(\"unknown kind '\" + kind + \"'\");\r\n        }\r\n        if (map && map.size > 0) {\r\n            return function (name) {\r\n                var ret = code(name);\r\n                if (ret !== 'X' || !map.has(name))\r\n                    return ret;\r\n                return code(map.get(name));\r\n            };\r\n        }\r\n        return code;\r\n    }\r\n    function ofResidueNames(compId, seqId) {\r\n        if (seqId.rowCount === 0)\r\n            throw new Error('cannot be empty');\r\n        var kind = determineKind(compId);\r\n        return new ResidueNamesImpl(kind, compId, seqId);\r\n    }\r\n    Sequence.ofResidueNames = ofResidueNames;\r\n    var ResidueNamesImpl = /** @class */ (function () {\r\n        function ResidueNamesImpl(kind, compId, seqId) {\r\n            this.kind = kind;\r\n            this.microHet = new Map();\r\n            var codeFromName = codeProvider(kind);\r\n            var codes = [];\r\n            var compIds = [];\r\n            var seqIds = [];\r\n            var microHet = new Map();\r\n            var idx = 0;\r\n            var indexMap = new Map();\r\n            for (var i = 0, il = seqId.rowCount; i < il; ++i) {\r\n                var seq_id = seqId.value(i);\r\n                if (!indexMap.has(seq_id)) {\r\n                    indexMap.set(seq_id, idx);\r\n                    var comp_id = compId.value(i);\r\n                    compIds[idx] = comp_id;\r\n                    seqIds[idx] = seq_id;\r\n                    codes[idx] = codeFromName(comp_id);\r\n                    idx += 1;\r\n                }\r\n                else {\r\n                    // micro-heterogeneity\r\n                    if (!microHet.has(seq_id)) {\r\n                        microHet.set(seq_id, [compIds[indexMap.get(seq_id)], compId.value(i)]);\r\n                    }\r\n                    else {\r\n                        microHet.get(seq_id).push(compId.value(i));\r\n                    }\r\n                }\r\n            }\r\n            var labels = [];\r\n            for (var i = 0, il = idx; i < il; ++i) {\r\n                var mh = microHet.get(seqIds[i]);\r\n                if (mh) {\r\n                    var l = mh.map(function (id) {\r\n                        var c = codeFromName(id);\r\n                        return c === 'X' ? id : c;\r\n                    });\r\n                    labels[i] = \"(\" + l.join('|') + \")\";\r\n                }\r\n                else {\r\n                    labels[i] = codes[i] === 'X' ? compIds[i] : codes[i];\r\n                }\r\n            }\r\n            this.length = idx;\r\n            this.code = Column.ofStringArray(codes);\r\n            this.compId = Column.ofStringArray(compIds);\r\n            this.seqId = Column.ofIntArray(seqIds);\r\n            this.label = Column.ofStringArray(labels);\r\n            this.microHet = microHet;\r\n            this.indexMap = indexMap;\r\n        }\r\n        ResidueNamesImpl.prototype.index = function (seqId) {\r\n            return this.indexMap.get(seqId);\r\n        };\r\n        return ResidueNamesImpl;\r\n    }());\r\n    function ofSequenceRanges(seqIdBegin, seqIdEnd) {\r\n        var kind = \"generic\" /* Generic */;\r\n        return new SequenceRangesImpl(kind, seqIdBegin, seqIdEnd);\r\n    }\r\n    Sequence.ofSequenceRanges = ofSequenceRanges;\r\n    var SequenceRangesImpl = /** @class */ (function () {\r\n        function SequenceRangesImpl(kind, seqIdStart, seqIdEnd) {\r\n            this.kind = kind;\r\n            this.seqIdStart = seqIdStart;\r\n            this.seqIdEnd = seqIdEnd;\r\n            this.microHet = new Map();\r\n            var maxSeqId = 0, minSeqId = Number.MAX_SAFE_INTEGER;\r\n            for (var i = 0, _i = this.seqIdStart.rowCount; i < _i; i++) {\r\n                var idStart = this.seqIdStart.value(i);\r\n                var idEnd = this.seqIdEnd.value(i);\r\n                if (idStart < minSeqId)\r\n                    minSeqId = idStart;\r\n                if (maxSeqId < idEnd)\r\n                    maxSeqId = idEnd;\r\n            }\r\n            var count = maxSeqId - minSeqId + 1;\r\n            this.code = Column.ofConst('X', count, Column.Schema.str);\r\n            this.label = Column.ofConst('', count, Column.Schema.str);\r\n            this.seqId = Column.ofLambda({\r\n                value: function (row) { return row + minSeqId + 1; },\r\n                rowCount: count,\r\n                schema: Column.Schema.int\r\n            });\r\n            this.compId = Column.ofConst('', count, Column.Schema.str);\r\n            this.length = count;\r\n            this.minSeqId = minSeqId;\r\n        }\r\n        SequenceRangesImpl.prototype.index = function (seqId) {\r\n            return seqId - this.minSeqId;\r\n        };\r\n        return SequenceRangesImpl;\r\n    }());\r\n})(Sequence || (Sequence = {}));\r\nexport { Sequence };\r\n//# sourceMappingURL=sequence.js.map"]},"metadata":{},"sourceType":"module"}