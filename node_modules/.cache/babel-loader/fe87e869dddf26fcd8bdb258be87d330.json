{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { StructureElement } from '../../../../../mol-model/structure';\nimport { Segmentation } from '../../../../../mol-data/int';\nimport { SecondaryStructureType } from '../../../../../mol-model/structure/model/types';\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\nimport { getPolymerRanges } from '../polymer';\nimport { SecondaryStructureProvider } from '../../../../../mol-model-props/computed/secondary-structure';\nimport { HelixOrientationProvider } from '../../../../../mol-model-props/computed/helix-orientation';\n\nfunction isHelixSS(ss) {\n  return SecondaryStructureType.is(ss, 2\n  /* Helix */\n  );\n}\n\nfunction isSheetSS(ss) {\n  return SecondaryStructureType.is(ss, 4\n  /* Beta */\n  );\n}\n/**\r\n * Iterates over individual residues/coarse elements in polymers of a unit while\r\n * providing information about the neighbourhood in the underlying model for drawing splines\r\n */\n\n\nexport function PolymerTraceIterator(unit, structure, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return new AtomicPolymerTraceIterator(unit, structure, options);\n\n    case 1\n    /* Spheres */\n    :\n    case 2\n    /* Gaussians */\n    :\n      return new CoarsePolymerTraceIterator(unit, structure);\n  }\n}\nvar SecStrucTypeNA = SecondaryStructureType.create(536870912\n/* NA */\n);\n\nfunction createPolymerTraceElement(structure, unit) {\n  return {\n    center: StructureElement.Location.create(structure, unit),\n    centerPrev: StructureElement.Location.create(structure, unit),\n    centerNext: StructureElement.Location.create(structure, unit),\n    first: false,\n    last: false,\n    initial: false,\n    final: false,\n    secStrucFirst: false,\n    secStrucLast: false,\n    secStrucType: SecStrucTypeNA,\n    moleculeType: 0\n    /* Unknown */\n    ,\n    coarseBackboneFirst: false,\n    coarseBackboneLast: false,\n    isCoarseBackbone: false,\n    p0: Vec3(),\n    p1: Vec3(),\n    p2: Vec3(),\n    p3: Vec3(),\n    p4: Vec3(),\n    d12: Vec3(),\n    d23: Vec3()\n  };\n}\n\nvar tmpDir = Vec3();\nvar tmpVecA = Vec3();\nvar tmpVecB = Vec3();\n\nvar AtomicPolymerTraceIterator =\n/** @class */\nfunction () {\n  function AtomicPolymerTraceIterator(unit, structure, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _a;\n\n    this.unit = unit;\n    this.state = 0\n    /* nextPolymer */\n    ;\n    this.p0 = Vec3();\n    this.p1 = Vec3();\n    this.p2 = Vec3();\n    this.p3 = Vec3();\n    this.p4 = Vec3();\n    this.p5 = Vec3();\n    this.p6 = Vec3();\n    this.d01 = Vec3();\n    this.d12 = Vec3();\n    this.d23 = Vec3();\n    this.d34 = Vec3();\n    this.hasNext = false;\n    this.atomicConformation = unit.model.atomicConformation;\n    this.residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\n    this.polymerRanges = unit.model.atomicRanges.polymerRanges;\n    this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\n\n    this.directionFromElementIndex = unit.model.atomicHierarchy.derived.residue.directionFromElementIndex;\n    this.directionToElementIndex = unit.model.atomicHierarchy.derived.residue.directionToElementIndex;\n    this.moleculeType = unit.model.atomicHierarchy.derived.residue.moleculeType;\n    this.cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;\n    this.polymerIt = SortedRanges.transientSegments(this.polymerRanges, unit.elements);\n    this.residueIt = Segmentation.transientSegments(this.residueAtomSegments, unit.elements);\n    this.value = createPolymerTraceElement(structure, unit);\n    this.hasNext = this.residueIt.hasNext && this.polymerIt.hasNext;\n\n    if (!options.ignoreSecondaryStructure) {\n      this.secondaryStructure = (_a = SecondaryStructureProvider.get(structure).value) === null || _a === void 0 ? void 0 : _a.get(unit.invariantId);\n    }\n\n    if (options.useHelixOrientation) {\n      var helixOrientation = HelixOrientationProvider.get(unit.model).value;\n      if (!helixOrientation) throw new Error('missing helix-orientation');\n      this.helixOrientationCenters = helixOrientation.centers;\n    }\n  }\n\n  AtomicPolymerTraceIterator.prototype.atomicPos = function (target, index) {\n    if (index !== -1) {\n      target[0] = this.atomicConformation.x[index];\n      target[1] = this.atomicConformation.y[index];\n      target[2] = this.atomicConformation.z[index];\n    }\n  };\n\n  AtomicPolymerTraceIterator.prototype.pos = function (target, residueIndex, ss) {\n    var index = this.traceElementIndex[residueIndex];\n\n    if (this.helixOrientationCenters && isHelixSS(ss)) {\n      Vec3.fromArray(target, this.helixOrientationCenters, residueIndex * 3);\n    } else {\n      this.atomicPos(target, index);\n    }\n  };\n\n  AtomicPolymerTraceIterator.prototype.updateResidueSegmentRange = function (polymerSegment) {\n    var index = this.residueAtomSegments.index;\n    this.residueSegmentMin = index[this.polymerRanges[polymerSegment.index * 2]];\n    this.residueSegmentMax = index[this.polymerRanges[polymerSegment.index * 2 + 1]];\n  };\n\n  AtomicPolymerTraceIterator.prototype.getResidueIndex = function (residueIndex) {\n    if (residueIndex < this.residueSegmentMin) {\n      var cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMin);\n\n      if (cyclicIndex !== undefined) {\n        residueIndex = cyclicIndex - (this.residueSegmentMin - residueIndex - 1);\n      } else {\n        residueIndex = this.residueSegmentMin;\n      }\n    } else if (residueIndex > this.residueSegmentMax) {\n      var cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMax);\n\n      if (cyclicIndex !== undefined) {\n        residueIndex = cyclicIndex + (residueIndex - this.residueSegmentMax - 1);\n      } else {\n        residueIndex = this.residueSegmentMax;\n      }\n    }\n\n    return residueIndex;\n  };\n\n  AtomicPolymerTraceIterator.prototype.getSecStruc = function (residueIndex) {\n    if (this.secondaryStructure) {\n      var _a = this.secondaryStructure,\n          type = _a.type,\n          getIndex = _a.getIndex;\n      var ss = type[getIndex(residueIndex)]; // normalize helix-type\n\n      return isHelixSS(ss) ? 2\n      /* Helix */\n      : ss;\n    } else {\n      return SecStrucTypeNA;\n    }\n  };\n\n  AtomicPolymerTraceIterator.prototype.setControlPoint = function (out, p1, p2, p3, ss) {\n    if (isSheetSS(ss) || this.helixOrientationCenters && isHelixSS(ss)) {\n      Vec3.scale(out, Vec3.add(out, p1, Vec3.add(out, p3, Vec3.add(out, p2, p2))), 1 / 4);\n    } else {\n      Vec3.copy(out, p2);\n    }\n  };\n\n  AtomicPolymerTraceIterator.prototype.setFromToVector = function (out, residueIndex, ss) {\n    if (this.value.isCoarseBackbone || this.helixOrientationCenters && isHelixSS(ss)) {\n      Vec3.set(out, 1, 0, 0);\n    } else {\n      this.atomicPos(tmpVecA, this.directionFromElementIndex[residueIndex]);\n      this.atomicPos(tmpVecB, this.directionToElementIndex[residueIndex]);\n      Vec3.sub(out, tmpVecB, tmpVecA);\n    }\n  };\n\n  AtomicPolymerTraceIterator.prototype.setDirection = function (out, v1, v2, v3) {\n    Vec3.matchDirection(tmpVecA, v1, v2);\n    Vec3.matchDirection(tmpVecB, v3, v2);\n    Vec3.scale(out, Vec3.add(out, tmpVecA, Vec3.add(out, tmpVecB, Vec3.add(out, v2, v2))), 1 / 4);\n  };\n\n  AtomicPolymerTraceIterator.prototype.move = function () {\n    var _a = this,\n        residueIt = _a.residueIt,\n        polymerIt = _a.polymerIt,\n        value = _a.value;\n\n    if (this.state === 0\n    /* nextPolymer */\n    ) {\n      while (polymerIt.hasNext) {\n        this.polymerSegment = polymerIt.move();\n        residueIt.setSegment(this.polymerSegment);\n        this.updateResidueSegmentRange(this.polymerSegment);\n\n        if (residueIt.hasNext) {\n          this.state = 1\n          /* nextResidue */\n          ;\n          var residueIndexBeg = this.residueAtomSegments.index[this.unit.elements[this.polymerSegment.start]];\n          var residueIndexBegPrev = this.getResidueIndex(residueIndexBeg - 1);\n          this.currSecStrucType = residueIndexBeg === residueIndexBegPrev ? SecStrucTypeNA : this.getSecStruc(residueIndexBegPrev);\n          this.nextSecStrucType = this.getSecStruc(residueIndexBeg);\n          this.currCoarseBackbone = this.directionFromElementIndex[residueIndexBegPrev] === -1 || this.directionToElementIndex[residueIndexBegPrev] === -1;\n          this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexBeg] === -1 || this.directionToElementIndex[residueIndexBeg] === -1;\n          break;\n        }\n      }\n    }\n\n    if (this.state === 1\n    /* nextResidue */\n    ) {\n      var residueIndex = residueIt.move().index;\n      var residueIndexPrev3 = this.getResidueIndex(residueIndex - 3);\n      var residueIndexPrev2 = this.getResidueIndex(residueIndex - 2);\n      var residueIndexPrev1 = this.getResidueIndex(residueIndex - 1);\n      var residueIndexNext1 = this.getResidueIndex(residueIndex + 1);\n      var residueIndexNext2 = this.getResidueIndex(residueIndex + 2);\n      var residueIndexNext3 = this.getResidueIndex(residueIndex + 3);\n      this.prevSecStrucType = this.currSecStrucType;\n      this.currSecStrucType = this.nextSecStrucType;\n      this.nextSecStrucType = residueIndex === residueIndexNext1 ? SecStrucTypeNA : this.getSecStruc(residueIndexNext1);\n      this.prevCoarseBackbone = this.currCoarseBackbone;\n      this.currCoarseBackbone = this.nextCoarseBackbone;\n      this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexNext1] === -1 || this.directionToElementIndex[residueIndexNext1] === -1;\n      value.secStrucType = this.currSecStrucType;\n      value.secStrucFirst = this.prevSecStrucType !== this.currSecStrucType;\n      value.secStrucLast = this.currSecStrucType !== this.nextSecStrucType;\n      value.isCoarseBackbone = this.currCoarseBackbone;\n      value.coarseBackboneFirst = this.prevCoarseBackbone !== this.currCoarseBackbone;\n      value.coarseBackboneLast = this.currCoarseBackbone !== this.nextCoarseBackbone;\n      value.first = residueIndex === this.residueSegmentMin;\n      value.last = residueIndex === this.residueSegmentMax;\n      value.moleculeType = this.moleculeType[residueIndex];\n      value.initial = residueIndex === residueIndexPrev1;\n      value.final = residueIndex === residueIndexNext1;\n      value.centerPrev.element = this.traceElementIndex[residueIndexPrev1];\n      value.center.element = this.traceElementIndex[residueIndex];\n      value.centerNext.element = this.traceElementIndex[residueIndexNext1];\n      var ssPrev3 = this.getSecStruc(residueIndexPrev3);\n      var ssPrev2 = this.getSecStruc(residueIndexPrev2);\n      var ssPrev1 = this.getSecStruc(residueIndexPrev1);\n      var ss = this.getSecStruc(residueIndex);\n      var ssNext1 = this.getSecStruc(residueIndexNext1);\n      var ssNext2 = this.getSecStruc(residueIndexNext2);\n      var ssNext3 = this.getSecStruc(residueIndexNext3);\n      this.pos(this.p0, residueIndexPrev3, ssPrev3);\n      this.pos(this.p1, residueIndexPrev2, ssPrev2);\n      this.pos(this.p2, residueIndexPrev1, ssPrev1);\n      this.pos(this.p3, residueIndex, ss);\n      this.pos(this.p4, residueIndexNext1, ssNext1);\n      this.pos(this.p5, residueIndexNext2, ssNext2);\n      this.pos(this.p6, residueIndexNext3, ssNext3);\n      var isHelixPrev3 = isHelixSS(ssPrev3);\n      var isHelixPrev2 = isHelixSS(ssPrev2);\n      var isHelixPrev1 = isHelixSS(ssPrev1);\n      var isHelix = isHelixSS(ss);\n      var isHelixNext1 = isHelixSS(ssNext1);\n      var isHelixNext2 = isHelixSS(ssNext2);\n      var isHelixNext3 = isHelixSS(ssNext3); // handle positions for tubular helices\n\n      if (this.helixOrientationCenters) {\n        if (isHelix !== isHelixPrev1) {\n          if (isHelix) {\n            Vec3.copy(this.p0, this.p3);\n            Vec3.copy(this.p1, this.p3);\n            Vec3.copy(this.p2, this.p3);\n          } else if (isHelixPrev1) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), 2);\n            Vec3.add(this.p2, this.p3, tmpDir);\n            Vec3.add(this.p1, this.p2, tmpDir);\n            Vec3.add(this.p0, this.p1, tmpDir);\n          }\n        } else if (isHelix !== isHelixPrev2) {\n          if (isHelix) {\n            Vec3.copy(this.p0, this.p2);\n            Vec3.copy(this.p1, this.p2);\n          } else if (isHelixPrev2) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), 2);\n            Vec3.add(this.p1, this.p2, tmpDir);\n            Vec3.add(this.p0, this.p1, tmpDir);\n          }\n        } else if (isHelix !== isHelixPrev3) {\n          if (isHelix) {\n            Vec3.copy(this.p0, this.p1);\n          } else if (isHelixPrev3) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p0, this.p1), 2);\n            Vec3.add(this.p0, this.p1, tmpDir);\n          }\n        }\n\n        if (isHelix !== isHelixNext1) {\n          if (isHelix) {\n            Vec3.copy(this.p4, this.p3);\n            Vec3.copy(this.p5, this.p3);\n            Vec3.copy(this.p6, this.p3);\n          } else if (isHelixNext1) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), 2);\n            Vec3.add(this.p4, this.p3, tmpDir);\n            Vec3.add(this.p5, this.p4, tmpDir);\n            Vec3.add(this.p6, this.p5, tmpDir);\n          }\n        } else if (isHelix !== isHelixNext2) {\n          if (isHelix) {\n            Vec3.copy(this.p5, this.p4);\n            Vec3.copy(this.p6, this.p4);\n          } else if (isHelixNext2) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), 2);\n            Vec3.add(this.p5, this.p4, tmpDir);\n            Vec3.add(this.p6, this.p5, tmpDir);\n          }\n        } else if (isHelix !== isHelixNext3) {\n          if (isHelix) {\n            Vec3.copy(this.p6, this.p5);\n          } else if (isHelixNext3) {\n            Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p6, this.p5), 2);\n            Vec3.add(this.p6, this.p5, tmpDir);\n          }\n        }\n      }\n\n      this.setFromToVector(this.d01, residueIndexPrev1, ssPrev1);\n      this.setFromToVector(this.d12, residueIndex, ss);\n      this.setFromToVector(this.d23, residueIndexNext1, ssNext1);\n      this.setFromToVector(this.d34, residueIndexNext2, ssNext2);\n      var helixFlag = isHelix && this.helixOrientationCenters; // extend termini\n\n      var f = 1.5;\n\n      if (residueIndex === residueIndexPrev1 || ss !== ssPrev1 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p4), f);\n        Vec3.add(this.p2, this.p3, tmpDir);\n        Vec3.add(this.p1, this.p2, tmpDir);\n        Vec3.add(this.p0, this.p1, tmpDir);\n      } else if (residueIndexPrev1 === residueIndexPrev2 || ss !== ssPrev2 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), f);\n        Vec3.add(this.p1, this.p2, tmpDir);\n        Vec3.add(this.p0, this.p1, tmpDir);\n      } else if (residueIndexPrev2 === residueIndexPrev3 || ss !== ssPrev3 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), f);\n        Vec3.add(this.p0, this.p1, tmpDir);\n      }\n\n      if (residueIndex === residueIndexNext1 || ss !== ssNext1 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p2), f);\n        Vec3.add(this.p4, this.p3, tmpDir);\n        Vec3.add(this.p5, this.p4, tmpDir);\n        Vec3.add(this.p6, this.p5, tmpDir);\n      } else if (residueIndexNext1 === residueIndexNext2 || ss !== ssNext2 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), f);\n        Vec3.add(this.p5, this.p4, tmpDir);\n        Vec3.add(this.p6, this.p5, tmpDir);\n      } else if (residueIndexNext2 === residueIndexNext3 || ss !== ssNext3 && helixFlag) {\n        Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), f);\n        Vec3.add(this.p6, this.p5, tmpDir);\n      }\n\n      this.setControlPoint(value.p0, this.p0, this.p1, this.p2, ssPrev2);\n      this.setControlPoint(value.p1, this.p1, this.p2, this.p3, ssPrev1);\n      this.setControlPoint(value.p2, this.p2, this.p3, this.p4, ss);\n      this.setControlPoint(value.p3, this.p3, this.p4, this.p5, ssNext1);\n      this.setControlPoint(value.p4, this.p4, this.p5, this.p6, ssNext2);\n      this.setDirection(value.d12, this.d01, this.d12, this.d23);\n      this.setDirection(value.d23, this.d12, this.d23, this.d34);\n\n      if (!residueIt.hasNext) {\n        this.state = 0\n        /* nextPolymer */\n        ;\n      }\n    }\n\n    this.hasNext = residueIt.hasNext || polymerIt.hasNext;\n    return this.value;\n  };\n\n  return AtomicPolymerTraceIterator;\n}();\n\nexport { AtomicPolymerTraceIterator };\n\nvar CoarsePolymerTraceIterator =\n/** @class */\nfunction () {\n  function CoarsePolymerTraceIterator(unit, structure) {\n    this.unit = unit;\n    this.state = 0\n    /* nextPolymer */\n    ;\n    this.hasNext = false;\n    this.polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\n    this.value = createPolymerTraceElement(structure, unit);\n    Vec3.set(this.value.d12, 1, 0, 0);\n    Vec3.set(this.value.d23, 1, 0, 0);\n\n    switch (unit.kind) {\n      case 1\n      /* Spheres */\n      :\n        this.conformation = unit.model.coarseConformation.spheres;\n        break;\n\n      case 2\n      /* Gaussians */\n      :\n        this.conformation = unit.model.coarseConformation.gaussians;\n        break;\n    }\n\n    this.hasNext = this.polymerIt.hasNext;\n  }\n\n  CoarsePolymerTraceIterator.prototype.getElementIndex = function (elementIndex) {\n    return Math.min(Math.max(this.polymerSegment.start, elementIndex), this.polymerSegment.end - 1);\n  };\n\n  CoarsePolymerTraceIterator.prototype.pos = function (target, elementIndex) {\n    var index = this.unit.elements[elementIndex];\n    target[0] = this.conformation.x[index];\n    target[1] = this.conformation.y[index];\n    target[2] = this.conformation.z[index];\n  };\n\n  CoarsePolymerTraceIterator.prototype.move = function () {\n    if (this.state === 0\n    /* nextPolymer */\n    ) {\n      while (this.polymerIt.hasNext) {\n        this.polymerSegment = this.polymerIt.move();\n        this.elementIndex = this.polymerSegment.start;\n\n        if (this.elementIndex < this.polymerSegment.end) {\n          this.state = 1\n          /* nextElement */\n          ;\n          break;\n        }\n      }\n    }\n\n    if (this.state === 1\n    /* nextElement */\n    ) {\n      var elementIndexPrev2 = this.getElementIndex(this.elementIndex - 2);\n      var elementIndexPrev1 = this.getElementIndex(this.elementIndex - 1);\n      var elementIndexNext1 = this.getElementIndex(this.elementIndex + 1);\n      var elementIndexNext2 = this.getElementIndex(this.elementIndex + 2);\n      this.value.centerPrev.element = this.value.center.unit.elements[elementIndexPrev1];\n      this.value.center.element = this.value.center.unit.elements[this.elementIndex];\n      this.value.centerNext.element = this.value.center.unit.elements[elementIndexNext1];\n      this.pos(this.value.p0, elementIndexPrev2);\n      this.pos(this.value.p1, elementIndexPrev1);\n      this.pos(this.value.p2, this.elementIndex);\n      this.pos(this.value.p3, elementIndexNext1);\n      this.pos(this.value.p4, elementIndexNext2); // extend termini\n\n      var f = 0.5;\n\n      if (this.elementIndex === elementIndexPrev1) {\n        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p3), f);\n        Vec3.add(this.value.p1, this.value.p2, tmpDir);\n        Vec3.add(this.value.p0, this.value.p1, tmpDir);\n      } else if (elementIndexPrev1 === elementIndexPrev2) {\n        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p1, this.value.p2), f);\n        Vec3.add(this.value.p0, this.value.p1, tmpDir);\n      }\n\n      if (this.elementIndex === elementIndexNext1) {\n        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p1), f);\n        Vec3.add(this.value.p3, this.value.p2, tmpDir);\n        Vec3.add(this.value.p4, this.value.p3, tmpDir);\n      } else if (elementIndexNext1 === elementIndexNext2) {\n        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p3, this.value.p2), f);\n        Vec3.add(this.value.p4, this.value.p3, tmpDir);\n      }\n\n      this.value.first = this.elementIndex === this.polymerSegment.start;\n      this.value.last = this.elementIndex === this.polymerSegment.end - 1;\n\n      if (this.elementIndex + 1 >= this.polymerSegment.end) {\n        this.state = 0\n        /* nextPolymer */\n        ;\n      }\n    }\n\n    this.hasNext = this.elementIndex + 1 < this.polymerSegment.end || this.polymerIt.hasNext;\n    this.elementIndex += 1;\n    return this.value;\n  };\n\n  return CoarsePolymerTraceIterator;\n}();\n\nexport { CoarsePolymerTraceIterator };","map":{"version":3,"sources":["../../../../../../src/mol-repr/structure/visual/util/polymer/trace-iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { StructureElement } from '../../../../../mol-model/structure';\r\nimport { Segmentation } from '../../../../../mol-data/int';\r\nimport { SecondaryStructureType } from '../../../../../mol-model/structure/model/types';\r\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\r\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\r\nimport { getPolymerRanges } from '../polymer';\r\nimport { SecondaryStructureProvider } from '../../../../../mol-model-props/computed/secondary-structure';\r\nimport { HelixOrientationProvider } from '../../../../../mol-model-props/computed/helix-orientation';\r\nfunction isHelixSS(ss) {\r\n    return SecondaryStructureType.is(ss, 2 /* Helix */);\r\n}\r\nfunction isSheetSS(ss) {\r\n    return SecondaryStructureType.is(ss, 4 /* Beta */);\r\n}\r\n/**\r\n * Iterates over individual residues/coarse elements in polymers of a unit while\r\n * providing information about the neighbourhood in the underlying model for drawing splines\r\n */\r\nexport function PolymerTraceIterator(unit, structure, options) {\r\n    if (options === void 0) { options = {}; }\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return new AtomicPolymerTraceIterator(unit, structure, options);\r\n        case 1 /* Spheres */:\r\n        case 2 /* Gaussians */:\r\n            return new CoarsePolymerTraceIterator(unit, structure);\r\n    }\r\n}\r\nvar SecStrucTypeNA = SecondaryStructureType.create(536870912 /* NA */);\r\nfunction createPolymerTraceElement(structure, unit) {\r\n    return {\r\n        center: StructureElement.Location.create(structure, unit),\r\n        centerPrev: StructureElement.Location.create(structure, unit),\r\n        centerNext: StructureElement.Location.create(structure, unit),\r\n        first: false, last: false,\r\n        initial: false, final: false,\r\n        secStrucFirst: false, secStrucLast: false,\r\n        secStrucType: SecStrucTypeNA,\r\n        moleculeType: 0 /* Unknown */,\r\n        coarseBackboneFirst: false, coarseBackboneLast: false,\r\n        isCoarseBackbone: false,\r\n        p0: Vec3(), p1: Vec3(), p2: Vec3(), p3: Vec3(), p4: Vec3(),\r\n        d12: Vec3(), d23: Vec3()\r\n    };\r\n}\r\nvar tmpDir = Vec3();\r\nvar tmpVecA = Vec3();\r\nvar tmpVecB = Vec3();\r\nvar AtomicPolymerTraceIterator = /** @class */ (function () {\r\n    function AtomicPolymerTraceIterator(unit, structure, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var _a;\r\n        this.unit = unit;\r\n        this.state = 0 /* nextPolymer */;\r\n        this.p0 = Vec3();\r\n        this.p1 = Vec3();\r\n        this.p2 = Vec3();\r\n        this.p3 = Vec3();\r\n        this.p4 = Vec3();\r\n        this.p5 = Vec3();\r\n        this.p6 = Vec3();\r\n        this.d01 = Vec3();\r\n        this.d12 = Vec3();\r\n        this.d23 = Vec3();\r\n        this.d34 = Vec3();\r\n        this.hasNext = false;\r\n        this.atomicConformation = unit.model.atomicConformation;\r\n        this.residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\r\n        this.polymerRanges = unit.model.atomicRanges.polymerRanges;\r\n        this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\r\n        this.directionFromElementIndex = unit.model.atomicHierarchy.derived.residue.directionFromElementIndex;\r\n        this.directionToElementIndex = unit.model.atomicHierarchy.derived.residue.directionToElementIndex;\r\n        this.moleculeType = unit.model.atomicHierarchy.derived.residue.moleculeType;\r\n        this.cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;\r\n        this.polymerIt = SortedRanges.transientSegments(this.polymerRanges, unit.elements);\r\n        this.residueIt = Segmentation.transientSegments(this.residueAtomSegments, unit.elements);\r\n        this.value = createPolymerTraceElement(structure, unit);\r\n        this.hasNext = this.residueIt.hasNext && this.polymerIt.hasNext;\r\n        if (!options.ignoreSecondaryStructure) {\r\n            this.secondaryStructure = (_a = SecondaryStructureProvider.get(structure).value) === null || _a === void 0 ? void 0 : _a.get(unit.invariantId);\r\n        }\r\n        if (options.useHelixOrientation) {\r\n            var helixOrientation = HelixOrientationProvider.get(unit.model).value;\r\n            if (!helixOrientation)\r\n                throw new Error('missing helix-orientation');\r\n            this.helixOrientationCenters = helixOrientation.centers;\r\n        }\r\n    }\r\n    AtomicPolymerTraceIterator.prototype.atomicPos = function (target, index) {\r\n        if (index !== -1) {\r\n            target[0] = this.atomicConformation.x[index];\r\n            target[1] = this.atomicConformation.y[index];\r\n            target[2] = this.atomicConformation.z[index];\r\n        }\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.pos = function (target, residueIndex, ss) {\r\n        var index = this.traceElementIndex[residueIndex];\r\n        if (this.helixOrientationCenters && isHelixSS(ss)) {\r\n            Vec3.fromArray(target, this.helixOrientationCenters, residueIndex * 3);\r\n        }\r\n        else {\r\n            this.atomicPos(target, index);\r\n        }\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.updateResidueSegmentRange = function (polymerSegment) {\r\n        var index = this.residueAtomSegments.index;\r\n        this.residueSegmentMin = index[this.polymerRanges[polymerSegment.index * 2]];\r\n        this.residueSegmentMax = index[this.polymerRanges[polymerSegment.index * 2 + 1]];\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.getResidueIndex = function (residueIndex) {\r\n        if (residueIndex < this.residueSegmentMin) {\r\n            var cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMin);\r\n            if (cyclicIndex !== undefined) {\r\n                residueIndex = cyclicIndex - (this.residueSegmentMin - residueIndex - 1);\r\n            }\r\n            else {\r\n                residueIndex = this.residueSegmentMin;\r\n            }\r\n        }\r\n        else if (residueIndex > this.residueSegmentMax) {\r\n            var cyclicIndex = this.cyclicPolymerMap.get(this.residueSegmentMax);\r\n            if (cyclicIndex !== undefined) {\r\n                residueIndex = cyclicIndex + (residueIndex - this.residueSegmentMax - 1);\r\n            }\r\n            else {\r\n                residueIndex = this.residueSegmentMax;\r\n            }\r\n        }\r\n        return residueIndex;\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.getSecStruc = function (residueIndex) {\r\n        if (this.secondaryStructure) {\r\n            var _a = this.secondaryStructure, type = _a.type, getIndex = _a.getIndex;\r\n            var ss = type[getIndex(residueIndex)];\r\n            // normalize helix-type\r\n            return isHelixSS(ss) ? 2 /* Helix */ : ss;\r\n        }\r\n        else {\r\n            return SecStrucTypeNA;\r\n        }\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.setControlPoint = function (out, p1, p2, p3, ss) {\r\n        if (isSheetSS(ss) || (this.helixOrientationCenters && isHelixSS(ss))) {\r\n            Vec3.scale(out, Vec3.add(out, p1, Vec3.add(out, p3, Vec3.add(out, p2, p2))), 1 / 4);\r\n        }\r\n        else {\r\n            Vec3.copy(out, p2);\r\n        }\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.setFromToVector = function (out, residueIndex, ss) {\r\n        if (this.value.isCoarseBackbone || (this.helixOrientationCenters && isHelixSS(ss))) {\r\n            Vec3.set(out, 1, 0, 0);\r\n        }\r\n        else {\r\n            this.atomicPos(tmpVecA, this.directionFromElementIndex[residueIndex]);\r\n            this.atomicPos(tmpVecB, this.directionToElementIndex[residueIndex]);\r\n            Vec3.sub(out, tmpVecB, tmpVecA);\r\n        }\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.setDirection = function (out, v1, v2, v3) {\r\n        Vec3.matchDirection(tmpVecA, v1, v2);\r\n        Vec3.matchDirection(tmpVecB, v3, v2);\r\n        Vec3.scale(out, Vec3.add(out, tmpVecA, Vec3.add(out, tmpVecB, Vec3.add(out, v2, v2))), 1 / 4);\r\n    };\r\n    AtomicPolymerTraceIterator.prototype.move = function () {\r\n        var _a = this, residueIt = _a.residueIt, polymerIt = _a.polymerIt, value = _a.value;\r\n        if (this.state === 0 /* nextPolymer */) {\r\n            while (polymerIt.hasNext) {\r\n                this.polymerSegment = polymerIt.move();\r\n                residueIt.setSegment(this.polymerSegment);\r\n                this.updateResidueSegmentRange(this.polymerSegment);\r\n                if (residueIt.hasNext) {\r\n                    this.state = 1 /* nextResidue */;\r\n                    var residueIndexBeg = this.residueAtomSegments.index[this.unit.elements[this.polymerSegment.start]];\r\n                    var residueIndexBegPrev = this.getResidueIndex(residueIndexBeg - 1);\r\n                    this.currSecStrucType = residueIndexBeg === residueIndexBegPrev ? SecStrucTypeNA : this.getSecStruc(residueIndexBegPrev);\r\n                    this.nextSecStrucType = this.getSecStruc(residueIndexBeg);\r\n                    this.currCoarseBackbone = this.directionFromElementIndex[residueIndexBegPrev] === -1 || this.directionToElementIndex[residueIndexBegPrev] === -1;\r\n                    this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexBeg] === -1 || this.directionToElementIndex[residueIndexBeg] === -1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (this.state === 1 /* nextResidue */) {\r\n            var residueIndex = residueIt.move().index;\r\n            var residueIndexPrev3 = this.getResidueIndex(residueIndex - 3);\r\n            var residueIndexPrev2 = this.getResidueIndex(residueIndex - 2);\r\n            var residueIndexPrev1 = this.getResidueIndex(residueIndex - 1);\r\n            var residueIndexNext1 = this.getResidueIndex(residueIndex + 1);\r\n            var residueIndexNext2 = this.getResidueIndex(residueIndex + 2);\r\n            var residueIndexNext3 = this.getResidueIndex(residueIndex + 3);\r\n            this.prevSecStrucType = this.currSecStrucType;\r\n            this.currSecStrucType = this.nextSecStrucType;\r\n            this.nextSecStrucType = residueIndex === residueIndexNext1 ? SecStrucTypeNA : this.getSecStruc(residueIndexNext1);\r\n            this.prevCoarseBackbone = this.currCoarseBackbone;\r\n            this.currCoarseBackbone = this.nextCoarseBackbone;\r\n            this.nextCoarseBackbone = this.directionFromElementIndex[residueIndexNext1] === -1 || this.directionToElementIndex[residueIndexNext1] === -1;\r\n            value.secStrucType = this.currSecStrucType;\r\n            value.secStrucFirst = this.prevSecStrucType !== this.currSecStrucType;\r\n            value.secStrucLast = this.currSecStrucType !== this.nextSecStrucType;\r\n            value.isCoarseBackbone = this.currCoarseBackbone;\r\n            value.coarseBackboneFirst = this.prevCoarseBackbone !== this.currCoarseBackbone;\r\n            value.coarseBackboneLast = this.currCoarseBackbone !== this.nextCoarseBackbone;\r\n            value.first = residueIndex === this.residueSegmentMin;\r\n            value.last = residueIndex === this.residueSegmentMax;\r\n            value.moleculeType = this.moleculeType[residueIndex];\r\n            value.initial = residueIndex === residueIndexPrev1;\r\n            value.final = residueIndex === residueIndexNext1;\r\n            value.centerPrev.element = this.traceElementIndex[residueIndexPrev1];\r\n            value.center.element = this.traceElementIndex[residueIndex];\r\n            value.centerNext.element = this.traceElementIndex[residueIndexNext1];\r\n            var ssPrev3 = this.getSecStruc(residueIndexPrev3);\r\n            var ssPrev2 = this.getSecStruc(residueIndexPrev2);\r\n            var ssPrev1 = this.getSecStruc(residueIndexPrev1);\r\n            var ss = this.getSecStruc(residueIndex);\r\n            var ssNext1 = this.getSecStruc(residueIndexNext1);\r\n            var ssNext2 = this.getSecStruc(residueIndexNext2);\r\n            var ssNext3 = this.getSecStruc(residueIndexNext3);\r\n            this.pos(this.p0, residueIndexPrev3, ssPrev3);\r\n            this.pos(this.p1, residueIndexPrev2, ssPrev2);\r\n            this.pos(this.p2, residueIndexPrev1, ssPrev1);\r\n            this.pos(this.p3, residueIndex, ss);\r\n            this.pos(this.p4, residueIndexNext1, ssNext1);\r\n            this.pos(this.p5, residueIndexNext2, ssNext2);\r\n            this.pos(this.p6, residueIndexNext3, ssNext3);\r\n            var isHelixPrev3 = isHelixSS(ssPrev3);\r\n            var isHelixPrev2 = isHelixSS(ssPrev2);\r\n            var isHelixPrev1 = isHelixSS(ssPrev1);\r\n            var isHelix = isHelixSS(ss);\r\n            var isHelixNext1 = isHelixSS(ssNext1);\r\n            var isHelixNext2 = isHelixSS(ssNext2);\r\n            var isHelixNext3 = isHelixSS(ssNext3);\r\n            // handle positions for tubular helices\r\n            if (this.helixOrientationCenters) {\r\n                if (isHelix !== isHelixPrev1) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p0, this.p3);\r\n                        Vec3.copy(this.p1, this.p3);\r\n                        Vec3.copy(this.p2, this.p3);\r\n                    }\r\n                    else if (isHelixPrev1) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), 2);\r\n                        Vec3.add(this.p2, this.p3, tmpDir);\r\n                        Vec3.add(this.p1, this.p2, tmpDir);\r\n                        Vec3.add(this.p0, this.p1, tmpDir);\r\n                    }\r\n                }\r\n                else if (isHelix !== isHelixPrev2) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p0, this.p2);\r\n                        Vec3.copy(this.p1, this.p2);\r\n                    }\r\n                    else if (isHelixPrev2) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), 2);\r\n                        Vec3.add(this.p1, this.p2, tmpDir);\r\n                        Vec3.add(this.p0, this.p1, tmpDir);\r\n                    }\r\n                }\r\n                else if (isHelix !== isHelixPrev3) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p0, this.p1);\r\n                    }\r\n                    else if (isHelixPrev3) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p0, this.p1), 2);\r\n                        Vec3.add(this.p0, this.p1, tmpDir);\r\n                    }\r\n                }\r\n                if (isHelix !== isHelixNext1) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p4, this.p3);\r\n                        Vec3.copy(this.p5, this.p3);\r\n                        Vec3.copy(this.p6, this.p3);\r\n                    }\r\n                    else if (isHelixNext1) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), 2);\r\n                        Vec3.add(this.p4, this.p3, tmpDir);\r\n                        Vec3.add(this.p5, this.p4, tmpDir);\r\n                        Vec3.add(this.p6, this.p5, tmpDir);\r\n                    }\r\n                }\r\n                else if (isHelix !== isHelixNext2) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p5, this.p4);\r\n                        Vec3.copy(this.p6, this.p4);\r\n                    }\r\n                    else if (isHelixNext2) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), 2);\r\n                        Vec3.add(this.p5, this.p4, tmpDir);\r\n                        Vec3.add(this.p6, this.p5, tmpDir);\r\n                    }\r\n                }\r\n                else if (isHelix !== isHelixNext3) {\r\n                    if (isHelix) {\r\n                        Vec3.copy(this.p6, this.p5);\r\n                    }\r\n                    else if (isHelixNext3) {\r\n                        Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.p6, this.p5), 2);\r\n                        Vec3.add(this.p6, this.p5, tmpDir);\r\n                    }\r\n                }\r\n            }\r\n            this.setFromToVector(this.d01, residueIndexPrev1, ssPrev1);\r\n            this.setFromToVector(this.d12, residueIndex, ss);\r\n            this.setFromToVector(this.d23, residueIndexNext1, ssNext1);\r\n            this.setFromToVector(this.d34, residueIndexNext2, ssNext2);\r\n            var helixFlag = isHelix && this.helixOrientationCenters;\r\n            // extend termini\r\n            var f = 1.5;\r\n            if (residueIndex === residueIndexPrev1 || (ss !== ssPrev1 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p4), f);\r\n                Vec3.add(this.p2, this.p3, tmpDir);\r\n                Vec3.add(this.p1, this.p2, tmpDir);\r\n                Vec3.add(this.p0, this.p1, tmpDir);\r\n            }\r\n            else if (residueIndexPrev1 === residueIndexPrev2 || (ss !== ssPrev2 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p2, this.p3), f);\r\n                Vec3.add(this.p1, this.p2, tmpDir);\r\n                Vec3.add(this.p0, this.p1, tmpDir);\r\n            }\r\n            else if (residueIndexPrev2 === residueIndexPrev3 || (ss !== ssPrev3 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p1, this.p2), f);\r\n                Vec3.add(this.p0, this.p1, tmpDir);\r\n            }\r\n            if (residueIndex === residueIndexNext1 || (ss !== ssNext1 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p3, this.p2), f);\r\n                Vec3.add(this.p4, this.p3, tmpDir);\r\n                Vec3.add(this.p5, this.p4, tmpDir);\r\n                Vec3.add(this.p6, this.p5, tmpDir);\r\n            }\r\n            else if (residueIndexNext1 === residueIndexNext2 || (ss !== ssNext2 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p4, this.p3), f);\r\n                Vec3.add(this.p5, this.p4, tmpDir);\r\n                Vec3.add(this.p6, this.p5, tmpDir);\r\n            }\r\n            else if (residueIndexNext2 === residueIndexNext3 || (ss !== ssNext3 && helixFlag)) {\r\n                Vec3.setMagnitude(tmpDir, Vec3.sub(tmpDir, this.p5, this.p4), f);\r\n                Vec3.add(this.p6, this.p5, tmpDir);\r\n            }\r\n            this.setControlPoint(value.p0, this.p0, this.p1, this.p2, ssPrev2);\r\n            this.setControlPoint(value.p1, this.p1, this.p2, this.p3, ssPrev1);\r\n            this.setControlPoint(value.p2, this.p2, this.p3, this.p4, ss);\r\n            this.setControlPoint(value.p3, this.p3, this.p4, this.p5, ssNext1);\r\n            this.setControlPoint(value.p4, this.p4, this.p5, this.p6, ssNext2);\r\n            this.setDirection(value.d12, this.d01, this.d12, this.d23);\r\n            this.setDirection(value.d23, this.d12, this.d23, this.d34);\r\n            if (!residueIt.hasNext) {\r\n                this.state = 0 /* nextPolymer */;\r\n            }\r\n        }\r\n        this.hasNext = residueIt.hasNext || polymerIt.hasNext;\r\n        return this.value;\r\n    };\r\n    return AtomicPolymerTraceIterator;\r\n}());\r\nexport { AtomicPolymerTraceIterator };\r\nvar CoarsePolymerTraceIterator = /** @class */ (function () {\r\n    function CoarsePolymerTraceIterator(unit, structure) {\r\n        this.unit = unit;\r\n        this.state = 0 /* nextPolymer */;\r\n        this.hasNext = false;\r\n        this.polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\r\n        this.value = createPolymerTraceElement(structure, unit);\r\n        Vec3.set(this.value.d12, 1, 0, 0);\r\n        Vec3.set(this.value.d23, 1, 0, 0);\r\n        switch (unit.kind) {\r\n            case 1 /* Spheres */:\r\n                this.conformation = unit.model.coarseConformation.spheres;\r\n                break;\r\n            case 2 /* Gaussians */:\r\n                this.conformation = unit.model.coarseConformation.gaussians;\r\n                break;\r\n        }\r\n        this.hasNext = this.polymerIt.hasNext;\r\n    }\r\n    CoarsePolymerTraceIterator.prototype.getElementIndex = function (elementIndex) {\r\n        return Math.min(Math.max(this.polymerSegment.start, elementIndex), this.polymerSegment.end - 1);\r\n    };\r\n    CoarsePolymerTraceIterator.prototype.pos = function (target, elementIndex) {\r\n        var index = this.unit.elements[elementIndex];\r\n        target[0] = this.conformation.x[index];\r\n        target[1] = this.conformation.y[index];\r\n        target[2] = this.conformation.z[index];\r\n    };\r\n    CoarsePolymerTraceIterator.prototype.move = function () {\r\n        if (this.state === 0 /* nextPolymer */) {\r\n            while (this.polymerIt.hasNext) {\r\n                this.polymerSegment = this.polymerIt.move();\r\n                this.elementIndex = this.polymerSegment.start;\r\n                if (this.elementIndex < this.polymerSegment.end) {\r\n                    this.state = 1 /* nextElement */;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (this.state === 1 /* nextElement */) {\r\n            var elementIndexPrev2 = this.getElementIndex(this.elementIndex - 2);\r\n            var elementIndexPrev1 = this.getElementIndex(this.elementIndex - 1);\r\n            var elementIndexNext1 = this.getElementIndex(this.elementIndex + 1);\r\n            var elementIndexNext2 = this.getElementIndex(this.elementIndex + 2);\r\n            this.value.centerPrev.element = this.value.center.unit.elements[elementIndexPrev1];\r\n            this.value.center.element = this.value.center.unit.elements[this.elementIndex];\r\n            this.value.centerNext.element = this.value.center.unit.elements[elementIndexNext1];\r\n            this.pos(this.value.p0, elementIndexPrev2);\r\n            this.pos(this.value.p1, elementIndexPrev1);\r\n            this.pos(this.value.p2, this.elementIndex);\r\n            this.pos(this.value.p3, elementIndexNext1);\r\n            this.pos(this.value.p4, elementIndexNext2);\r\n            // extend termini\r\n            var f = 0.5;\r\n            if (this.elementIndex === elementIndexPrev1) {\r\n                Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p3), f);\r\n                Vec3.add(this.value.p1, this.value.p2, tmpDir);\r\n                Vec3.add(this.value.p0, this.value.p1, tmpDir);\r\n            }\r\n            else if (elementIndexPrev1 === elementIndexPrev2) {\r\n                Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p1, this.value.p2), f);\r\n                Vec3.add(this.value.p0, this.value.p1, tmpDir);\r\n            }\r\n            if (this.elementIndex === elementIndexNext1) {\r\n                Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p2, this.value.p1), f);\r\n                Vec3.add(this.value.p3, this.value.p2, tmpDir);\r\n                Vec3.add(this.value.p4, this.value.p3, tmpDir);\r\n            }\r\n            else if (elementIndexNext1 === elementIndexNext2) {\r\n                Vec3.scale(tmpDir, Vec3.sub(tmpDir, this.value.p3, this.value.p2), f);\r\n                Vec3.add(this.value.p4, this.value.p3, tmpDir);\r\n            }\r\n            this.value.first = this.elementIndex === this.polymerSegment.start;\r\n            this.value.last = this.elementIndex === this.polymerSegment.end - 1;\r\n            if (this.elementIndex + 1 >= this.polymerSegment.end) {\r\n                this.state = 0 /* nextPolymer */;\r\n            }\r\n        }\r\n        this.hasNext = this.elementIndex + 1 < this.polymerSegment.end || this.polymerIt.hasNext;\r\n        this.elementIndex += 1;\r\n        return this.value;\r\n    };\r\n    return CoarsePolymerTraceIterator;\r\n}());\r\nexport { CoarsePolymerTraceIterator };\r\n//# sourceMappingURL=trace-iterator.js.map"]},"metadata":{},"sourceType":"module"}