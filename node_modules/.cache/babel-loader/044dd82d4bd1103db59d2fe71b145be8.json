{"ast":null,"code":"/**\r\n * Copyright (c) 2018 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { MonadicParser as P } from '../../mol-util/monadic-parser';\nimport { Expression } from './expression';\nimport { MolScriptBuilder as B } from './builder';\nexport function parseMolScript(input) {\n  return Language.parse(input);\n}\nvar Language;\n\n(function (Language) {\n  var ASTNode;\n\n  (function (ASTNode) {\n    function str(value) {\n      return {\n        kind: 'string',\n        value: value\n      };\n    }\n\n    ASTNode.str = str;\n\n    function symb(value) {\n      return {\n        kind: 'symbol',\n        value: value\n      };\n    }\n\n    ASTNode.symb = symb;\n\n    function list(bracket, nodes) {\n      return {\n        kind: 'list',\n        bracket: bracket,\n        nodes: nodes\n      };\n    }\n\n    ASTNode.list = list;\n\n    function comment(value) {\n      return {\n        kind: 'comment',\n        value: value\n      };\n    }\n\n    ASTNode.comment = comment;\n  })(ASTNode || (ASTNode = {}));\n\n  var ws = P.regexp(/[\\n\\r\\s]*/);\n  var Expr = P.lazy(function () {\n    return P.alt(Str, List, Symb, Comment).trim(ws);\n  });\n  var Str = P.takeWhile(function (c) {\n    return c !== '`';\n  }).trim('`').map(ASTNode.str);\n  var Symb = P.regexp(/[^()\\[\\]{};`,\\n\\r\\s]+/).map(ASTNode.symb);\n  var Comment = P.regexp(/\\s*;+([^\\n\\r]*)\\n/, 1).map(ASTNode.comment);\n  var Args = Expr.many();\n  var List1 = Args.wrap('(', ')').map(function (args) {\n    return ASTNode.list('(', args);\n  });\n  var List2 = Args.wrap('[', ']').map(function (args) {\n    return ASTNode.list('[', args);\n  });\n  var List3 = Args.wrap('{', '}').map(function (args) {\n    return ASTNode.list('{', args);\n  });\n  var List = P.alt(List1, List2, List3);\n  var Expressions = Expr.many();\n\n  function getAST(input) {\n    return Expressions.tryParse(input);\n  }\n\n  function visitExpr(expr) {\n    switch (expr.kind) {\n      case 'string':\n        return expr.value;\n\n      case 'symbol':\n        {\n          var value = expr.value;\n\n          if (value.length > 1) {\n            var fst = value.charAt(0);\n\n            switch (fst) {\n              case '.':\n                return B.atomName(value.substr(1));\n\n              case '_':\n                return B.struct.type.elementSymbol([value.substr(1)]);\n            }\n          }\n\n          if (value === 'true') return true;\n          if (value === 'false') return false;\n          if (isNumber(value)) return +value;\n          return Expression.Symbol(value);\n        }\n\n      case 'list':\n        {\n          switch (expr.bracket) {\n            case '[':\n              return B.core.type.list(withoutComments(expr.nodes).map(visitExpr));\n\n            case '{':\n              return B.core.type.set(withoutComments(expr.nodes).map(visitExpr));\n\n            case '(':\n              {\n                var head = visitExpr(expr.nodes[0]);\n                return Expression.Apply(head, getArgs(expr.nodes));\n              }\n          }\n\n          return 0;\n        }\n\n      default:\n        {\n          throw new Error('should not happen');\n        }\n    }\n  }\n\n  function getArgs(nodes) {\n    if (nodes.length <= 1) return void 0;\n\n    if (!hasNamedArgs(nodes)) {\n      var args_1 = [];\n\n      for (var i = 1, _i = nodes.length; i < _i; i++) {\n        var n = nodes[i];\n        if (n.kind === 'comment') continue;\n        args_1[args_1.length] = visitExpr(n);\n      }\n\n      return args_1;\n    }\n\n    var args = {};\n    var allNumeric = true;\n    var pos = 0;\n\n    for (var i = 1, _i = nodes.length; i < _i; i++) {\n      var n = nodes[i];\n      if (n.kind === 'comment') continue;\n\n      if (n.kind === 'symbol' && n.value.length > 1 && n.value.charAt(0) === ':') {\n        var name_1 = n.value.substr(1);\n        ++i;\n\n        while (i < _i && nodes[i].kind === 'comment') {\n          i++;\n        }\n\n        if (i >= _i) throw new Error(\"There must be a value foolowed a named arg ':\" + name_1 + \"'.\");\n        args[name_1] = visitExpr(nodes[i]);\n        if (isNaN(+name_1)) allNumeric = false;\n      } else {\n        args[pos++] = visitExpr(n);\n      }\n    }\n\n    if (allNumeric) {\n      var keys = Object.keys(args).map(function (a) {\n        return +a;\n      }).sort(function (a, b) {\n        return a - b;\n      });\n      var isArray = true;\n\n      for (var i = 0, _i = keys.length; i < _i; i++) {\n        if (keys[i] !== i) {\n          isArray = false;\n          break;\n        }\n      }\n\n      if (isArray) {\n        var arrayArgs = [];\n\n        for (var i = 0, _i = keys.length; i < _i; i++) {\n          arrayArgs[i] = args[i];\n        }\n\n        return arrayArgs;\n      }\n    }\n\n    return args;\n  }\n\n  function hasNamedArgs(nodes) {\n    for (var i = 1, _i = nodes.length; i < _i; i++) {\n      var n = nodes[i];\n      if (n.kind === 'symbol' && n.value.length > 1 && n.value.charAt(0) === ':') return true;\n    }\n\n    return false;\n  }\n\n  function withoutComments(nodes) {\n    var hasComment = false;\n\n    for (var i = 0, _i = nodes.length; i < _i; i++) {\n      if (nodes[i].kind === 'comment') {\n        hasComment = true;\n        break;\n      }\n    }\n\n    if (!hasComment) return nodes;\n    return nodes.filter(function (n) {\n      return n.kind !== 'comment';\n    });\n  }\n\n  function isNumber(value) {\n    return /-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/.test(value) && !isNaN(+value);\n  }\n\n  function parse(input) {\n    var ast = getAST(input);\n    var ret = [];\n\n    for (var _a = 0, ast_1 = ast; _a < ast_1.length; _a++) {\n      var expr = ast_1[_a];\n      if (expr.kind === 'comment') continue;\n      ret[ret.length] = visitExpr(expr);\n    }\n\n    return ret;\n  }\n\n  Language.parse = parse;\n})(Language || (Language = {}));","map":{"version":3,"sources":["../../../src/mol-script/language/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { MonadicParser as P } from '../../mol-util/monadic-parser';\r\nimport { Expression } from './expression';\r\nimport { MolScriptBuilder as B } from './builder';\r\nexport function parseMolScript(input) {\r\n    return Language.parse(input);\r\n}\r\nvar Language;\r\n(function (Language) {\r\n    var ASTNode;\r\n    (function (ASTNode) {\r\n        function str(value) { return { kind: 'string', value: value }; }\r\n        ASTNode.str = str;\r\n        function symb(value) { return { kind: 'symbol', value: value }; }\r\n        ASTNode.symb = symb;\r\n        function list(bracket, nodes) { return { kind: 'list', bracket: bracket, nodes: nodes }; }\r\n        ASTNode.list = list;\r\n        function comment(value) { return { kind: 'comment', value: value }; }\r\n        ASTNode.comment = comment;\r\n    })(ASTNode || (ASTNode = {}));\r\n    var ws = P.regexp(/[\\n\\r\\s]*/);\r\n    var Expr = P.lazy(function () { return (P.alt(Str, List, Symb, Comment).trim(ws)); });\r\n    var Str = P.takeWhile(function (c) { return c !== '`'; }).trim('`').map(ASTNode.str);\r\n    var Symb = P.regexp(/[^()\\[\\]{};`,\\n\\r\\s]+/).map(ASTNode.symb);\r\n    var Comment = P.regexp(/\\s*;+([^\\n\\r]*)\\n/, 1).map(ASTNode.comment);\r\n    var Args = Expr.many();\r\n    var List1 = Args.wrap('(', ')').map(function (args) { return ASTNode.list('(', args); });\r\n    var List2 = Args.wrap('[', ']').map(function (args) { return ASTNode.list('[', args); });\r\n    var List3 = Args.wrap('{', '}').map(function (args) { return ASTNode.list('{', args); });\r\n    var List = P.alt(List1, List2, List3);\r\n    var Expressions = Expr.many();\r\n    function getAST(input) { return Expressions.tryParse(input); }\r\n    function visitExpr(expr) {\r\n        switch (expr.kind) {\r\n            case 'string': return expr.value;\r\n            case 'symbol': {\r\n                var value = expr.value;\r\n                if (value.length > 1) {\r\n                    var fst = value.charAt(0);\r\n                    switch (fst) {\r\n                        case '.': return B.atomName(value.substr(1));\r\n                        case '_': return B.struct.type.elementSymbol([value.substr(1)]);\r\n                    }\r\n                }\r\n                if (value === 'true')\r\n                    return true;\r\n                if (value === 'false')\r\n                    return false;\r\n                if (isNumber(value))\r\n                    return +value;\r\n                return Expression.Symbol(value);\r\n            }\r\n            case 'list': {\r\n                switch (expr.bracket) {\r\n                    case '[': return B.core.type.list(withoutComments(expr.nodes).map(visitExpr));\r\n                    case '{': return B.core.type.set(withoutComments(expr.nodes).map(visitExpr));\r\n                    case '(': {\r\n                        var head = visitExpr(expr.nodes[0]);\r\n                        return Expression.Apply(head, getArgs(expr.nodes));\r\n                    }\r\n                }\r\n                return 0;\r\n            }\r\n            default: {\r\n                throw new Error('should not happen');\r\n            }\r\n        }\r\n    }\r\n    function getArgs(nodes) {\r\n        if (nodes.length <= 1)\r\n            return void 0;\r\n        if (!hasNamedArgs(nodes)) {\r\n            var args_1 = [];\r\n            for (var i = 1, _i = nodes.length; i < _i; i++) {\r\n                var n = nodes[i];\r\n                if (n.kind === 'comment')\r\n                    continue;\r\n                args_1[args_1.length] = visitExpr(n);\r\n            }\r\n            return args_1;\r\n        }\r\n        var args = {};\r\n        var allNumeric = true;\r\n        var pos = 0;\r\n        for (var i = 1, _i = nodes.length; i < _i; i++) {\r\n            var n = nodes[i];\r\n            if (n.kind === 'comment')\r\n                continue;\r\n            if (n.kind === 'symbol' && n.value.length > 1 && n.value.charAt(0) === ':') {\r\n                var name_1 = n.value.substr(1);\r\n                ++i;\r\n                while (i < _i && nodes[i].kind === 'comment') {\r\n                    i++;\r\n                }\r\n                if (i >= _i)\r\n                    throw new Error(\"There must be a value foolowed a named arg ':\" + name_1 + \"'.\");\r\n                args[name_1] = visitExpr(nodes[i]);\r\n                if (isNaN(+name_1))\r\n                    allNumeric = false;\r\n            }\r\n            else {\r\n                args[pos++] = visitExpr(n);\r\n            }\r\n        }\r\n        if (allNumeric) {\r\n            var keys = Object.keys(args).map(function (a) { return +a; }).sort(function (a, b) { return a - b; });\r\n            var isArray = true;\r\n            for (var i = 0, _i = keys.length; i < _i; i++) {\r\n                if (keys[i] !== i) {\r\n                    isArray = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isArray) {\r\n                var arrayArgs = [];\r\n                for (var i = 0, _i = keys.length; i < _i; i++) {\r\n                    arrayArgs[i] = args[i];\r\n                }\r\n                return arrayArgs;\r\n            }\r\n        }\r\n        return args;\r\n    }\r\n    function hasNamedArgs(nodes) {\r\n        for (var i = 1, _i = nodes.length; i < _i; i++) {\r\n            var n = nodes[i];\r\n            if (n.kind === 'symbol' && n.value.length > 1 && n.value.charAt(0) === ':')\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function withoutComments(nodes) {\r\n        var hasComment = false;\r\n        for (var i = 0, _i = nodes.length; i < _i; i++) {\r\n            if (nodes[i].kind === 'comment') {\r\n                hasComment = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!hasComment)\r\n            return nodes;\r\n        return nodes.filter(function (n) { return n.kind !== 'comment'; });\r\n    }\r\n    function isNumber(value) {\r\n        return /-?(0|[1-9][0-9]*)([.][0-9]+)?([eE][+-]?[0-9]+)?/.test(value) && !isNaN(+value);\r\n    }\r\n    function parse(input) {\r\n        var ast = getAST(input);\r\n        var ret = [];\r\n        for (var _a = 0, ast_1 = ast; _a < ast_1.length; _a++) {\r\n            var expr = ast_1[_a];\r\n            if (expr.kind === 'comment')\r\n                continue;\r\n            ret[ret.length] = visitExpr(expr);\r\n        }\r\n        return ret;\r\n    }\r\n    Language.parse = parse;\r\n})(Language || (Language = {}));\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}