/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __extends } from "tslib";
import { InterUnitGraph } from '../../../mol-math/graph/inter-unit-graph';
export { InteractionsIntraContacts };
var InteractionsIntraContacts;
(function (InteractionsIntraContacts) {
    /**
     * Note: assumes that feature members of a contact are non-overlapping
     */
    function createElementsIndex(contacts, features, elementsCount) {
        var offsets = new Int32Array(elementsCount + 1);
        var bucketFill = new Int32Array(elementsCount);
        var bucketSizes = new Int32Array(elementsCount);
        var members = features.members, featureOffsets = features.offsets;
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                ++bucketSizes[members[j]];
            }
        }
        var offset = 0;
        for (var i = 0; i < elementsCount; i++) {
            offsets[i] = offset;
            offset += bucketSizes[i];
        }
        offsets[elementsCount] = offset;
        var indices = new Int32Array(offset);
        for (var i = 0, il = contacts.edgeCount * 2; i < il; ++i) {
            var aI = contacts.a[i];
            var bI = contacts.b[i];
            if (aI > bI)
                continue;
            for (var j = featureOffsets[aI], jl = featureOffsets[aI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
            for (var j = featureOffsets[bI], jl = featureOffsets[bI + 1]; j < jl; ++j) {
                var m = members[j];
                var om = offsets[m] + bucketFill[m];
                indices[om] = i;
                ++bucketFill[m];
            }
        }
        return { indices: indices, offsets: offsets };
    }
    InteractionsIntraContacts.createElementsIndex = createElementsIndex;
})(InteractionsIntraContacts || (InteractionsIntraContacts = {}));
export { InteractionsInterContacts };
var InteractionsInterContacts = /** @class */ (function (_super) {
    __extends(InteractionsInterContacts, _super);
    function InteractionsInterContacts(map, unitsFeatures) {
        var _this = _super.call(this, map) || this;
        var count = 0;
        var elementKeyIndex = new Map();
        var add = function (index, unitId) {
            var vertexKey = _this.getElementKey(index, unitId);
            var e = elementKeyIndex.get(vertexKey);
            if (e === undefined)
                elementKeyIndex.set(vertexKey, [count]);
            else
                e.push(count);
        };
        _this.map.forEach(function (pairEdgesArray) {
            pairEdgesArray.forEach(function (_a) {
                var unitA = _a.unitA, connectedIndices = _a.connectedIndices;
                connectedIndices.forEach(function (indexA) {
                    var _a = unitsFeatures.get(unitA), offsetsA = _a.offsets, membersA = _a.members;
                    for (var j = offsetsA[indexA], jl = offsetsA[indexA + 1]; j < jl; ++j) {
                        add(membersA[j], unitA);
                    }
                    count += 1;
                });
            });
        });
        _this.elementKeyIndex = elementKeyIndex;
        return _this;
    }
    InteractionsInterContacts.prototype.getContactIndicesForElement = function (index, unit) {
        return this.elementKeyIndex.get(this.getElementKey(index, unit.id)) || [];
    };
    InteractionsInterContacts.prototype.getElementKey = function (index, unitId) {
        return index + "|" + unitId;
    };
    return InteractionsInterContacts;
}(InterUnitGraph));
export function interactionTypeLabel(type) {
    switch (type) {
        case 4 /* HydrogenBond */:
            return 'Hydrogen Bond';
        case 6 /* Hydrophobic */:
            return 'Hydrophobic Contact';
        case 5 /* HalogenBond */:
            return 'Halogen Bond';
        case 1 /* Ionic */:
            return 'Ionic Interaction';
        case 7 /* MetalCoordination */:
            return 'Metal Coordination';
        case 2 /* CationPi */:
            return 'Cation-Pi Interaction';
        case 3 /* PiStacking */:
            return 'Pi Stacking';
        case 8 /* WeakHydrogenBond */:
            return 'Weak Hydrogen Bond';
        case 0 /* Unknown */:
            return 'Unknown Interaction';
    }
}
export function featureTypeLabel(type) {
    switch (type) {
        case 0 /* None */:
            return 'None';
        case 1 /* PositiveCharge */:
            return 'Positive Charge';
        case 2 /* NegativeCharge */:
            return 'Negative Charge';
        case 3 /* AromaticRing */:
            return 'Aromatic Ring';
        case 4 /* HydrogenDonor */:
            return 'Hydrogen Donor';
        case 5 /* HydrogenAcceptor */:
            return 'Hydrogen Acceptor';
        case 6 /* HalogenDonor */:
            return 'Halogen Donor';
        case 7 /* HalogenAcceptor */:
            return 'Halogen Acceptor';
        case 8 /* HydrophobicAtom */:
            return 'HydrophobicAtom';
        case 9 /* WeakHydrogenDonor */:
            return 'Weak Hydrogen Donor';
        case 10 /* IonicTypePartner */:
            return 'Ionic Type Partner';
        case 11 /* DativeBondPartner */:
            return 'Dative Bond Partner';
        case 12 /* TransitionMetal */:
            return 'Transition Metal';
        case 13 /* IonicTypeMetal */:
            return 'Ionic Type Metal';
    }
}
export function featureGroupLabel(group) {
    switch (group) {
        case 0 /* None */:
            return 'None';
        case 1 /* QuaternaryAmine */:
            return 'Quaternary Amine';
        case 2 /* TertiaryAmine */:
            return 'Tertiary Amine';
        case 3 /* Sulfonium */:
            return 'Sulfonium';
        case 4 /* SulfonicAcid */:
            return 'Sulfonic Acid';
        case 5 /* Sulfate */:
            return 'Sulfate';
        case 6 /* Phosphate */:
            return 'Phosphate';
        case 7 /* Halocarbon */:
            return 'Halocarbon';
        case 8 /* Guanidine */:
            return 'Guanidine';
        case 9 /* Acetamidine */:
            return 'Acetamidine';
        case 10 /* Carboxylate */:
            return 'Carboxylate';
    }
}
//# sourceMappingURL=common.js.map