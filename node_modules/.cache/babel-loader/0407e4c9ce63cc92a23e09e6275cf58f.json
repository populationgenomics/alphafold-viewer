{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from NGL.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../../mol-task';\nimport { ReaderResult as Result } from '../result';\nvar MagicInts = new Uint32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 10, 12, 16, 20, 25, 32, 40, 50, 64, 80, 101, 128, 161, 203, 256, 322, 406, 512, 645, 812, 1024, 1290, 1625, 2048, 2580, 3250, 4096, 5060, 6501, 8192, 10321, 13003, 16384, 20642, 26007, 32768, 41285, 52015, 65536, 82570, 104031, 131072, 165140, 208063, 262144, 330280, 416127, 524287, 660561, 832255, 1048576, 1321122, 1664510, 2097152, 2642245, 3329021, 4194304, 5284491, 6658042, 8388607, 10568983, 13316085, 16777216]);\nvar FirstIdx = 9; // const LastIdx = MagicInts.length\n\nvar Decoder;\n\n(function (Decoder) {\n  function sizeOfInt(size) {\n    var num = 1;\n    var numOfBits = 0;\n\n    while (size >= num && numOfBits < 32) {\n      numOfBits++;\n      num <<= 1;\n    }\n\n    return numOfBits;\n  }\n\n  Decoder.sizeOfInt = sizeOfInt;\n\n  var _tmpBytes = new Uint8Array(32);\n\n  function sizeOfInts(numOfInts, sizes) {\n    var numOfBytes = 1;\n    var numOfBits = 0;\n    _tmpBytes[0] = 1;\n\n    for (var i = 0; i < numOfInts; i++) {\n      var bytecnt = void 0;\n      var tmp = 0;\n\n      for (bytecnt = 0; bytecnt < numOfBytes; bytecnt++) {\n        tmp += _tmpBytes[bytecnt] * sizes[i];\n        _tmpBytes[bytecnt] = tmp & 0xff;\n        tmp >>= 8;\n      }\n\n      while (tmp !== 0) {\n        _tmpBytes[bytecnt++] = tmp & 0xff;\n        tmp >>= 8;\n      }\n\n      numOfBytes = bytecnt;\n    }\n\n    var num = 1;\n    numOfBytes--;\n\n    while (_tmpBytes[numOfBytes] >= num) {\n      numOfBits++;\n      num *= 2;\n    }\n\n    return numOfBits + numOfBytes * 8;\n  }\n\n  Decoder.sizeOfInts = sizeOfInts;\n\n  var _buffer = new ArrayBuffer(8 * 3);\n\n  Decoder.buf = new Int32Array(_buffer);\n  var uint32view = new Uint32Array(_buffer);\n\n  function decodeBits(cbuf, offset, numOfBits1) {\n    var numOfBits = numOfBits1;\n    var mask = (1 << numOfBits) - 1;\n    var lastBB0 = uint32view[1];\n    var lastBB1 = uint32view[2];\n    var cnt = Decoder.buf[0];\n    var num = 0;\n\n    while (numOfBits >= 8) {\n      lastBB1 = lastBB1 << 8 | cbuf[offset + cnt++];\n      num |= lastBB1 >> lastBB0 << numOfBits - 8;\n      numOfBits -= 8;\n    }\n\n    if (numOfBits > 0) {\n      if (lastBB0 < numOfBits) {\n        lastBB0 += 8;\n        lastBB1 = lastBB1 << 8 | cbuf[offset + cnt++];\n      }\n\n      lastBB0 -= numOfBits;\n      num |= lastBB1 >> lastBB0 & (1 << numOfBits) - 1;\n    }\n\n    num &= mask;\n    Decoder.buf[0] = cnt;\n    Decoder.buf[1] = lastBB0;\n    Decoder.buf[2] = lastBB1;\n    return num;\n  }\n\n  Decoder.decodeBits = decodeBits;\n\n  function decodeByte(cbuf, offset) {\n    // special version of decodeBits with numOfBits = 8\n    // const mask = 0xff; // (1 << 8) - 1;\n    // let lastBB0 = uint32view[1];\n    var lastBB1 = uint32view[2];\n    var cnt = Decoder.buf[0];\n    lastBB1 = lastBB1 << 8 | cbuf[offset + cnt];\n    Decoder.buf[0] = cnt + 1; // buf[1] = lastBB0;\n\n    Decoder.buf[2] = lastBB1;\n    return lastBB1 >> uint32view[1] & 0xff;\n  }\n\n  var intBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // new Int32Array(32);\n\n  function decodeInts(cbuf, offset, numOfBits1, sizes, nums) {\n    var numOfBits = numOfBits1;\n    var numOfBytes = 0;\n    intBytes[0] = 0;\n    intBytes[1] = 0;\n    intBytes[2] = 0;\n    intBytes[3] = 0;\n\n    while (numOfBits > 8) {\n      // this is inversed??? why??? because of the endiannness???\n      intBytes[numOfBytes++] = decodeByte(cbuf, offset);\n      numOfBits -= 8;\n    }\n\n    if (numOfBits > 0) {\n      intBytes[numOfBytes++] = decodeBits(cbuf, offset, numOfBits);\n    }\n\n    for (var i = 2; i > 0; i--) {\n      var num = 0;\n      var s = sizes[i];\n\n      for (var j = numOfBytes - 1; j >= 0; j--) {\n        num = num << 8 | intBytes[j];\n        var t = num / s | 0;\n        intBytes[j] = t;\n        num = num - t * s;\n      }\n\n      nums[i] = num;\n    }\n\n    nums[0] = intBytes[0] | intBytes[1] << 8 | intBytes[2] << 16 | intBytes[3] << 24;\n  }\n\n  Decoder.decodeInts = decodeInts;\n})(Decoder || (Decoder = {}));\n\nfunction undefinedError() {\n  throw new Error('(xdrfile error) Undefined error.');\n}\n\nfunction parseInternal(ctx, data) {\n  return __awaiter(this, void 0, void 0, function () {\n    var dv, f, coordinates, boxes, times, minMaxInt, sizeint, bitsizeint, sizesmall, thiscoord, prevcoord, offset, buf, frameCoords, natoms, box, i, i, lfp, lsize, precision, bitsize, smallidx, tmpIdx, smaller, smallnum, adz, invPrecision, run_1, i, flag, isSmaller, k, tmpSwap, c;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          dv = new DataView(data.buffer, data.byteOffset);\n          f = {\n            frames: [],\n            boxes: [],\n            times: [],\n            timeOffset: 0,\n            deltaTime: 0\n          };\n          coordinates = f.frames;\n          boxes = f.boxes;\n          times = f.times;\n          minMaxInt = [0, 0, 0, 0, 0, 0];\n          sizeint = [0, 0, 0];\n          bitsizeint = [0, 0, 0];\n          sizesmall = [0, 0, 0];\n          thiscoord = [0.1, 0.1, 0.1];\n          prevcoord = [0.1, 0.1, 0.1];\n          offset = 0;\n          buf = Decoder.buf;\n          _a.label = 1;\n\n        case 1:\n          if (!true) return [3\n          /*break*/\n          , 4];\n          frameCoords = void 0;\n          natoms = dv.getInt32(offset + 4); // const step = dv.getInt32(offset + 8)\n\n          offset += 12;\n          times.push(dv.getFloat32(offset));\n          offset += 4;\n          box = new Float32Array(9);\n\n          for (i = 0; i < 9; ++i) {\n            box[i] = dv.getFloat32(offset) * 10;\n            offset += 4;\n          }\n\n          boxes.push(box);\n\n          if (natoms <= 9) {\n            // no compression\n            frameCoords = {\n              count: natoms / 3,\n              x: new Float32Array(natoms / 3),\n              y: new Float32Array(natoms / 3),\n              z: new Float32Array(natoms / 3)\n            };\n\n            for (i = 0; i < natoms / 3; ++i) {\n              frameCoords.x[i] = dv.getFloat32(offset);\n              frameCoords.y[i] = dv.getFloat32(offset);\n              frameCoords.z[i] = dv.getFloat32(offset);\n              offset += 4;\n            }\n          } else {\n            buf[0] = buf[1] = buf[2] = 0;\n            sizeint[0] = sizeint[1] = sizeint[2] = 0;\n            sizesmall[0] = sizesmall[1] = sizesmall[2] = 0;\n            bitsizeint[0] = bitsizeint[1] = bitsizeint[2] = 0;\n            thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\n            prevcoord[0] = prevcoord[1] = prevcoord[2] = 0;\n            frameCoords = {\n              count: natoms,\n              x: new Float32Array(natoms),\n              y: new Float32Array(natoms),\n              z: new Float32Array(natoms)\n            };\n            lfp = 0;\n            lsize = dv.getInt32(offset);\n            offset += 4;\n            precision = dv.getFloat32(offset);\n            offset += 4;\n            minMaxInt[0] = dv.getInt32(offset);\n            minMaxInt[1] = dv.getInt32(offset + 4);\n            minMaxInt[2] = dv.getInt32(offset + 8);\n            minMaxInt[3] = dv.getInt32(offset + 12);\n            minMaxInt[4] = dv.getInt32(offset + 16);\n            minMaxInt[5] = dv.getInt32(offset + 20);\n            sizeint[0] = minMaxInt[3] - minMaxInt[0] + 1;\n            sizeint[1] = minMaxInt[4] - minMaxInt[1] + 1;\n            sizeint[2] = minMaxInt[5] - minMaxInt[2] + 1;\n            offset += 24;\n            bitsize = void 0;\n\n            if ((sizeint[0] | sizeint[1] | sizeint[2]) > 0xffffff) {\n              bitsizeint[0] = Decoder.sizeOfInt(sizeint[0]);\n              bitsizeint[1] = Decoder.sizeOfInt(sizeint[1]);\n              bitsizeint[2] = Decoder.sizeOfInt(sizeint[2]);\n              bitsize = 0; // flag the use of large sizes\n            } else {\n              bitsize = Decoder.sizeOfInts(3, sizeint);\n            }\n\n            smallidx = dv.getInt32(offset);\n            offset += 4;\n            tmpIdx = smallidx - 1;\n            tmpIdx = FirstIdx > tmpIdx ? FirstIdx : tmpIdx;\n            smaller = MagicInts[tmpIdx] / 2 | 0;\n            smallnum = MagicInts[smallidx] / 2 | 0;\n            sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];\n            adz = Math.ceil(dv.getInt32(offset) / 4) * 4;\n            offset += 4;\n            invPrecision = 1.0 / precision;\n            run_1 = 0;\n            i = 0; // const buf8 = new Uint8Array(data.buffer, data.byteOffset + offset, 32 * 4); // 229...\n\n            thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\n\n            while (i < lsize) {\n              if (bitsize === 0) {\n                thiscoord[0] = Decoder.decodeBits(data, offset, bitsizeint[0]);\n                thiscoord[1] = Decoder.decodeBits(data, offset, bitsizeint[1]);\n                thiscoord[2] = Decoder.decodeBits(data, offset, bitsizeint[2]);\n              } else {\n                Decoder.decodeInts(data, offset, bitsize, sizeint, thiscoord);\n              }\n\n              i++;\n              thiscoord[0] += minMaxInt[0];\n              thiscoord[1] += minMaxInt[1];\n              thiscoord[2] += minMaxInt[2];\n              prevcoord[0] = thiscoord[0];\n              prevcoord[1] = thiscoord[1];\n              prevcoord[2] = thiscoord[2];\n              flag = Decoder.decodeBits(data, offset, 1);\n              isSmaller = 0;\n\n              if (flag === 1) {\n                run_1 = Decoder.decodeBits(data, offset, 5);\n                isSmaller = run_1 % 3;\n                run_1 -= isSmaller;\n                isSmaller--;\n              } // if ((lfp-ptrstart)+run > size3){\n              //   fprintf(stderr, \"(xdrfile error) Buffer overrun during decompression.\\n\");\n              //   return 0;\n              // }\n\n\n              if (run_1 > 0) {\n                thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\n\n                for (k = 0; k < run_1; k += 3) {\n                  Decoder.decodeInts(data, offset, smallidx, sizesmall, thiscoord);\n                  i++;\n                  thiscoord[0] += prevcoord[0] - smallnum;\n                  thiscoord[1] += prevcoord[1] - smallnum;\n                  thiscoord[2] += prevcoord[2] - smallnum;\n\n                  if (k === 0) {\n                    tmpSwap = thiscoord[0];\n                    thiscoord[0] = prevcoord[0];\n                    prevcoord[0] = tmpSwap;\n                    tmpSwap = thiscoord[1];\n                    thiscoord[1] = prevcoord[1];\n                    prevcoord[1] = tmpSwap;\n                    tmpSwap = thiscoord[2];\n                    thiscoord[2] = prevcoord[2];\n                    prevcoord[2] = tmpSwap;\n                    frameCoords.x[lfp] = prevcoord[0] * invPrecision;\n                    frameCoords.y[lfp] = prevcoord[1] * invPrecision;\n                    frameCoords.z[lfp] = prevcoord[2] * invPrecision;\n                    lfp++;\n                  } else {\n                    prevcoord[0] = thiscoord[0];\n                    prevcoord[1] = thiscoord[1];\n                    prevcoord[2] = thiscoord[2];\n                  }\n\n                  frameCoords.x[lfp] = thiscoord[0] * invPrecision;\n                  frameCoords.y[lfp] = thiscoord[1] * invPrecision;\n                  frameCoords.z[lfp] = thiscoord[2] * invPrecision;\n                  lfp++;\n                }\n              } else {\n                frameCoords.x[lfp] = thiscoord[0] * invPrecision;\n                frameCoords.y[lfp] = thiscoord[1] * invPrecision;\n                frameCoords.z[lfp] = thiscoord[2] * invPrecision;\n                lfp++;\n              }\n\n              smallidx += isSmaller;\n\n              if (isSmaller < 0) {\n                smallnum = smaller;\n\n                if (smallidx > FirstIdx) {\n                  smaller = MagicInts[smallidx - 1] / 2 | 0;\n                } else {\n                  smaller = 0;\n                }\n              } else if (isSmaller > 0) {\n                smaller = smallnum;\n                smallnum = MagicInts[smallidx] / 2 | 0;\n              }\n\n              sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];\n\n              if (sizesmall[0] === 0 || sizesmall[1] === 0 || sizesmall[2] === 0) {\n                undefinedError();\n              }\n            }\n\n            offset += adz;\n          }\n\n          for (c = 0; c < natoms; c++) {\n            frameCoords.x[c] *= 10;\n            frameCoords.y[c] *= 10;\n            frameCoords.z[c] *= 10;\n          }\n\n          coordinates.push(frameCoords);\n          if (!ctx.shouldUpdate) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , ctx.update({\n            current: offset,\n            max: data.length\n          })];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          if (offset >= data.length) return [3\n          /*break*/\n          , 4];\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          if (times.length >= 1) {\n            f.timeOffset = times[0];\n          }\n\n          if (times.length >= 2) {\n            f.deltaTime = times[1] - times[0];\n          }\n\n          return [2\n          /*return*/\n          , f];\n      }\n    });\n  });\n}\n\nexport function parseXtc(data) {\n  var _this = this;\n\n  return Task.create('Parse XTC', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var file, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            ctx.update({\n              canAbort: true,\n              message: 'Parsing trajectory...'\n            });\n            return [4\n            /*yield*/\n            , parseInternal(ctx, data)];\n\n          case 1:\n            file = _a.sent();\n            return [2\n            /*return*/\n            , Result.success(file)];\n\n          case 2:\n            e_1 = _a.sent();\n            return [2\n            /*return*/\n            , Result.error('' + e_1)];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-io/reader/xtc/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from NGL.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../../mol-task';\r\nimport { ReaderResult as Result } from '../result';\r\nvar MagicInts = new Uint32Array([\r\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 10, 12, 16, 20, 25, 32, 40, 50, 64,\r\n    80, 101, 128, 161, 203, 256, 322, 406, 512, 645, 812, 1024, 1290,\r\n    1625, 2048, 2580, 3250, 4096, 5060, 6501, 8192, 10321, 13003,\r\n    16384, 20642, 26007, 32768, 41285, 52015, 65536, 82570, 104031,\r\n    131072, 165140, 208063, 262144, 330280, 416127, 524287, 660561,\r\n    832255, 1048576, 1321122, 1664510, 2097152, 2642245, 3329021,\r\n    4194304, 5284491, 6658042, 8388607, 10568983, 13316085, 16777216\r\n]);\r\nvar FirstIdx = 9;\r\n// const LastIdx = MagicInts.length\r\nvar Decoder;\r\n(function (Decoder) {\r\n    function sizeOfInt(size) {\r\n        var num = 1;\r\n        var numOfBits = 0;\r\n        while (size >= num && numOfBits < 32) {\r\n            numOfBits++;\r\n            num <<= 1;\r\n        }\r\n        return numOfBits;\r\n    }\r\n    Decoder.sizeOfInt = sizeOfInt;\r\n    var _tmpBytes = new Uint8Array(32);\r\n    function sizeOfInts(numOfInts, sizes) {\r\n        var numOfBytes = 1;\r\n        var numOfBits = 0;\r\n        _tmpBytes[0] = 1;\r\n        for (var i = 0; i < numOfInts; i++) {\r\n            var bytecnt = void 0;\r\n            var tmp = 0;\r\n            for (bytecnt = 0; bytecnt < numOfBytes; bytecnt++) {\r\n                tmp += _tmpBytes[bytecnt] * sizes[i];\r\n                _tmpBytes[bytecnt] = tmp & 0xff;\r\n                tmp >>= 8;\r\n            }\r\n            while (tmp !== 0) {\r\n                _tmpBytes[bytecnt++] = tmp & 0xff;\r\n                tmp >>= 8;\r\n            }\r\n            numOfBytes = bytecnt;\r\n        }\r\n        var num = 1;\r\n        numOfBytes--;\r\n        while (_tmpBytes[numOfBytes] >= num) {\r\n            numOfBits++;\r\n            num *= 2;\r\n        }\r\n        return numOfBits + numOfBytes * 8;\r\n    }\r\n    Decoder.sizeOfInts = sizeOfInts;\r\n    var _buffer = new ArrayBuffer(8 * 3);\r\n    Decoder.buf = new Int32Array(_buffer);\r\n    var uint32view = new Uint32Array(_buffer);\r\n    function decodeBits(cbuf, offset, numOfBits1) {\r\n        var numOfBits = numOfBits1;\r\n        var mask = (1 << numOfBits) - 1;\r\n        var lastBB0 = uint32view[1];\r\n        var lastBB1 = uint32view[2];\r\n        var cnt = Decoder.buf[0];\r\n        var num = 0;\r\n        while (numOfBits >= 8) {\r\n            lastBB1 = (lastBB1 << 8) | cbuf[offset + cnt++];\r\n            num |= (lastBB1 >> lastBB0) << (numOfBits - 8);\r\n            numOfBits -= 8;\r\n        }\r\n        if (numOfBits > 0) {\r\n            if (lastBB0 < numOfBits) {\r\n                lastBB0 += 8;\r\n                lastBB1 = (lastBB1 << 8) | cbuf[offset + cnt++];\r\n            }\r\n            lastBB0 -= numOfBits;\r\n            num |= (lastBB1 >> lastBB0) & ((1 << numOfBits) - 1);\r\n        }\r\n        num &= mask;\r\n        Decoder.buf[0] = cnt;\r\n        Decoder.buf[1] = lastBB0;\r\n        Decoder.buf[2] = lastBB1;\r\n        return num;\r\n    }\r\n    Decoder.decodeBits = decodeBits;\r\n    function decodeByte(cbuf, offset) {\r\n        // special version of decodeBits with numOfBits = 8\r\n        // const mask = 0xff; // (1 << 8) - 1;\r\n        // let lastBB0 = uint32view[1];\r\n        var lastBB1 = uint32view[2];\r\n        var cnt = Decoder.buf[0];\r\n        lastBB1 = (lastBB1 << 8) | cbuf[offset + cnt];\r\n        Decoder.buf[0] = cnt + 1;\r\n        // buf[1] = lastBB0;\r\n        Decoder.buf[2] = lastBB1;\r\n        return (lastBB1 >> uint32view[1]) & 0xff;\r\n    }\r\n    var intBytes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    // new Int32Array(32);\r\n    function decodeInts(cbuf, offset, numOfBits1, sizes, nums) {\r\n        var numOfBits = numOfBits1;\r\n        var numOfBytes = 0;\r\n        intBytes[0] = 0;\r\n        intBytes[1] = 0;\r\n        intBytes[2] = 0;\r\n        intBytes[3] = 0;\r\n        while (numOfBits > 8) {\r\n            // this is inversed??? why??? because of the endiannness???\r\n            intBytes[numOfBytes++] = decodeByte(cbuf, offset);\r\n            numOfBits -= 8;\r\n        }\r\n        if (numOfBits > 0) {\r\n            intBytes[numOfBytes++] = decodeBits(cbuf, offset, numOfBits);\r\n        }\r\n        for (var i = 2; i > 0; i--) {\r\n            var num = 0;\r\n            var s = sizes[i];\r\n            for (var j = numOfBytes - 1; j >= 0; j--) {\r\n                num = (num << 8) | intBytes[j];\r\n                var t = (num / s) | 0;\r\n                intBytes[j] = t;\r\n                num = num - t * s;\r\n            }\r\n            nums[i] = num;\r\n        }\r\n        nums[0] = intBytes[0] | (intBytes[1] << 8) | (intBytes[2] << 16) | (intBytes[3] << 24);\r\n    }\r\n    Decoder.decodeInts = decodeInts;\r\n})(Decoder || (Decoder = {}));\r\nfunction undefinedError() {\r\n    throw new Error('(xdrfile error) Undefined error.');\r\n}\r\nfunction parseInternal(ctx, data) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var dv, f, coordinates, boxes, times, minMaxInt, sizeint, bitsizeint, sizesmall, thiscoord, prevcoord, offset, buf, frameCoords, natoms, box, i, i, lfp, lsize, precision, bitsize, smallidx, tmpIdx, smaller, smallnum, adz, invPrecision, run_1, i, flag, isSmaller, k, tmpSwap, c;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    dv = new DataView(data.buffer, data.byteOffset);\r\n                    f = {\r\n                        frames: [],\r\n                        boxes: [],\r\n                        times: [],\r\n                        timeOffset: 0,\r\n                        deltaTime: 0\r\n                    };\r\n                    coordinates = f.frames;\r\n                    boxes = f.boxes;\r\n                    times = f.times;\r\n                    minMaxInt = [0, 0, 0, 0, 0, 0];\r\n                    sizeint = [0, 0, 0];\r\n                    bitsizeint = [0, 0, 0];\r\n                    sizesmall = [0, 0, 0];\r\n                    thiscoord = [0.1, 0.1, 0.1];\r\n                    prevcoord = [0.1, 0.1, 0.1];\r\n                    offset = 0;\r\n                    buf = Decoder.buf;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!true) return [3 /*break*/, 4];\r\n                    frameCoords = void 0;\r\n                    natoms = dv.getInt32(offset + 4);\r\n                    // const step = dv.getInt32(offset + 8)\r\n                    offset += 12;\r\n                    times.push(dv.getFloat32(offset));\r\n                    offset += 4;\r\n                    box = new Float32Array(9);\r\n                    for (i = 0; i < 9; ++i) {\r\n                        box[i] = dv.getFloat32(offset) * 10;\r\n                        offset += 4;\r\n                    }\r\n                    boxes.push(box);\r\n                    if (natoms <= 9) { // no compression\r\n                        frameCoords = { count: natoms / 3, x: new Float32Array(natoms / 3), y: new Float32Array(natoms / 3), z: new Float32Array(natoms / 3) };\r\n                        for (i = 0; i < natoms / 3; ++i) {\r\n                            frameCoords.x[i] = dv.getFloat32(offset);\r\n                            frameCoords.y[i] = dv.getFloat32(offset);\r\n                            frameCoords.z[i] = dv.getFloat32(offset);\r\n                            offset += 4;\r\n                        }\r\n                    }\r\n                    else {\r\n                        buf[0] = buf[1] = buf[2] = 0;\r\n                        sizeint[0] = sizeint[1] = sizeint[2] = 0;\r\n                        sizesmall[0] = sizesmall[1] = sizesmall[2] = 0;\r\n                        bitsizeint[0] = bitsizeint[1] = bitsizeint[2] = 0;\r\n                        thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\r\n                        prevcoord[0] = prevcoord[1] = prevcoord[2] = 0;\r\n                        frameCoords = { count: natoms, x: new Float32Array(natoms), y: new Float32Array(natoms), z: new Float32Array(natoms) };\r\n                        lfp = 0;\r\n                        lsize = dv.getInt32(offset);\r\n                        offset += 4;\r\n                        precision = dv.getFloat32(offset);\r\n                        offset += 4;\r\n                        minMaxInt[0] = dv.getInt32(offset);\r\n                        minMaxInt[1] = dv.getInt32(offset + 4);\r\n                        minMaxInt[2] = dv.getInt32(offset + 8);\r\n                        minMaxInt[3] = dv.getInt32(offset + 12);\r\n                        minMaxInt[4] = dv.getInt32(offset + 16);\r\n                        minMaxInt[5] = dv.getInt32(offset + 20);\r\n                        sizeint[0] = minMaxInt[3] - minMaxInt[0] + 1;\r\n                        sizeint[1] = minMaxInt[4] - minMaxInt[1] + 1;\r\n                        sizeint[2] = minMaxInt[5] - minMaxInt[2] + 1;\r\n                        offset += 24;\r\n                        bitsize = void 0;\r\n                        if ((sizeint[0] | sizeint[1] | sizeint[2]) > 0xffffff) {\r\n                            bitsizeint[0] = Decoder.sizeOfInt(sizeint[0]);\r\n                            bitsizeint[1] = Decoder.sizeOfInt(sizeint[1]);\r\n                            bitsizeint[2] = Decoder.sizeOfInt(sizeint[2]);\r\n                            bitsize = 0; // flag the use of large sizes\r\n                        }\r\n                        else {\r\n                            bitsize = Decoder.sizeOfInts(3, sizeint);\r\n                        }\r\n                        smallidx = dv.getInt32(offset);\r\n                        offset += 4;\r\n                        tmpIdx = smallidx - 1;\r\n                        tmpIdx = (FirstIdx > tmpIdx) ? FirstIdx : tmpIdx;\r\n                        smaller = (MagicInts[tmpIdx] / 2) | 0;\r\n                        smallnum = (MagicInts[smallidx] / 2) | 0;\r\n                        sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];\r\n                        adz = Math.ceil(dv.getInt32(offset) / 4) * 4;\r\n                        offset += 4;\r\n                        invPrecision = 1.0 / precision;\r\n                        run_1 = 0;\r\n                        i = 0;\r\n                        // const buf8 = new Uint8Array(data.buffer, data.byteOffset + offset, 32 * 4); // 229...\r\n                        thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\r\n                        while (i < lsize) {\r\n                            if (bitsize === 0) {\r\n                                thiscoord[0] = Decoder.decodeBits(data, offset, bitsizeint[0]);\r\n                                thiscoord[1] = Decoder.decodeBits(data, offset, bitsizeint[1]);\r\n                                thiscoord[2] = Decoder.decodeBits(data, offset, bitsizeint[2]);\r\n                            }\r\n                            else {\r\n                                Decoder.decodeInts(data, offset, bitsize, sizeint, thiscoord);\r\n                            }\r\n                            i++;\r\n                            thiscoord[0] += minMaxInt[0];\r\n                            thiscoord[1] += minMaxInt[1];\r\n                            thiscoord[2] += minMaxInt[2];\r\n                            prevcoord[0] = thiscoord[0];\r\n                            prevcoord[1] = thiscoord[1];\r\n                            prevcoord[2] = thiscoord[2];\r\n                            flag = Decoder.decodeBits(data, offset, 1);\r\n                            isSmaller = 0;\r\n                            if (flag === 1) {\r\n                                run_1 = Decoder.decodeBits(data, offset, 5);\r\n                                isSmaller = run_1 % 3;\r\n                                run_1 -= isSmaller;\r\n                                isSmaller--;\r\n                            }\r\n                            // if ((lfp-ptrstart)+run > size3){\r\n                            //   fprintf(stderr, \"(xdrfile error) Buffer overrun during decompression.\\n\");\r\n                            //   return 0;\r\n                            // }\r\n                            if (run_1 > 0) {\r\n                                thiscoord[0] = thiscoord[1] = thiscoord[2] = 0;\r\n                                for (k = 0; k < run_1; k += 3) {\r\n                                    Decoder.decodeInts(data, offset, smallidx, sizesmall, thiscoord);\r\n                                    i++;\r\n                                    thiscoord[0] += prevcoord[0] - smallnum;\r\n                                    thiscoord[1] += prevcoord[1] - smallnum;\r\n                                    thiscoord[2] += prevcoord[2] - smallnum;\r\n                                    if (k === 0) {\r\n                                        tmpSwap = thiscoord[0];\r\n                                        thiscoord[0] = prevcoord[0];\r\n                                        prevcoord[0] = tmpSwap;\r\n                                        tmpSwap = thiscoord[1];\r\n                                        thiscoord[1] = prevcoord[1];\r\n                                        prevcoord[1] = tmpSwap;\r\n                                        tmpSwap = thiscoord[2];\r\n                                        thiscoord[2] = prevcoord[2];\r\n                                        prevcoord[2] = tmpSwap;\r\n                                        frameCoords.x[lfp] = prevcoord[0] * invPrecision;\r\n                                        frameCoords.y[lfp] = prevcoord[1] * invPrecision;\r\n                                        frameCoords.z[lfp] = prevcoord[2] * invPrecision;\r\n                                        lfp++;\r\n                                    }\r\n                                    else {\r\n                                        prevcoord[0] = thiscoord[0];\r\n                                        prevcoord[1] = thiscoord[1];\r\n                                        prevcoord[2] = thiscoord[2];\r\n                                    }\r\n                                    frameCoords.x[lfp] = thiscoord[0] * invPrecision;\r\n                                    frameCoords.y[lfp] = thiscoord[1] * invPrecision;\r\n                                    frameCoords.z[lfp] = thiscoord[2] * invPrecision;\r\n                                    lfp++;\r\n                                }\r\n                            }\r\n                            else {\r\n                                frameCoords.x[lfp] = thiscoord[0] * invPrecision;\r\n                                frameCoords.y[lfp] = thiscoord[1] * invPrecision;\r\n                                frameCoords.z[lfp] = thiscoord[2] * invPrecision;\r\n                                lfp++;\r\n                            }\r\n                            smallidx += isSmaller;\r\n                            if (isSmaller < 0) {\r\n                                smallnum = smaller;\r\n                                if (smallidx > FirstIdx) {\r\n                                    smaller = (MagicInts[smallidx - 1] / 2) | 0;\r\n                                }\r\n                                else {\r\n                                    smaller = 0;\r\n                                }\r\n                            }\r\n                            else if (isSmaller > 0) {\r\n                                smaller = smallnum;\r\n                                smallnum = (MagicInts[smallidx] / 2) | 0;\r\n                            }\r\n                            sizesmall[0] = sizesmall[1] = sizesmall[2] = MagicInts[smallidx];\r\n                            if (sizesmall[0] === 0 || sizesmall[1] === 0 || sizesmall[2] === 0) {\r\n                                undefinedError();\r\n                            }\r\n                        }\r\n                        offset += adz;\r\n                    }\r\n                    for (c = 0; c < natoms; c++) {\r\n                        frameCoords.x[c] *= 10;\r\n                        frameCoords.y[c] *= 10;\r\n                        frameCoords.z[c] *= 10;\r\n                    }\r\n                    coordinates.push(frameCoords);\r\n                    if (!ctx.shouldUpdate) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, ctx.update({ current: offset, max: data.length })];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3:\r\n                    if (offset >= data.length)\r\n                        return [3 /*break*/, 4];\r\n                    return [3 /*break*/, 1];\r\n                case 4:\r\n                    if (times.length >= 1) {\r\n                        f.timeOffset = times[0];\r\n                    }\r\n                    if (times.length >= 2) {\r\n                        f.deltaTime = times[1] - times[0];\r\n                    }\r\n                    return [2 /*return*/, f];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function parseXtc(data) {\r\n    var _this = this;\r\n    return Task.create('Parse XTC', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var file, e_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, 2, , 3]);\r\n                    ctx.update({ canAbort: true, message: 'Parsing trajectory...' });\r\n                    return [4 /*yield*/, parseInternal(ctx, data)];\r\n                case 1:\r\n                    file = _a.sent();\r\n                    return [2 /*return*/, Result.success(file)];\r\n                case 2:\r\n                    e_1 = _a.sent();\r\n                    return [2 /*return*/, Result.error('' + e_1)];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}