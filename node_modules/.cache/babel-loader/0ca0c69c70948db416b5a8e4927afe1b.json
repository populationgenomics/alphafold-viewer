{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Box3D, fillGridDim } from '../../geometry';\nimport { Vec3, Mat4, Tensor } from '../../linear-algebra';\nimport { OrderedSet } from '../../../mol-data/int';\nimport { fasterExp } from '../../approx';\nexport function GaussianDensityCPU(ctx, position, box, radius, props) {\n  return __awaiter(this, void 0, void 0, function () {\n    function accumulateRange(begI, endI) {\n      for (var i = begI; i < endI; ++i) {\n        var j = OrderedSet.getAt(indices, i);\n        var vx = x[j],\n            vy = y[j],\n            vz = z[j];\n        var rad = radii[i];\n        var rSq = rad * rad;\n        var rSqInv = 1 / rSq;\n        var r2 = rad * 2;\n        var r2sq = r2 * r2; // Number of grid points, round this up...\n\n        var ng = Math.ceil(r2 * scaleFactor); // Center of the atom, mapped to grid points (take floor)\n\n        var iax = Math.floor(scaleFactor * (vx - min[0]));\n        var iay = Math.floor(scaleFactor * (vy - min[1]));\n        var iaz = Math.floor(scaleFactor * (vz - min[2])); // Extents of grid to consider for this atom\n\n        var begX = Math.max(0, iax - ng);\n        var begY = Math.max(0, iay - ng);\n        var begZ = Math.max(0, iaz - ng); // Add two to these points:\n        // - iax are floor'd values so this ensures coverage\n        // - these are loop limits (exclusive)\n\n        var endX = Math.min(dimX, iax + ng + 2);\n        var endY = Math.min(dimY, iay + ng + 2);\n        var endZ = Math.min(dimZ, iaz + ng + 2);\n\n        for (var xi = begX; xi < endX; ++xi) {\n          var dx = gridx[xi] - vx;\n          var xIdx = xi * iuv;\n\n          for (var yi = begY; yi < endY; ++yi) {\n            var dy = gridy[yi] - vy;\n            var dxySq = dx * dx + dy * dy;\n            var xyIdx = yi * iu + xIdx;\n\n            for (var zi = begZ; zi < endZ; ++zi) {\n              var dz = gridz[zi] - vz;\n              var dSq = dxySq + dz * dz;\n\n              if (dSq <= r2sq) {\n                var dens = fasterExp(-alpha * (dSq * rSqInv));\n                var idx = zi + xyIdx;\n                data[idx] += dens;\n\n                if (dens > densData[idx]) {\n                  densData[idx] = dens;\n                  idData[idx] = id ? id[i] : i;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function accumulate() {\n      return __awaiter(this, void 0, void 0, function () {\n        var i;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              i = 0;\n              _a.label = 1;\n\n            case 1:\n              if (!(i < n)) return [3\n              /*break*/\n              , 4];\n              accumulateRange(i, Math.min(i + updateChunk, n));\n              if (!ctx.shouldUpdate) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , ctx.update({\n                message: 'filling density grid',\n                current: i,\n                max: n\n              })];\n\n            case 2:\n              _a.sent();\n\n              _a.label = 3;\n\n            case 3:\n              i += updateChunk;\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    var resolution, radiusOffset, smoothness, scaleFactor, indices, x, y, z, id, n, radii, maxRadius, i, r, pad, expandedBox, min, scaledBox, dim, space, data, field, idData, idField, dimX, dimY, dimZ, iu, iv, iuv, gridx, gridy, gridz, densData, alpha, updateChunk, transform;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          resolution = props.resolution, radiusOffset = props.radiusOffset, smoothness = props.smoothness;\n          scaleFactor = 1 / resolution;\n          indices = position.indices, x = position.x, y = position.y, z = position.z, id = position.id;\n          n = OrderedSet.size(indices);\n          radii = new Float32Array(n);\n          maxRadius = 0;\n\n          for (i = 0; i < n; ++i) {\n            r = radius(OrderedSet.getAt(indices, i)) + radiusOffset;\n            if (maxRadius < r) maxRadius = r;\n            radii[i] = r;\n          }\n\n          pad = maxRadius * 2 + resolution;\n          expandedBox = Box3D.expand(Box3D(), box, Vec3.create(pad, pad, pad));\n          min = expandedBox.min;\n          scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);\n          dim = Box3D.size(Vec3(), scaledBox);\n          Vec3.ceil(dim, dim);\n          space = Tensor.Space(dim, [0, 1, 2], Float32Array);\n          data = space.create();\n          field = Tensor.create(space, data);\n          idData = space.create();\n          idData.fill(-1);\n          idField = Tensor.create(space, idData);\n          dimX = dim[0], dimY = dim[1], dimZ = dim[2];\n          iu = dimZ, iv = dimY, iuv = iu * iv;\n          gridx = fillGridDim(dim[0], min[0], resolution);\n          gridy = fillGridDim(dim[1], min[1], resolution);\n          gridz = fillGridDim(dim[2], min[2], resolution);\n          densData = space.create();\n          alpha = smoothness;\n          updateChunk = Math.ceil(100000 / (Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor)); // console.time('gaussian density cpu')\n\n          return [4\n          /*yield*/\n          , accumulate()];\n\n        case 1:\n          // console.time('gaussian density cpu')\n          _a.sent();\n\n          transform = Mat4.identity();\n          Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));\n          Mat4.setTranslation(transform, expandedBox.min);\n          return [2\n          /*return*/\n          , {\n            field: field,\n            idField: idField,\n            transform: transform,\n            radiusFactor: 1,\n            resolution: resolution\n          }];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-math/geometry/gaussian-density/cpu.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Box3D, fillGridDim } from '../../geometry';\r\nimport { Vec3, Mat4, Tensor } from '../../linear-algebra';\r\nimport { OrderedSet } from '../../../mol-data/int';\r\nimport { fasterExp } from '../../approx';\r\nexport function GaussianDensityCPU(ctx, position, box, radius, props) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        function accumulateRange(begI, endI) {\r\n            for (var i = begI; i < endI; ++i) {\r\n                var j = OrderedSet.getAt(indices, i);\r\n                var vx = x[j], vy = y[j], vz = z[j];\r\n                var rad = radii[i];\r\n                var rSq = rad * rad;\r\n                var rSqInv = 1 / rSq;\r\n                var r2 = rad * 2;\r\n                var r2sq = r2 * r2;\r\n                // Number of grid points, round this up...\r\n                var ng = Math.ceil(r2 * scaleFactor);\r\n                // Center of the atom, mapped to grid points (take floor)\r\n                var iax = Math.floor(scaleFactor * (vx - min[0]));\r\n                var iay = Math.floor(scaleFactor * (vy - min[1]));\r\n                var iaz = Math.floor(scaleFactor * (vz - min[2]));\r\n                // Extents of grid to consider for this atom\r\n                var begX = Math.max(0, iax - ng);\r\n                var begY = Math.max(0, iay - ng);\r\n                var begZ = Math.max(0, iaz - ng);\r\n                // Add two to these points:\r\n                // - iax are floor'd values so this ensures coverage\r\n                // - these are loop limits (exclusive)\r\n                var endX = Math.min(dimX, iax + ng + 2);\r\n                var endY = Math.min(dimY, iay + ng + 2);\r\n                var endZ = Math.min(dimZ, iaz + ng + 2);\r\n                for (var xi = begX; xi < endX; ++xi) {\r\n                    var dx = gridx[xi] - vx;\r\n                    var xIdx = xi * iuv;\r\n                    for (var yi = begY; yi < endY; ++yi) {\r\n                        var dy = gridy[yi] - vy;\r\n                        var dxySq = dx * dx + dy * dy;\r\n                        var xyIdx = yi * iu + xIdx;\r\n                        for (var zi = begZ; zi < endZ; ++zi) {\r\n                            var dz = gridz[zi] - vz;\r\n                            var dSq = dxySq + dz * dz;\r\n                            if (dSq <= r2sq) {\r\n                                var dens = fasterExp(-alpha * (dSq * rSqInv));\r\n                                var idx = zi + xyIdx;\r\n                                data[idx] += dens;\r\n                                if (dens > densData[idx]) {\r\n                                    densData[idx] = dens;\r\n                                    idData[idx] = id ? id[i] : i;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function accumulate() {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var i;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            i = 0;\r\n                            _a.label = 1;\r\n                        case 1:\r\n                            if (!(i < n)) return [3 /*break*/, 4];\r\n                            accumulateRange(i, Math.min(i + updateChunk, n));\r\n                            if (!ctx.shouldUpdate) return [3 /*break*/, 3];\r\n                            return [4 /*yield*/, ctx.update({ message: 'filling density grid', current: i, max: n })];\r\n                        case 2:\r\n                            _a.sent();\r\n                            _a.label = 3;\r\n                        case 3:\r\n                            i += updateChunk;\r\n                            return [3 /*break*/, 1];\r\n                        case 4: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        var resolution, radiusOffset, smoothness, scaleFactor, indices, x, y, z, id, n, radii, maxRadius, i, r, pad, expandedBox, min, scaledBox, dim, space, data, field, idData, idField, dimX, dimY, dimZ, iu, iv, iuv, gridx, gridy, gridz, densData, alpha, updateChunk, transform;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    resolution = props.resolution, radiusOffset = props.radiusOffset, smoothness = props.smoothness;\r\n                    scaleFactor = 1 / resolution;\r\n                    indices = position.indices, x = position.x, y = position.y, z = position.z, id = position.id;\r\n                    n = OrderedSet.size(indices);\r\n                    radii = new Float32Array(n);\r\n                    maxRadius = 0;\r\n                    for (i = 0; i < n; ++i) {\r\n                        r = radius(OrderedSet.getAt(indices, i)) + radiusOffset;\r\n                        if (maxRadius < r)\r\n                            maxRadius = r;\r\n                        radii[i] = r;\r\n                    }\r\n                    pad = maxRadius * 2 + resolution;\r\n                    expandedBox = Box3D.expand(Box3D(), box, Vec3.create(pad, pad, pad));\r\n                    min = expandedBox.min;\r\n                    scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);\r\n                    dim = Box3D.size(Vec3(), scaledBox);\r\n                    Vec3.ceil(dim, dim);\r\n                    space = Tensor.Space(dim, [0, 1, 2], Float32Array);\r\n                    data = space.create();\r\n                    field = Tensor.create(space, data);\r\n                    idData = space.create();\r\n                    idData.fill(-1);\r\n                    idField = Tensor.create(space, idData);\r\n                    dimX = dim[0], dimY = dim[1], dimZ = dim[2];\r\n                    iu = dimZ, iv = dimY, iuv = iu * iv;\r\n                    gridx = fillGridDim(dim[0], min[0], resolution);\r\n                    gridy = fillGridDim(dim[1], min[1], resolution);\r\n                    gridz = fillGridDim(dim[2], min[2], resolution);\r\n                    densData = space.create();\r\n                    alpha = smoothness;\r\n                    updateChunk = Math.ceil(100000 / ((Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor)));\r\n                    // console.time('gaussian density cpu')\r\n                    return [4 /*yield*/, accumulate()];\r\n                case 1:\r\n                    // console.time('gaussian density cpu')\r\n                    _a.sent();\r\n                    transform = Mat4.identity();\r\n                    Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));\r\n                    Mat4.setTranslation(transform, expandedBox.min);\r\n                    return [2 /*return*/, { field: field, idField: idField, transform: transform, radiusFactor: 1, resolution: resolution }];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=cpu.js.map"]},"metadata":{},"sourceType":"module"}