"use strict";
/**
 * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CellpackMembranePreset = exports.CellpackMembranePresetParams = exports.CellpackPackingPreset = exports.CellpackPackingPresetParams = void 0;
var tslib_1 = require("tslib");
var mol_state_1 = require("../../mol-state");
var representation_preset_1 = require("../../mol-plugin-state/builder/structure/representation-preset");
var param_definition_1 = require("../../mol-util/param-definition");
var names_1 = require("../../mol-util/color/names");
var generate_1 = require("./color/generate");
var property_1 = require("./property");
var provided_1 = require("./color/provided");
exports.CellpackPackingPresetParams = {
    traceOnly: param_definition_1.ParamDefinition.Boolean(true),
    representation: param_definition_1.ParamDefinition.Select('gaussian-surface', param_definition_1.ParamDefinition.arrayToOptions(['gaussian-surface', 'spacefill', 'point', 'orientation'])),
};
exports.CellpackPackingPreset = (0, representation_preset_1.StructureRepresentationPresetProvider)({
    id: 'preset-structure-representation-cellpack-packing',
    display: { name: 'CellPack Packing' },
    params: function () { return exports.CellpackPackingPresetParams; },
    apply: function (ref, params, plugin) {
        var _a, _b;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structureCell, reprProps, components, info, color, _c, update, builder, typeParams, representations;
            var _d;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        structureCell = mol_state_1.StateObjectRef.resolveAndCheck(plugin.state.data, ref);
                        if (!structureCell)
                            return [2 /*return*/, {}];
                        reprProps = {
                            ignoreHydrogens: true,
                            traceOnly: params.traceOnly
                        };
                        _d = {};
                        return [4 /*yield*/, (0, representation_preset_1.presetStaticComponent)(plugin, structureCell, 'polymer')];
                    case 1:
                        components = (_d.polymer = _e.sent(),
                            _d);
                        if (params.representation === 'gaussian-surface') {
                            Object.assign(reprProps, {
                                quality: 'custom', resolution: 10, radiusOffset: 2, doubleSided: false
                            });
                        }
                        else if (params.representation === 'spacefill' && params.traceOnly) {
                            Object.assign(reprProps, { sizeFactor: 2 });
                        }
                        info = ((_a = structureCell.obj) === null || _a === void 0 ? void 0 : _a.data) && property_1.CellPackInfoProvider.get((_b = structureCell.obj) === null || _b === void 0 ? void 0 : _b.data).value;
                        color = (info === null || info === void 0 ? void 0 : info.colors) ? provided_1.CellPackProvidedColorThemeProvider.name : generate_1.CellPackGenerateColorThemeProvider.name;
                        _c = representation_preset_1.StructureRepresentationPresetProvider.reprBuilder(plugin, {}), update = _c.update, builder = _c.builder, typeParams = _c.typeParams;
                        representations = {
                            polymer: builder.buildRepresentation(update, components.polymer, { type: params.representation, typeParams: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, typeParams), reprProps), color: color }, { tag: 'polymer' })
                        };
                        return [4 /*yield*/, update.commit({ revertOnError: true })];
                    case 2:
                        _e.sent();
                        return [2 /*return*/, { components: components, representations: representations }];
                }
            });
        });
    }
});
//
exports.CellpackMembranePresetParams = {
    representation: param_definition_1.ParamDefinition.Select('gaussian-surface', param_definition_1.ParamDefinition.arrayToOptions(['gaussian-surface', 'spacefill', 'point', 'orientation'])),
};
exports.CellpackMembranePreset = (0, representation_preset_1.StructureRepresentationPresetProvider)({
    id: 'preset-structure-representation-cellpack-membrane',
    display: { name: 'CellPack Membrane' },
    params: function () { return exports.CellpackMembranePresetParams; },
    apply: function (ref, params, plugin) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structureCell, reprProps, components, _a, update, builder, typeParams, representations;
            var _b;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        structureCell = mol_state_1.StateObjectRef.resolveAndCheck(plugin.state.data, ref);
                        if (!structureCell)
                            return [2 /*return*/, {}];
                        reprProps = {
                            ignoreHydrogens: true,
                        };
                        _b = {};
                        return [4 /*yield*/, (0, representation_preset_1.presetStaticComponent)(plugin, structureCell, 'all', { label: 'Membrane' })];
                    case 1:
                        components = (_b.membrane = _c.sent(),
                            _b);
                        if (params.representation === 'gaussian-surface') {
                            Object.assign(reprProps, {
                                quality: 'custom', resolution: 10, radiusOffset: 2, doubleSided: false
                            });
                        }
                        _a = representation_preset_1.StructureRepresentationPresetProvider.reprBuilder(plugin, {}), update = _a.update, builder = _a.builder, typeParams = _a.typeParams;
                        representations = {
                            membrane: builder.buildRepresentation(update, components.membrane, { type: 'gaussian-surface', typeParams: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, typeParams), reprProps), color: 'uniform', colorParams: { value: names_1.ColorNames.lightgrey } }, { tag: 'all' })
                        };
                        return [4 /*yield*/, update.commit({ revertOnError: true })];
                    case 2:
                        _c.sent();
                        return [2 /*return*/, { components: components, representations: representations }];
                }
            });
        });
    }
});
//# sourceMappingURL=preset.js.map