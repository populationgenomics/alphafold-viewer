{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\nimport { Unit } from '../../../mol-model/structure';\nimport { Features } from './features';\nexport function refineInteractions(structure, interactions) {\n  var contacts = interactions.contacts,\n      unitsContacts = interactions.unitsContacts,\n      unitsFeatures = interactions.unitsFeatures;\n  var contactRefiners = [hydrophobicRefiner(structure, interactions), weakHydrogenBondsRefiner(structure, interactions), saltBridgeRefiner(structure, interactions), piStackingRefiner(structure, interactions), metalCoordinationRefiner(structure, interactions)];\n\n  for (var i = 0, il = contacts.edgeCount; i < il; ++i) {\n    var e = contacts.edges[i];\n    var uA = structure.unitMap.get(e.unitA);\n    var uB = structure.unitMap.get(e.unitB);\n    var infoA = Features.Info(structure, uA, unitsFeatures.get(e.unitA));\n    infoA.feature = e.indexA;\n    var infoB = Features.Info(structure, uB, unitsFeatures.get(e.unitB));\n    infoB.feature = e.indexB;\n\n    for (var _i = 0, contactRefiners_1 = contactRefiners; _i < contactRefiners_1.length; _i++) {\n      var refiner = contactRefiners_1[_i];\n      if (refiner.isApplicable(e.props.type)) refiner.handleInterContact(i, infoA, infoB);\n    }\n  } //\n\n\n  var ucKeys = unitsContacts.keys();\n\n  while (true) {\n    var _a = ucKeys.next(),\n        done = _a.done,\n        value = _a.value;\n\n    if (done) break;\n    var contacts_1 = unitsContacts.get(value);\n    var features = unitsFeatures.get(value);\n    var unit = structure.unitMap.get(value);\n    if (!Unit.isAtomic(unit)) continue;\n    var infoA = Features.Info(structure, unit, features);\n    var infoB = Features.Info(structure, unit, features);\n\n    for (var _b = 0, contactRefiners_2 = contactRefiners; _b < contactRefiners_2.length; _b++) {\n      var refiner = contactRefiners_2[_b];\n      refiner.startUnit(unit, contacts_1, features);\n    }\n\n    for (var i = 0, il = contacts_1.edgeCount * 2; i < il; ++i) {\n      infoA.feature = contacts_1.a[i];\n      infoB.feature = contacts_1.b[i]; // console.log(i, contacts.a[i], contacts.b[i])\n\n      for (var _c = 0, contactRefiners_3 = contactRefiners; _c < contactRefiners_3.length; _c++) {\n        var refiner = contactRefiners_3[_c];\n        if (refiner.isApplicable(contacts_1.edgeProps.type[i])) refiner.handleIntraContact(i, infoA, infoB);\n      }\n    }\n  }\n}\n/**\r\n * For atoms interacting with several atoms in the same residue\r\n * only the one with the closest distance is kept.\r\n */\n\nfunction hydrophobicRefiner(structure, interactions) {\n  var contacts = interactions.contacts;\n  /* keep only closest contact between residues */\n\n  var handleResidueContact = function (dist, edge, key, map, set) {\n    var _a = map.get(key) || [Infinity, -1],\n        minDist = _a[0],\n        minIndex = _a[1];\n\n    if (dist < minDist) {\n      if (minIndex !== -1) set(minIndex);\n      map.set(key, [dist, edge]);\n    } else {\n      set(edge);\n    }\n  };\n\n  function handleEdge(edge, infoA, infoB, map, set) {\n    var elementA = infoA.members[infoA.offsets[infoA.feature]];\n    var elementB = infoB.members[infoB.offsets[infoB.feature]];\n    var residueA = infoA.unit.getResidueIndex(elementA);\n    var residueB = infoB.unit.getResidueIndex(elementB);\n    var keyA = elementA + \"|\" + infoA.unit.id + \"|\" + residueB + \"|\" + infoB.unit.id + \"|A\";\n    var keyB = elementB + \"|\" + infoB.unit.id + \"|\" + residueA + \"|\" + infoA.unit.id + \"|B\";\n    var dist = Features.distance(infoA, infoB);\n    handleResidueContact(dist, edge, keyA, map, set);\n    handleResidueContact(dist, edge, keyB, map, set);\n  }\n\n  var residueInterMap = new Map();\n\n  var setInterFiltered = function (i) {\n    return contacts.edges[i].props.flag = 1\n    /* Filtered */\n    ;\n  };\n\n  var residueIntraMap;\n  var setIntraFiltered;\n  return {\n    isApplicable: function (type) {\n      return type === 6\n      /* Hydrophobic */\n      ;\n    },\n    handleInterContact: function (index, infoA, infoB) {\n      handleEdge(index, infoA, infoB, residueInterMap, setInterFiltered);\n    },\n    startUnit: function (unit, contacts, features) {\n      residueIntraMap = new Map();\n\n      setIntraFiltered = function (i) {\n        return contacts.edgeProps.flag[i] = 1\n        /* Filtered */\n        ;\n      };\n    },\n    handleIntraContact: function (index, infoA, infoB) {\n      handleEdge(index, infoA, infoB, residueIntraMap, setIntraFiltered);\n    }\n  };\n}\n/**\r\n * Remove weak hydrogen bonds when the acceptor is involved in\r\n * a normal/strong hydrogen bond\r\n */\n\n\nfunction weakHydrogenBondsRefiner(structure, interactions) {\n  var contacts = interactions.contacts;\n\n  var hasHydrogenBond = function (infoA, infoB) {\n    var acc = infoA.types[infoA.feature] === 9\n    /* WeakHydrogenDonor */\n    ? infoB : infoA; // check intra\n\n    var eI = acc.members[acc.offsets[acc.feature]];\n\n    var _a = interactions.unitsContacts.get(acc.unit.id),\n        type = _a.edgeProps.type,\n        _b = _a.elementsIndex,\n        offsets = _b.offsets,\n        indices = _b.indices;\n\n    for (var i = offsets[eI], il = offsets[eI + 1]; i < il; ++i) {\n      if (type[indices[i]] === 4\n      /* HydrogenBond */\n      ) return true;\n    } // check inter\n\n\n    var interIndices = contacts.getEdgeIndices(acc.feature, acc.unit.id);\n\n    for (var i = 0, il = interIndices.length; i < il; ++i) {\n      if (contacts.edges[interIndices[i]].props.type === 4\n      /* HydrogenBond */\n      ) return true;\n    }\n\n    return false;\n  };\n\n  return {\n    isApplicable: function (type) {\n      return type === 8\n      /* WeakHydrogenBond */\n      ;\n    },\n    handleInterContact: function (index, infoA, infoB) {\n      if (hasHydrogenBond(infoA, infoB)) {\n        contacts.edges[index].props.flag = 1\n        /* Filtered */\n        ;\n      }\n    },\n    startUnit: function () {},\n    handleIntraContact: function (index, infoA, infoB) {\n      if (hasHydrogenBond(infoA, infoB)) {\n        var flag = interactions.unitsContacts.get(infoA.unit.id).edgeProps.flag;\n        flag[index] = 1\n        /* Filtered */\n        ;\n      }\n    }\n  };\n}\n/**\r\n * Filter inter-unit contact `index` if there is a contact of `types` between its members\r\n */\n\n\nfunction filterInter(types, index, infoA, infoB, contacts) {\n  var offsetsA = infoA.offsets,\n      featureA = infoA.feature;\n  var offsetsB = infoB.offsets,\n      featureB = infoB.feature;\n\n  for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\n    var aI = infoA.members[i];\n    var indices = contacts.getContactIndicesForElement(aI, infoA.unit);\n\n    for (var k = 0, kl = indices.length; k < kl; ++k) {\n      var cI = indices[k];\n\n      if (types.includes(contacts.edges[cI].props.type)) {\n        for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\n          var bI = infoB.members[j];\n\n          if (contacts.getContactIndicesForElement(bI, infoB.unit).includes(cI)) {\n            contacts.edges[index].props.flag = 1\n            /* Filtered */\n            ;\n            return;\n          }\n        }\n      }\n    }\n  }\n}\n/**\r\n * Filter intra-unit contact `index` if there is a contact of `types` between its members\r\n */\n\n\nfunction filterIntra(types, index, infoA, infoB, contacts) {\n  var _a = contacts.edgeProps,\n      type = _a.type,\n      flag = _a.flag,\n      _b = contacts.elementsIndex,\n      offsets = _b.offsets,\n      indices = _b.indices;\n  var offsetsA = infoA.offsets,\n      featureA = infoA.feature;\n  var offsetsB = infoB.offsets,\n      featureB = infoB.feature;\n\n  for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\n    var aI = infoA.members[i];\n\n    for (var k = offsets[aI], kl = offsets[aI + 1]; k < kl; ++k) {\n      var cI = indices[k];\n\n      if (types.includes(type[cI])) {\n        for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\n          var bI = infoB.members[j];\n\n          for (var l = offsets[bI], ll = offsets[bI + 1]; l < ll; ++l) {\n            if (cI === indices[l]) {\n              flag[index] = 1\n              /* Filtered */\n              ;\n              return;\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\r\n * Remove hydrogen bonds (normal and weak) between groups that also form\r\n * an ionic interaction between each other\r\n */\n\n\nfunction saltBridgeRefiner(structure, interactions) {\n  var contacts = interactions.contacts;\n  return {\n    isApplicable: function (type) {\n      return type === 1\n      /* Ionic */\n      ;\n    },\n    handleInterContact: function (index, infoA, infoB) {\n      filterInter([4\n      /* HydrogenBond */\n      , 8\n      /* WeakHydrogenBond */\n      ], index, infoA, infoB, contacts);\n    },\n    startUnit: function () {},\n    handleIntraContact: function (index, infoA, infoB) {\n      filterIntra([4\n      /* HydrogenBond */\n      , 8\n      /* WeakHydrogenBond */\n      ], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\n    }\n  };\n}\n/**\r\n * Remove hydrophobic and cation-pi interactions between groups that also form\r\n * a pi-stacking interaction between each other\r\n */\n\n\nfunction piStackingRefiner(structure, interactions) {\n  var contacts = interactions.contacts;\n  return {\n    isApplicable: function (type) {\n      return type === 6\n      /* Hydrophobic */\n      || type === 2\n      /* CationPi */\n      ;\n    },\n    handleInterContact: function (index, infoA, infoB) {\n      filterInter([3\n      /* PiStacking */\n      ], index, infoA, infoB, contacts);\n    },\n    startUnit: function () {},\n    handleIntraContact: function (index, infoA, infoB) {\n      filterIntra([3\n      /* PiStacking */\n      ], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\n    }\n  };\n}\n/**\r\n * Remove ionic interactions between groups that also form\r\n * a metal coordination between each other\r\n */\n\n\nfunction metalCoordinationRefiner(structure, interactions) {\n  var contacts = interactions.contacts;\n  return {\n    isApplicable: function (type) {\n      return type === 1\n      /* Ionic */\n      ;\n    },\n    handleInterContact: function (index, infoA, infoB) {\n      filterInter([7\n      /* MetalCoordination */\n      ], index, infoA, infoB, contacts);\n    },\n    startUnit: function () {},\n    handleIntraContact: function (index, infoA, infoB) {\n      filterIntra([7\n      /* MetalCoordination */\n      ], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\n    }\n  };\n}","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/interactions/refine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\r\nimport { Unit } from '../../../mol-model/structure';\r\nimport { Features } from './features';\r\nexport function refineInteractions(structure, interactions) {\r\n    var contacts = interactions.contacts, unitsContacts = interactions.unitsContacts, unitsFeatures = interactions.unitsFeatures;\r\n    var contactRefiners = [\r\n        hydrophobicRefiner(structure, interactions),\r\n        weakHydrogenBondsRefiner(structure, interactions),\r\n        saltBridgeRefiner(structure, interactions),\r\n        piStackingRefiner(structure, interactions),\r\n        metalCoordinationRefiner(structure, interactions),\r\n    ];\r\n    for (var i = 0, il = contacts.edgeCount; i < il; ++i) {\r\n        var e = contacts.edges[i];\r\n        var uA = structure.unitMap.get(e.unitA);\r\n        var uB = structure.unitMap.get(e.unitB);\r\n        var infoA = Features.Info(structure, uA, unitsFeatures.get(e.unitA));\r\n        infoA.feature = e.indexA;\r\n        var infoB = Features.Info(structure, uB, unitsFeatures.get(e.unitB));\r\n        infoB.feature = e.indexB;\r\n        for (var _i = 0, contactRefiners_1 = contactRefiners; _i < contactRefiners_1.length; _i++) {\r\n            var refiner = contactRefiners_1[_i];\r\n            if (refiner.isApplicable(e.props.type))\r\n                refiner.handleInterContact(i, infoA, infoB);\r\n        }\r\n    }\r\n    //\r\n    var ucKeys = unitsContacts.keys();\r\n    while (true) {\r\n        var _a = ucKeys.next(), done = _a.done, value = _a.value;\r\n        if (done)\r\n            break;\r\n        var contacts_1 = unitsContacts.get(value);\r\n        var features = unitsFeatures.get(value);\r\n        var unit = structure.unitMap.get(value);\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        var infoA = Features.Info(structure, unit, features);\r\n        var infoB = Features.Info(structure, unit, features);\r\n        for (var _b = 0, contactRefiners_2 = contactRefiners; _b < contactRefiners_2.length; _b++) {\r\n            var refiner = contactRefiners_2[_b];\r\n            refiner.startUnit(unit, contacts_1, features);\r\n        }\r\n        for (var i = 0, il = contacts_1.edgeCount * 2; i < il; ++i) {\r\n            infoA.feature = contacts_1.a[i];\r\n            infoB.feature = contacts_1.b[i];\r\n            // console.log(i, contacts.a[i], contacts.b[i])\r\n            for (var _c = 0, contactRefiners_3 = contactRefiners; _c < contactRefiners_3.length; _c++) {\r\n                var refiner = contactRefiners_3[_c];\r\n                if (refiner.isApplicable(contacts_1.edgeProps.type[i]))\r\n                    refiner.handleIntraContact(i, infoA, infoB);\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * For atoms interacting with several atoms in the same residue\r\n * only the one with the closest distance is kept.\r\n */\r\nfunction hydrophobicRefiner(structure, interactions) {\r\n    var contacts = interactions.contacts;\r\n    /* keep only closest contact between residues */\r\n    var handleResidueContact = function (dist, edge, key, map, set) {\r\n        var _a = map.get(key) || [Infinity, -1], minDist = _a[0], minIndex = _a[1];\r\n        if (dist < minDist) {\r\n            if (minIndex !== -1)\r\n                set(minIndex);\r\n            map.set(key, [dist, edge]);\r\n        }\r\n        else {\r\n            set(edge);\r\n        }\r\n    };\r\n    function handleEdge(edge, infoA, infoB, map, set) {\r\n        var elementA = infoA.members[infoA.offsets[infoA.feature]];\r\n        var elementB = infoB.members[infoB.offsets[infoB.feature]];\r\n        var residueA = infoA.unit.getResidueIndex(elementA);\r\n        var residueB = infoB.unit.getResidueIndex(elementB);\r\n        var keyA = elementA + \"|\" + infoA.unit.id + \"|\" + residueB + \"|\" + infoB.unit.id + \"|A\";\r\n        var keyB = elementB + \"|\" + infoB.unit.id + \"|\" + residueA + \"|\" + infoA.unit.id + \"|B\";\r\n        var dist = Features.distance(infoA, infoB);\r\n        handleResidueContact(dist, edge, keyA, map, set);\r\n        handleResidueContact(dist, edge, keyB, map, set);\r\n    }\r\n    var residueInterMap = new Map();\r\n    var setInterFiltered = function (i) { return contacts.edges[i].props.flag = 1 /* Filtered */; };\r\n    var residueIntraMap;\r\n    var setIntraFiltered;\r\n    return {\r\n        isApplicable: function (type) { return type === 6 /* Hydrophobic */; },\r\n        handleInterContact: function (index, infoA, infoB) {\r\n            handleEdge(index, infoA, infoB, residueInterMap, setInterFiltered);\r\n        },\r\n        startUnit: function (unit, contacts, features) {\r\n            residueIntraMap = new Map();\r\n            setIntraFiltered = function (i) { return contacts.edgeProps.flag[i] = 1 /* Filtered */; };\r\n        },\r\n        handleIntraContact: function (index, infoA, infoB) {\r\n            handleEdge(index, infoA, infoB, residueIntraMap, setIntraFiltered);\r\n        }\r\n    };\r\n}\r\n/**\r\n * Remove weak hydrogen bonds when the acceptor is involved in\r\n * a normal/strong hydrogen bond\r\n */\r\nfunction weakHydrogenBondsRefiner(structure, interactions) {\r\n    var contacts = interactions.contacts;\r\n    var hasHydrogenBond = function (infoA, infoB) {\r\n        var acc = infoA.types[infoA.feature] === 9 /* WeakHydrogenDonor */ ? infoB : infoA;\r\n        // check intra\r\n        var eI = acc.members[acc.offsets[acc.feature]];\r\n        var _a = interactions.unitsContacts.get(acc.unit.id), type = _a.edgeProps.type, _b = _a.elementsIndex, offsets = _b.offsets, indices = _b.indices;\r\n        for (var i = offsets[eI], il = offsets[eI + 1]; i < il; ++i) {\r\n            if (type[indices[i]] === 4 /* HydrogenBond */)\r\n                return true;\r\n        }\r\n        // check inter\r\n        var interIndices = contacts.getEdgeIndices(acc.feature, acc.unit.id);\r\n        for (var i = 0, il = interIndices.length; i < il; ++i) {\r\n            if (contacts.edges[interIndices[i]].props.type === 4 /* HydrogenBond */)\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n    return {\r\n        isApplicable: function (type) { return type === 8 /* WeakHydrogenBond */; },\r\n        handleInterContact: function (index, infoA, infoB) {\r\n            if (hasHydrogenBond(infoA, infoB)) {\r\n                contacts.edges[index].props.flag = 1 /* Filtered */;\r\n            }\r\n        },\r\n        startUnit: function () { },\r\n        handleIntraContact: function (index, infoA, infoB) {\r\n            if (hasHydrogenBond(infoA, infoB)) {\r\n                var flag = interactions.unitsContacts.get(infoA.unit.id).edgeProps.flag;\r\n                flag[index] = 1 /* Filtered */;\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Filter inter-unit contact `index` if there is a contact of `types` between its members\r\n */\r\nfunction filterInter(types, index, infoA, infoB, contacts) {\r\n    var offsetsA = infoA.offsets, featureA = infoA.feature;\r\n    var offsetsB = infoB.offsets, featureB = infoB.feature;\r\n    for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\r\n        var aI = infoA.members[i];\r\n        var indices = contacts.getContactIndicesForElement(aI, infoA.unit);\r\n        for (var k = 0, kl = indices.length; k < kl; ++k) {\r\n            var cI = indices[k];\r\n            if (types.includes(contacts.edges[cI].props.type)) {\r\n                for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\r\n                    var bI = infoB.members[j];\r\n                    if (contacts.getContactIndicesForElement(bI, infoB.unit).includes(cI)) {\r\n                        contacts.edges[index].props.flag = 1 /* Filtered */;\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Filter intra-unit contact `index` if there is a contact of `types` between its members\r\n */\r\nfunction filterIntra(types, index, infoA, infoB, contacts) {\r\n    var _a = contacts.edgeProps, type = _a.type, flag = _a.flag, _b = contacts.elementsIndex, offsets = _b.offsets, indices = _b.indices;\r\n    var offsetsA = infoA.offsets, featureA = infoA.feature;\r\n    var offsetsB = infoB.offsets, featureB = infoB.feature;\r\n    for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\r\n        var aI = infoA.members[i];\r\n        for (var k = offsets[aI], kl = offsets[aI + 1]; k < kl; ++k) {\r\n            var cI = indices[k];\r\n            if (types.includes(type[cI])) {\r\n                for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\r\n                    var bI = infoB.members[j];\r\n                    for (var l = offsets[bI], ll = offsets[bI + 1]; l < ll; ++l) {\r\n                        if (cI === indices[l]) {\r\n                            flag[index] = 1 /* Filtered */;\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n/**\r\n * Remove hydrogen bonds (normal and weak) between groups that also form\r\n * an ionic interaction between each other\r\n */\r\nfunction saltBridgeRefiner(structure, interactions) {\r\n    var contacts = interactions.contacts;\r\n    return {\r\n        isApplicable: function (type) { return type === 1 /* Ionic */; },\r\n        handleInterContact: function (index, infoA, infoB) {\r\n            filterInter([4 /* HydrogenBond */, 8 /* WeakHydrogenBond */], index, infoA, infoB, contacts);\r\n        },\r\n        startUnit: function () { },\r\n        handleIntraContact: function (index, infoA, infoB) {\r\n            filterIntra([4 /* HydrogenBond */, 8 /* WeakHydrogenBond */], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\r\n        }\r\n    };\r\n}\r\n/**\r\n * Remove hydrophobic and cation-pi interactions between groups that also form\r\n * a pi-stacking interaction between each other\r\n */\r\nfunction piStackingRefiner(structure, interactions) {\r\n    var contacts = interactions.contacts;\r\n    return {\r\n        isApplicable: function (type) { return type === 6 /* Hydrophobic */ || type === 2 /* CationPi */; },\r\n        handleInterContact: function (index, infoA, infoB) {\r\n            filterInter([3 /* PiStacking */], index, infoA, infoB, contacts);\r\n        },\r\n        startUnit: function () { },\r\n        handleIntraContact: function (index, infoA, infoB) {\r\n            filterIntra([3 /* PiStacking */], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\r\n        }\r\n    };\r\n}\r\n/**\r\n * Remove ionic interactions between groups that also form\r\n * a metal coordination between each other\r\n */\r\nfunction metalCoordinationRefiner(structure, interactions) {\r\n    var contacts = interactions.contacts;\r\n    return {\r\n        isApplicable: function (type) { return type === 1 /* Ionic */; },\r\n        handleInterContact: function (index, infoA, infoB) {\r\n            filterInter([7 /* MetalCoordination */], index, infoA, infoB, contacts);\r\n        },\r\n        startUnit: function () { },\r\n        handleIntraContact: function (index, infoA, infoB) {\r\n            filterIntra([7 /* MetalCoordination */], index, infoA, infoB, interactions.unitsContacts.get(infoA.unit.id));\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=refine.js.map"]},"metadata":{},"sourceType":"module"}