/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __awaiter, __extends, __generator } from "tslib";
import { PluginStateObject as PSO, PluginStateTransform } from '../../mol-plugin-state/objects';
import { ParamDefinition as PD } from '../../mol-util/param-definition';
import { Task } from '../../mol-task';
import { createStructureFromCellPack } from './model';
import { CellPackInfoProvider } from './property';
import { Structure, StructureSymmetry, Model } from '../../mol-model/structure';
import { ModelSymmetry } from '../../mol-model-formats/structure/property/symmetry';
export var DefaultCellPackBaseUrl = 'https://mesoscope.scripps.edu/data/cellPACK_data/cellPACK_database_1.1.0/';
var CellPack = /** @class */ (function (_super) {
    __extends(CellPack, _super);
    function CellPack() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CellPack;
}(PSO.Create({ name: 'CellPack', typeClass: 'Object' })));
export { CellPack };
export { ParseCellPack };
var ParseCellPack = PluginStateTransform.BuiltIn({
    name: 'parse-cellpack',
    display: { name: 'Parse CellPack', description: 'Parse CellPack from JSON data' },
    from: PSO.Format.Json,
    to: CellPack
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return Task.create('Parse CellPack', function (ctx) { return __awaiter(_this, void 0, void 0, function () {
            var cell, packings, compartments, cytoplasme, name_1, _a, surface, interior;
            return __generator(this, function (_b) {
                cell = a.data;
                packings = [];
                compartments = cell.compartments, cytoplasme = cell.cytoplasme;
                if (compartments) {
                    for (name_1 in compartments) {
                        _a = compartments[name_1], surface = _a.surface, interior = _a.interior;
                        if (surface)
                            packings.push({ name: name_1, location: 'surface', ingredients: surface.ingredients });
                        if (interior)
                            packings.push({ name: name_1, location: 'interior', ingredients: interior.ingredients });
                    }
                }
                if (cytoplasme)
                    packings.push({ name: 'Cytoplasme', location: 'cytoplasme', ingredients: cytoplasme.ingredients });
                return [2 /*return*/, new CellPack({ cell: cell, packings: packings })];
            });
        }); });
    }
});
export { StructureFromCellpack };
var StructureFromCellpack = PluginStateTransform.BuiltIn({
    name: 'structure-from-cellpack',
    display: { name: 'Structure from CellPack', description: 'Create Structure from CellPack Packing' },
    from: CellPack,
    to: PSO.Molecule.Structure,
    params: function (a) {
        var options = a ? a.data.packings.map(function (d, i) { return [i, d.name]; }) : [];
        return {
            packing: PD.Select(0, options),
            baseUrl: PD.Text(DefaultCellPackBaseUrl),
            ingredientFiles: PD.FileList({ accept: '.cif,.bcif,.pdb' })
        };
    }
})({
    apply: function (_a, plugin) {
        var _this = this;
        var a = _a.a, params = _a.params, cache = _a.cache;
        return Task.create('Structure from CellPack', function (ctx) { return __awaiter(_this, void 0, void 0, function () {
            var packing, ingredientFiles, _i, _a, file, _b, structure, assets, colors;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        packing = a.data.packings[params.packing];
                        ingredientFiles = {};
                        if (params.ingredientFiles !== null) {
                            for (_i = 0, _a = params.ingredientFiles; _i < _a.length; _i++) {
                                file = _a[_i];
                                ingredientFiles[file.name] = file;
                            }
                        }
                        return [4 /*yield*/, createStructureFromCellPack(plugin, packing, params.baseUrl, ingredientFiles).runInContext(ctx)];
                    case 1:
                        _b = _c.sent(), structure = _b.structure, assets = _b.assets, colors = _b.colors;
                        return [4 /*yield*/, CellPackInfoProvider.attach({ runtime: ctx, assetManager: plugin.managers.asset }, structure, {
                                info: { packingsCount: a.data.packings.length, packingIndex: params.packing, colors: colors }
                            })];
                    case 2:
                        _c.sent();
                        cache.assets = assets;
                        return [2 /*return*/, new PSO.Molecule.Structure(structure, { label: packing.name })];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b, cache = _a.cache;
        var assets = cache.assets;
        if (assets) {
            for (var _i = 0, assets_1 = assets; _i < assets_1.length; _i++) {
                var a = assets_1[_i];
                a.dispose();
            }
        }
        if (b) {
            b.data.customPropertyDescriptors.dispose();
            for (var _b = 0, _c = b.data.models; _b < _c.length; _b++) {
                var m = _c[_b];
                m.customProperties.dispose();
            }
        }
    }
});
export { StructureFromAssemblies };
var StructureFromAssemblies = PluginStateTransform.BuiltIn({
    name: 'Structure from all assemblies',
    display: { name: 'Structure from all assemblies' },
    from: PSO.Molecule.Model,
    to: PSO.Molecule.Structure,
    params: {}
})({
    canAutoUpdate: function (_a) {
        var newParams = _a.newParams;
        return true;
    },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return Task.create('Build Structure', function (ctx) { return __awaiter(_this, void 0, void 0, function () {
            var model, initial_structure, structures, structure, symmetry, _i, _a, a_1, s, builder, offsetInvariantId, _b, structures_1, s, maxInvariantId, _c, _d, u, invariantId, i, il;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        model = a.data;
                        initial_structure = Structure.ofModel(model);
                        structures = [];
                        structure = initial_structure;
                        symmetry = ModelSymmetry.Provider.get(model);
                        if (!(symmetry && symmetry.assemblies.length !== 0)) return [3 /*break*/, 5];
                        _i = 0, _a = symmetry.assemblies;
                        _e.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        a_1 = _a[_i];
                        return [4 /*yield*/, StructureSymmetry.buildAssembly(initial_structure, a_1.id).runInContext(ctx)];
                    case 2:
                        s = _e.sent();
                        structures.push(s);
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        builder = Structure.Builder();
                        offsetInvariantId = 0;
                        for (_b = 0, structures_1 = structures; _b < structures_1.length; _b++) {
                            s = structures_1[_b];
                            maxInvariantId = 0;
                            for (_c = 0, _d = s.units; _c < _d.length; _c++) {
                                u = _d[_c];
                                invariantId = u.invariantId + offsetInvariantId;
                                if (u.invariantId > maxInvariantId)
                                    maxInvariantId = u.invariantId;
                                builder.addUnit(u.kind, u.model, u.conformation.operator, u.elements, 0 /* None */, invariantId);
                            }
                            offsetInvariantId += maxInvariantId + 1;
                        }
                        structure = builder.getStructure();
                        for (i = 0, il = structure.models.length; i < il; ++i) {
                            Model.TrajectoryInfo.set(structure.models[i], { size: il, index: i });
                        }
                        _e.label = 5;
                    case 5: return [2 /*return*/, new PSO.Molecule.Structure(structure, { label: a.label, description: "" + a.description })];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
//# sourceMappingURL=state.js.map