{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../mol-util';\nimport { Vec2 } from '../../mol-math/linear-algebra';\nimport { createTextureImage } from '../../mol-gl/renderable/util';\nimport { NullLocation } from '../../mol-model/location';\nimport { Geometry } from './geometry';\nimport { decodeFloatRGB, encodeFloatRGBtoArray } from '../../mol-util/float-packing';\nexport function createSizes(locationIt, sizeTheme, sizeData) {\n  switch (Geometry.getGranularity(locationIt, sizeTheme.granularity)) {\n    case 'uniform':\n      return createUniformSize(locationIt, sizeTheme.size, sizeData);\n\n    case 'group':\n      return createGroupSize(locationIt, sizeTheme.size, sizeData);\n\n    case 'groupInstance':\n      return createGroupInstanceSize(locationIt, sizeTheme.size, sizeData);\n\n    case 'instance':\n      return createInstanceSize(locationIt, sizeTheme.size, sizeData);\n  }\n}\nexport var sizeDataFactor = 100; // NOTE same factor is set in shaders\n\nexport function getMaxSize(sizeData) {\n  var type = sizeData.dSizeType.ref.value;\n\n  switch (type) {\n    case 'uniform':\n      return sizeData.uSize.ref.value;\n\n    case 'instance':\n    case 'group':\n    case 'groupInstance':\n      var maxSize = 0;\n      var array = sizeData.tSize.ref.value.array;\n\n      for (var i = 0, il = array.length; i < il; i += 3) {\n        var value = decodeFloatRGB(array[i], array[i + 1], array[i + 2]);\n        if (maxSize < value) maxSize = value;\n      }\n\n      return maxSize / sizeDataFactor;\n  }\n}\nvar emptySizeTexture = {\n  array: new Uint8Array(3),\n  width: 1,\n  height: 1\n};\n\nfunction createEmptySizeTexture() {\n  return {\n    tSize: ValueCell.create(emptySizeTexture),\n    uSizeTexDim: ValueCell.create(Vec2.create(1, 1))\n  };\n}\n\nexport function createValueSize(value, sizeData) {\n  if (sizeData) {\n    ValueCell.update(sizeData.uSize, value);\n    ValueCell.updateIfChanged(sizeData.dSizeType, 'uniform');\n    return sizeData;\n  } else {\n    return __assign(__assign({\n      uSize: ValueCell.create(value)\n    }, createEmptySizeTexture()), {\n      dSizeType: ValueCell.create('uniform')\n    });\n  }\n}\n/** Creates size uniform */\n\nexport function createUniformSize(locationIt, sizeFn, sizeData) {\n  return createValueSize(sizeFn(NullLocation), sizeData);\n}\nexport function createTextureSize(sizes, type, sizeData) {\n  if (sizeData) {\n    ValueCell.update(sizeData.tSize, sizes);\n    ValueCell.update(sizeData.uSizeTexDim, Vec2.create(sizes.width, sizes.height));\n    ValueCell.updateIfChanged(sizeData.dSizeType, type);\n    return sizeData;\n  } else {\n    return {\n      uSize: ValueCell.create(0),\n      tSize: ValueCell.create(sizes),\n      uSizeTexDim: ValueCell.create(Vec2.create(sizes.width, sizes.height)),\n      dSizeType: ValueCell.create(type)\n    };\n  }\n}\n/** Creates size texture with size for each instance/unit */\n\nexport function createInstanceSize(locationIt, sizeFn, sizeData) {\n  var instanceCount = locationIt.instanceCount;\n  var sizes = createTextureImage(Math.max(1, instanceCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\n  locationIt.reset();\n\n  while (locationIt.hasNext && !locationIt.isNextNewInstance) {\n    var v = locationIt.move();\n    encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.instanceIndex * 3);\n    locationIt.skipInstance();\n  }\n\n  return createTextureSize(sizes, 'instance', sizeData);\n}\n/** Creates size texture with size for each group (i.e. shared across instances/units) */\n\nexport function createGroupSize(locationIt, sizeFn, sizeData) {\n  var groupCount = locationIt.groupCount;\n  var sizes = createTextureImage(Math.max(1, groupCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\n  locationIt.reset();\n\n  while (locationIt.hasNext && !locationIt.isNextNewInstance) {\n    var v = locationIt.move();\n    encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.groupIndex * 3);\n  }\n\n  return createTextureSize(sizes, 'group', sizeData);\n}\n/** Creates size texture with size for each group in each instance (i.e. for each unit) */\n\nexport function createGroupInstanceSize(locationIt, sizeFn, sizeData) {\n  var groupCount = locationIt.groupCount,\n      instanceCount = locationIt.instanceCount;\n  var count = instanceCount * groupCount;\n  var sizes = createTextureImage(Math.max(1, count), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\n  locationIt.reset();\n\n  while (locationIt.hasNext) {\n    var v = locationIt.move();\n    encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.index * 3);\n  }\n\n  return createTextureSize(sizes, 'groupInstance', sizeData);\n}","map":{"version":3,"sources":["../../../src/mol-geo/geometry/size-data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../mol-util';\r\nimport { Vec2 } from '../../mol-math/linear-algebra';\r\nimport { createTextureImage } from '../../mol-gl/renderable/util';\r\nimport { NullLocation } from '../../mol-model/location';\r\nimport { Geometry } from './geometry';\r\nimport { decodeFloatRGB, encodeFloatRGBtoArray } from '../../mol-util/float-packing';\r\nexport function createSizes(locationIt, sizeTheme, sizeData) {\r\n    switch (Geometry.getGranularity(locationIt, sizeTheme.granularity)) {\r\n        case 'uniform': return createUniformSize(locationIt, sizeTheme.size, sizeData);\r\n        case 'group': return createGroupSize(locationIt, sizeTheme.size, sizeData);\r\n        case 'groupInstance': return createGroupInstanceSize(locationIt, sizeTheme.size, sizeData);\r\n        case 'instance': return createInstanceSize(locationIt, sizeTheme.size, sizeData);\r\n    }\r\n}\r\nexport var sizeDataFactor = 100; // NOTE same factor is set in shaders\r\nexport function getMaxSize(sizeData) {\r\n    var type = sizeData.dSizeType.ref.value;\r\n    switch (type) {\r\n        case 'uniform':\r\n            return sizeData.uSize.ref.value;\r\n        case 'instance':\r\n        case 'group':\r\n        case 'groupInstance':\r\n            var maxSize = 0;\r\n            var array = sizeData.tSize.ref.value.array;\r\n            for (var i = 0, il = array.length; i < il; i += 3) {\r\n                var value = decodeFloatRGB(array[i], array[i + 1], array[i + 2]);\r\n                if (maxSize < value)\r\n                    maxSize = value;\r\n            }\r\n            return maxSize / sizeDataFactor;\r\n    }\r\n}\r\nvar emptySizeTexture = { array: new Uint8Array(3), width: 1, height: 1 };\r\nfunction createEmptySizeTexture() {\r\n    return {\r\n        tSize: ValueCell.create(emptySizeTexture),\r\n        uSizeTexDim: ValueCell.create(Vec2.create(1, 1))\r\n    };\r\n}\r\nexport function createValueSize(value, sizeData) {\r\n    if (sizeData) {\r\n        ValueCell.update(sizeData.uSize, value);\r\n        ValueCell.updateIfChanged(sizeData.dSizeType, 'uniform');\r\n        return sizeData;\r\n    }\r\n    else {\r\n        return __assign(__assign({ uSize: ValueCell.create(value) }, createEmptySizeTexture()), { dSizeType: ValueCell.create('uniform') });\r\n    }\r\n}\r\n/** Creates size uniform */\r\nexport function createUniformSize(locationIt, sizeFn, sizeData) {\r\n    return createValueSize(sizeFn(NullLocation), sizeData);\r\n}\r\nexport function createTextureSize(sizes, type, sizeData) {\r\n    if (sizeData) {\r\n        ValueCell.update(sizeData.tSize, sizes);\r\n        ValueCell.update(sizeData.uSizeTexDim, Vec2.create(sizes.width, sizes.height));\r\n        ValueCell.updateIfChanged(sizeData.dSizeType, type);\r\n        return sizeData;\r\n    }\r\n    else {\r\n        return {\r\n            uSize: ValueCell.create(0),\r\n            tSize: ValueCell.create(sizes),\r\n            uSizeTexDim: ValueCell.create(Vec2.create(sizes.width, sizes.height)),\r\n            dSizeType: ValueCell.create(type),\r\n        };\r\n    }\r\n}\r\n/** Creates size texture with size for each instance/unit */\r\nexport function createInstanceSize(locationIt, sizeFn, sizeData) {\r\n    var instanceCount = locationIt.instanceCount;\r\n    var sizes = createTextureImage(Math.max(1, instanceCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\r\n    locationIt.reset();\r\n    while (locationIt.hasNext && !locationIt.isNextNewInstance) {\r\n        var v = locationIt.move();\r\n        encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.instanceIndex * 3);\r\n        locationIt.skipInstance();\r\n    }\r\n    return createTextureSize(sizes, 'instance', sizeData);\r\n}\r\n/** Creates size texture with size for each group (i.e. shared across instances/units) */\r\nexport function createGroupSize(locationIt, sizeFn, sizeData) {\r\n    var groupCount = locationIt.groupCount;\r\n    var sizes = createTextureImage(Math.max(1, groupCount), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\r\n    locationIt.reset();\r\n    while (locationIt.hasNext && !locationIt.isNextNewInstance) {\r\n        var v = locationIt.move();\r\n        encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.groupIndex * 3);\r\n    }\r\n    return createTextureSize(sizes, 'group', sizeData);\r\n}\r\n/** Creates size texture with size for each group in each instance (i.e. for each unit) */\r\nexport function createGroupInstanceSize(locationIt, sizeFn, sizeData) {\r\n    var groupCount = locationIt.groupCount, instanceCount = locationIt.instanceCount;\r\n    var count = instanceCount * groupCount;\r\n    var sizes = createTextureImage(Math.max(1, count), 3, Uint8Array, sizeData && sizeData.tSize.ref.value.array);\r\n    locationIt.reset();\r\n    while (locationIt.hasNext) {\r\n        var v = locationIt.move();\r\n        encodeFloatRGBtoArray(sizeFn(v.location) * sizeDataFactor, sizes.array, v.index * 3);\r\n    }\r\n    return createTextureSize(sizes, 'groupInstance', sizeData);\r\n}\r\n//# sourceMappingURL=size-data.js.map"]},"metadata":{},"sourceType":"module"}