{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { UniqueArray } from '../../../../mol-data/generic';\nimport { OrderedSet, SortedArray, Interval } from '../../../../mol-data/int';\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\nimport { MolScriptBuilder as MS } from '../../../../mol-script/language/builder';\nimport { Structure } from '../structure';\nimport { Unit } from '../unit';\nimport { sortArray, hashFnv32a, hash2 } from '../../../../mol-data/util';\nimport { Location } from './location';\nimport { PrincipalAxes } from '../../../../mol-math/linear-algebra/matrix/principal-axes';\nimport { StructureProperties } from '../properties';\nimport { BoundaryHelper } from '../../../../mol-math/geometry/boundary-helper';\nimport { IntTuple } from '../../../../mol-data/int/tuple'; // avoiding namespace lookup improved performance in Chrome (Aug 2020)\n\nvar itDiff = IntTuple.diff;\nexport function Loci(structure, elements) {\n  return {\n    kind: 'element-loci',\n    structure: structure,\n    elements: elements\n  };\n}\n\n(function (Loci) {\n  function is(x) {\n    return !!x && x.kind === 'element-loci';\n  }\n\n  Loci.is = is;\n\n  function areEqual(a, b) {\n    if (a.structure !== b.structure) return false;\n    if (a.elements.length !== b.elements.length) return false;\n\n    for (var i = 0, il = a.elements.length; i < il; ++i) {\n      var elementA = a.elements[i];\n      var elementB = b.elements[i];\n      if (elementA.unit.id !== elementB.unit.id) return false;\n      if (!OrderedSet.areEqual(elementA.indices, elementB.indices)) return false;\n    }\n\n    return true;\n  }\n\n  Loci.areEqual = areEqual;\n\n  function isEmpty(loci) {\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var u = _b[_a];\n      if (OrderedSet.size(u.indices) > 0) return false;\n    }\n\n    return true;\n  }\n\n  Loci.isEmpty = isEmpty;\n\n  function isWholeStructure(loci) {\n    return size(loci) === loci.structure.elementCount;\n  }\n\n  Loci.isWholeStructure = isWholeStructure;\n\n  function size(loci) {\n    var s = 0; // inlined for max performance, crucial for marking large cellpack models\n    // `for (const u of loci.elements) s += OrderedSet.size(u.indices);`\n\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var indices = _b[_a].indices;\n\n      if (typeof indices === 'number') {\n        s += itDiff(indices);\n      } else {\n        s += indices.length;\n      }\n    }\n\n    return s;\n  }\n\n  Loci.size = size;\n\n  function all(structure) {\n    return Loci(structure, structure.units.map(function (unit) {\n      return {\n        unit: unit,\n        indices: OrderedSet.ofBounds(0, unit.elements.length)\n      };\n    }));\n  }\n\n  Loci.all = all;\n\n  function none(structure) {\n    return Loci(structure, []);\n  }\n\n  Loci.none = none;\n\n  function getFirstLocation(loci, e) {\n    if (isEmpty(loci)) return void 0;\n    var unit = loci.elements[0].unit;\n    var element = unit.elements[OrderedSet.getAt(loci.elements[0].indices, 0)];\n\n    if (e) {\n      e.structure = loci.structure;\n      e.unit = loci.elements[0].unit;\n      e.element = element;\n      return e;\n    }\n\n    return Location.create(loci.structure, unit, element);\n  }\n\n  Loci.getFirstLocation = getFirstLocation;\n\n  function firstElement(loci) {\n    if (isEmpty(loci)) return loci;\n    return Loci(loci.structure, [{\n      unit: loci.elements[0].unit,\n      indices: OrderedSet.ofSingleton(OrderedSet.start(loci.elements[0].indices))\n    }]);\n  }\n\n  Loci.firstElement = firstElement;\n\n  function firstResidue(loci) {\n    if (isEmpty(loci)) return loci;\n    return extendToWholeResidues(firstElement(loci));\n  }\n\n  Loci.firstResidue = firstResidue;\n\n  function firstChain(loci) {\n    if (isEmpty(loci)) return loci;\n    return extendToWholeChains(firstElement(loci));\n  }\n\n  Loci.firstChain = firstChain;\n\n  function toStructure(loci) {\n    var units = [];\n\n    var _loop_1 = function (e) {\n      var unit = e.unit,\n          indices = e.indices;\n      var elements = new Int32Array(OrderedSet.size(indices));\n      OrderedSet.forEach(indices, function (v, i) {\n        return elements[i] = unit.elements[v];\n      });\n      units.push(unit.getChild(SortedArray.ofSortedArray(elements)));\n    };\n\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n\n      _loop_1(e);\n    }\n\n    return Structure.create(units, {\n      parent: loci.structure.parent\n    });\n  }\n\n  Loci.toStructure = toStructure; // TODO: there should be a version that properly supports partitioned units\n\n  function remap(loci, structure) {\n    if (structure === loci.structure) return loci;\n    var elements = [];\n    loci.elements.forEach(function (e) {\n      if (!structure.unitMap.has(e.unit.id)) return;\n      var unit = structure.unitMap.get(e.unit.id);\n      var indices = OrderedSet.indexedIntersect(e.indices, e.unit.elements, unit.elements);\n      if (OrderedSet.size(indices) > 0) elements.push({\n        unit: unit,\n        indices: indices\n      });\n    });\n    return Loci(structure, elements);\n  }\n\n  Loci.remap = remap;\n  /** Create union of `xs` and `ys` */\n\n  function union(xs, ys) {\n    if (xs.elements.length > ys.elements.length) return union(ys, xs);\n    if (Loci.isEmpty(xs)) return ys;\n    var map = new Map();\n\n    for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      map.set(e.unit.id, e.indices);\n    }\n\n    var elements = [];\n\n    for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n\n      if (map.has(e.unit.id)) {\n        elements[elements.length] = {\n          unit: e.unit,\n          indices: OrderedSet.union(map.get(e.unit.id), e.indices)\n        };\n        map.delete(e.unit.id);\n      } else {\n        elements[elements.length] = e;\n      }\n    }\n\n    map.forEach(function (indices, id) {\n      elements[elements.length] = {\n        unit: xs.structure.unitMap.get(id),\n        indices: indices\n      };\n    });\n    return Loci(xs.structure, elements);\n  }\n\n  Loci.union = union;\n  /** Subtract `ys` from `xs` */\n\n  function subtract(xs, ys) {\n    var map = new Map();\n\n    for (var _a = 0, _b = ys.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      map.set(e.unit.id, e.indices);\n    }\n\n    var elements = [];\n\n    for (var _c = 0, _d = xs.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n\n      if (map.has(e.unit.id)) {\n        var indices = OrderedSet.subtract(e.indices, map.get(e.unit.id));\n        if (OrderedSet.size(indices) === 0) continue;\n        elements[elements.length] = {\n          unit: e.unit,\n          indices: indices\n        };\n      } else {\n        elements[elements.length] = e;\n      }\n    }\n\n    return Loci(xs.structure, elements);\n  }\n\n  Loci.subtract = subtract;\n  /** Intersect `xs` and `ys` */\n\n  function intersect(xs, ys) {\n    var map = new Map();\n\n    for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      map.set(e.unit.id, e.indices);\n    }\n\n    var elements = [];\n\n    for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n      if (!map.has(e.unit.id)) continue;\n      var indices = OrderedSet.intersect(map.get(e.unit.id), e.indices);\n      if (OrderedSet.size(indices) === 0) continue;\n      elements[elements.length] = {\n        unit: e.unit,\n        indices: indices\n      };\n    }\n\n    return Loci(xs.structure, elements);\n  }\n\n  Loci.intersect = intersect;\n\n  function areIntersecting(xs, ys) {\n    if (xs.elements.length > ys.elements.length) return areIntersecting(ys, xs);\n    if (Loci.isEmpty(xs)) return Loci.isEmpty(ys);\n    var map = new Map();\n\n    for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      map.set(e.unit.id, e.indices);\n    }\n\n    for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n      if (!map.has(e.unit.id)) continue;\n      if (OrderedSet.areIntersecting(map.get(e.unit.id), e.indices)) return true;\n    }\n\n    return false;\n  }\n\n  Loci.areIntersecting = areIntersecting;\n  /** Check if second loci is a subset of the first */\n\n  function isSubset(xs, ys) {\n    if (Loci.isEmpty(xs)) return Loci.isEmpty(ys);\n    var map = new Map();\n\n    for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      map.set(e.unit.id, e.indices);\n    }\n\n    var isSubset = false;\n\n    for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n      if (!map.has(e.unit.id)) continue;\n      if (!OrderedSet.isSubset(map.get(e.unit.id), e.indices)) return false;else isSubset = true;\n    }\n\n    return isSubset;\n  }\n\n  Loci.isSubset = isSubset;\n\n  function makeIndexSet(newIndices) {\n    if (newIndices.length > 3 && SortedArray.isRange(newIndices)) {\n      return Interval.ofRange(newIndices[0], newIndices[newIndices.length - 1]);\n    } else {\n      return SortedArray.ofSortedArray(newIndices);\n    }\n  }\n\n  function extendToWholeResidues(loci, restrictToConformation) {\n    var elements = [];\n    var residueAltIds = new Set();\n\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var lociElement = _b[_a];\n\n      if (isWholeUnit(lociElement)) {\n        elements[elements.length] = lociElement;\n        continue;\n      }\n\n      if (lociElement.unit.kind === 0\n      /* Atomic */\n      ) {\n        var unitElements = lociElement.unit.elements;\n        var h = lociElement.unit.model.atomicHierarchy;\n        var label_alt_id = lociElement.unit.model.atomicHierarchy.atoms.label_alt_id;\n        var _c = h.residueAtomSegments,\n            residueIndex = _c.index,\n            residueOffsets = _c.offsets;\n        var newIndices = [];\n        var indices = lociElement.indices,\n            len = OrderedSet.size(indices);\n        var i = 0;\n\n        while (i < len) {\n          residueAltIds.clear();\n          var eI = unitElements[OrderedSet.getAt(indices, i)];\n          var rI = residueIndex[eI];\n          residueAltIds.add(label_alt_id.value(eI));\n          i++;\n\n          while (i < len) {\n            var eI_1 = unitElements[OrderedSet.getAt(indices, i)];\n            if (residueIndex[eI_1] !== rI) break;\n            residueAltIds.add(label_alt_id.value(eI_1));\n            i++;\n          }\n\n          var hasSharedAltId = residueAltIds.has('');\n\n          for (var j = residueOffsets[rI], _j = residueOffsets[rI + 1]; j < _j; j++) {\n            var idx = OrderedSet.indexOf(unitElements, j);\n\n            if (idx >= 0) {\n              var altId = label_alt_id.value(j);\n\n              if (!restrictToConformation || hasSharedAltId || !altId || residueAltIds.has(altId)) {\n                newIndices[newIndices.length] = idx;\n              }\n            }\n          }\n        }\n\n        elements[elements.length] = {\n          unit: lociElement.unit,\n          indices: makeIndexSet(newIndices)\n        };\n      } else {\n        // coarse elements are already by-residue\n        elements[elements.length] = lociElement;\n      }\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToWholeResidues = extendToWholeResidues;\n\n  function getChainSegments(unit) {\n    switch (unit.kind) {\n      case 0\n      /* Atomic */\n      :\n        return unit.model.atomicHierarchy.chainAtomSegments;\n\n      case 1\n      /* Spheres */\n      :\n        return unit.model.coarseHierarchy.spheres.chainElementSegments;\n\n      case 2\n      /* Gaussians */\n      :\n        return unit.model.coarseHierarchy.gaussians.chainElementSegments;\n    }\n  }\n\n  function isWholeUnit(element) {\n    return element.unit.elements.length === OrderedSet.size(element.indices);\n  }\n\n  function collectChains(unit, chainIndices, elements) {\n    var index = getChainSegments(unit).index;\n    var xs = unit.elements;\n    var size = 0;\n\n    for (var i = 0, _i = xs.length; i < _i; i++) {\n      var eI = xs[i];\n      var cI = index[eI];\n      if (!chainIndices.has(cI)) continue;\n      size++;\n    }\n\n    if (size === unit.elements.length) {\n      elements[elements.length] = {\n        unit: unit,\n        indices: Interval.ofBounds(0, size)\n      };\n      return;\n    }\n\n    var newIndices = new Int32Array(size);\n    size = 0;\n\n    for (var i = 0, _i = xs.length; i < _i; i++) {\n      var eI = xs[i];\n      var cI = index[eI];\n      if (!chainIndices.has(cI)) continue;\n      newIndices[size++] = i;\n    }\n\n    if (newIndices.length > 0) {\n      elements[elements.length] = {\n        unit: unit,\n        indices: makeIndexSet(newIndices)\n      };\n    }\n  }\n\n  function extendGroupToWholeChains(loci, start, end, isPartitioned, elements) {\n    var chainIndex = getChainSegments(loci.elements[0].unit).index;\n    var chainIndices = new Set();\n\n    for (var lI = start; lI < end; lI++) {\n      var lociElement = loci.elements[lI];\n      var indices = lociElement.indices;\n      var unitElements = lociElement.unit.elements;\n\n      for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\n        chainIndices.add(chainIndex[unitElements[OrderedSet.getAt(indices, i)]]);\n      }\n    }\n\n    if (isPartitioned) {\n      var baseUnit = loci.elements[0].unit; // TODO: check for accidental quadratic for really large structures (but should be ok).\n\n      for (var _a = 0, _b = loci.structure.units; _a < _b.length; _a++) {\n        var unit = _b[_a];\n        if (!Unit.areSameChainOperatorGroup(unit, baseUnit)) continue;\n        collectChains(unit, chainIndices, elements);\n      }\n    } else {\n      for (var lI = start; lI < end; lI++) {\n        collectChains(loci.elements[lI].unit, chainIndices, elements);\n      }\n    }\n  }\n\n  function extendToWholeChains(loci) {\n    var elements = [];\n\n    for (var i = 0, len = loci.elements.length; i < len; i++) {\n      var e = loci.elements[i];\n\n      if (Unit.Traits.is(e.unit.traits, 2\n      /* Partitioned */\n      )) {\n        var start = i;\n\n        while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {\n          i++;\n        }\n\n        var end = i;\n        i--;\n        extendGroupToWholeChains(loci, start, end, true, elements);\n      } else {\n        if (isWholeUnit(e)) {\n          elements[elements.length] = e;\n        } else {\n          extendGroupToWholeChains(loci, i, i + 1, false, elements);\n        }\n      }\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToWholeChains = extendToWholeChains;\n\n  function entityModelKey(location) {\n    return location.unit.model.id + \"|\" + StructureProperties.entity.id(location);\n  }\n\n  function extendToWholeEntities(loci) {\n    var elements = [];\n    var l = Location.create(loci.structure);\n    var entities = new Set();\n    var units = loci.structure.units;\n\n    for (var i = 0, len = loci.elements.length; i < len; i++) {\n      var e = loci.elements[i];\n      l.unit = e.unit;\n      l.element = e.unit.elements[0];\n      entities.add(entityModelKey(l));\n    }\n\n    for (var i = 0, il = units.length; i < il; ++i) {\n      var unit = units[i];\n      l.unit = unit;\n      l.element = unit.elements[0];\n\n      if (entities.has(entityModelKey(l))) {\n        var indices = OrderedSet.ofBounds(0, unit.elements.length);\n        elements[elements.length] = {\n          unit: unit,\n          indices: indices\n        };\n      }\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToWholeEntities = extendToWholeEntities;\n\n  function extendToWholeModels(loci) {\n    var elements = [];\n    var models = new Set();\n    var units = loci.structure.units;\n\n    for (var i = 0, len = loci.elements.length; i < len; i++) {\n      var e = loci.elements[i];\n      models.add(e.unit.model.id);\n    }\n\n    for (var i = 0, il = units.length; i < il; ++i) {\n      var unit = units[i];\n\n      if (models.has(unit.model.id)) {\n        var indices = OrderedSet.ofBounds(0, unit.elements.length);\n        elements[elements.length] = {\n          unit: unit,\n          indices: indices\n        };\n      }\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToWholeModels = extendToWholeModels;\n\n  function getElementIndices(elements, indices) {\n    var elementIndices = [];\n\n    for (var i = 0, il = OrderedSet.size(indices); i < il; ++i) {\n      elementIndices.push(elements[OrderedSet.getAt(indices, i)]);\n    }\n\n    return SortedArray.ofSortedArray(elementIndices);\n  }\n\n  function getUnitIndices(elements, indices) {\n    if (SortedArray.isRange(elements) && SortedArray.areEqual(elements, indices)) {\n      return Interval.ofLength(elements.length);\n    }\n\n    return makeIndexSet(SortedArray.indicesOf(elements, indices));\n  }\n\n  function extendToAllInstances(loci) {\n    var elements = [];\n    var byModel = new Map();\n\n    for (var i = 0, len = loci.elements.length; i < len; i++) {\n      var e = loci.elements[i];\n      var model = e.unit.model;\n      var elementIndices = getElementIndices(e.unit.elements, e.indices);\n\n      if (byModel.has(model)) {\n        byModel.set(model, SortedArray.union(elementIndices, byModel.get(model)));\n      } else {\n        byModel.set(model, elementIndices);\n      }\n    }\n\n    for (var i = 0, il = loci.structure.units.length; i < il; ++i) {\n      var unit = loci.structure.units[i];\n      var elementIndices = byModel.get(unit.model);\n      if (!elementIndices) continue;\n      var indices = getUnitIndices(unit.elements, elementIndices);\n      elements[elements.length] = {\n        unit: unit,\n        indices: indices\n      };\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToAllInstances = extendToAllInstances;\n\n  function extendToWholeOperators(loci) {\n    var elements = [];\n    var operators = new Set();\n    var units = loci.structure.units;\n\n    for (var i = 0, len = loci.elements.length; i < len; i++) {\n      var e = loci.elements[i];\n      operators.add(e.unit.conformation.operator.name);\n    }\n\n    for (var i = 0, il = units.length; i < il; ++i) {\n      var unit = units[i];\n\n      if (operators.has(unit.conformation.operator.name)) {\n        var indices = OrderedSet.ofBounds(0, unit.elements.length);\n        elements[elements.length] = {\n          unit: unit,\n          indices: indices\n        };\n      }\n    }\n\n    return Loci(loci.structure, elements);\n  }\n\n  Loci.extendToWholeOperators = extendToWholeOperators; //\n\n  var boundaryHelper = new BoundaryHelper('98');\n  var tempPosBoundary = Vec3();\n\n  function getBoundary(loci, transform) {\n    boundaryHelper.reset();\n\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      var indices = e.indices;\n      var pos = e.unit.conformation.position,\n          r = e.unit.conformation.r;\n      var elements = e.unit.elements;\n\n      for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\n        var eI = elements[OrderedSet.getAt(indices, i)];\n        pos(eI, tempPosBoundary);\n        if (transform) Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);\n        boundaryHelper.includePositionRadius(tempPosBoundary, r(eI));\n      }\n    }\n\n    boundaryHelper.finishedIncludeStep();\n\n    for (var _c = 0, _d = loci.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n      var indices = e.indices;\n      var pos = e.unit.conformation.position,\n          r = e.unit.conformation.r;\n      var elements = e.unit.elements;\n\n      for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\n        var eI = elements[OrderedSet.getAt(indices, i)];\n        pos(eI, tempPosBoundary);\n        if (transform) Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);\n        boundaryHelper.radiusPositionRadius(tempPosBoundary, r(eI));\n      }\n    }\n\n    return {\n      box: boundaryHelper.getBox(),\n      sphere: boundaryHelper.getSphere()\n    };\n  }\n\n  Loci.getBoundary = getBoundary;\n  var tempPos = Vec3();\n\n  function toPositionsArray(loci, positions, offset) {\n    if (offset === void 0) {\n      offset = 0;\n    }\n\n    var m = offset;\n\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n      var e = _b[_a];\n      var indices = e.indices;\n      var pos = e.unit.conformation.position;\n      var elements = e.unit.elements;\n      var indexCount = OrderedSet.size(indices);\n\n      for (var i = 0; i < indexCount; i++) {\n        var eI = elements[OrderedSet.getAt(indices, i)];\n        pos(eI, tempPos);\n        Vec3.toArray(tempPos, positions, m + i * 3);\n      }\n\n      m += indexCount * 3;\n    }\n\n    return positions;\n  }\n\n  Loci.toPositionsArray = toPositionsArray;\n\n  function getPrincipalAxes(loci) {\n    var elementCount = size(loci);\n    var positions = toPositionsArray(loci, new Float32Array(3 * elementCount));\n    return PrincipalAxes.ofPositions(positions);\n  }\n\n  Loci.getPrincipalAxes = getPrincipalAxes;\n\n  function sourceIndex(unit, element) {\n    return Unit.isAtomic(unit) ? unit.model.atomicHierarchy.atomSourceIndex.value(element) // TODO: when implemented, this should map to the source index.\n    : element;\n  }\n\n  function toExpression(loci) {\n    var _a;\n\n    if (Loci.isEmpty(loci)) return MS.struct.generator.empty();\n    var models = loci.structure.models;\n    var sourceIndexMap = new Map();\n\n    for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\n      var e = _c[_b];\n      var indices = e.indices;\n      var elements = e.unit.elements;\n      var key = e.unit.conformation.operator.name;\n      var sourceIndices = void 0;\n      if (sourceIndexMap.has(key)) sourceIndices = sourceIndexMap.get(key).xs;else {\n        sourceIndices = UniqueArray.create();\n        sourceIndexMap.set(key, {\n          modelLabel: e.unit.model.label,\n          modelIndex: e.unit.model.modelNum,\n          xs: sourceIndices\n        });\n      }\n\n      for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\n        var idx = sourceIndex(e.unit, elements[OrderedSet.getAt(indices, i)]);\n        UniqueArray.add(sourceIndices, idx, idx);\n      }\n    }\n\n    var opData = [];\n    var keys = sourceIndexMap.keys();\n\n    while (true) {\n      var k = keys.next();\n      if (k.done) break;\n      var e = sourceIndexMap.get(k.value);\n      opData.push(getOpData(k.value, e.xs.array, models.length > 1, e.modelLabel, e.modelIndex));\n    }\n\n    var opGroups = new Map();\n\n    for (var i = 0, il = opData.length; i < il; ++i) {\n      var d = opData[i];\n      var hash = hash2(hashFnv32a(d.atom.ranges), hashFnv32a(d.atom.set));\n      var key = hash + \"|\" + (d.entity ? d.entity.modelLabel + d.entity.modelIndex : '');\n\n      if (opGroups.has(key)) {\n        (_a = opGroups.get(key).chain.opName).push.apply(_a, d.chain.opName);\n      } else {\n        opGroups.set(key, d);\n      }\n    }\n\n    var opQueries = [];\n    opGroups.forEach(function (d) {\n      var _a = d.atom,\n          ranges = _a.ranges,\n          set = _a.set;\n      var opName = d.chain.opName;\n      var opProp = MS.struct.atomProperty.core.operatorName();\n      var siProp = MS.struct.atomProperty.core.sourceIndex();\n      var tests = []; // TODO: add set.ofRanges constructor to MolQL???\n\n      if (set.length > 0) {\n        tests[tests.length] = MS.core.set.has([MS.core.type.set(set), siProp]);\n      }\n\n      for (var rI = 0, _rI = ranges.length / 2; rI < _rI; rI++) {\n        tests[tests.length] = MS.core.rel.inRange([siProp, ranges[2 * rI], ranges[2 * rI + 1]]);\n      }\n\n      if (d.entity) {\n        var _b = d.entity,\n            modelLabel = _b.modelLabel,\n            modelIndex = _b.modelIndex;\n        opQueries.push(MS.struct.generator.atomGroups({\n          'atom-test': tests.length > 1 ? MS.core.logic.or(tests) : tests[0],\n          'chain-test': opName.length > 1 ? MS.core.set.has([MS.core.type.set(opName), opProp]) : MS.core.rel.eq([opProp, opName[0]]),\n          'entity-test': MS.core.logic.and([MS.core.rel.eq([MS.struct.atomProperty.core.modelLabel(), modelLabel]), MS.core.rel.eq([MS.struct.atomProperty.core.modelIndex(), modelIndex])])\n        }));\n      } else {\n        opQueries.push(MS.struct.generator.atomGroups({\n          'atom-test': tests.length > 1 ? MS.core.logic.or(tests) : tests[0],\n          'chain-test': opName.length > 1 ? MS.core.set.has([MS.core.type.set(opName), opProp]) : MS.core.rel.eq([opProp, opName[0]])\n        }));\n      }\n    });\n    return MS.struct.modifier.union([opQueries.length === 1 ? opQueries[0] // Need to union before merge for fast performance\n    : MS.struct.combinator.merge(opQueries.map(function (q) {\n      return MS.struct.modifier.union([q]);\n    }))]);\n  }\n\n  Loci.toExpression = toExpression;\n\n  function getOpData(opName, xs, multimodel, modelLabel, modelIndex) {\n    sortArray(xs);\n    var ranges = [];\n    var set = [];\n    var i = 0;\n    var len = xs.length;\n\n    while (i < len) {\n      var start = i;\n      i++;\n\n      while (i < len && xs[i - 1] + 1 === xs[i]) i++;\n\n      var end = i; // TODO: is this a good value?\n\n      if (end - start > 12) {\n        ranges[ranges.length] = xs[start];\n        ranges[ranges.length] = xs[end - 1];\n      } else {\n        for (var j = start; j < end; j++) {\n          set[set.length] = xs[j];\n        }\n      }\n    }\n\n    return multimodel ? {\n      atom: {\n        set: set,\n        ranges: ranges\n      },\n      chain: {\n        opName: [opName]\n      },\n      entity: {\n        modelLabel: modelLabel,\n        modelIndex: modelIndex\n      }\n    } : {\n      atom: {\n        set: set,\n        ranges: ranges\n      },\n      chain: {\n        opName: [opName]\n      }\n    };\n  }\n})(Loci || (Loci = {}));","map":{"version":3,"sources":["../../../../../src/mol-model/structure/structure/element/loci.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { UniqueArray } from '../../../../mol-data/generic';\r\nimport { OrderedSet, SortedArray, Interval } from '../../../../mol-data/int';\r\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\r\nimport { MolScriptBuilder as MS } from '../../../../mol-script/language/builder';\r\nimport { Structure } from '../structure';\r\nimport { Unit } from '../unit';\r\nimport { sortArray, hashFnv32a, hash2 } from '../../../../mol-data/util';\r\nimport { Location } from './location';\r\nimport { PrincipalAxes } from '../../../../mol-math/linear-algebra/matrix/principal-axes';\r\nimport { StructureProperties } from '../properties';\r\nimport { BoundaryHelper } from '../../../../mol-math/geometry/boundary-helper';\r\nimport { IntTuple } from '../../../../mol-data/int/tuple';\r\n// avoiding namespace lookup improved performance in Chrome (Aug 2020)\r\nvar itDiff = IntTuple.diff;\r\nexport function Loci(structure, elements) {\r\n    return { kind: 'element-loci', structure: structure, elements: elements };\r\n}\r\n(function (Loci) {\r\n    function is(x) {\r\n        return !!x && x.kind === 'element-loci';\r\n    }\r\n    Loci.is = is;\r\n    function areEqual(a, b) {\r\n        if (a.structure !== b.structure)\r\n            return false;\r\n        if (a.elements.length !== b.elements.length)\r\n            return false;\r\n        for (var i = 0, il = a.elements.length; i < il; ++i) {\r\n            var elementA = a.elements[i];\r\n            var elementB = b.elements[i];\r\n            if (elementA.unit.id !== elementB.unit.id)\r\n                return false;\r\n            if (!OrderedSet.areEqual(elementA.indices, elementB.indices))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    Loci.areEqual = areEqual;\r\n    function isEmpty(loci) {\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var u = _b[_a];\r\n            if (OrderedSet.size(u.indices) > 0)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    Loci.isEmpty = isEmpty;\r\n    function isWholeStructure(loci) {\r\n        return size(loci) === loci.structure.elementCount;\r\n    }\r\n    Loci.isWholeStructure = isWholeStructure;\r\n    function size(loci) {\r\n        var s = 0;\r\n        // inlined for max performance, crucial for marking large cellpack models\r\n        // `for (const u of loci.elements) s += OrderedSet.size(u.indices);`\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var indices = _b[_a].indices;\r\n            if (typeof indices === 'number') {\r\n                s += itDiff(indices);\r\n            }\r\n            else {\r\n                s += indices.length;\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n    Loci.size = size;\r\n    function all(structure) {\r\n        return Loci(structure, structure.units.map(function (unit) { return ({\r\n            unit: unit,\r\n            indices: OrderedSet.ofBounds(0, unit.elements.length)\r\n        }); }));\r\n    }\r\n    Loci.all = all;\r\n    function none(structure) {\r\n        return Loci(structure, []);\r\n    }\r\n    Loci.none = none;\r\n    function getFirstLocation(loci, e) {\r\n        if (isEmpty(loci))\r\n            return void 0;\r\n        var unit = loci.elements[0].unit;\r\n        var element = unit.elements[OrderedSet.getAt(loci.elements[0].indices, 0)];\r\n        if (e) {\r\n            e.structure = loci.structure;\r\n            e.unit = loci.elements[0].unit;\r\n            e.element = element;\r\n            return e;\r\n        }\r\n        return Location.create(loci.structure, unit, element);\r\n    }\r\n    Loci.getFirstLocation = getFirstLocation;\r\n    function firstElement(loci) {\r\n        if (isEmpty(loci))\r\n            return loci;\r\n        return Loci(loci.structure, [{\r\n                unit: loci.elements[0].unit,\r\n                indices: OrderedSet.ofSingleton(OrderedSet.start(loci.elements[0].indices))\r\n            }]);\r\n    }\r\n    Loci.firstElement = firstElement;\r\n    function firstResidue(loci) {\r\n        if (isEmpty(loci))\r\n            return loci;\r\n        return extendToWholeResidues(firstElement(loci));\r\n    }\r\n    Loci.firstResidue = firstResidue;\r\n    function firstChain(loci) {\r\n        if (isEmpty(loci))\r\n            return loci;\r\n        return extendToWholeChains(firstElement(loci));\r\n    }\r\n    Loci.firstChain = firstChain;\r\n    function toStructure(loci) {\r\n        var units = [];\r\n        var _loop_1 = function (e) {\r\n            var unit = e.unit, indices = e.indices;\r\n            var elements = new Int32Array(OrderedSet.size(indices));\r\n            OrderedSet.forEach(indices, function (v, i) { return elements[i] = unit.elements[v]; });\r\n            units.push(unit.getChild(SortedArray.ofSortedArray(elements)));\r\n        };\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            _loop_1(e);\r\n        }\r\n        return Structure.create(units, { parent: loci.structure.parent });\r\n    }\r\n    Loci.toStructure = toStructure;\r\n    // TODO: there should be a version that properly supports partitioned units\r\n    function remap(loci, structure) {\r\n        if (structure === loci.structure)\r\n            return loci;\r\n        var elements = [];\r\n        loci.elements.forEach(function (e) {\r\n            if (!structure.unitMap.has(e.unit.id))\r\n                return;\r\n            var unit = structure.unitMap.get(e.unit.id);\r\n            var indices = OrderedSet.indexedIntersect(e.indices, e.unit.elements, unit.elements);\r\n            if (OrderedSet.size(indices) > 0)\r\n                elements.push({ unit: unit, indices: indices });\r\n        });\r\n        return Loci(structure, elements);\r\n    }\r\n    Loci.remap = remap;\r\n    /** Create union of `xs` and `ys` */\r\n    function union(xs, ys) {\r\n        if (xs.elements.length > ys.elements.length)\r\n            return union(ys, xs);\r\n        if (Loci.isEmpty(xs))\r\n            return ys;\r\n        var map = new Map();\r\n        for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            map.set(e.unit.id, e.indices);\r\n        }\r\n        var elements = [];\r\n        for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            if (map.has(e.unit.id)) {\r\n                elements[elements.length] = { unit: e.unit, indices: OrderedSet.union(map.get(e.unit.id), e.indices) };\r\n                map.delete(e.unit.id);\r\n            }\r\n            else {\r\n                elements[elements.length] = e;\r\n            }\r\n        }\r\n        map.forEach(function (indices, id) {\r\n            elements[elements.length] = { unit: xs.structure.unitMap.get(id), indices: indices };\r\n        });\r\n        return Loci(xs.structure, elements);\r\n    }\r\n    Loci.union = union;\r\n    /** Subtract `ys` from `xs` */\r\n    function subtract(xs, ys) {\r\n        var map = new Map();\r\n        for (var _a = 0, _b = ys.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            map.set(e.unit.id, e.indices);\r\n        }\r\n        var elements = [];\r\n        for (var _c = 0, _d = xs.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            if (map.has(e.unit.id)) {\r\n                var indices = OrderedSet.subtract(e.indices, map.get(e.unit.id));\r\n                if (OrderedSet.size(indices) === 0)\r\n                    continue;\r\n                elements[elements.length] = { unit: e.unit, indices: indices };\r\n            }\r\n            else {\r\n                elements[elements.length] = e;\r\n            }\r\n        }\r\n        return Loci(xs.structure, elements);\r\n    }\r\n    Loci.subtract = subtract;\r\n    /** Intersect `xs` and `ys` */\r\n    function intersect(xs, ys) {\r\n        var map = new Map();\r\n        for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            map.set(e.unit.id, e.indices);\r\n        }\r\n        var elements = [];\r\n        for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            if (!map.has(e.unit.id))\r\n                continue;\r\n            var indices = OrderedSet.intersect(map.get(e.unit.id), e.indices);\r\n            if (OrderedSet.size(indices) === 0)\r\n                continue;\r\n            elements[elements.length] = { unit: e.unit, indices: indices };\r\n        }\r\n        return Loci(xs.structure, elements);\r\n    }\r\n    Loci.intersect = intersect;\r\n    function areIntersecting(xs, ys) {\r\n        if (xs.elements.length > ys.elements.length)\r\n            return areIntersecting(ys, xs);\r\n        if (Loci.isEmpty(xs))\r\n            return Loci.isEmpty(ys);\r\n        var map = new Map();\r\n        for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            map.set(e.unit.id, e.indices);\r\n        }\r\n        for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            if (!map.has(e.unit.id))\r\n                continue;\r\n            if (OrderedSet.areIntersecting(map.get(e.unit.id), e.indices))\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    Loci.areIntersecting = areIntersecting;\r\n    /** Check if second loci is a subset of the first */\r\n    function isSubset(xs, ys) {\r\n        if (Loci.isEmpty(xs))\r\n            return Loci.isEmpty(ys);\r\n        var map = new Map();\r\n        for (var _a = 0, _b = xs.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            map.set(e.unit.id, e.indices);\r\n        }\r\n        var isSubset = false;\r\n        for (var _c = 0, _d = ys.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            if (!map.has(e.unit.id))\r\n                continue;\r\n            if (!OrderedSet.isSubset(map.get(e.unit.id), e.indices))\r\n                return false;\r\n            else\r\n                isSubset = true;\r\n        }\r\n        return isSubset;\r\n    }\r\n    Loci.isSubset = isSubset;\r\n    function makeIndexSet(newIndices) {\r\n        if (newIndices.length > 3 && SortedArray.isRange(newIndices)) {\r\n            return Interval.ofRange(newIndices[0], newIndices[newIndices.length - 1]);\r\n        }\r\n        else {\r\n            return SortedArray.ofSortedArray(newIndices);\r\n        }\r\n    }\r\n    function extendToWholeResidues(loci, restrictToConformation) {\r\n        var elements = [];\r\n        var residueAltIds = new Set();\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var lociElement = _b[_a];\r\n            if (isWholeUnit(lociElement)) {\r\n                elements[elements.length] = lociElement;\r\n                continue;\r\n            }\r\n            if (lociElement.unit.kind === 0 /* Atomic */) {\r\n                var unitElements = lociElement.unit.elements;\r\n                var h = lociElement.unit.model.atomicHierarchy;\r\n                var label_alt_id = lociElement.unit.model.atomicHierarchy.atoms.label_alt_id;\r\n                var _c = h.residueAtomSegments, residueIndex = _c.index, residueOffsets = _c.offsets;\r\n                var newIndices = [];\r\n                var indices = lociElement.indices, len = OrderedSet.size(indices);\r\n                var i = 0;\r\n                while (i < len) {\r\n                    residueAltIds.clear();\r\n                    var eI = unitElements[OrderedSet.getAt(indices, i)];\r\n                    var rI = residueIndex[eI];\r\n                    residueAltIds.add(label_alt_id.value(eI));\r\n                    i++;\r\n                    while (i < len) {\r\n                        var eI_1 = unitElements[OrderedSet.getAt(indices, i)];\r\n                        if (residueIndex[eI_1] !== rI)\r\n                            break;\r\n                        residueAltIds.add(label_alt_id.value(eI_1));\r\n                        i++;\r\n                    }\r\n                    var hasSharedAltId = residueAltIds.has('');\r\n                    for (var j = residueOffsets[rI], _j = residueOffsets[rI + 1]; j < _j; j++) {\r\n                        var idx = OrderedSet.indexOf(unitElements, j);\r\n                        if (idx >= 0) {\r\n                            var altId = label_alt_id.value(j);\r\n                            if (!restrictToConformation || hasSharedAltId || !altId || residueAltIds.has(altId)) {\r\n                                newIndices[newIndices.length] = idx;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                elements[elements.length] = { unit: lociElement.unit, indices: makeIndexSet(newIndices) };\r\n            }\r\n            else {\r\n                // coarse elements are already by-residue\r\n                elements[elements.length] = lociElement;\r\n            }\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToWholeResidues = extendToWholeResidues;\r\n    function getChainSegments(unit) {\r\n        switch (unit.kind) {\r\n            case 0 /* Atomic */: return unit.model.atomicHierarchy.chainAtomSegments;\r\n            case 1 /* Spheres */: return unit.model.coarseHierarchy.spheres.chainElementSegments;\r\n            case 2 /* Gaussians */: return unit.model.coarseHierarchy.gaussians.chainElementSegments;\r\n        }\r\n    }\r\n    function isWholeUnit(element) {\r\n        return element.unit.elements.length === OrderedSet.size(element.indices);\r\n    }\r\n    function collectChains(unit, chainIndices, elements) {\r\n        var index = getChainSegments(unit).index;\r\n        var xs = unit.elements;\r\n        var size = 0;\r\n        for (var i = 0, _i = xs.length; i < _i; i++) {\r\n            var eI = xs[i];\r\n            var cI = index[eI];\r\n            if (!chainIndices.has(cI))\r\n                continue;\r\n            size++;\r\n        }\r\n        if (size === unit.elements.length) {\r\n            elements[elements.length] = { unit: unit, indices: Interval.ofBounds(0, size) };\r\n            return;\r\n        }\r\n        var newIndices = new Int32Array(size);\r\n        size = 0;\r\n        for (var i = 0, _i = xs.length; i < _i; i++) {\r\n            var eI = xs[i];\r\n            var cI = index[eI];\r\n            if (!chainIndices.has(cI))\r\n                continue;\r\n            newIndices[size++] = i;\r\n        }\r\n        if (newIndices.length > 0) {\r\n            elements[elements.length] = { unit: unit, indices: makeIndexSet(newIndices) };\r\n        }\r\n    }\r\n    function extendGroupToWholeChains(loci, start, end, isPartitioned, elements) {\r\n        var chainIndex = getChainSegments(loci.elements[0].unit).index;\r\n        var chainIndices = new Set();\r\n        for (var lI = start; lI < end; lI++) {\r\n            var lociElement = loci.elements[lI];\r\n            var indices = lociElement.indices;\r\n            var unitElements = lociElement.unit.elements;\r\n            for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\r\n                chainIndices.add(chainIndex[unitElements[OrderedSet.getAt(indices, i)]]);\r\n            }\r\n        }\r\n        if (isPartitioned) {\r\n            var baseUnit = loci.elements[0].unit;\r\n            // TODO: check for accidental quadratic for really large structures (but should be ok).\r\n            for (var _a = 0, _b = loci.structure.units; _a < _b.length; _a++) {\r\n                var unit = _b[_a];\r\n                if (!Unit.areSameChainOperatorGroup(unit, baseUnit))\r\n                    continue;\r\n                collectChains(unit, chainIndices, elements);\r\n            }\r\n        }\r\n        else {\r\n            for (var lI = start; lI < end; lI++) {\r\n                collectChains(loci.elements[lI].unit, chainIndices, elements);\r\n            }\r\n        }\r\n    }\r\n    function extendToWholeChains(loci) {\r\n        var elements = [];\r\n        for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n            var e = loci.elements[i];\r\n            if (Unit.Traits.is(e.unit.traits, 2 /* Partitioned */)) {\r\n                var start = i;\r\n                while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {\r\n                    i++;\r\n                }\r\n                var end = i;\r\n                i--;\r\n                extendGroupToWholeChains(loci, start, end, true, elements);\r\n            }\r\n            else {\r\n                if (isWholeUnit(e)) {\r\n                    elements[elements.length] = e;\r\n                }\r\n                else {\r\n                    extendGroupToWholeChains(loci, i, i + 1, false, elements);\r\n                }\r\n            }\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToWholeChains = extendToWholeChains;\r\n    function entityModelKey(location) {\r\n        return location.unit.model.id + \"|\" + StructureProperties.entity.id(location);\r\n    }\r\n    function extendToWholeEntities(loci) {\r\n        var elements = [];\r\n        var l = Location.create(loci.structure);\r\n        var entities = new Set();\r\n        var units = loci.structure.units;\r\n        for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n            var e = loci.elements[i];\r\n            l.unit = e.unit;\r\n            l.element = e.unit.elements[0];\r\n            entities.add(entityModelKey(l));\r\n        }\r\n        for (var i = 0, il = units.length; i < il; ++i) {\r\n            var unit = units[i];\r\n            l.unit = unit;\r\n            l.element = unit.elements[0];\r\n            if (entities.has(entityModelKey(l))) {\r\n                var indices = OrderedSet.ofBounds(0, unit.elements.length);\r\n                elements[elements.length] = { unit: unit, indices: indices };\r\n            }\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToWholeEntities = extendToWholeEntities;\r\n    function extendToWholeModels(loci) {\r\n        var elements = [];\r\n        var models = new Set();\r\n        var units = loci.structure.units;\r\n        for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n            var e = loci.elements[i];\r\n            models.add(e.unit.model.id);\r\n        }\r\n        for (var i = 0, il = units.length; i < il; ++i) {\r\n            var unit = units[i];\r\n            if (models.has(unit.model.id)) {\r\n                var indices = OrderedSet.ofBounds(0, unit.elements.length);\r\n                elements[elements.length] = { unit: unit, indices: indices };\r\n            }\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToWholeModels = extendToWholeModels;\r\n    function getElementIndices(elements, indices) {\r\n        var elementIndices = [];\r\n        for (var i = 0, il = OrderedSet.size(indices); i < il; ++i) {\r\n            elementIndices.push(elements[OrderedSet.getAt(indices, i)]);\r\n        }\r\n        return SortedArray.ofSortedArray(elementIndices);\r\n    }\r\n    function getUnitIndices(elements, indices) {\r\n        if (SortedArray.isRange(elements) && SortedArray.areEqual(elements, indices)) {\r\n            return Interval.ofLength(elements.length);\r\n        }\r\n        return makeIndexSet(SortedArray.indicesOf(elements, indices));\r\n    }\r\n    function extendToAllInstances(loci) {\r\n        var elements = [];\r\n        var byModel = new Map();\r\n        for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n            var e = loci.elements[i];\r\n            var model = e.unit.model;\r\n            var elementIndices = getElementIndices(e.unit.elements, e.indices);\r\n            if (byModel.has(model)) {\r\n                byModel.set(model, SortedArray.union(elementIndices, byModel.get(model)));\r\n            }\r\n            else {\r\n                byModel.set(model, elementIndices);\r\n            }\r\n        }\r\n        for (var i = 0, il = loci.structure.units.length; i < il; ++i) {\r\n            var unit = loci.structure.units[i];\r\n            var elementIndices = byModel.get(unit.model);\r\n            if (!elementIndices)\r\n                continue;\r\n            var indices = getUnitIndices(unit.elements, elementIndices);\r\n            elements[elements.length] = { unit: unit, indices: indices };\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToAllInstances = extendToAllInstances;\r\n    function extendToWholeOperators(loci) {\r\n        var elements = [];\r\n        var operators = new Set();\r\n        var units = loci.structure.units;\r\n        for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n            var e = loci.elements[i];\r\n            operators.add(e.unit.conformation.operator.name);\r\n        }\r\n        for (var i = 0, il = units.length; i < il; ++i) {\r\n            var unit = units[i];\r\n            if (operators.has(unit.conformation.operator.name)) {\r\n                var indices = OrderedSet.ofBounds(0, unit.elements.length);\r\n                elements[elements.length] = { unit: unit, indices: indices };\r\n            }\r\n        }\r\n        return Loci(loci.structure, elements);\r\n    }\r\n    Loci.extendToWholeOperators = extendToWholeOperators;\r\n    //\r\n    var boundaryHelper = new BoundaryHelper('98');\r\n    var tempPosBoundary = Vec3();\r\n    function getBoundary(loci, transform) {\r\n        boundaryHelper.reset();\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            var indices = e.indices;\r\n            var pos = e.unit.conformation.position, r = e.unit.conformation.r;\r\n            var elements = e.unit.elements;\r\n            for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\r\n                var eI = elements[OrderedSet.getAt(indices, i)];\r\n                pos(eI, tempPosBoundary);\r\n                if (transform)\r\n                    Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);\r\n                boundaryHelper.includePositionRadius(tempPosBoundary, r(eI));\r\n            }\r\n        }\r\n        boundaryHelper.finishedIncludeStep();\r\n        for (var _c = 0, _d = loci.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            var indices = e.indices;\r\n            var pos = e.unit.conformation.position, r = e.unit.conformation.r;\r\n            var elements = e.unit.elements;\r\n            for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\r\n                var eI = elements[OrderedSet.getAt(indices, i)];\r\n                pos(eI, tempPosBoundary);\r\n                if (transform)\r\n                    Vec3.transformMat4(tempPosBoundary, tempPosBoundary, transform);\r\n                boundaryHelper.radiusPositionRadius(tempPosBoundary, r(eI));\r\n            }\r\n        }\r\n        return { box: boundaryHelper.getBox(), sphere: boundaryHelper.getSphere() };\r\n    }\r\n    Loci.getBoundary = getBoundary;\r\n    var tempPos = Vec3();\r\n    function toPositionsArray(loci, positions, offset) {\r\n        if (offset === void 0) { offset = 0; }\r\n        var m = offset;\r\n        for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n            var e = _b[_a];\r\n            var indices = e.indices;\r\n            var pos = e.unit.conformation.position;\r\n            var elements = e.unit.elements;\r\n            var indexCount = OrderedSet.size(indices);\r\n            for (var i = 0; i < indexCount; i++) {\r\n                var eI = elements[OrderedSet.getAt(indices, i)];\r\n                pos(eI, tempPos);\r\n                Vec3.toArray(tempPos, positions, m + i * 3);\r\n            }\r\n            m += indexCount * 3;\r\n        }\r\n        return positions;\r\n    }\r\n    Loci.toPositionsArray = toPositionsArray;\r\n    function getPrincipalAxes(loci) {\r\n        var elementCount = size(loci);\r\n        var positions = toPositionsArray(loci, new Float32Array(3 * elementCount));\r\n        return PrincipalAxes.ofPositions(positions);\r\n    }\r\n    Loci.getPrincipalAxes = getPrincipalAxes;\r\n    function sourceIndex(unit, element) {\r\n        return Unit.isAtomic(unit)\r\n            ? unit.model.atomicHierarchy.atomSourceIndex.value(element)\r\n            // TODO: when implemented, this should map to the source index.\r\n            : element;\r\n    }\r\n    function toExpression(loci) {\r\n        var _a;\r\n        if (Loci.isEmpty(loci))\r\n            return MS.struct.generator.empty();\r\n        var models = loci.structure.models;\r\n        var sourceIndexMap = new Map();\r\n        for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\r\n            var e = _c[_b];\r\n            var indices = e.indices;\r\n            var elements = e.unit.elements;\r\n            var key = e.unit.conformation.operator.name;\r\n            var sourceIndices = void 0;\r\n            if (sourceIndexMap.has(key))\r\n                sourceIndices = sourceIndexMap.get(key).xs;\r\n            else {\r\n                sourceIndices = UniqueArray.create();\r\n                sourceIndexMap.set(key, { modelLabel: e.unit.model.label, modelIndex: e.unit.model.modelNum, xs: sourceIndices });\r\n            }\r\n            for (var i = 0, _i = OrderedSet.size(indices); i < _i; i++) {\r\n                var idx = sourceIndex(e.unit, elements[OrderedSet.getAt(indices, i)]);\r\n                UniqueArray.add(sourceIndices, idx, idx);\r\n            }\r\n        }\r\n        var opData = [];\r\n        var keys = sourceIndexMap.keys();\r\n        while (true) {\r\n            var k = keys.next();\r\n            if (k.done)\r\n                break;\r\n            var e = sourceIndexMap.get(k.value);\r\n            opData.push(getOpData(k.value, e.xs.array, models.length > 1, e.modelLabel, e.modelIndex));\r\n        }\r\n        var opGroups = new Map();\r\n        for (var i = 0, il = opData.length; i < il; ++i) {\r\n            var d = opData[i];\r\n            var hash = hash2(hashFnv32a(d.atom.ranges), hashFnv32a(d.atom.set));\r\n            var key = hash + \"|\" + (d.entity ? (d.entity.modelLabel + d.entity.modelIndex) : '');\r\n            if (opGroups.has(key)) {\r\n                (_a = opGroups.get(key).chain.opName).push.apply(_a, d.chain.opName);\r\n            }\r\n            else {\r\n                opGroups.set(key, d);\r\n            }\r\n        }\r\n        var opQueries = [];\r\n        opGroups.forEach(function (d) {\r\n            var _a = d.atom, ranges = _a.ranges, set = _a.set;\r\n            var opName = d.chain.opName;\r\n            var opProp = MS.struct.atomProperty.core.operatorName();\r\n            var siProp = MS.struct.atomProperty.core.sourceIndex();\r\n            var tests = [];\r\n            // TODO: add set.ofRanges constructor to MolQL???\r\n            if (set.length > 0) {\r\n                tests[tests.length] = MS.core.set.has([MS.core.type.set(set), siProp]);\r\n            }\r\n            for (var rI = 0, _rI = ranges.length / 2; rI < _rI; rI++) {\r\n                tests[tests.length] = MS.core.rel.inRange([siProp, ranges[2 * rI], ranges[2 * rI + 1]]);\r\n            }\r\n            if (d.entity) {\r\n                var _b = d.entity, modelLabel = _b.modelLabel, modelIndex = _b.modelIndex;\r\n                opQueries.push(MS.struct.generator.atomGroups({\r\n                    'atom-test': tests.length > 1 ? MS.core.logic.or(tests) : tests[0],\r\n                    'chain-test': opName.length > 1\r\n                        ? MS.core.set.has([MS.core.type.set(opName), opProp])\r\n                        : MS.core.rel.eq([opProp, opName[0]]),\r\n                    'entity-test': MS.core.logic.and([\r\n                        MS.core.rel.eq([MS.struct.atomProperty.core.modelLabel(), modelLabel]),\r\n                        MS.core.rel.eq([MS.struct.atomProperty.core.modelIndex(), modelIndex]),\r\n                    ])\r\n                }));\r\n            }\r\n            else {\r\n                opQueries.push(MS.struct.generator.atomGroups({\r\n                    'atom-test': tests.length > 1 ? MS.core.logic.or(tests) : tests[0],\r\n                    'chain-test': opName.length > 1\r\n                        ? MS.core.set.has([MS.core.type.set(opName), opProp])\r\n                        : MS.core.rel.eq([opProp, opName[0]])\r\n                }));\r\n            }\r\n        });\r\n        return MS.struct.modifier.union([\r\n            opQueries.length === 1\r\n                ? opQueries[0]\r\n                // Need to union before merge for fast performance\r\n                : MS.struct.combinator.merge(opQueries.map(function (q) { return MS.struct.modifier.union([q]); }))\r\n        ]);\r\n    }\r\n    Loci.toExpression = toExpression;\r\n    function getOpData(opName, xs, multimodel, modelLabel, modelIndex) {\r\n        sortArray(xs);\r\n        var ranges = [];\r\n        var set = [];\r\n        var i = 0;\r\n        var len = xs.length;\r\n        while (i < len) {\r\n            var start = i;\r\n            i++;\r\n            while (i < len && xs[i - 1] + 1 === xs[i])\r\n                i++;\r\n            var end = i;\r\n            // TODO: is this a good value?\r\n            if (end - start > 12) {\r\n                ranges[ranges.length] = xs[start];\r\n                ranges[ranges.length] = xs[end - 1];\r\n            }\r\n            else {\r\n                for (var j = start; j < end; j++) {\r\n                    set[set.length] = xs[j];\r\n                }\r\n            }\r\n        }\r\n        return multimodel\r\n            ? {\r\n                atom: { set: set, ranges: ranges },\r\n                chain: { opName: [opName] },\r\n                entity: { modelLabel: modelLabel, modelIndex: modelIndex }\r\n            }\r\n            : {\r\n                atom: { set: set, ranges: ranges },\r\n                chain: { opName: [opName] },\r\n            };\r\n    }\r\n})(Loci || (Loci = {}));\r\n//# sourceMappingURL=loci.js.map"]},"metadata":{},"sourceType":"module"}