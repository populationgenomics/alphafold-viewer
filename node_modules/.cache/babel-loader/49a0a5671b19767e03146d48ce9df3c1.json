{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Unit } from '../../../../mol-model/structure';\nimport { Segmentation, OrderedSet, Interval, SortedArray } from '../../../../mol-data/int';\nimport { SortedRanges } from '../../../../mol-data/int/sorted-ranges';\nimport { isNucleic, isProtein } from '../../../../mol-model/structure/model/types';\nexport function getAtomicPolymerElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model;\n  var residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\n  var traceElementIndex = model.atomicHierarchy.derived.residue.traceElementIndex;\n  var polymerIt = SortedRanges.transientSegments(unit.model.atomicRanges.polymerRanges, elements);\n  var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\n\n  while (polymerIt.hasNext) {\n    var polymerSegment = polymerIt.move();\n    residueIt.setSegment(polymerSegment);\n\n    while (residueIt.hasNext) {\n      var residueSegment = residueIt.move();\n      var start = residueSegment.start,\n          end = residueSegment.end,\n          index = residueSegment.index;\n\n      if (OrderedSet.areIntersecting(Interval.ofRange(elements[start], elements[end - 1]), elements)) {\n        var elementIndex = traceElementIndex[index];\n        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\n      }\n    }\n  }\n\n  return SortedArray.ofSortedArray(indices);\n}\nexport function getCoarsePolymerElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model;\n  var _a = model.coarseHierarchy,\n      spheres = _a.spheres,\n      gaussians = _a.gaussians;\n  var polymerRanges = Unit.isSpheres(unit) ? spheres.polymerRanges : gaussians.polymerRanges;\n  var polymerIt = SortedRanges.transientSegments(polymerRanges, elements);\n\n  while (polymerIt.hasNext) {\n    var _b = polymerIt.move(),\n        start = _b.start,\n        end = _b.end;\n\n    for (var i = start; i < end; ++i) {\n      indices.push(elements[i]);\n    }\n  }\n\n  return SortedArray.ofSortedArray(indices);\n} //\n\nexport function getAtomicGapElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model,\n      residueIndex = unit.residueIndex;\n  var residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\n  var traceElementIndex = model.atomicHierarchy.derived.residue.traceElementIndex;\n  var gapIt = SortedRanges.transientSegments(unit.model.atomicRanges.gapRanges, unit.elements);\n\n  while (gapIt.hasNext) {\n    var gapSegment = gapIt.move();\n    var indexStart = residueIndex[elements[gapSegment.start]];\n    var indexEnd = residueIndex[elements[gapSegment.end - 1]];\n    var elementIndexStart = traceElementIndex[indexStart];\n    var elementIndexEnd = traceElementIndex[indexEnd];\n    indices.push(elementIndexStart === -1 ? residueAtomSegments.offsets[indexStart] : elementIndexStart);\n    indices.push(elementIndexEnd === -1 ? residueAtomSegments.offsets[indexEnd] : elementIndexEnd);\n  }\n\n  return SortedArray.ofSortedArray(indices);\n}\nexport function getCoarseGapElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model;\n  var _a = model.coarseHierarchy,\n      spheres = _a.spheres,\n      gaussians = _a.gaussians;\n  var gapRanges = Unit.isSpheres(unit) ? spheres.gapRanges : gaussians.gapRanges;\n  var gapIt = SortedRanges.transientSegments(gapRanges, elements);\n\n  while (gapIt.hasNext) {\n    var _b = gapIt.move(),\n        start = _b.start,\n        end = _b.end;\n\n    indices.push(elements[start], elements[end - 1]);\n  }\n\n  return SortedArray.ofSortedArray(indices);\n} //\n\nexport function getNucleotideElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model;\n  var _a = model.atomicHierarchy,\n      chainAtomSegments = _a.chainAtomSegments,\n      residueAtomSegments = _a.residueAtomSegments;\n  var _b = model.atomicHierarchy.derived.residue,\n      moleculeType = _b.moleculeType,\n      traceElementIndex = _b.traceElementIndex;\n  var chainIt = Segmentation.transientSegments(chainAtomSegments, elements);\n  var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\n\n  while (chainIt.hasNext) {\n    residueIt.setSegment(chainIt.move());\n\n    while (residueIt.hasNext) {\n      var index = residueIt.move().index;\n\n      if (isNucleic(moleculeType[index])) {\n        var elementIndex = traceElementIndex[index];\n        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\n      }\n    }\n  }\n\n  return SortedArray.ofSortedArray(indices);\n}\nexport function getProteinElements(unit) {\n  var indices = [];\n  var elements = unit.elements,\n      model = unit.model;\n  var _a = model.atomicHierarchy,\n      chainAtomSegments = _a.chainAtomSegments,\n      residueAtomSegments = _a.residueAtomSegments;\n  var _b = model.atomicHierarchy.derived.residue,\n      moleculeType = _b.moleculeType,\n      traceElementIndex = _b.traceElementIndex;\n  var chainIt = Segmentation.transientSegments(chainAtomSegments, elements);\n  var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\n\n  while (chainIt.hasNext) {\n    residueIt.setSegment(chainIt.move());\n\n    while (residueIt.hasNext) {\n      var index = residueIt.move().index;\n\n      if (isProtein(moleculeType[index])) {\n        var elementIndex = traceElementIndex[index];\n        indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\n      }\n    }\n  }\n\n  return SortedArray.ofSortedArray(indices);\n}","map":{"version":3,"sources":["../../../../../src/mol-model/structure/structure/util/polymer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Unit } from '../../../../mol-model/structure';\r\nimport { Segmentation, OrderedSet, Interval, SortedArray } from '../../../../mol-data/int';\r\nimport { SortedRanges } from '../../../../mol-data/int/sorted-ranges';\r\nimport { isNucleic, isProtein } from '../../../../mol-model/structure/model/types';\r\nexport function getAtomicPolymerElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model;\r\n    var residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\r\n    var traceElementIndex = model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var polymerIt = SortedRanges.transientSegments(unit.model.atomicRanges.polymerRanges, elements);\r\n    var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\r\n    while (polymerIt.hasNext) {\r\n        var polymerSegment = polymerIt.move();\r\n        residueIt.setSegment(polymerSegment);\r\n        while (residueIt.hasNext) {\r\n            var residueSegment = residueIt.move();\r\n            var start = residueSegment.start, end = residueSegment.end, index = residueSegment.index;\r\n            if (OrderedSet.areIntersecting(Interval.ofRange(elements[start], elements[end - 1]), elements)) {\r\n                var elementIndex = traceElementIndex[index];\r\n                indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\r\n            }\r\n        }\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\nexport function getCoarsePolymerElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model;\r\n    var _a = model.coarseHierarchy, spheres = _a.spheres, gaussians = _a.gaussians;\r\n    var polymerRanges = Unit.isSpheres(unit) ? spheres.polymerRanges : gaussians.polymerRanges;\r\n    var polymerIt = SortedRanges.transientSegments(polymerRanges, elements);\r\n    while (polymerIt.hasNext) {\r\n        var _b = polymerIt.move(), start = _b.start, end = _b.end;\r\n        for (var i = start; i < end; ++i) {\r\n            indices.push(elements[i]);\r\n        }\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\n//\r\nexport function getAtomicGapElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model, residueIndex = unit.residueIndex;\r\n    var residueAtomSegments = unit.model.atomicHierarchy.residueAtomSegments;\r\n    var traceElementIndex = model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var gapIt = SortedRanges.transientSegments(unit.model.atomicRanges.gapRanges, unit.elements);\r\n    while (gapIt.hasNext) {\r\n        var gapSegment = gapIt.move();\r\n        var indexStart = residueIndex[elements[gapSegment.start]];\r\n        var indexEnd = residueIndex[elements[gapSegment.end - 1]];\r\n        var elementIndexStart = traceElementIndex[indexStart];\r\n        var elementIndexEnd = traceElementIndex[indexEnd];\r\n        indices.push(elementIndexStart === -1 ? residueAtomSegments.offsets[indexStart] : elementIndexStart);\r\n        indices.push(elementIndexEnd === -1 ? residueAtomSegments.offsets[indexEnd] : elementIndexEnd);\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\nexport function getCoarseGapElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model;\r\n    var _a = model.coarseHierarchy, spheres = _a.spheres, gaussians = _a.gaussians;\r\n    var gapRanges = Unit.isSpheres(unit) ? spheres.gapRanges : gaussians.gapRanges;\r\n    var gapIt = SortedRanges.transientSegments(gapRanges, elements);\r\n    while (gapIt.hasNext) {\r\n        var _b = gapIt.move(), start = _b.start, end = _b.end;\r\n        indices.push(elements[start], elements[end - 1]);\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\n//\r\nexport function getNucleotideElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model;\r\n    var _a = model.atomicHierarchy, chainAtomSegments = _a.chainAtomSegments, residueAtomSegments = _a.residueAtomSegments;\r\n    var _b = model.atomicHierarchy.derived.residue, moleculeType = _b.moleculeType, traceElementIndex = _b.traceElementIndex;\r\n    var chainIt = Segmentation.transientSegments(chainAtomSegments, elements);\r\n    var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\r\n    while (chainIt.hasNext) {\r\n        residueIt.setSegment(chainIt.move());\r\n        while (residueIt.hasNext) {\r\n            var index = residueIt.move().index;\r\n            if (isNucleic(moleculeType[index])) {\r\n                var elementIndex = traceElementIndex[index];\r\n                indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\r\n            }\r\n        }\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\nexport function getProteinElements(unit) {\r\n    var indices = [];\r\n    var elements = unit.elements, model = unit.model;\r\n    var _a = model.atomicHierarchy, chainAtomSegments = _a.chainAtomSegments, residueAtomSegments = _a.residueAtomSegments;\r\n    var _b = model.atomicHierarchy.derived.residue, moleculeType = _b.moleculeType, traceElementIndex = _b.traceElementIndex;\r\n    var chainIt = Segmentation.transientSegments(chainAtomSegments, elements);\r\n    var residueIt = Segmentation.transientSegments(residueAtomSegments, elements);\r\n    while (chainIt.hasNext) {\r\n        residueIt.setSegment(chainIt.move());\r\n        while (residueIt.hasNext) {\r\n            var index = residueIt.move().index;\r\n            if (isProtein(moleculeType[index])) {\r\n                var elementIndex = traceElementIndex[index];\r\n                indices.push(elementIndex === -1 ? residueAtomSegments.offsets[index] : elementIndex);\r\n            }\r\n        }\r\n    }\r\n    return SortedArray.ofSortedArray(indices);\r\n}\r\n//# sourceMappingURL=polymer.js.map"]},"metadata":{},"sourceType":"module"}