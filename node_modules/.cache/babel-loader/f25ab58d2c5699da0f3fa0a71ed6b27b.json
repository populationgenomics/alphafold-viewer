{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\"; // adapted from three.js, MIT License Copyright 2010-2018 three.js authors\n\nimport { Vec3 } from '../../mol-math/linear-algebra';\nimport { computeIndexedVertexNormals, appplyRadius } from '../util';\nexport var DefaultPolyhedronProps = {\n  radius: 1,\n  detail: 0\n};\nexport function Polyhedron(_vertices, _indices, props) {\n  var _a = __assign(__assign({}, DefaultPolyhedronProps), props),\n      radius = _a.radius,\n      detail = _a.detail;\n\n  var builder = createBuilder();\n  var vertices = builder.vertices,\n      indices = builder.indices; // the subdivision creates the vertex buffer data\n\n  subdivide(detail); // all vertices should lie on a conceptual sphere with a given radius\n\n  appplyRadius(vertices, radius);\n  var normals = new Float32Array(vertices.length);\n  computeIndexedVertexNormals(vertices, indices, normals, vertices.length / 3, indices.length / 3);\n  return {\n    vertices: new Float32Array(vertices),\n    normals: new Float32Array(normals),\n    indices: new Uint32Array(indices)\n  }; // helper functions\n\n  function subdivide(detail) {\n    var a = Vec3();\n    var b = Vec3();\n    var c = Vec3(); // iterate over all faces and apply a subdivison with the given detail value\n\n    for (var i = 0; i < _indices.length; i += 3) {\n      // get the vertices of the face\n      Vec3.fromArray(a, _vertices, _indices[i + 0] * 3);\n      Vec3.fromArray(b, _vertices, _indices[i + 1] * 3);\n      Vec3.fromArray(c, _vertices, _indices[i + 2] * 3); // perform subdivision\n\n      subdivideFace(a, b, c, detail);\n    }\n  }\n\n  function subdivideFace(a, b, c, detail) {\n    var cols = Math.pow(2, detail); // we use this multidimensional array as a data structure for creating the subdivision\n\n    var v = []; // construct all of the vertices for this subdivision\n\n    for (var i = 0; i <= cols; ++i) {\n      v[i] = [];\n      var aj = Vec3();\n      Vec3.lerp(aj, a, c, i / cols);\n      var bj = Vec3();\n      Vec3.lerp(bj, b, c, i / cols);\n      var rows = cols - i;\n\n      for (var j = 0; j <= rows; ++j) {\n        if (j === 0 && i === cols) {\n          v[i][j] = aj;\n        } else {\n          var abj = Vec3();\n          Vec3.lerp(abj, aj, bj, j / rows);\n          v[i][j] = abj;\n        }\n      }\n    } // construct all of the faces\n\n\n    for (var i = 0; i < cols; ++i) {\n      for (var j = 0; j < 2 * (cols - i) - 1; ++j) {\n        var k = Math.floor(j / 2);\n\n        if (j % 2 === 0) {\n          builder.add(v[i][k + 1], v[i + 1][k], v[i][k]);\n        } else {\n          builder.add(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);\n        }\n      }\n    }\n  }\n}\n\nfunction createBuilder() {\n  var vertices = [];\n  var indices = [];\n  var vertexMap = new Map();\n\n  function addVertex(v) {\n    var key = v[0].toFixed(5) + \"|\" + v[1].toFixed(5) + \"|\" + v[2].toFixed(5);\n    var idx = vertexMap.get(key);\n\n    if (idx === undefined) {\n      idx = vertices.length / 3;\n      vertexMap.set(key, idx);\n      vertices.push.apply(vertices, v);\n    }\n\n    return idx;\n  }\n\n  return {\n    vertices: vertices,\n    indices: indices,\n    add: function (v1, v2, v3) {\n      indices.push(addVertex(v1), addVertex(v2), addVertex(v3));\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/mol-geo/primitive/polyhedron.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\n// adapted from three.js, MIT License Copyright 2010-2018 three.js authors\r\nimport { Vec3 } from '../../mol-math/linear-algebra';\r\nimport { computeIndexedVertexNormals, appplyRadius } from '../util';\r\nexport var DefaultPolyhedronProps = {\r\n    radius: 1,\r\n    detail: 0\r\n};\r\nexport function Polyhedron(_vertices, _indices, props) {\r\n    var _a = __assign(__assign({}, DefaultPolyhedronProps), props), radius = _a.radius, detail = _a.detail;\r\n    var builder = createBuilder();\r\n    var vertices = builder.vertices, indices = builder.indices;\r\n    // the subdivision creates the vertex buffer data\r\n    subdivide(detail);\r\n    // all vertices should lie on a conceptual sphere with a given radius\r\n    appplyRadius(vertices, radius);\r\n    var normals = new Float32Array(vertices.length);\r\n    computeIndexedVertexNormals(vertices, indices, normals, vertices.length / 3, indices.length / 3);\r\n    return {\r\n        vertices: new Float32Array(vertices),\r\n        normals: new Float32Array(normals),\r\n        indices: new Uint32Array(indices)\r\n    };\r\n    // helper functions\r\n    function subdivide(detail) {\r\n        var a = Vec3();\r\n        var b = Vec3();\r\n        var c = Vec3();\r\n        // iterate over all faces and apply a subdivison with the given detail value\r\n        for (var i = 0; i < _indices.length; i += 3) {\r\n            // get the vertices of the face\r\n            Vec3.fromArray(a, _vertices, _indices[i + 0] * 3);\r\n            Vec3.fromArray(b, _vertices, _indices[i + 1] * 3);\r\n            Vec3.fromArray(c, _vertices, _indices[i + 2] * 3);\r\n            // perform subdivision\r\n            subdivideFace(a, b, c, detail);\r\n        }\r\n    }\r\n    function subdivideFace(a, b, c, detail) {\r\n        var cols = Math.pow(2, detail);\r\n        // we use this multidimensional array as a data structure for creating the subdivision\r\n        var v = [];\r\n        // construct all of the vertices for this subdivision\r\n        for (var i = 0; i <= cols; ++i) {\r\n            v[i] = [];\r\n            var aj = Vec3();\r\n            Vec3.lerp(aj, a, c, i / cols);\r\n            var bj = Vec3();\r\n            Vec3.lerp(bj, b, c, i / cols);\r\n            var rows = cols - i;\r\n            for (var j = 0; j <= rows; ++j) {\r\n                if (j === 0 && i === cols) {\r\n                    v[i][j] = aj;\r\n                }\r\n                else {\r\n                    var abj = Vec3();\r\n                    Vec3.lerp(abj, aj, bj, j / rows);\r\n                    v[i][j] = abj;\r\n                }\r\n            }\r\n        }\r\n        // construct all of the faces\r\n        for (var i = 0; i < cols; ++i) {\r\n            for (var j = 0; j < 2 * (cols - i) - 1; ++j) {\r\n                var k = Math.floor(j / 2);\r\n                if (j % 2 === 0) {\r\n                    builder.add(v[i][k + 1], v[i + 1][k], v[i][k]);\r\n                }\r\n                else {\r\n                    builder.add(v[i][k + 1], v[i + 1][k + 1], v[i + 1][k]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction createBuilder() {\r\n    var vertices = [];\r\n    var indices = [];\r\n    var vertexMap = new Map();\r\n    function addVertex(v) {\r\n        var key = v[0].toFixed(5) + \"|\" + v[1].toFixed(5) + \"|\" + v[2].toFixed(5);\r\n        var idx = vertexMap.get(key);\r\n        if (idx === undefined) {\r\n            idx = vertices.length / 3;\r\n            vertexMap.set(key, idx);\r\n            vertices.push.apply(vertices, v);\r\n        }\r\n        return idx;\r\n    }\r\n    return {\r\n        vertices: vertices,\r\n        indices: indices,\r\n        add: function (v1, v2, v3) {\r\n            indices.push(addVertex(v1), addVertex(v2), addVertex(v3));\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=polyhedron.js.map"]},"metadata":{},"sourceType":"module"}