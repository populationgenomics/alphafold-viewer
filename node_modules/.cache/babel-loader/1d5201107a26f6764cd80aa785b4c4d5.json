{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { hashFnv32a } from '../../../mol-data/util';\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\nimport { calculateTransformBoundingSphere, createTextureImage } from '../../../mol-gl/renderable/util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { Vec2, Vec4, Vec3 } from '../../../mol-math/linear-algebra';\nimport { ValueCell } from '../../../mol-util';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { BaseGeometry } from '../base';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { fillSerial } from '../../../mol-util/array';\nimport { createEmptyClipping } from '../clipping-data';\nimport { NullLocation } from '../../../mol-model/location';\nimport { QuadPositions } from '../../../mol-gl/compute/util';\nvar QuadIndices = new Uint32Array([0, 1, 2, 1, 3, 2]);\nvar QuadUvs = new Float32Array([0, 1, 0, 0, 1, 1, 1, 0]);\nexport var InterpolationTypes = {\n  'nearest': 'Nearest',\n  'catmulrom': 'Catmulrom (Cubic)',\n  'mitchell': 'Mitchell (Cubic)',\n  'bspline': 'B-Spline (Cubic)'\n};\nexport var InterpolationTypeNames = Object.keys(InterpolationTypes);\nexport { Image };\nvar Image;\n\n(function (Image) {\n  function create(imageTexture, corners, groupTexture, image) {\n    return image ? update(imageTexture, corners, groupTexture, image) : fromData(imageTexture, corners, groupTexture);\n  }\n\n  Image.create = create;\n\n  function hashCode(image) {\n    return hashFnv32a([image.cornerBuffer.ref.version]);\n  }\n\n  function fromData(imageTexture, corners, groupTexture) {\n    var boundingSphere = Sphere3D();\n    var currentHash = -1;\n    var width = imageTexture.width;\n    var height = imageTexture.height;\n    var image = {\n      kind: 'image',\n      imageTexture: ValueCell.create(imageTexture),\n      imageTextureDim: ValueCell.create(Vec2.create(width, height)),\n      cornerBuffer: ValueCell.create(corners),\n      groupTexture: ValueCell.create(groupTexture),\n\n      get boundingSphere() {\n        var newHash = hashCode(image);\n\n        if (newHash !== currentHash) {\n          var b = getBoundingSphere(image.cornerBuffer.ref.value);\n          Sphere3D.copy(boundingSphere, b);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      }\n\n    };\n    return image;\n  }\n\n  function update(imageTexture, corners, groupTexture, image) {\n    var width = imageTexture.width;\n    var height = imageTexture.height;\n    ValueCell.update(image.imageTexture, imageTexture);\n    ValueCell.update(image.imageTextureDim, Vec2.set(image.imageTextureDim.ref.value, width, height));\n    ValueCell.update(image.cornerBuffer, corners);\n    ValueCell.update(image.groupTexture, groupTexture);\n    return image;\n  }\n\n  function createEmpty(image) {\n    var imageTexture = createTextureImage(0, 4, Uint8Array);\n    var corners = image ? image.cornerBuffer.ref.value : new Float32Array(8 * 3);\n    var groupTexture = createTextureImage(0, 4, Uint8Array);\n    return create(imageTexture, corners, groupTexture, image);\n  }\n\n  Image.createEmpty = createEmpty;\n  Image.Params = __assign(__assign({}, BaseGeometry.Params), {\n    interpolation: PD.Select('bspline', PD.objectToOptions(InterpolationTypes))\n  });\n  Image.Utils = {\n    Params: Image.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: createRenderableState,\n    updateRenderableState: updateRenderableState,\n    createPositionIterator: function () {\n      return LocationIterator(1, 1, 1, function () {\n        return NullLocation;\n      });\n    }\n  };\n\n  function createValues(image, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = Image.Utils.createPositionIterator(image, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: QuadIndices.length,\n      vertexCount: QuadPositions.length / 3,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), {\n      aPosition: image.cornerBuffer,\n      aUv: ValueCell.create(QuadUvs),\n      elements: ValueCell.create(QuadIndices),\n      // aGroup is used as a vertex index here, group id is in tGroupTex\n      aGroup: ValueCell.create(fillSerial(new Float32Array(4))),\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)),\n      dInterpolation: ValueCell.create(props.interpolation),\n      uImageTexDim: image.imageTextureDim,\n      tImageTex: image.imageTexture,\n      tGroupTex: image.groupTexture\n    });\n  }\n\n  function createValuesSimple(image, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Image.Params)), props);\n\n    return createValues(image, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.dInterpolation, props.interpolation);\n  }\n\n  function updateBoundingSphere(values, image) {\n    var invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n\n  function createRenderableState(props) {\n    var state = BaseGeometry.createRenderableState(props);\n    state.opaque = false;\n    return state;\n  }\n\n  function updateRenderableState(state, props) {\n    BaseGeometry.updateRenderableState(state, props);\n    state.opaque = false;\n  }\n})(Image || (Image = {})); //\n\n\nfunction getBoundingSphere(corners) {\n  var center = Vec3();\n  var extrema = [];\n\n  for (var i = 0, il = corners.length; i < il; i += 3) {\n    var e = Vec3.fromArray(Vec3(), corners, i);\n    extrema.push(e);\n    Vec3.add(center, center, e);\n  }\n\n  Vec3.scale(center, center, 1 / (corners.length / 3));\n  var radius = 0;\n\n  for (var _i = 0, extrema_1 = extrema; _i < extrema_1.length; _i++) {\n    var e = extrema_1[_i];\n    var d = Vec3.distance(center, e);\n    if (d > radius) radius = d;\n  }\n\n  var sphere = Sphere3D.create(center, radius);\n  Sphere3D.setExtrema(sphere, extrema);\n  return sphere;\n}","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/image/image.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { hashFnv32a } from '../../../mol-data/util';\r\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\r\nimport { calculateTransformBoundingSphere, createTextureImage } from '../../../mol-gl/renderable/util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { Vec2, Vec4, Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { BaseGeometry } from '../base';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { fillSerial } from '../../../mol-util/array';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nimport { NullLocation } from '../../../mol-model/location';\r\nimport { QuadPositions } from '../../../mol-gl/compute/util';\r\nvar QuadIndices = new Uint32Array([\r\n    0, 1, 2,\r\n    1, 3, 2\r\n]);\r\nvar QuadUvs = new Float32Array([\r\n    0, 1,\r\n    0, 0,\r\n    1, 1,\r\n    1, 0\r\n]);\r\nexport var InterpolationTypes = {\r\n    'nearest': 'Nearest',\r\n    'catmulrom': 'Catmulrom (Cubic)',\r\n    'mitchell': 'Mitchell (Cubic)',\r\n    'bspline': 'B-Spline (Cubic)'\r\n};\r\nexport var InterpolationTypeNames = Object.keys(InterpolationTypes);\r\nexport { Image };\r\nvar Image;\r\n(function (Image) {\r\n    function create(imageTexture, corners, groupTexture, image) {\r\n        return image ?\r\n            update(imageTexture, corners, groupTexture, image) :\r\n            fromData(imageTexture, corners, groupTexture);\r\n    }\r\n    Image.create = create;\r\n    function hashCode(image) {\r\n        return hashFnv32a([\r\n            image.cornerBuffer.ref.version\r\n        ]);\r\n    }\r\n    function fromData(imageTexture, corners, groupTexture) {\r\n        var boundingSphere = Sphere3D();\r\n        var currentHash = -1;\r\n        var width = imageTexture.width;\r\n        var height = imageTexture.height;\r\n        var image = {\r\n            kind: 'image',\r\n            imageTexture: ValueCell.create(imageTexture),\r\n            imageTextureDim: ValueCell.create(Vec2.create(width, height)),\r\n            cornerBuffer: ValueCell.create(corners),\r\n            groupTexture: ValueCell.create(groupTexture),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(image);\r\n                if (newHash !== currentHash) {\r\n                    var b = getBoundingSphere(image.cornerBuffer.ref.value);\r\n                    Sphere3D.copy(boundingSphere, b);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n        };\r\n        return image;\r\n    }\r\n    function update(imageTexture, corners, groupTexture, image) {\r\n        var width = imageTexture.width;\r\n        var height = imageTexture.height;\r\n        ValueCell.update(image.imageTexture, imageTexture);\r\n        ValueCell.update(image.imageTextureDim, Vec2.set(image.imageTextureDim.ref.value, width, height));\r\n        ValueCell.update(image.cornerBuffer, corners);\r\n        ValueCell.update(image.groupTexture, groupTexture);\r\n        return image;\r\n    }\r\n    function createEmpty(image) {\r\n        var imageTexture = createTextureImage(0, 4, Uint8Array);\r\n        var corners = image ? image.cornerBuffer.ref.value : new Float32Array(8 * 3);\r\n        var groupTexture = createTextureImage(0, 4, Uint8Array);\r\n        return create(imageTexture, corners, groupTexture, image);\r\n    }\r\n    Image.createEmpty = createEmpty;\r\n    Image.Params = __assign(__assign({}, BaseGeometry.Params), { interpolation: PD.Select('bspline', PD.objectToOptions(InterpolationTypes)) });\r\n    Image.Utils = {\r\n        Params: Image.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: createRenderableState,\r\n        updateRenderableState: updateRenderableState,\r\n        createPositionIterator: function () { return LocationIterator(1, 1, 1, function () { return NullLocation; }); }\r\n    };\r\n    function createValues(image, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = Image.Utils.createPositionIterator(image, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: QuadIndices.length, vertexCount: QuadPositions.length / 3, groupCount: groupCount, instanceCount: instanceCount };\r\n        var invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({}, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), { aPosition: image.cornerBuffer, aUv: ValueCell.create(QuadUvs), elements: ValueCell.create(QuadIndices), \r\n            // aGroup is used as a vertex index here, group id is in tGroupTex\r\n            aGroup: ValueCell.create(fillSerial(new Float32Array(4))), boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)), dInterpolation: ValueCell.create(props.interpolation), uImageTexDim: image.imageTextureDim, tImageTex: image.imageTexture, tGroupTex: image.groupTexture });\r\n    }\r\n    function createValuesSimple(image, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Image.Params)), props);\r\n        return createValues(image, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.dInterpolation, props.interpolation);\r\n    }\r\n    function updateBoundingSphere(values, image) {\r\n        var invariantBoundingSphere = Sphere3D.clone(image.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n    function createRenderableState(props) {\r\n        var state = BaseGeometry.createRenderableState(props);\r\n        state.opaque = false;\r\n        return state;\r\n    }\r\n    function updateRenderableState(state, props) {\r\n        BaseGeometry.updateRenderableState(state, props);\r\n        state.opaque = false;\r\n    }\r\n})(Image || (Image = {}));\r\n//\r\nfunction getBoundingSphere(corners) {\r\n    var center = Vec3();\r\n    var extrema = [];\r\n    for (var i = 0, il = corners.length; i < il; i += 3) {\r\n        var e = Vec3.fromArray(Vec3(), corners, i);\r\n        extrema.push(e);\r\n        Vec3.add(center, center, e);\r\n    }\r\n    Vec3.scale(center, center, 1 / (corners.length / 3));\r\n    var radius = 0;\r\n    for (var _i = 0, extrema_1 = extrema; _i < extrema_1.length; _i++) {\r\n        var e = extrema_1[_i];\r\n        var d = Vec3.distance(center, e);\r\n        if (d > radius)\r\n            radius = d;\r\n    }\r\n    var sphere = Sphere3D.create(center, radius);\r\n    Sphere3D.setExtrema(sphere, extrema);\r\n    return sphere;\r\n}\r\n//# sourceMappingURL=image.js.map"]},"metadata":{},"sourceType":"module"}