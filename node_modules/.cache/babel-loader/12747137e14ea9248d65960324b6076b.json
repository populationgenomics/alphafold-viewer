{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Mat4 } from '../../../../mol-math/linear-algebra';\nimport { IntMap } from '../../../../mol-data/int';\nimport { fillIdentityTransform } from '../../../../mol-geo/geometry/transform-data';\nvar tmpMat = Mat4();\n\nvar StructureUnitTransforms =\n/** @class */\nfunction () {\n  function StructureUnitTransforms(structure) {\n    this.structure = structure;\n    this.groupUnitTransforms = [];\n    /** maps unit.id to offset of transform in unitTransforms */\n\n    this.unitOffsetMap = IntMap.Mutable();\n    this.groupIndexMap = IntMap.Mutable();\n    this._isIdentity = undefined;\n    this.version = 0;\n    this.unitTransforms = new Float32Array(structure.units.length * 16);\n    this.size = structure.units.length;\n    this.reset(); // to set to identity\n\n    var groupOffset = 0;\n\n    for (var i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {\n      var g = structure.unitSymmetryGroups[i];\n      this.groupIndexMap.set(g.hashCode, i);\n      var groupTransforms = this.unitTransforms.subarray(groupOffset, groupOffset + g.units.length * 16);\n      this.groupUnitTransforms.push(groupTransforms);\n\n      for (var j = 0, jl = g.units.length; j < jl; ++j) {\n        this.unitOffsetMap.set(g.units[j].id, groupOffset + j * 16);\n      }\n\n      groupOffset += g.units.length * 16;\n    }\n  }\n\n  StructureUnitTransforms.prototype.reset = function () {\n    this.version = 0;\n    fillIdentityTransform(this.unitTransforms, this.size);\n    this._isIdentity = true;\n  };\n\n  Object.defineProperty(StructureUnitTransforms.prototype, \"isIdentity\", {\n    get: function () {\n      if (this._isIdentity === undefined) {\n        this._isIdentity = true;\n\n        for (var i = 0, il = this.size * 16; i < il; i += 16) {\n          Mat4.fromArray(tmpMat, this.unitTransforms, i);\n\n          if (!Mat4.isIdentity(tmpMat)) {\n            this._isIdentity = false;\n            break;\n          }\n        }\n      }\n\n      return this._isIdentity;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  StructureUnitTransforms.prototype.setTransform = function (matrix, unit) {\n    this.version = (this.version + 1) % 0x7fffffff;\n    Mat4.toArray(matrix, this.unitTransforms, this.unitOffsetMap.get(unit.id));\n    this._isIdentity = undefined;\n  };\n\n  StructureUnitTransforms.prototype.getTransform = function (out, unit) {\n    return Mat4.fromArray(out, this.unitTransforms, this.unitOffsetMap.get(unit.id));\n  };\n\n  StructureUnitTransforms.prototype.getSymmetryGroupTransforms = function (group) {\n    return this.groupUnitTransforms[this.groupIndexMap.get(group.hashCode)];\n  };\n\n  return StructureUnitTransforms;\n}();\n\nexport { StructureUnitTransforms };","map":{"version":3,"sources":["../../../../../src/mol-model/structure/structure/util/unit-transforms.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Mat4 } from '../../../../mol-math/linear-algebra';\r\nimport { IntMap } from '../../../../mol-data/int';\r\nimport { fillIdentityTransform } from '../../../../mol-geo/geometry/transform-data';\r\nvar tmpMat = Mat4();\r\nvar StructureUnitTransforms = /** @class */ (function () {\r\n    function StructureUnitTransforms(structure) {\r\n        this.structure = structure;\r\n        this.groupUnitTransforms = [];\r\n        /** maps unit.id to offset of transform in unitTransforms */\r\n        this.unitOffsetMap = IntMap.Mutable();\r\n        this.groupIndexMap = IntMap.Mutable();\r\n        this._isIdentity = undefined;\r\n        this.version = 0;\r\n        this.unitTransforms = new Float32Array(structure.units.length * 16);\r\n        this.size = structure.units.length;\r\n        this.reset(); // to set to identity\r\n        var groupOffset = 0;\r\n        for (var i = 0, il = structure.unitSymmetryGroups.length; i < il; ++i) {\r\n            var g = structure.unitSymmetryGroups[i];\r\n            this.groupIndexMap.set(g.hashCode, i);\r\n            var groupTransforms = this.unitTransforms.subarray(groupOffset, groupOffset + g.units.length * 16);\r\n            this.groupUnitTransforms.push(groupTransforms);\r\n            for (var j = 0, jl = g.units.length; j < jl; ++j) {\r\n                this.unitOffsetMap.set(g.units[j].id, groupOffset + j * 16);\r\n            }\r\n            groupOffset += g.units.length * 16;\r\n        }\r\n    }\r\n    StructureUnitTransforms.prototype.reset = function () {\r\n        this.version = 0;\r\n        fillIdentityTransform(this.unitTransforms, this.size);\r\n        this._isIdentity = true;\r\n    };\r\n    Object.defineProperty(StructureUnitTransforms.prototype, \"isIdentity\", {\r\n        get: function () {\r\n            if (this._isIdentity === undefined) {\r\n                this._isIdentity = true;\r\n                for (var i = 0, il = this.size * 16; i < il; i += 16) {\r\n                    Mat4.fromArray(tmpMat, this.unitTransforms, i);\r\n                    if (!Mat4.isIdentity(tmpMat)) {\r\n                        this._isIdentity = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return this._isIdentity;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    StructureUnitTransforms.prototype.setTransform = function (matrix, unit) {\r\n        this.version = (this.version + 1) % 0x7fffffff;\r\n        Mat4.toArray(matrix, this.unitTransforms, this.unitOffsetMap.get(unit.id));\r\n        this._isIdentity = undefined;\r\n    };\r\n    StructureUnitTransforms.prototype.getTransform = function (out, unit) {\r\n        return Mat4.fromArray(out, this.unitTransforms, this.unitOffsetMap.get(unit.id));\r\n    };\r\n    StructureUnitTransforms.prototype.getSymmetryGroupTransforms = function (group) {\r\n        return this.groupUnitTransforms[this.groupIndexMap.get(group.hashCode)];\r\n    };\r\n    return StructureUnitTransforms;\r\n}());\r\nexport { StructureUnitTransforms };\r\n//# sourceMappingURL=unit-transforms.js.map"]},"metadata":{},"sourceType":"module"}