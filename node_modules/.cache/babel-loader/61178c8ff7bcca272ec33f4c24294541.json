{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { degToRad } from '../../../mol-math/misc';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { eachBondedAtom, typeSymbol } from './util';\nexport function geometryLabel(geometry) {\n  switch (geometry) {\n    case 0\n    /* Spherical */\n    :\n      return 'Spherical';\n\n    case 1\n    /* Terminal */\n    :\n      return 'Terminal';\n\n    case 2\n    /* Linear */\n    :\n      return 'Linear';\n\n    case 3\n    /* Trigonal */\n    :\n      return 'Trigonal';\n\n    case 4\n    /* Tetrahedral */\n    :\n      return 'Tetrahedral';\n\n    case 5\n    /* TrigonalBiPyramidal */\n    :\n      return 'Trigonal Bi-Pyramidal';\n\n    case 6\n    /* Octahedral */\n    :\n      return 'Octahedral';\n\n    case 7\n    /* SquarePlanar */\n    :\n      return 'Square Planar';\n\n    case 8\n    /* Unknown */\n    :\n      return 'Unknown';\n  }\n}\nexport function assignGeometry(totalCoordination) {\n  switch (totalCoordination) {\n    case 0:\n      return 0\n      /* Spherical */\n      ;\n\n    case 1:\n      return 1\n      /* Terminal */\n      ;\n\n    case 2:\n      return 2\n      /* Linear */\n      ;\n\n    case 3:\n      return 3\n      /* Trigonal */\n      ;\n\n    case 4:\n      return 4\n      /* Tetrahedral */\n      ;\n\n    default:\n      return 8\n      /* Unknown */\n      ;\n  }\n}\nexport var AtomGeometryAngles = new Map([[2\n/* Linear */\n, degToRad(180)], [3\n/* Trigonal */\n, degToRad(120)], [4\n/* Tetrahedral */\n, degToRad(109.4721)], [6\n/* Octahedral */\n, degToRad(90)]]); // tmp objects for `calcAngles` and `calcPlaneAngle`\n\nvar tmpDir1 = Vec3();\nvar tmpDir2 = Vec3();\nvar tmpPosA = Vec3();\nvar tmpPosB = Vec3();\nvar tmpPosX = Vec3();\n/**\r\n * Calculate the angles x-a1-a2 for all x where x is a heavy atom (not H) bonded to ap1.\r\n */\n\nexport function calcAngles(structure, unitA, indexA, unitB, indexB) {\n  var angles = [];\n  unitA.conformation.position(unitA.elements[indexA], tmpPosA);\n  unitB.conformation.position(unitB.elements[indexB], tmpPosB);\n  Vec3.sub(tmpDir1, tmpPosB, tmpPosA);\n  eachBondedAtom(structure, unitA, indexA, function (unitX, indexX) {\n    if (typeSymbol(unitX, indexX) !== \"H\"\n    /* H */\n    ) {\n      unitX.conformation.position(unitX.elements[indexX], tmpPosX);\n      Vec3.sub(tmpDir2, tmpPosX, tmpPosA);\n      angles.push(Vec3.angle(tmpDir1, tmpDir2));\n    }\n  });\n  return angles;\n}\n/**\r\n * Find two neighbours of ap1 to define a plane (if possible) and\r\n * measure angle out of plane to ap2\r\n * @param  {AtomProxy} ap1 First atom (angle centre)\r\n * @param  {AtomProxy} ap2 Second atom (out-of-plane)\r\n * @return {number}        Angle from plane to second atom\r\n */\n\nexport function calcPlaneAngle(structure, unitA, indexA, unitB, indexB) {\n  unitA.conformation.position(unitA.elements[indexA], tmpPosA);\n  unitB.conformation.position(unitB.elements[indexB], tmpPosB);\n  Vec3.sub(tmpDir1, tmpPosB, tmpPosA);\n  var neighbours = [Vec3(), Vec3()];\n  var ni = 0;\n  var unitX1;\n  var indexX1;\n  eachBondedAtom(structure, unitA, indexA, function (unitX, indexX) {\n    if (ni > 1) return;\n\n    if (typeSymbol(unitX, indexX) !== \"H\"\n    /* H */\n    ) {\n      unitX1 = unitX;\n      indexX1 = indexX;\n      unitX.conformation.position(unitX.elements[indexX], tmpPosX);\n      Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);\n    }\n  });\n\n  if (ni === 1 && unitX1 && indexX1) {\n    eachBondedAtom(structure, unitX1, indexX1, function (unitX, indexX) {\n      if (ni > 1) return;\n      if (unitX === unitA && indexX === indexA) return;\n\n      if (typeSymbol(unitX, indexX) !== \"H\"\n      /* H */\n      ) {\n        unitX.conformation.position(unitX.elements[indexX], tmpPosX);\n        Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);\n      }\n    });\n  }\n\n  if (ni !== 2) {\n    return;\n  }\n\n  Vec3.cross(tmpDir2, neighbours[0], neighbours[1]);\n  return Math.abs(Math.PI / 2 - Vec3.angle(tmpDir2, tmpDir1));\n}","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/chemistry/geometry.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAAS,QAAT,QAAyB,wBAAzB;AACA,SAAS,IAAT,QAAqB,kCAArB;AAEA,SAAS,cAAT,EAAyB,UAAzB,QAA2C,QAA3C;AAmBA,OAAM,SAAU,aAAV,CAAwB,QAAxB,EAA8C;AAChD,UAAQ,QAAR;AACI,SAAA;AAAA;AAAA;AACI,aAAO,WAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,UAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,QAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,UAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,aAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,uBAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,YAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,eAAP;;AACJ,SAAA;AAAA;AAAA;AACI,aAAO,SAAP;AAlBR;AAoBH;AAED,OAAM,SAAU,cAAV,CAAyB,iBAAzB,EAAkD;AACpD,UAAQ,iBAAR;AACI,SAAK,CAAL;AAAQ,aAAA;AAAA;AAAA;;AACR,SAAK,CAAL;AAAQ,aAAA;AAAA;AAAA;;AACR,SAAK,CAAL;AAAQ,aAAA;AAAA;AAAA;;AACR,SAAK,CAAL;AAAQ,aAAA;AAAA;AAAA;;AACR,SAAK,CAAL;AAAQ,aAAA;AAAA;AAAA;;AACR;AAAS,aAAA;AAAA;AAAA;AANb;AASH;AAED,OAAO,IAAM,kBAAkB,GAAG,IAAI,GAAJ,CAA8B,CAC5D,CAAA;AAAA;AAAA,EAAsB,QAAQ,CAAC,GAAD,CAA9B,CAD4D,EAE5D,CAAA;AAAA;AAAA,EAAwB,QAAQ,CAAC,GAAD,CAAhC,CAF4D,EAG5D,CAAA;AAAA;AAAA,EAA2B,QAAQ,CAAC,QAAD,CAAnC,CAH4D,EAI5D,CAAA;AAAA;AAAA,EAA0B,QAAQ,CAAC,EAAD,CAAlC,CAJ4D,CAA9B,CAA3B,C,CAOP;;AACA,IAAM,OAAO,GAAG,IAAI,EAApB;AACA,IAAM,OAAO,GAAG,IAAI,EAApB;AACA,IAAM,OAAO,GAAG,IAAI,EAApB;AACA,IAAM,OAAO,GAAG,IAAI,EAApB;AACA,IAAM,OAAO,GAAG,IAAI,EAApB;AAEA;;AAEG;;AACH,OAAM,SAAU,UAAV,CAAqB,SAArB,EAA2C,KAA3C,EAA+D,MAA/D,EAAmG,KAAnG,EAAuH,MAAvH,EAAyJ;AAC3J,MAAM,MAAM,GAAa,EAAzB;AACA,EAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,EAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,EAAA,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,OAAlB,EAA2B,OAA3B;AAEA,EAAA,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,MAAnB,EAA2B,UAAC,KAAD,EAAqB,MAArB,EAAuD;AAC5F,QAAI,UAAU,CAAC,KAAD,EAAQ,MAAR,CAAV,KAAyB;AAAA;AAA7B,MAA8C;AAC1C,MAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,OAAlB,EAA2B,OAA3B;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,KAAL,CAAW,OAAX,EAAoB,OAApB,CAAZ;AACH;AACJ,GANa,CAAd;AAOA,SAAO,MAAP;AACH;AAED;;;;;;AAMG;;AACH,OAAM,SAAU,cAAV,CAAyB,SAAzB,EAA+C,KAA/C,EAAmE,MAAnE,EAAuG,KAAvG,EAA2H,MAA3H,EAA6J;AAC/J,EAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,EAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,EAAA,IAAI,CAAC,GAAL,CAAS,OAAT,EAAkB,OAAlB,EAA2B,OAA3B;AAEA,MAAM,UAAU,GAAG,CAAC,IAAI,EAAL,EAAS,IAAI,EAAb,CAAnB;AACA,MAAI,EAAE,GAAG,CAAT;AACA,MAAI,MAAJ;AACA,MAAI,OAAJ;AACA,EAAA,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,MAAnB,EAA2B,UAAC,KAAD,EAAqB,MAArB,EAAuD;AAC5F,QAAI,EAAE,GAAG,CAAT,EAAY;;AACZ,QAAI,UAAU,CAAC,KAAD,EAAQ,MAAR,CAAV,KAAyB;AAAA;AAA7B,MAA8C;AAC1C,MAAA,MAAM,GAAG,KAAT;AACA,MAAA,OAAO,GAAG,MAAV;AACA,MAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,EAAE,EAAH,CAAnB,EAA2B,OAA3B,EAAoC,OAApC;AACH;AACJ,GARa,CAAd;;AASA,MAAI,EAAE,KAAK,CAAP,IAAY,MAAZ,IAAsB,OAA1B,EAAmC;AAC/B,IAAA,cAAc,CAAC,SAAD,EAAY,MAAZ,EAAoB,OAApB,EAA6B,UAAC,KAAD,EAAqB,MAArB,EAAuD;AAC9F,UAAI,EAAE,GAAG,CAAT,EAAY;AACZ,UAAI,KAAK,KAAK,KAAV,IAAmB,MAAM,KAAK,MAAlC,EAA0C;;AAC1C,UAAI,UAAU,CAAC,KAAD,EAAQ,MAAR,CAAV,KAAyB;AAAA;AAA7B,QAA8C;AAC1C,QAAA,KAAK,CAAC,YAAN,CAAmB,QAAnB,CAA4B,KAAK,CAAC,QAAN,CAAe,MAAf,CAA5B,EAAoD,OAApD;AACA,QAAA,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,EAAE,EAAH,CAAnB,EAA2B,OAA3B,EAAoC,OAApC;AACH;AACJ,KAPa,CAAd;AAQH;;AAED,MAAI,EAAE,KAAK,CAAX,EAAc;AACV;AACH;;AAED,EAAA,IAAI,CAAC,KAAL,CAAW,OAAX,EAAoB,UAAU,CAAC,CAAD,CAA9B,EAAmC,UAAU,CAAC,CAAD,CAA7C;AACA,SAAO,IAAI,CAAC,GAAL,CAAU,IAAI,CAAC,EAAL,GAAU,CAAX,GAAgB,IAAI,CAAC,KAAL,CAAW,OAAX,EAAoB,OAApB,CAAzB,CAAP;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { degToRad } from '../../../mol-math/misc';\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { eachBondedAtom, typeSymbol } from './util';\r\nexport function geometryLabel(geometry) {\r\n    switch (geometry) {\r\n        case 0 /* Spherical */:\r\n            return 'Spherical';\r\n        case 1 /* Terminal */:\r\n            return 'Terminal';\r\n        case 2 /* Linear */:\r\n            return 'Linear';\r\n        case 3 /* Trigonal */:\r\n            return 'Trigonal';\r\n        case 4 /* Tetrahedral */:\r\n            return 'Tetrahedral';\r\n        case 5 /* TrigonalBiPyramidal */:\r\n            return 'Trigonal Bi-Pyramidal';\r\n        case 6 /* Octahedral */:\r\n            return 'Octahedral';\r\n        case 7 /* SquarePlanar */:\r\n            return 'Square Planar';\r\n        case 8 /* Unknown */:\r\n            return 'Unknown';\r\n    }\r\n}\r\nexport function assignGeometry(totalCoordination) {\r\n    switch (totalCoordination) {\r\n        case 0: return 0 /* Spherical */;\r\n        case 1: return 1 /* Terminal */;\r\n        case 2: return 2 /* Linear */;\r\n        case 3: return 3 /* Trigonal */;\r\n        case 4: return 4 /* Tetrahedral */;\r\n        default: return 8 /* Unknown */;\r\n    }\r\n}\r\nexport var AtomGeometryAngles = new Map([\r\n    [2 /* Linear */, degToRad(180)],\r\n    [3 /* Trigonal */, degToRad(120)],\r\n    [4 /* Tetrahedral */, degToRad(109.4721)],\r\n    [6 /* Octahedral */, degToRad(90)]\r\n]);\r\n// tmp objects for `calcAngles` and `calcPlaneAngle`\r\nvar tmpDir1 = Vec3();\r\nvar tmpDir2 = Vec3();\r\nvar tmpPosA = Vec3();\r\nvar tmpPosB = Vec3();\r\nvar tmpPosX = Vec3();\r\n/**\r\n * Calculate the angles x-a1-a2 for all x where x is a heavy atom (not H) bonded to ap1.\r\n */\r\nexport function calcAngles(structure, unitA, indexA, unitB, indexB) {\r\n    var angles = [];\r\n    unitA.conformation.position(unitA.elements[indexA], tmpPosA);\r\n    unitB.conformation.position(unitB.elements[indexB], tmpPosB);\r\n    Vec3.sub(tmpDir1, tmpPosB, tmpPosA);\r\n    eachBondedAtom(structure, unitA, indexA, function (unitX, indexX) {\r\n        if (typeSymbol(unitX, indexX) !== \"H\" /* H */) {\r\n            unitX.conformation.position(unitX.elements[indexX], tmpPosX);\r\n            Vec3.sub(tmpDir2, tmpPosX, tmpPosA);\r\n            angles.push(Vec3.angle(tmpDir1, tmpDir2));\r\n        }\r\n    });\r\n    return angles;\r\n}\r\n/**\r\n * Find two neighbours of ap1 to define a plane (if possible) and\r\n * measure angle out of plane to ap2\r\n * @param  {AtomProxy} ap1 First atom (angle centre)\r\n * @param  {AtomProxy} ap2 Second atom (out-of-plane)\r\n * @return {number}        Angle from plane to second atom\r\n */\r\nexport function calcPlaneAngle(structure, unitA, indexA, unitB, indexB) {\r\n    unitA.conformation.position(unitA.elements[indexA], tmpPosA);\r\n    unitB.conformation.position(unitB.elements[indexB], tmpPosB);\r\n    Vec3.sub(tmpDir1, tmpPosB, tmpPosA);\r\n    var neighbours = [Vec3(), Vec3()];\r\n    var ni = 0;\r\n    var unitX1;\r\n    var indexX1;\r\n    eachBondedAtom(structure, unitA, indexA, function (unitX, indexX) {\r\n        if (ni > 1)\r\n            return;\r\n        if (typeSymbol(unitX, indexX) !== \"H\" /* H */) {\r\n            unitX1 = unitX;\r\n            indexX1 = indexX;\r\n            unitX.conformation.position(unitX.elements[indexX], tmpPosX);\r\n            Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);\r\n        }\r\n    });\r\n    if (ni === 1 && unitX1 && indexX1) {\r\n        eachBondedAtom(structure, unitX1, indexX1, function (unitX, indexX) {\r\n            if (ni > 1)\r\n                return;\r\n            if (unitX === unitA && indexX === indexA)\r\n                return;\r\n            if (typeSymbol(unitX, indexX) !== \"H\" /* H */) {\r\n                unitX.conformation.position(unitX.elements[indexX], tmpPosX);\r\n                Vec3.sub(neighbours[ni++], tmpPosX, tmpPosA);\r\n            }\r\n        });\r\n    }\r\n    if (ni !== 2) {\r\n        return;\r\n    }\r\n    Vec3.cross(tmpDir2, neighbours[0], neighbours[1]);\r\n    return Math.abs((Math.PI / 2) - Vec3.angle(tmpDir2, tmpDir1));\r\n}\r\n//# sourceMappingURL=geometry.js.map"]},"metadata":{},"sourceType":"module"}