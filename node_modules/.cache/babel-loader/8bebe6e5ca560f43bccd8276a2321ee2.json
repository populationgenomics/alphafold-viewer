{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nimport { Bridge } from './common';\n/**\r\n * Two nonoverlapping stretches of three residues each, i - 1, i, i + 1 and j - 1, j, j + 1,\r\n * form either a parallel or antiparallel bridge, depending on which of\r\n * two basic patterns is matched. We assign a bridge between residues i and j\r\n * if there are two H bonds characteristic of P-structure; in particular,\r\n *\r\n * Parallel Bridge(i, j) =:\r\n *      [Hbond(i - 1, j) and Hbond(j, i + 1)] or\r\n *      [Hbond(j - 1, i) and Hbond(i, j + 1)]\r\n *\r\n * Antiparallel Bridge(i, j) =:\r\n *      [Hbond(i, j) and Hbond(j, i)] or\r\n *      [Hbond(i - 1, j + 1) and Hbond(j - 1, i + l)]\r\n *\r\n * Type: B\r\n */\n\nexport function assignBridges(ctx) {\n  var proteinInfo = ctx.proteinInfo,\n      hbonds = ctx.hbonds,\n      flags = ctx.flags,\n      bridges = ctx.bridges;\n  var offset = hbonds.offset,\n      b = hbonds.b;\n  var i, j;\n\n  for (var k = 0, kl = proteinInfo.residueIndices.length; k < kl; ++k) {\n    for (var t = offset[k], _t = offset[k + 1]; t < _t; t++) {\n      var l = b[t];\n      if (k > l) continue; // Parallel Bridge(i, j) =: [Hbond(i - 1, j) and Hbond(j, i + 1)]\n\n      i = k + 1; // k is i - 1\n\n      j = l;\n\n      if (i !== j && hbonds.getDirectedEdgeIndex(j, i + 1) !== -1) {\n        flags[i] |= 2\n        /* B */\n        ;\n        flags[j] |= 2\n        /* B */\n        ; // TODO move to constructor, actually omit object all together\n\n        bridges[bridges.length] = new Bridge(i, j, 0\n        /* PARALLEL */\n        );\n      } // Parallel Bridge(i, j) =: [Hbond(j - 1, i) and Hbond(i, j + 1)]\n\n\n      i = k;\n      j = l - 1; // l is j + 1\n\n      if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i) !== -1) {\n        flags[i] |= 2\n        /* B */\n        ;\n        flags[j] |= 2\n        /* B */\n        ;\n        bridges[bridges.length] = new Bridge(j, i, 0\n        /* PARALLEL */\n        );\n      } // Antiparallel Bridge(i, j) =: [Hbond(i, j) and Hbond(j, i)]\n\n\n      i = k;\n      j = l;\n\n      if (i !== j && hbonds.getDirectedEdgeIndex(j, i) !== -1) {\n        flags[i] |= 2\n        /* B */\n        ;\n        flags[j] |= 2\n        /* B */\n        ;\n        bridges[bridges.length] = new Bridge(j, i, 1\n        /* ANTI_PARALLEL */\n        );\n      } // Antiparallel Bridge(i, j) =: [Hbond(i - 1, j + 1) and Hbond(j - 1, i + l)]\n\n\n      i = k + 1;\n      j = l - 1;\n\n      if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i + 1) !== -1) {\n        flags[i] |= 2\n        /* B */\n        ;\n        flags[j] |= 2\n        /* B */\n        ;\n        bridges[bridges.length] = new Bridge(j, i, 1\n        /* ANTI_PARALLEL */\n        );\n      }\n    }\n  }\n\n  bridges.sort(function (a, b) {\n    return a.partner1 > b.partner1 ? 1 : a.partner1 < b.partner1 ? -1 : 0;\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/bridges.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAA4C,MAA5C,QAA0D,UAA1D;AAEA;;;;;;;;;;;;;;;AAeG;;AACH,OAAM,SAAU,aAAV,CAAwB,GAAxB,EAAwC;AAClC,MAAA,WAAW,GAA6B,GAAG,CAAhC,WAAX;AAAA,MAAa,MAAM,GAAqB,GAAG,CAAxB,MAAnB;AAAA,MAAqB,KAAK,GAAc,GAAG,CAAjB,KAA1B;AAAA,MAA4B,OAAO,GAAK,GAAG,CAAR,OAAnC;AAEA,MAAA,MAAM,GAAQ,MAAM,CAAd,MAAN;AAAA,MAAQ,CAAC,GAAK,MAAM,CAAX,CAAT;AACR,MAAI,CAAJ,EAAe,CAAf;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,WAAW,CAAC,cAAZ,CAA2B,MAAhD,EAAwD,CAAC,GAAG,EAA5D,EAAgE,EAAE,CAAlE,EAAqE;AACjE,SAAK,IAAI,CAAC,GAAG,MAAM,CAAC,CAAD,CAAd,EAAmB,EAAE,GAAG,MAAM,CAAC,CAAC,GAAG,CAAL,CAAnC,EAA4C,CAAC,GAAG,EAAhD,EAAoD,CAAC,EAArD,EAAyD;AACrD,UAAM,CAAC,GAAG,CAAC,CAAC,CAAD,CAAX;AACA,UAAI,CAAC,GAAG,CAAR,EAAW,SAF0C,CAIrD;;AACA,MAAA,CAAC,GAAG,CAAC,GAAG,CAAR,CALqD,CAK1C;;AACX,MAAA,CAAC,GAAG,CAAJ;;AACA,UAAI,CAAC,KAAK,CAAN,IAAW,MAAM,CAAC,oBAAP,CAA4B,CAA5B,EAA+B,CAAC,GAAG,CAAnC,MAA0C,CAAC,CAA1D,EAA6D;AACzD,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR,SAFyD,CAGzD;;AACA,QAAA,OAAO,CAAC,OAAO,CAAC,MAAT,CAAP,GAA0B,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAe;AAAA;AAAf,SAA1B;AACH,OAZoD,CAcrD;;;AACA,MAAA,CAAC,GAAG,CAAJ;AACA,MAAA,CAAC,GAAG,CAAC,GAAG,CAAR,CAhBqD,CAgB1C;;AACX,UAAI,CAAC,KAAK,CAAN,IAAW,MAAM,CAAC,oBAAP,CAA4B,CAAC,GAAG,CAAhC,EAAmC,CAAnC,MAA0C,CAAC,CAA1D,EAA6D;AACzD,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,OAAO,CAAC,OAAO,CAAC,MAAT,CAAP,GAA0B,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAe;AAAA;AAAf,SAA1B;AACH,OArBoD,CAuBrD;;;AACA,MAAA,CAAC,GAAG,CAAJ;AACA,MAAA,CAAC,GAAG,CAAJ;;AACA,UAAI,CAAC,KAAK,CAAN,IAAW,MAAM,CAAC,oBAAP,CAA4B,CAA5B,EAA+B,CAA/B,MAAsC,CAAC,CAAtD,EAAyD;AACrD,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,OAAO,CAAC,OAAO,CAAC,MAAT,CAAP,GAA0B,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAe;AAAA;AAAf,SAA1B;AACH,OA9BoD,CAgCrD;;;AACA,MAAA,CAAC,GAAG,CAAC,GAAG,CAAR;AACA,MAAA,CAAC,GAAG,CAAC,GAAG,CAAR;;AACA,UAAI,CAAC,KAAK,CAAN,IAAW,MAAM,CAAC,oBAAP,CAA4B,CAAC,GAAG,CAAhC,EAAmC,CAAC,GAAG,CAAvC,MAA8C,CAAC,CAA9D,EAAiE;AAC7D,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,KAAK,CAAC,CAAD,CAAL,IAAQ;AAAA;AAAR;AACA,QAAA,OAAO,CAAC,OAAO,CAAC,MAAT,CAAP,GAA0B,IAAI,MAAJ,CAAW,CAAX,EAAc,CAAd,EAAe;AAAA;AAAf,SAA1B;AACH;AACJ;AACJ;;AAED,EAAA,OAAO,CAAC,IAAR,CAAa,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,QAAf,GAA0B,CAA1B,GAA8B,CAAC,CAAC,QAAF,GAAa,CAAC,CAAC,QAAf,GAA0B,CAAC,CAA3B,GAA9B,CAAA;AAA8D,GAArF;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nimport { Bridge } from './common';\r\n/**\r\n * Two nonoverlapping stretches of three residues each, i - 1, i, i + 1 and j - 1, j, j + 1,\r\n * form either a parallel or antiparallel bridge, depending on which of\r\n * two basic patterns is matched. We assign a bridge between residues i and j\r\n * if there are two H bonds characteristic of P-structure; in particular,\r\n *\r\n * Parallel Bridge(i, j) =:\r\n *      [Hbond(i - 1, j) and Hbond(j, i + 1)] or\r\n *      [Hbond(j - 1, i) and Hbond(i, j + 1)]\r\n *\r\n * Antiparallel Bridge(i, j) =:\r\n *      [Hbond(i, j) and Hbond(j, i)] or\r\n *      [Hbond(i - 1, j + 1) and Hbond(j - 1, i + l)]\r\n *\r\n * Type: B\r\n */\r\nexport function assignBridges(ctx) {\r\n    var proteinInfo = ctx.proteinInfo, hbonds = ctx.hbonds, flags = ctx.flags, bridges = ctx.bridges;\r\n    var offset = hbonds.offset, b = hbonds.b;\r\n    var i, j;\r\n    for (var k = 0, kl = proteinInfo.residueIndices.length; k < kl; ++k) {\r\n        for (var t = offset[k], _t = offset[k + 1]; t < _t; t++) {\r\n            var l = b[t];\r\n            if (k > l)\r\n                continue;\r\n            // Parallel Bridge(i, j) =: [Hbond(i - 1, j) and Hbond(j, i + 1)]\r\n            i = k + 1; // k is i - 1\r\n            j = l;\r\n            if (i !== j && hbonds.getDirectedEdgeIndex(j, i + 1) !== -1) {\r\n                flags[i] |= 2 /* B */;\r\n                flags[j] |= 2 /* B */;\r\n                // TODO move to constructor, actually omit object all together\r\n                bridges[bridges.length] = new Bridge(i, j, 0 /* PARALLEL */);\r\n            }\r\n            // Parallel Bridge(i, j) =: [Hbond(j - 1, i) and Hbond(i, j + 1)]\r\n            i = k;\r\n            j = l - 1; // l is j + 1\r\n            if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i) !== -1) {\r\n                flags[i] |= 2 /* B */;\r\n                flags[j] |= 2 /* B */;\r\n                bridges[bridges.length] = new Bridge(j, i, 0 /* PARALLEL */);\r\n            }\r\n            // Antiparallel Bridge(i, j) =: [Hbond(i, j) and Hbond(j, i)]\r\n            i = k;\r\n            j = l;\r\n            if (i !== j && hbonds.getDirectedEdgeIndex(j, i) !== -1) {\r\n                flags[i] |= 2 /* B */;\r\n                flags[j] |= 2 /* B */;\r\n                bridges[bridges.length] = new Bridge(j, i, 1 /* ANTI_PARALLEL */);\r\n            }\r\n            // Antiparallel Bridge(i, j) =: [Hbond(i - 1, j + 1) and Hbond(j - 1, i + l)]\r\n            i = k + 1;\r\n            j = l - 1;\r\n            if (i !== j && hbonds.getDirectedEdgeIndex(j - 1, i + 1) !== -1) {\r\n                flags[i] |= 2 /* B */;\r\n                flags[j] |= 2 /* B */;\r\n                bridges[bridges.length] = new Bridge(j, i, 1 /* ANTI_PARALLEL */);\r\n            }\r\n        }\r\n    }\r\n    bridges.sort(function (a, b) { return a.partner1 > b.partner1 ? 1 : a.partner1 < b.partner1 ? -1 : 0; });\r\n}\r\n//# sourceMappingURL=bridges.js.map"]},"metadata":{},"sourceType":"module"}