{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { PluginCommands } from '../../../mol-plugin/commands';\nimport { StateTransform } from '../../../mol-state';\nimport { shallowEqual } from '../../../mol-util';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { PluginStateAnimation } from '../model';\nexport var AnimateStateInterpolation = PluginStateAnimation.create({\n  name: 'built-in.animate-state-interpolation',\n  display: {\n    name: 'Animate State (experimental)'\n  },\n  params: function () {\n    return {\n      transtionDurationInMs: PD.Numeric(2000, {\n        min: 100,\n        max: 30000,\n        step: 10\n      })\n    };\n  },\n  canApply: function (plugin) {\n    return {\n      canApply: plugin.managers.snapshot.state.entries.size > 1\n    };\n  },\n  initialState: function () {\n    return {};\n  },\n  apply: function (animState, t, ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var snapshots, currentT, srcIndex, tarIndex, _src, _tar, src, tar, state, update, _i, src_1, s, _a, tar_1, t_1, e, f, oldState, newState;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            snapshots = ctx.plugin.managers.snapshot.state.entries;\n            if (snapshots.size < 2) return [2\n            /*return*/\n            , {\n              kind: 'finished'\n            }];\n            currentT = t.current % ctx.params.transtionDurationInMs / ctx.params.transtionDurationInMs;\n            srcIndex = Math.floor(t.current / ctx.params.transtionDurationInMs) % snapshots.size;\n            tarIndex = Math.ceil(t.current / ctx.params.transtionDurationInMs);\n            if (tarIndex === srcIndex) tarIndex++;\n            tarIndex = tarIndex % snapshots.size;\n            _src = snapshots.get(srcIndex).snapshot, _tar = snapshots.get(tarIndex).snapshot;\n            if (!_src.data || !_tar.data) return [2\n            /*return*/\n            , {\n              kind: 'skip'\n            }];\n            src = _src.data.tree.transforms, tar = _tar.data.tree.transforms;\n            state = ctx.plugin.state.data;\n            update = state.build();\n\n            for (_i = 0, src_1 = src; _i < src_1.length; _i++) {\n              s = src_1[_i];\n\n              for (_a = 0, tar_1 = tar; _a < tar_1.length; _a++) {\n                t_1 = tar_1[_a]; // TODO: better than quadratic alg.\n                // TODO: support for adding/removing nodes\n\n                if (t_1.ref !== s.ref) continue;\n                if (t_1.version === s.version) continue;\n                e = StateTransform.fromJSON(s), f = StateTransform.fromJSON(t_1);\n                oldState = state.cells.get(s.ref);\n                if (!oldState) continue;\n                newState = void 0;\n\n                if (!e.transformer.definition.interpolate) {\n                  newState = currentT <= 0.5 ? e.params : f.params;\n                } else {\n                  newState = e.transformer.definition.interpolate(e.params, f.params, currentT, ctx.plugin);\n                }\n\n                if (!shallowEqual(oldState, newState)) {\n                  update.to(s.ref).update(newState);\n                }\n              }\n            }\n\n            return [4\n            /*yield*/\n            , PluginCommands.State.Update(ctx.plugin, {\n              state: state,\n              tree: update,\n              options: {\n                doNotLogTiming: true\n              }\n            })];\n\n          case 1:\n            _b.sent();\n\n            return [2\n            /*return*/\n            , {\n              kind: 'next',\n              state: {}\n            }];\n        }\n      });\n    });\n  }\n});","map":{"version":3,"sources":["../../../../src/mol-plugin-state/animation/built-in/state-interpolation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { PluginCommands } from '../../../mol-plugin/commands';\r\nimport { StateTransform } from '../../../mol-state';\r\nimport { shallowEqual } from '../../../mol-util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { PluginStateAnimation } from '../model';\r\nexport var AnimateStateInterpolation = PluginStateAnimation.create({\r\n    name: 'built-in.animate-state-interpolation',\r\n    display: { name: 'Animate State (experimental)' },\r\n    params: function () { return ({\r\n        transtionDurationInMs: PD.Numeric(2000, { min: 100, max: 30000, step: 10 })\r\n    }); },\r\n    canApply: function (plugin) {\r\n        return { canApply: plugin.managers.snapshot.state.entries.size > 1 };\r\n    },\r\n    initialState: function () { return ({}); },\r\n    apply: function (animState, t, ctx) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var snapshots, currentT, srcIndex, tarIndex, _src, _tar, src, tar, state, update, _i, src_1, s, _a, tar_1, t_1, e, f, oldState, newState;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        snapshots = ctx.plugin.managers.snapshot.state.entries;\r\n                        if (snapshots.size < 2)\r\n                            return [2 /*return*/, { kind: 'finished' }];\r\n                        currentT = (t.current % ctx.params.transtionDurationInMs) / ctx.params.transtionDurationInMs;\r\n                        srcIndex = Math.floor(t.current / ctx.params.transtionDurationInMs) % snapshots.size;\r\n                        tarIndex = Math.ceil(t.current / ctx.params.transtionDurationInMs);\r\n                        if (tarIndex === srcIndex)\r\n                            tarIndex++;\r\n                        tarIndex = tarIndex % snapshots.size;\r\n                        _src = snapshots.get(srcIndex).snapshot, _tar = snapshots.get(tarIndex).snapshot;\r\n                        if (!_src.data || !_tar.data)\r\n                            return [2 /*return*/, { kind: 'skip' }];\r\n                        src = _src.data.tree.transforms, tar = _tar.data.tree.transforms;\r\n                        state = ctx.plugin.state.data;\r\n                        update = state.build();\r\n                        for (_i = 0, src_1 = src; _i < src_1.length; _i++) {\r\n                            s = src_1[_i];\r\n                            for (_a = 0, tar_1 = tar; _a < tar_1.length; _a++) {\r\n                                t_1 = tar_1[_a];\r\n                                // TODO: better than quadratic alg.\r\n                                // TODO: support for adding/removing nodes\r\n                                if (t_1.ref !== s.ref)\r\n                                    continue;\r\n                                if (t_1.version === s.version)\r\n                                    continue;\r\n                                e = StateTransform.fromJSON(s), f = StateTransform.fromJSON(t_1);\r\n                                oldState = state.cells.get(s.ref);\r\n                                if (!oldState)\r\n                                    continue;\r\n                                newState = void 0;\r\n                                if (!e.transformer.definition.interpolate) {\r\n                                    newState = currentT <= 0.5 ? e.params : f.params;\r\n                                }\r\n                                else {\r\n                                    newState = e.transformer.definition.interpolate(e.params, f.params, currentT, ctx.plugin);\r\n                                }\r\n                                if (!shallowEqual(oldState, newState)) {\r\n                                    update.to(s.ref).update(newState);\r\n                                }\r\n                            }\r\n                        }\r\n                        return [4 /*yield*/, PluginCommands.State.Update(ctx.plugin, { state: state, tree: update, options: { doNotLogTiming: true } })];\r\n                    case 1:\r\n                        _b.sent();\r\n                        return [2 /*return*/, { kind: 'next', state: {} }];\r\n                }\r\n            });\r\n        });\r\n    }\r\n});\r\n//# sourceMappingURL=state-interpolation.js.map"]},"metadata":{},"sourceType":"module"}