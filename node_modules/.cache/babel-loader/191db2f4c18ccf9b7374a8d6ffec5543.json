{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { Unit } from '../../../mol-model/structure';\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\nimport { createCurveSegmentState, PolymerTraceIterator, interpolateCurveSegment, interpolateSizes, PolymerLocationIterator, getPolymerElementLoci, eachPolymerElement, HelixTension, NucleicShift, StandardShift, StandardTension, OverhangFactor } from './util/polymer';\nimport { isNucleic, SecondaryStructureType } from '../../../mol-model/structure/model/types';\nimport { addSheet } from '../../../mol-geo/geometry/mesh/builder/sheet';\nimport { addTube } from '../../../mol-geo/geometry/mesh/builder/tube';\nimport { UnitsMeshParams, UnitsMeshVisual } from '../units-visual';\nimport { SecondaryStructureProvider } from '../../../mol-model-props/computed/secondary-structure';\nimport { addRibbon } from '../../../mol-geo/geometry/mesh/builder/ribbon';\nimport { addSphere } from '../../../mol-geo/geometry/mesh/builder/sphere';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\nimport { Sphere3D } from '../../../mol-math/geometry';\nexport var PolymerTraceMeshParams = {\n  sizeFactor: PD.Numeric(0.2, {\n    min: 0,\n    max: 10,\n    step: 0.01\n  }),\n  aspectRatio: PD.Numeric(5, {\n    min: 0.1,\n    max: 10,\n    step: 0.1\n  }),\n  arrowFactor: PD.Numeric(1.5, {\n    min: 0,\n    max: 3,\n    step: 0.1\n  }),\n  tubularHelices: PD.Boolean(false),\n  detail: PD.Numeric(0, {\n    min: 0,\n    max: 3,\n    step: 1\n  }, BaseGeometry.CustomQualityParamInfo),\n  linearSegments: PD.Numeric(8, {\n    min: 1,\n    max: 48,\n    step: 1\n  }, BaseGeometry.CustomQualityParamInfo),\n  radialSegments: PD.Numeric(16, {\n    min: 2,\n    max: 56,\n    step: 2\n  }, BaseGeometry.CustomQualityParamInfo)\n};\nexport var DefaultPolymerTraceMeshProps = PD.getDefaultValues(PolymerTraceMeshParams);\nvar tmpV1 = Vec3();\n\nfunction createPolymerTraceMesh(ctx, unit, structure, theme, props, mesh) {\n  var _a, _b, _c;\n\n  var polymerElementCount = unit.polymerElements.length;\n  if (!polymerElementCount) return Mesh.createEmpty(mesh);\n  var sizeFactor = props.sizeFactor,\n      detail = props.detail,\n      linearSegments = props.linearSegments,\n      radialSegments = props.radialSegments,\n      aspectRatio = props.aspectRatio,\n      arrowFactor = props.arrowFactor,\n      tubularHelices = props.tubularHelices;\n  var vertexCount = linearSegments * radialSegments * polymerElementCount + (radialSegments + 1) * polymerElementCount * 2;\n  var builderState = MeshBuilder.createState(vertexCount, vertexCount / 10, mesh);\n  var isCoarse = Unit.isCoarse(unit);\n  var state = createCurveSegmentState(linearSegments);\n  var curvePoints = state.curvePoints,\n      normalVectors = state.normalVectors,\n      binormalVectors = state.binormalVectors,\n      widthValues = state.widthValues,\n      heightValues = state.heightValues;\n  var i = 0;\n  var polymerTraceIt = PolymerTraceIterator(unit, structure, {\n    ignoreSecondaryStructure: false,\n    useHelixOrientation: tubularHelices\n  });\n\n  while (polymerTraceIt.hasNext) {\n    var v = polymerTraceIt.move();\n    builderState.currentGroup = i;\n    var isNucleicType = isNucleic(v.moleculeType);\n    var isSheet = SecondaryStructureType.is(v.secStrucType, 4\n    /* Beta */\n    );\n    var isHelix = SecondaryStructureType.is(v.secStrucType, 2\n    /* Helix */\n    );\n    var tension = isHelix && !tubularHelices ? HelixTension : StandardTension;\n    var shift = isNucleicType ? NucleicShift : StandardShift;\n    interpolateCurveSegment(state, v, tension, shift);\n    var w0 = theme.size.size(v.centerPrev) * sizeFactor;\n    var w1 = theme.size.size(v.center) * sizeFactor;\n    var w2 = theme.size.size(v.centerNext) * sizeFactor;\n\n    if (isCoarse) {\n      w0 *= aspectRatio / 2;\n      w1 *= aspectRatio / 2;\n      w2 *= aspectRatio / 2;\n    }\n\n    var startCap = v.secStrucFirst || v.coarseBackboneFirst || v.first;\n    var endCap = v.secStrucLast || v.coarseBackboneLast || v.last;\n    var segmentCount = linearSegments;\n\n    if (v.initial) {\n      segmentCount = Math.max(Math.round(linearSegments * shift), 1);\n      var offset = linearSegments - segmentCount;\n      curvePoints.copyWithin(0, offset * 3);\n      binormalVectors.copyWithin(0, offset * 3);\n      normalVectors.copyWithin(0, offset * 3);\n      Vec3.fromArray(tmpV1, curvePoints, 3);\n      Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v.p2, tmpV1));\n      Vec3.scaleAndAdd(tmpV1, v.p2, tmpV1, w1 * OverhangFactor);\n      Vec3.toArray(tmpV1, curvePoints, 0);\n    } else if (v.final) {\n      segmentCount = Math.max(Math.round(linearSegments * (1 - shift)), 1);\n      Vec3.fromArray(tmpV1, curvePoints, segmentCount * 3 - 3);\n      Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v.p2, tmpV1));\n      Vec3.scaleAndAdd(tmpV1, v.p2, tmpV1, w1 * OverhangFactor);\n      Vec3.toArray(tmpV1, curvePoints, segmentCount * 3);\n    }\n\n    if (v.initial === true && v.final === true) {\n      addSphere(builderState, v.p2, w1 * 2, detail);\n    } else if (isSheet) {\n      var h0 = w0 * aspectRatio;\n      var h1 = w1 * aspectRatio;\n      var h2 = w2 * aspectRatio;\n      var arrowHeight = v.secStrucLast ? h1 * arrowFactor : 0;\n      interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift);\n\n      if (radialSegments === 2) {\n        addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, arrowHeight);\n      } else {\n        addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, arrowHeight, startCap, endCap);\n      }\n    } else {\n      var h0 = void 0,\n          h1 = void 0,\n          h2 = void 0;\n\n      if (isHelix && !v.isCoarseBackbone) {\n        if (tubularHelices) {\n          w0 *= aspectRatio * 1.5;\n          w1 *= aspectRatio * 1.5;\n          w2 *= aspectRatio * 1.5;\n          h0 = w0;\n          h1 = w1;\n          h2 = w2;\n        } else {\n          h0 = w0 * aspectRatio;\n          h1 = w1 * aspectRatio;\n          h2 = w2 * aspectRatio;\n        }\n      } else if (isNucleicType && !v.isCoarseBackbone) {\n        h0 = w0 * aspectRatio;\n        h1 = w1 * aspectRatio;\n        h2 = w2 * aspectRatio;\n        _a = [h0, w0], w0 = _a[0], h0 = _a[1];\n        _b = [h1, w1], w1 = _b[0], h1 = _b[1];\n        _c = [h2, w2], w2 = _c[0], h2 = _c[1];\n      } else {\n        h0 = w0;\n        h1 = w1;\n        h2 = w2;\n      }\n\n      interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift);\n\n      if (radialSegments === 2) {\n        if (isNucleicType && !v.isCoarseBackbone) {\n          // TODO find a cleaner way to swap normal and binormal for nucleic types\n          for (var i_1 = 0, il = binormalVectors.length; i_1 < il; i_1++) binormalVectors[i_1] *= -1;\n\n          addRibbon(builderState, curvePoints, binormalVectors, normalVectors, segmentCount, heightValues, widthValues, 0);\n        } else {\n          addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, 0);\n        }\n      } else if (radialSegments === 4) {\n        addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, 0, startCap, endCap);\n      } else {\n        addTube(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, radialSegments, widthValues, heightValues, startCap, endCap);\n      }\n    }\n\n    ++i;\n  }\n\n  var m = MeshBuilder.getMesh(builderState);\n  var sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);\n  m.setBoundingSphere(sphere);\n  return m;\n}\n\nexport var PolymerTraceParams = __assign(__assign({}, UnitsMeshParams), PolymerTraceMeshParams);\nexport function PolymerTraceVisual(materialId) {\n  return UnitsMeshVisual({\n    defaultProps: PD.getDefaultValues(PolymerTraceParams),\n    createGeometry: createPolymerTraceMesh,\n    createLocationIterator: PolymerLocationIterator.fromGroup,\n    getLoci: getPolymerElementLoci,\n    eachLocation: eachPolymerElement,\n    setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {\n      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.tubularHelices !== currentProps.tubularHelices || newProps.detail !== currentProps.detail || newProps.linearSegments !== currentProps.linearSegments || newProps.radialSegments !== currentProps.radialSegments || newProps.aspectRatio !== currentProps.aspectRatio || newProps.arrowFactor !== currentProps.arrowFactor;\n      var secondaryStructureHash = SecondaryStructureProvider.get(newStructureGroup.structure).version;\n\n      if (state.info.secondaryStructureHash !== secondaryStructureHash) {\n        state.createGeometry = true;\n        state.info.secondaryStructureHash = secondaryStructureHash;\n      }\n    }\n  }, materialId);\n}","map":{"version":3,"sources":["../../../../src/mol-repr/structure/visual/polymer-trace-mesh.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { Unit } from '../../../mol-model/structure';\r\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\r\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\r\nimport { createCurveSegmentState, PolymerTraceIterator, interpolateCurveSegment, interpolateSizes, PolymerLocationIterator, getPolymerElementLoci, eachPolymerElement, HelixTension, NucleicShift, StandardShift, StandardTension, OverhangFactor } from './util/polymer';\r\nimport { isNucleic, SecondaryStructureType } from '../../../mol-model/structure/model/types';\r\nimport { addSheet } from '../../../mol-geo/geometry/mesh/builder/sheet';\r\nimport { addTube } from '../../../mol-geo/geometry/mesh/builder/tube';\r\nimport { UnitsMeshParams, UnitsMeshVisual } from '../units-visual';\r\nimport { SecondaryStructureProvider } from '../../../mol-model-props/computed/secondary-structure';\r\nimport { addRibbon } from '../../../mol-geo/geometry/mesh/builder/ribbon';\r\nimport { addSphere } from '../../../mol-geo/geometry/mesh/builder/sphere';\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nexport var PolymerTraceMeshParams = {\r\n    sizeFactor: PD.Numeric(0.2, { min: 0, max: 10, step: 0.01 }),\r\n    aspectRatio: PD.Numeric(5, { min: 0.1, max: 10, step: 0.1 }),\r\n    arrowFactor: PD.Numeric(1.5, { min: 0, max: 3, step: 0.1 }),\r\n    tubularHelices: PD.Boolean(false),\r\n    detail: PD.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo),\r\n    linearSegments: PD.Numeric(8, { min: 1, max: 48, step: 1 }, BaseGeometry.CustomQualityParamInfo),\r\n    radialSegments: PD.Numeric(16, { min: 2, max: 56, step: 2 }, BaseGeometry.CustomQualityParamInfo)\r\n};\r\nexport var DefaultPolymerTraceMeshProps = PD.getDefaultValues(PolymerTraceMeshParams);\r\nvar tmpV1 = Vec3();\r\nfunction createPolymerTraceMesh(ctx, unit, structure, theme, props, mesh) {\r\n    var _a, _b, _c;\r\n    var polymerElementCount = unit.polymerElements.length;\r\n    if (!polymerElementCount)\r\n        return Mesh.createEmpty(mesh);\r\n    var sizeFactor = props.sizeFactor, detail = props.detail, linearSegments = props.linearSegments, radialSegments = props.radialSegments, aspectRatio = props.aspectRatio, arrowFactor = props.arrowFactor, tubularHelices = props.tubularHelices;\r\n    var vertexCount = linearSegments * radialSegments * polymerElementCount + (radialSegments + 1) * polymerElementCount * 2;\r\n    var builderState = MeshBuilder.createState(vertexCount, vertexCount / 10, mesh);\r\n    var isCoarse = Unit.isCoarse(unit);\r\n    var state = createCurveSegmentState(linearSegments);\r\n    var curvePoints = state.curvePoints, normalVectors = state.normalVectors, binormalVectors = state.binormalVectors, widthValues = state.widthValues, heightValues = state.heightValues;\r\n    var i = 0;\r\n    var polymerTraceIt = PolymerTraceIterator(unit, structure, { ignoreSecondaryStructure: false, useHelixOrientation: tubularHelices });\r\n    while (polymerTraceIt.hasNext) {\r\n        var v = polymerTraceIt.move();\r\n        builderState.currentGroup = i;\r\n        var isNucleicType = isNucleic(v.moleculeType);\r\n        var isSheet = SecondaryStructureType.is(v.secStrucType, 4 /* Beta */);\r\n        var isHelix = SecondaryStructureType.is(v.secStrucType, 2 /* Helix */);\r\n        var tension = isHelix && !tubularHelices ? HelixTension : StandardTension;\r\n        var shift = isNucleicType ? NucleicShift : StandardShift;\r\n        interpolateCurveSegment(state, v, tension, shift);\r\n        var w0 = theme.size.size(v.centerPrev) * sizeFactor;\r\n        var w1 = theme.size.size(v.center) * sizeFactor;\r\n        var w2 = theme.size.size(v.centerNext) * sizeFactor;\r\n        if (isCoarse) {\r\n            w0 *= aspectRatio / 2;\r\n            w1 *= aspectRatio / 2;\r\n            w2 *= aspectRatio / 2;\r\n        }\r\n        var startCap = v.secStrucFirst || v.coarseBackboneFirst || v.first;\r\n        var endCap = v.secStrucLast || v.coarseBackboneLast || v.last;\r\n        var segmentCount = linearSegments;\r\n        if (v.initial) {\r\n            segmentCount = Math.max(Math.round(linearSegments * shift), 1);\r\n            var offset = linearSegments - segmentCount;\r\n            curvePoints.copyWithin(0, offset * 3);\r\n            binormalVectors.copyWithin(0, offset * 3);\r\n            normalVectors.copyWithin(0, offset * 3);\r\n            Vec3.fromArray(tmpV1, curvePoints, 3);\r\n            Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v.p2, tmpV1));\r\n            Vec3.scaleAndAdd(tmpV1, v.p2, tmpV1, w1 * OverhangFactor);\r\n            Vec3.toArray(tmpV1, curvePoints, 0);\r\n        }\r\n        else if (v.final) {\r\n            segmentCount = Math.max(Math.round(linearSegments * (1 - shift)), 1);\r\n            Vec3.fromArray(tmpV1, curvePoints, segmentCount * 3 - 3);\r\n            Vec3.normalize(tmpV1, Vec3.sub(tmpV1, v.p2, tmpV1));\r\n            Vec3.scaleAndAdd(tmpV1, v.p2, tmpV1, w1 * OverhangFactor);\r\n            Vec3.toArray(tmpV1, curvePoints, segmentCount * 3);\r\n        }\r\n        if (v.initial === true && v.final === true) {\r\n            addSphere(builderState, v.p2, w1 * 2, detail);\r\n        }\r\n        else if (isSheet) {\r\n            var h0 = w0 * aspectRatio;\r\n            var h1 = w1 * aspectRatio;\r\n            var h2 = w2 * aspectRatio;\r\n            var arrowHeight = v.secStrucLast ? h1 * arrowFactor : 0;\r\n            interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift);\r\n            if (radialSegments === 2) {\r\n                addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, arrowHeight);\r\n            }\r\n            else {\r\n                addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, arrowHeight, startCap, endCap);\r\n            }\r\n        }\r\n        else {\r\n            var h0 = void 0, h1 = void 0, h2 = void 0;\r\n            if (isHelix && !v.isCoarseBackbone) {\r\n                if (tubularHelices) {\r\n                    w0 *= aspectRatio * 1.5;\r\n                    w1 *= aspectRatio * 1.5;\r\n                    w2 *= aspectRatio * 1.5;\r\n                    h0 = w0;\r\n                    h1 = w1;\r\n                    h2 = w2;\r\n                }\r\n                else {\r\n                    h0 = w0 * aspectRatio;\r\n                    h1 = w1 * aspectRatio;\r\n                    h2 = w2 * aspectRatio;\r\n                }\r\n            }\r\n            else if (isNucleicType && !v.isCoarseBackbone) {\r\n                h0 = w0 * aspectRatio;\r\n                h1 = w1 * aspectRatio;\r\n                h2 = w2 * aspectRatio;\r\n                _a = [h0, w0], w0 = _a[0], h0 = _a[1];\r\n                _b = [h1, w1], w1 = _b[0], h1 = _b[1];\r\n                _c = [h2, w2], w2 = _c[0], h2 = _c[1];\r\n            }\r\n            else {\r\n                h0 = w0;\r\n                h1 = w1;\r\n                h2 = w2;\r\n            }\r\n            interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift);\r\n            if (radialSegments === 2) {\r\n                if (isNucleicType && !v.isCoarseBackbone) {\r\n                    // TODO find a cleaner way to swap normal and binormal for nucleic types\r\n                    for (var i_1 = 0, il = binormalVectors.length; i_1 < il; i_1++)\r\n                        binormalVectors[i_1] *= -1;\r\n                    addRibbon(builderState, curvePoints, binormalVectors, normalVectors, segmentCount, heightValues, widthValues, 0);\r\n                }\r\n                else {\r\n                    addRibbon(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, 0);\r\n                }\r\n            }\r\n            else if (radialSegments === 4) {\r\n                addSheet(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, widthValues, heightValues, 0, startCap, endCap);\r\n            }\r\n            else {\r\n                addTube(builderState, curvePoints, normalVectors, binormalVectors, segmentCount, radialSegments, widthValues, heightValues, startCap, endCap);\r\n            }\r\n        }\r\n        ++i;\r\n    }\r\n    var m = MeshBuilder.getMesh(builderState);\r\n    var sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);\r\n    m.setBoundingSphere(sphere);\r\n    return m;\r\n}\r\nexport var PolymerTraceParams = __assign(__assign({}, UnitsMeshParams), PolymerTraceMeshParams);\r\nexport function PolymerTraceVisual(materialId) {\r\n    return UnitsMeshVisual({\r\n        defaultProps: PD.getDefaultValues(PolymerTraceParams),\r\n        createGeometry: createPolymerTraceMesh,\r\n        createLocationIterator: PolymerLocationIterator.fromGroup,\r\n        getLoci: getPolymerElementLoci,\r\n        eachLocation: eachPolymerElement,\r\n        setUpdateState: function (state, newProps, currentProps, newTheme, currentTheme, newStructureGroup, currentStructureGroup) {\r\n            state.createGeometry = (newProps.sizeFactor !== currentProps.sizeFactor ||\r\n                newProps.tubularHelices !== currentProps.tubularHelices ||\r\n                newProps.detail !== currentProps.detail ||\r\n                newProps.linearSegments !== currentProps.linearSegments ||\r\n                newProps.radialSegments !== currentProps.radialSegments ||\r\n                newProps.aspectRatio !== currentProps.aspectRatio ||\r\n                newProps.arrowFactor !== currentProps.arrowFactor);\r\n            var secondaryStructureHash = SecondaryStructureProvider.get(newStructureGroup.structure).version;\r\n            if (state.info.secondaryStructureHash !== secondaryStructureHash) {\r\n                state.createGeometry = true;\r\n                state.info.secondaryStructureHash = secondaryStructureHash;\r\n            }\r\n        }\r\n    }, materialId);\r\n}\r\n//# sourceMappingURL=polymer-trace-mesh.js.map"]},"metadata":{},"sourceType":"module"}