{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { arrayPickIndices, cantorPairing } from '../../mol-data/util';\nimport { LinkedIndex, SortedArray } from '../../mol-data/int';\nexport var IntAdjacencyGraph;\n\n(function (IntAdjacencyGraph) {\n  function areEqual(a, b) {\n    if (a === b) return true;\n    if (a.vertexCount !== b.vertexCount || a.edgeCount !== b.edgeCount) return false;\n    var aa = a.a,\n        ab = a.b,\n        ao = a.offset;\n    var ba = b.a,\n        bb = b.b,\n        bo = b.offset;\n\n    for (var i = 0, _i = a.a.length; i < _i; i++) {\n      if (aa[i] !== ba[i]) return false;\n    }\n\n    for (var i = 0, _i = a.b.length; i < _i; i++) {\n      if (ab[i] !== bb[i]) return false;\n    }\n\n    for (var i = 0, _i = a.offset.length; i < _i; i++) {\n      if (ao[i] !== bo[i]) return false;\n    }\n\n    for (var _a = 0, _b = Object.keys(a.edgeProps); _a < _b.length; _a++) {\n      var k = _b[_a];\n      var pa = a.edgeProps[k],\n          pb = b.edgeProps[k];\n      if (!pb) return false;\n\n      for (var i = 0, _i = pa.length; i < _i; i++) {\n        if (pa[i] !== pb[i]) return false;\n      }\n    }\n\n    return true;\n  }\n\n  IntAdjacencyGraph.areEqual = areEqual;\n\n  var IntGraphImpl =\n  /** @class */\n  function () {\n    function IntGraphImpl(offset, a, b, edgeCount, edgeProps, props) {\n      this.offset = offset;\n      this.a = a;\n      this.b = b;\n      this.edgeCount = edgeCount;\n      this.props = props;\n      this.vertexCount = offset.length - 1;\n      this.edgeProps = edgeProps || {};\n    }\n\n    IntGraphImpl.prototype.getEdgeIndex = function (i, j) {\n      var a, b;\n\n      if (i < j) {\n        a = i;\n        b = j;\n      } else {\n        a = j;\n        b = i;\n      }\n\n      for (var t = this.offset[a], _t = this.offset[a + 1]; t < _t; t++) {\n        if (this.b[t] === b) return t;\n      }\n\n      return -1;\n    };\n\n    IntGraphImpl.prototype.getDirectedEdgeIndex = function (i, j) {\n      for (var t = this.offset[i], _t = this.offset[i + 1]; t < _t; t++) {\n        if (this.b[t] === j) return t;\n      }\n\n      return -1;\n    };\n\n    IntGraphImpl.prototype.getVertexEdgeCount = function (i) {\n      return this.offset[i + 1] - this.offset[i];\n    };\n\n    return IntGraphImpl;\n  }();\n\n  function create(offset, a, b, edgeCount, edgeProps, props) {\n    return new IntGraphImpl(offset, a, b, edgeCount, edgeProps, props);\n  }\n\n  IntAdjacencyGraph.create = create;\n\n  var EdgeBuilder =\n  /** @class */\n  function () {\n    function EdgeBuilder(vertexCount, xs, ys) {\n      this.vertexCount = vertexCount;\n      this.xs = xs;\n      this.ys = ys;\n      this.current = 0;\n      this.curA = 0;\n      this.curB = 0;\n      this.edgeCount = xs.length;\n      this.offsets = new Int32Array(this.vertexCount + 1);\n      this.bucketFill = new Int32Array(this.vertexCount);\n      var bucketSizes = new Int32Array(this.vertexCount);\n\n      for (var i = 0, _i = this.xs.length; i < _i; i++) bucketSizes[this.xs[i]]++;\n\n      for (var i = 0, _i = this.ys.length; i < _i; i++) bucketSizes[this.ys[i]]++;\n\n      var offset = 0;\n\n      for (var i = 0; i < this.vertexCount; i++) {\n        this.offsets[i] = offset;\n        offset += bucketSizes[i];\n      }\n\n      this.offsets[this.vertexCount] = offset;\n      this.slotCount = offset;\n      this.a = new Int32Array(offset);\n      this.b = new Int32Array(offset);\n    }\n\n    EdgeBuilder.prototype.createGraph = function (edgeProps, props) {\n      return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps, props);\n    };\n    /**\r\n     * @example\r\n     *   const property = new Int32Array(builder.slotCount);\r\n     *   for (let i = 0; i < builder.edgeCount; i++) {\r\n     *     builder.addNextEdge();\r\n     *     builder.assignProperty(property, srcProp[i]);\r\n     *   }\r\n     *   return builder.createGraph({ property });\r\n     */\n\n\n    EdgeBuilder.prototype.addNextEdge = function () {\n      var a = this.xs[this.current],\n          b = this.ys[this.current];\n      var oa = this.offsets[a] + this.bucketFill[a];\n      var ob = this.offsets[b] + this.bucketFill[b];\n      this.a[oa] = a;\n      this.b[oa] = b;\n      this.bucketFill[a]++;\n      this.a[ob] = b;\n      this.b[ob] = a;\n      this.bucketFill[b]++;\n      this.current++;\n      this.curA = oa;\n      this.curB = ob;\n    };\n    /** Builds property-less graph */\n\n\n    EdgeBuilder.prototype.addAllEdges = function () {\n      for (var i = 0; i < this.edgeCount; i++) {\n        this.addNextEdge();\n      }\n    };\n\n    EdgeBuilder.prototype.assignProperty = function (prop, value) {\n      prop[this.curA] = value;\n      prop[this.curB] = value;\n    };\n\n    return EdgeBuilder;\n  }();\n\n  IntAdjacencyGraph.EdgeBuilder = EdgeBuilder;\n\n  var DirectedEdgeBuilder =\n  /** @class */\n  function () {\n    function DirectedEdgeBuilder(vertexCount, xs, ys) {\n      this.vertexCount = vertexCount;\n      this.xs = xs;\n      this.ys = ys;\n      this.current = 0;\n      this.curA = 0;\n      this.edgeCount = xs.length;\n      this.offsets = new Int32Array(this.vertexCount + 1);\n      this.bucketFill = new Int32Array(this.vertexCount);\n      var bucketSizes = new Int32Array(this.vertexCount);\n\n      for (var i = 0, _i = this.xs.length; i < _i; i++) bucketSizes[this.xs[i]]++;\n\n      var offset = 0;\n\n      for (var i = 0; i < this.vertexCount; i++) {\n        this.offsets[i] = offset;\n        offset += bucketSizes[i];\n      }\n\n      this.offsets[this.vertexCount] = offset;\n      this.slotCount = offset;\n      this.a = new Int32Array(offset);\n      this.b = new Int32Array(offset);\n    }\n\n    DirectedEdgeBuilder.prototype.createGraph = function (edgeProps) {\n      return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps);\n    };\n    /**\r\n     * @example\r\n     *   const property = new Int32Array(builder.slotCount);\r\n     *   for (let i = 0; i < builder.edgeCount; i++) {\r\n     *     builder.addNextEdge();\r\n     *     builder.assignProperty(property, srcProp[i]);\r\n     *   }\r\n     *   return builder.createGraph({ property });\r\n     */\n\n\n    DirectedEdgeBuilder.prototype.addNextEdge = function () {\n      var a = this.xs[this.current],\n          b = this.ys[this.current];\n      var oa = this.offsets[a] + this.bucketFill[a];\n      this.a[oa] = a;\n      this.b[oa] = b;\n      this.bucketFill[a]++;\n      this.current++;\n      this.curA = oa;\n    };\n    /** Builds property-less graph */\n\n\n    DirectedEdgeBuilder.prototype.addAllEdges = function () {\n      for (var i = 0; i < this.edgeCount; i++) {\n        this.addNextEdge();\n      }\n    };\n\n    DirectedEdgeBuilder.prototype.assignProperty = function (prop, value) {\n      prop[this.curA] = value;\n    };\n\n    return DirectedEdgeBuilder;\n  }();\n\n  IntAdjacencyGraph.DirectedEdgeBuilder = DirectedEdgeBuilder;\n\n  var UniqueEdgeBuilder =\n  /** @class */\n  function () {\n    function UniqueEdgeBuilder(vertexCount) {\n      this.vertexCount = vertexCount;\n      this.xs = [];\n      this.ys = [];\n      this.included = new Set();\n    }\n\n    UniqueEdgeBuilder.prototype.addEdge = function (i, j) {\n      var u = i,\n          v = j;\n\n      if (i > j) {\n        u = j;\n        v = i;\n      }\n\n      var id = cantorPairing(u, v);\n      if (this.included.has(id)) return false;\n      this.included.add(id);\n      this.xs[this.xs.length] = u;\n      this.ys[this.ys.length] = v;\n      return true;\n    };\n\n    UniqueEdgeBuilder.prototype.getGraph = function () {\n      return fromVertexPairs(this.vertexCount, this.xs, this.ys);\n    }; // if we cant to add custom props as well\n\n\n    UniqueEdgeBuilder.prototype.getEdgeBuiler = function () {\n      return new EdgeBuilder(this.vertexCount, this.xs, this.ys);\n    };\n\n    return UniqueEdgeBuilder;\n  }();\n\n  IntAdjacencyGraph.UniqueEdgeBuilder = UniqueEdgeBuilder;\n\n  function fromVertexPairs(vertexCount, xs, ys) {\n    var graphBuilder = new IntAdjacencyGraph.EdgeBuilder(vertexCount, xs, ys);\n    graphBuilder.addAllEdges();\n    return graphBuilder.createGraph({});\n  }\n\n  IntAdjacencyGraph.fromVertexPairs = fromVertexPairs;\n\n  function induceByVertices(graph, vertexIndices) {\n    var b = graph.b,\n        offset = graph.offset,\n        vertexCount = graph.vertexCount,\n        edgeProps = graph.edgeProps;\n    var vertexMap = new Int32Array(vertexCount);\n\n    for (var i = 0, _i = vertexIndices.length; i < _i; i++) vertexMap[vertexIndices[i]] = i + 1;\n\n    var newEdgeCount = 0;\n\n    for (var i = 0; i < vertexCount; i++) {\n      if (vertexMap[i] === 0) continue;\n\n      for (var j = offset[i], _j = offset[i + 1]; j < _j; j++) {\n        if (b[j] > i && vertexMap[b[j]] !== 0) newEdgeCount++;\n      }\n    }\n\n    var newOffsets = new Int32Array(vertexIndices.length + 1);\n    var edgeIndices = new Int32Array(2 * newEdgeCount);\n    var newA = new Int32Array(2 * newEdgeCount);\n    var newB = new Int32Array(2 * newEdgeCount);\n    var eo = 0,\n        vo = 0;\n\n    for (var i = 0; i < vertexCount; i++) {\n      if (vertexMap[i] === 0) continue;\n      var aa = vertexMap[i] - 1;\n\n      for (var j = offset[i], _j = offset[i + 1]; j < _j; j++) {\n        var bb = vertexMap[b[j]];\n        if (bb === 0) continue;\n        newA[eo] = aa;\n        newB[eo] = bb - 1;\n        edgeIndices[eo] = j;\n        eo++;\n      }\n\n      newOffsets[++vo] = eo;\n    }\n\n    var newEdgeProps = {};\n\n    for (var _a = 0, _b = Object.keys(edgeProps); _a < _b.length; _a++) {\n      var key = _b[_a];\n      newEdgeProps[key] = arrayPickIndices(edgeProps[key], edgeIndices);\n    }\n\n    return create(newOffsets, newA, newB, newEdgeCount, newEdgeProps);\n  }\n\n  IntAdjacencyGraph.induceByVertices = induceByVertices;\n\n  function connectedComponents(graph) {\n    var vCount = graph.vertexCount;\n    if (vCount === 0) return {\n      componentCount: 0,\n      componentIndex: new Int32Array(0)\n    };\n\n    if (graph.edgeCount === 0) {\n      var componentIndex_1 = new Int32Array(vCount);\n\n      for (var i = 0, _i = vCount; i < _i; i++) {\n        componentIndex_1[i] = i;\n      }\n\n      return {\n        componentCount: vCount,\n        componentIndex: componentIndex_1\n      };\n    }\n\n    var componentIndex = new Int32Array(vCount);\n\n    for (var i = 0, _i = vCount; i < _i; i++) componentIndex[i] = -1;\n\n    var currentComponent = 0;\n    componentIndex[0] = currentComponent;\n    var offset = graph.offset,\n        neighbor = graph.b;\n    var stack = [0];\n    var list = LinkedIndex(vCount);\n    list.remove(0);\n\n    while (stack.length > 0) {\n      var v = stack.pop();\n      var cIdx = componentIndex[v];\n\n      for (var eI = offset[v], _eI = offset[v + 1]; eI < _eI; eI++) {\n        var n = neighbor[eI];\n        if (!list.has(n)) continue;\n        list.remove(n);\n        stack.push(n);\n        componentIndex[n] = cIdx;\n      } // check if we visited all vertices.\n      // If not, create a new component and continue.\n\n\n      if (stack.length === 0 && list.head >= 0) {\n        stack.push(list.head);\n        componentIndex[list.head] = ++currentComponent;\n        list.remove(list.head);\n      }\n    }\n\n    return {\n      componentCount: vCount,\n      componentIndex: componentIndex\n    };\n  }\n\n  IntAdjacencyGraph.connectedComponents = connectedComponents;\n  /**\r\n   * Check if any vertex in `verticesA` is connected to any vertex in `verticesB`\r\n   * via at most `maxDistance` edges.\r\n   *\r\n   * Returns true if verticesA and verticesB are intersecting.\r\n   */\n\n  function areVertexSetsConnected(graph, verticesA, verticesB, maxDistance) {\n    // check if A and B are intersecting, this handles maxDistance = 0\n    if (SortedArray.areIntersecting(verticesA, verticesB)) return true;\n    if (maxDistance < 1) return false;\n    var visited = new Set();\n\n    for (var i = 0, il = verticesA.length; i < il; ++i) {\n      visited.add(verticesA[i]);\n    }\n\n    return areVertexSetsConnectedImpl(graph, verticesA, verticesB, maxDistance, visited);\n  }\n\n  IntAdjacencyGraph.areVertexSetsConnected = areVertexSetsConnected;\n})(IntAdjacencyGraph || (IntAdjacencyGraph = {}));\n\nfunction areVertexSetsConnectedImpl(graph, frontier, target, distance, visited) {\n  var neighbor = graph.b,\n      offset = graph.offset;\n  var newFrontier = [];\n\n  for (var i = 0, il = frontier.length; i < il; ++i) {\n    var src = frontier[i];\n\n    for (var j = offset[src], jl = offset[src + 1]; j < jl; ++j) {\n      var other = neighbor[j];\n      if (visited.has(other)) continue;\n      if (SortedArray.has(target, other)) return true;\n      visited.add(other);\n      newFrontier[newFrontier.length] = other;\n    }\n  }\n\n  return distance > 1 ? areVertexSetsConnectedImpl(graph, newFrontier, target, distance - 1, visited) : false;\n}","map":{"version":3,"sources":["../../../src/mol-math/graph/int-adjacency-graph.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { arrayPickIndices, cantorPairing } from '../../mol-data/util';\r\nimport { LinkedIndex, SortedArray } from '../../mol-data/int';\r\nexport var IntAdjacencyGraph;\r\n(function (IntAdjacencyGraph) {\r\n    function areEqual(a, b) {\r\n        if (a === b)\r\n            return true;\r\n        if (a.vertexCount !== b.vertexCount || a.edgeCount !== b.edgeCount)\r\n            return false;\r\n        var aa = a.a, ab = a.b, ao = a.offset;\r\n        var ba = b.a, bb = b.b, bo = b.offset;\r\n        for (var i = 0, _i = a.a.length; i < _i; i++) {\r\n            if (aa[i] !== ba[i])\r\n                return false;\r\n        }\r\n        for (var i = 0, _i = a.b.length; i < _i; i++) {\r\n            if (ab[i] !== bb[i])\r\n                return false;\r\n        }\r\n        for (var i = 0, _i = a.offset.length; i < _i; i++) {\r\n            if (ao[i] !== bo[i])\r\n                return false;\r\n        }\r\n        for (var _a = 0, _b = Object.keys(a.edgeProps); _a < _b.length; _a++) {\r\n            var k = _b[_a];\r\n            var pa = a.edgeProps[k], pb = b.edgeProps[k];\r\n            if (!pb)\r\n                return false;\r\n            for (var i = 0, _i = pa.length; i < _i; i++) {\r\n                if (pa[i] !== pb[i])\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    IntAdjacencyGraph.areEqual = areEqual;\r\n    var IntGraphImpl = /** @class */ (function () {\r\n        function IntGraphImpl(offset, a, b, edgeCount, edgeProps, props) {\r\n            this.offset = offset;\r\n            this.a = a;\r\n            this.b = b;\r\n            this.edgeCount = edgeCount;\r\n            this.props = props;\r\n            this.vertexCount = offset.length - 1;\r\n            this.edgeProps = (edgeProps || {});\r\n        }\r\n        IntGraphImpl.prototype.getEdgeIndex = function (i, j) {\r\n            var a, b;\r\n            if (i < j) {\r\n                a = i;\r\n                b = j;\r\n            }\r\n            else {\r\n                a = j;\r\n                b = i;\r\n            }\r\n            for (var t = this.offset[a], _t = this.offset[a + 1]; t < _t; t++) {\r\n                if (this.b[t] === b)\r\n                    return t;\r\n            }\r\n            return -1;\r\n        };\r\n        IntGraphImpl.prototype.getDirectedEdgeIndex = function (i, j) {\r\n            for (var t = this.offset[i], _t = this.offset[i + 1]; t < _t; t++) {\r\n                if (this.b[t] === j)\r\n                    return t;\r\n            }\r\n            return -1;\r\n        };\r\n        IntGraphImpl.prototype.getVertexEdgeCount = function (i) {\r\n            return this.offset[i + 1] - this.offset[i];\r\n        };\r\n        return IntGraphImpl;\r\n    }());\r\n    function create(offset, a, b, edgeCount, edgeProps, props) {\r\n        return new IntGraphImpl(offset, a, b, edgeCount, edgeProps, props);\r\n    }\r\n    IntAdjacencyGraph.create = create;\r\n    var EdgeBuilder = /** @class */ (function () {\r\n        function EdgeBuilder(vertexCount, xs, ys) {\r\n            this.vertexCount = vertexCount;\r\n            this.xs = xs;\r\n            this.ys = ys;\r\n            this.current = 0;\r\n            this.curA = 0;\r\n            this.curB = 0;\r\n            this.edgeCount = xs.length;\r\n            this.offsets = new Int32Array(this.vertexCount + 1);\r\n            this.bucketFill = new Int32Array(this.vertexCount);\r\n            var bucketSizes = new Int32Array(this.vertexCount);\r\n            for (var i = 0, _i = this.xs.length; i < _i; i++)\r\n                bucketSizes[this.xs[i]]++;\r\n            for (var i = 0, _i = this.ys.length; i < _i; i++)\r\n                bucketSizes[this.ys[i]]++;\r\n            var offset = 0;\r\n            for (var i = 0; i < this.vertexCount; i++) {\r\n                this.offsets[i] = offset;\r\n                offset += bucketSizes[i];\r\n            }\r\n            this.offsets[this.vertexCount] = offset;\r\n            this.slotCount = offset;\r\n            this.a = new Int32Array(offset);\r\n            this.b = new Int32Array(offset);\r\n        }\r\n        EdgeBuilder.prototype.createGraph = function (edgeProps, props) {\r\n            return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps, props);\r\n        };\r\n        /**\r\n         * @example\r\n         *   const property = new Int32Array(builder.slotCount);\r\n         *   for (let i = 0; i < builder.edgeCount; i++) {\r\n         *     builder.addNextEdge();\r\n         *     builder.assignProperty(property, srcProp[i]);\r\n         *   }\r\n         *   return builder.createGraph({ property });\r\n         */\r\n        EdgeBuilder.prototype.addNextEdge = function () {\r\n            var a = this.xs[this.current], b = this.ys[this.current];\r\n            var oa = this.offsets[a] + this.bucketFill[a];\r\n            var ob = this.offsets[b] + this.bucketFill[b];\r\n            this.a[oa] = a;\r\n            this.b[oa] = b;\r\n            this.bucketFill[a]++;\r\n            this.a[ob] = b;\r\n            this.b[ob] = a;\r\n            this.bucketFill[b]++;\r\n            this.current++;\r\n            this.curA = oa;\r\n            this.curB = ob;\r\n        };\r\n        /** Builds property-less graph */\r\n        EdgeBuilder.prototype.addAllEdges = function () {\r\n            for (var i = 0; i < this.edgeCount; i++) {\r\n                this.addNextEdge();\r\n            }\r\n        };\r\n        EdgeBuilder.prototype.assignProperty = function (prop, value) {\r\n            prop[this.curA] = value;\r\n            prop[this.curB] = value;\r\n        };\r\n        return EdgeBuilder;\r\n    }());\r\n    IntAdjacencyGraph.EdgeBuilder = EdgeBuilder;\r\n    var DirectedEdgeBuilder = /** @class */ (function () {\r\n        function DirectedEdgeBuilder(vertexCount, xs, ys) {\r\n            this.vertexCount = vertexCount;\r\n            this.xs = xs;\r\n            this.ys = ys;\r\n            this.current = 0;\r\n            this.curA = 0;\r\n            this.edgeCount = xs.length;\r\n            this.offsets = new Int32Array(this.vertexCount + 1);\r\n            this.bucketFill = new Int32Array(this.vertexCount);\r\n            var bucketSizes = new Int32Array(this.vertexCount);\r\n            for (var i = 0, _i = this.xs.length; i < _i; i++)\r\n                bucketSizes[this.xs[i]]++;\r\n            var offset = 0;\r\n            for (var i = 0; i < this.vertexCount; i++) {\r\n                this.offsets[i] = offset;\r\n                offset += bucketSizes[i];\r\n            }\r\n            this.offsets[this.vertexCount] = offset;\r\n            this.slotCount = offset;\r\n            this.a = new Int32Array(offset);\r\n            this.b = new Int32Array(offset);\r\n        }\r\n        DirectedEdgeBuilder.prototype.createGraph = function (edgeProps) {\r\n            return create(this.offsets, this.a, this.b, this.edgeCount, edgeProps);\r\n        };\r\n        /**\r\n         * @example\r\n         *   const property = new Int32Array(builder.slotCount);\r\n         *   for (let i = 0; i < builder.edgeCount; i++) {\r\n         *     builder.addNextEdge();\r\n         *     builder.assignProperty(property, srcProp[i]);\r\n         *   }\r\n         *   return builder.createGraph({ property });\r\n         */\r\n        DirectedEdgeBuilder.prototype.addNextEdge = function () {\r\n            var a = this.xs[this.current], b = this.ys[this.current];\r\n            var oa = this.offsets[a] + this.bucketFill[a];\r\n            this.a[oa] = a;\r\n            this.b[oa] = b;\r\n            this.bucketFill[a]++;\r\n            this.current++;\r\n            this.curA = oa;\r\n        };\r\n        /** Builds property-less graph */\r\n        DirectedEdgeBuilder.prototype.addAllEdges = function () {\r\n            for (var i = 0; i < this.edgeCount; i++) {\r\n                this.addNextEdge();\r\n            }\r\n        };\r\n        DirectedEdgeBuilder.prototype.assignProperty = function (prop, value) {\r\n            prop[this.curA] = value;\r\n        };\r\n        return DirectedEdgeBuilder;\r\n    }());\r\n    IntAdjacencyGraph.DirectedEdgeBuilder = DirectedEdgeBuilder;\r\n    var UniqueEdgeBuilder = /** @class */ (function () {\r\n        function UniqueEdgeBuilder(vertexCount) {\r\n            this.vertexCount = vertexCount;\r\n            this.xs = [];\r\n            this.ys = [];\r\n            this.included = new Set();\r\n        }\r\n        UniqueEdgeBuilder.prototype.addEdge = function (i, j) {\r\n            var u = i, v = j;\r\n            if (i > j) {\r\n                u = j;\r\n                v = i;\r\n            }\r\n            var id = cantorPairing(u, v);\r\n            if (this.included.has(id))\r\n                return false;\r\n            this.included.add(id);\r\n            this.xs[this.xs.length] = u;\r\n            this.ys[this.ys.length] = v;\r\n            return true;\r\n        };\r\n        UniqueEdgeBuilder.prototype.getGraph = function () {\r\n            return fromVertexPairs(this.vertexCount, this.xs, this.ys);\r\n        };\r\n        // if we cant to add custom props as well\r\n        UniqueEdgeBuilder.prototype.getEdgeBuiler = function () {\r\n            return new EdgeBuilder(this.vertexCount, this.xs, this.ys);\r\n        };\r\n        return UniqueEdgeBuilder;\r\n    }());\r\n    IntAdjacencyGraph.UniqueEdgeBuilder = UniqueEdgeBuilder;\r\n    function fromVertexPairs(vertexCount, xs, ys) {\r\n        var graphBuilder = new IntAdjacencyGraph.EdgeBuilder(vertexCount, xs, ys);\r\n        graphBuilder.addAllEdges();\r\n        return graphBuilder.createGraph({});\r\n    }\r\n    IntAdjacencyGraph.fromVertexPairs = fromVertexPairs;\r\n    function induceByVertices(graph, vertexIndices) {\r\n        var b = graph.b, offset = graph.offset, vertexCount = graph.vertexCount, edgeProps = graph.edgeProps;\r\n        var vertexMap = new Int32Array(vertexCount);\r\n        for (var i = 0, _i = vertexIndices.length; i < _i; i++)\r\n            vertexMap[vertexIndices[i]] = i + 1;\r\n        var newEdgeCount = 0;\r\n        for (var i = 0; i < vertexCount; i++) {\r\n            if (vertexMap[i] === 0)\r\n                continue;\r\n            for (var j = offset[i], _j = offset[i + 1]; j < _j; j++) {\r\n                if (b[j] > i && vertexMap[b[j]] !== 0)\r\n                    newEdgeCount++;\r\n            }\r\n        }\r\n        var newOffsets = new Int32Array(vertexIndices.length + 1);\r\n        var edgeIndices = new Int32Array(2 * newEdgeCount);\r\n        var newA = new Int32Array(2 * newEdgeCount);\r\n        var newB = new Int32Array(2 * newEdgeCount);\r\n        var eo = 0, vo = 0;\r\n        for (var i = 0; i < vertexCount; i++) {\r\n            if (vertexMap[i] === 0)\r\n                continue;\r\n            var aa = vertexMap[i] - 1;\r\n            for (var j = offset[i], _j = offset[i + 1]; j < _j; j++) {\r\n                var bb = vertexMap[b[j]];\r\n                if (bb === 0)\r\n                    continue;\r\n                newA[eo] = aa;\r\n                newB[eo] = bb - 1;\r\n                edgeIndices[eo] = j;\r\n                eo++;\r\n            }\r\n            newOffsets[++vo] = eo;\r\n        }\r\n        var newEdgeProps = {};\r\n        for (var _a = 0, _b = Object.keys(edgeProps); _a < _b.length; _a++) {\r\n            var key = _b[_a];\r\n            newEdgeProps[key] = arrayPickIndices(edgeProps[key], edgeIndices);\r\n        }\r\n        return create(newOffsets, newA, newB, newEdgeCount, newEdgeProps);\r\n    }\r\n    IntAdjacencyGraph.induceByVertices = induceByVertices;\r\n    function connectedComponents(graph) {\r\n        var vCount = graph.vertexCount;\r\n        if (vCount === 0)\r\n            return { componentCount: 0, componentIndex: new Int32Array(0) };\r\n        if (graph.edgeCount === 0) {\r\n            var componentIndex_1 = new Int32Array(vCount);\r\n            for (var i = 0, _i = vCount; i < _i; i++) {\r\n                componentIndex_1[i] = i;\r\n            }\r\n            return { componentCount: vCount, componentIndex: componentIndex_1 };\r\n        }\r\n        var componentIndex = new Int32Array(vCount);\r\n        for (var i = 0, _i = vCount; i < _i; i++)\r\n            componentIndex[i] = -1;\r\n        var currentComponent = 0;\r\n        componentIndex[0] = currentComponent;\r\n        var offset = graph.offset, neighbor = graph.b;\r\n        var stack = [0];\r\n        var list = LinkedIndex(vCount);\r\n        list.remove(0);\r\n        while (stack.length > 0) {\r\n            var v = stack.pop();\r\n            var cIdx = componentIndex[v];\r\n            for (var eI = offset[v], _eI = offset[v + 1]; eI < _eI; eI++) {\r\n                var n = neighbor[eI];\r\n                if (!list.has(n))\r\n                    continue;\r\n                list.remove(n);\r\n                stack.push(n);\r\n                componentIndex[n] = cIdx;\r\n            }\r\n            // check if we visited all vertices.\r\n            // If not, create a new component and continue.\r\n            if (stack.length === 0 && list.head >= 0) {\r\n                stack.push(list.head);\r\n                componentIndex[list.head] = ++currentComponent;\r\n                list.remove(list.head);\r\n            }\r\n        }\r\n        return { componentCount: vCount, componentIndex: componentIndex };\r\n    }\r\n    IntAdjacencyGraph.connectedComponents = connectedComponents;\r\n    /**\r\n     * Check if any vertex in `verticesA` is connected to any vertex in `verticesB`\r\n     * via at most `maxDistance` edges.\r\n     *\r\n     * Returns true if verticesA and verticesB are intersecting.\r\n     */\r\n    function areVertexSetsConnected(graph, verticesA, verticesB, maxDistance) {\r\n        // check if A and B are intersecting, this handles maxDistance = 0\r\n        if (SortedArray.areIntersecting(verticesA, verticesB))\r\n            return true;\r\n        if (maxDistance < 1)\r\n            return false;\r\n        var visited = new Set();\r\n        for (var i = 0, il = verticesA.length; i < il; ++i) {\r\n            visited.add(verticesA[i]);\r\n        }\r\n        return areVertexSetsConnectedImpl(graph, verticesA, verticesB, maxDistance, visited);\r\n    }\r\n    IntAdjacencyGraph.areVertexSetsConnected = areVertexSetsConnected;\r\n})(IntAdjacencyGraph || (IntAdjacencyGraph = {}));\r\nfunction areVertexSetsConnectedImpl(graph, frontier, target, distance, visited) {\r\n    var neighbor = graph.b, offset = graph.offset;\r\n    var newFrontier = [];\r\n    for (var i = 0, il = frontier.length; i < il; ++i) {\r\n        var src = frontier[i];\r\n        for (var j = offset[src], jl = offset[src + 1]; j < jl; ++j) {\r\n            var other = neighbor[j];\r\n            if (visited.has(other))\r\n                continue;\r\n            if (SortedArray.has(target, other))\r\n                return true;\r\n            visited.add(other);\r\n            newFrontier[newFrontier.length] = other;\r\n        }\r\n    }\r\n    return distance > 1 ? areVertexSetsConnectedImpl(graph, newFrontier, target, distance - 1, visited) : false;\r\n}\r\n//# sourceMappingURL=int-adjacency-graph.js.map"]},"metadata":{},"sourceType":"module"}