{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Unit, StructureElement, Bond, Structure } from '../../../../mol-model/structure';\nimport { OrderedSet, Interval } from '../../../../mol-data/int';\nimport { EmptyLoci } from '../../../../mol-model/loci';\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\nimport { getResidueLoci } from './common';\nexport * from './polymer/backbone';\nexport * from './polymer/gap-iterator';\nexport * from './polymer/trace-iterator';\nexport * from './polymer/curve-segment';\nexport var StandardTension = 0.5;\nexport var HelixTension = 0.9;\nexport var StandardShift = 0.5;\nexport var NucleicShift = 0.3;\nexport var OverhangFactor = 2;\nexport function getPolymerRanges(unit) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return unit.model.atomicRanges.polymerRanges;\n\n    case 1\n    /* Spheres */\n    :\n      return unit.model.coarseHierarchy.spheres.polymerRanges;\n\n    case 2\n    /* Gaussians */\n    :\n      return unit.model.coarseHierarchy.gaussians.polymerRanges;\n  }\n}\nexport function getGapRanges(unit) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return unit.model.atomicRanges.gapRanges;\n\n    case 1\n    /* Spheres */\n    :\n      return unit.model.coarseHierarchy.spheres.gapRanges;\n\n    case 2\n    /* Gaussians */\n    :\n      return unit.model.coarseHierarchy.gaussians.gapRanges;\n  }\n}\nexport var PolymerLocationIterator;\n\n(function (PolymerLocationIterator) {\n  function fromGroup(structureGroup) {\n    var group = structureGroup.group,\n        structure = structureGroup.structure;\n    var polymerElements = group.units[0].polymerElements;\n    var groupCount = polymerElements.length;\n    var instanceCount = group.units.length;\n    var location = StructureElement.Location.create(structure);\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var unit = group.units[instanceIndex];\n      location.unit = unit;\n      location.element = polymerElements[groupIndex];\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  PolymerLocationIterator.fromGroup = fromGroup;\n})(PolymerLocationIterator || (PolymerLocationIterator = {}));\n\nexport var PolymerGapLocationIterator;\n\n(function (PolymerGapLocationIterator) {\n  function fromGroup(structureGroup) {\n    var group = structureGroup.group,\n        structure = structureGroup.structure;\n    var gapElements = group.units[0].gapElements;\n    var groupCount = gapElements.length;\n    var instanceCount = group.units.length;\n    var location = StructureElement.Location.create(structure);\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var unit = group.units[instanceIndex];\n      location.unit = unit;\n      location.element = gapElements[groupIndex];\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  PolymerGapLocationIterator.fromGroup = fromGroup;\n})(PolymerGapLocationIterator || (PolymerGapLocationIterator = {}));\n/** Return a Loci for the elements of the whole residue of a polymer element. */\n\n\nexport function getPolymerElementLoci(pickingId, structureGroup, id) {\n  var objectId = pickingId.objectId,\n      instanceId = pickingId.instanceId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    var unit = group.units[instanceId];\n\n    if (Unit.isAtomic(unit)) {\n      return getResidueLoci(structure, unit, unit.polymerElements[groupId]);\n    } else {\n      var elements = unit.elements;\n      var elementIndex = unit.polymerElements[groupId];\n      var unitIndex = OrderedSet.indexOf(elements, elementIndex);\n\n      if (unitIndex !== -1) {\n        var indices = OrderedSet.ofSingleton(unitIndex);\n        return StructureElement.Loci(structure, [{\n          unit: unit,\n          indices: indices\n        }]);\n      }\n    }\n  }\n\n  return EmptyLoci;\n}\n\nfunction tryApplyResidueInterval(offset, elements, traceElementIndex, apply, r1, r2) {\n  var start = -1,\n      startIdx = -1;\n\n  for (var rI = r1; rI <= r2; rI++) {\n    var eI = traceElementIndex[rI];\n    if (eI < 0) continue;\n    start = OrderedSet.indexOf(elements, eI);\n\n    if (start >= 0) {\n      startIdx = rI;\n      break;\n    }\n  }\n\n  if (start < 0) {\n    return false;\n  }\n\n  var end = start;\n\n  for (var rI = r2; rI > startIdx; rI--) {\n    var eI = traceElementIndex[rI];\n    if (eI < 0) continue;\n    var e = OrderedSet.indexOf(elements, eI);\n\n    if (e >= 0) {\n      end = e;\n      break;\n    }\n  }\n\n  return apply(Interval.ofRange(offset + start, offset + end));\n}\n\nexport function eachAtomicUnitTracedElement(offset, groupSize, elementsSelector, apply, e) {\n  var changed = false;\n  var elements = e.unit.elements;\n  var traceElementIndex = e.unit.model.atomicHierarchy.derived.residue.traceElementIndex;\n  var resIndex = e.unit.model.atomicHierarchy.residueAtomSegments.index;\n  var tracedElements = elementsSelector(e.unit);\n\n  if (Interval.is(e.indices)) {\n    if (Interval.start(e.indices) === 0 && Interval.end(e.indices) === e.unit.elements.length) {\n      // full unit here\n      changed = apply(Interval.ofBounds(offset, offset + groupSize)) || changed;\n    } else {\n      var r1 = resIndex[elements[Interval.min(e.indices)]];\n      var r2 = resIndex[elements[Interval.max(e.indices)]];\n      changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;\n    }\n  } else {\n    var indices = e.indices;\n\n    for (var i = 0, _i = indices.length; i < _i; i++) {\n      var r1 = resIndex[elements[indices[i]]];\n      var r2 = r1;\n      var endI = i + 1;\n\n      while (endI < _i) {\n        var _r = resIndex[elements[indices[endI]]];\n        if (_r - r2 > 1) break;\n        r2 = _r;\n        endI++;\n      }\n\n      i = endI - 1;\n      changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;\n    }\n  }\n\n  return changed;\n}\n\nfunction selectPolymerElements(u) {\n  return u.polymerElements;\n}\n/** Mark a polymer element (e.g. part of a cartoon trace) */\n\n\nexport function eachPolymerElement(loci, structureGroup, apply) {\n  var changed = false;\n  if (!StructureElement.Loci.is(loci)) return false;\n  var structure = structureGroup.structure,\n      group = structureGroup.group;\n  if (!Structure.areEquivalent(loci.structure, structure)) return false;\n  var groupCount = group.units[0].polymerElements.length;\n\n  for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\n    var e = _b[_a];\n    if (!group.unitIndexMap.has(e.unit.id)) continue;\n    var offset = group.unitIndexMap.get(e.unit.id) * groupCount; // to target unit instance\n\n    if (Unit.isAtomic(e.unit)) {\n      changed = eachAtomicUnitTracedElement(offset, groupCount, selectPolymerElements, apply, e) || changed;\n    } else {\n      if (Interval.is(e.indices)) {\n        var start = offset + Interval.start(e.indices);\n        var end = offset + Interval.end(e.indices);\n        changed = apply(Interval.ofBounds(start, end)) || changed;\n      } else {\n        for (var i = 0, _i = e.indices.length; i < _i; i++) {\n          var start = e.indices[i];\n          var endI = i + 1;\n\n          while (endI < _i && e.indices[endI] === start) endI++;\n\n          i = endI - 1;\n          var end = e.indices[i];\n          changed = apply(Interval.ofRange(offset + start, offset + end)) || changed;\n        }\n      }\n    }\n  }\n\n  return changed;\n}\n/** Return a Loci for both directions of the polymer gap element. */\n\nexport function getPolymerGapElementLoci(pickingId, structureGroup, id) {\n  var objectId = pickingId.objectId,\n      instanceId = pickingId.instanceId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    var unit = group.units[instanceId];\n    var unitIndexA = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId]);\n    var unitIndexB = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId % 2 ? groupId - 1 : groupId + 1]);\n\n    if (unitIndexA !== -1 && unitIndexB !== -1) {\n      return Bond.Loci(structure, [Bond.Location(structure, unit, unitIndexA, structure, unit, unitIndexB), Bond.Location(structure, unit, unitIndexB, structure, unit, unitIndexA)]);\n    }\n  }\n\n  return EmptyLoci;\n}\nexport function eachPolymerGapElement(loci, structureGroup, apply) {\n  var changed = false;\n\n  if (Bond.isLoci(loci)) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n    loci = Bond.remapLoci(loci, structure);\n    var groupCount = group.units[0].gapElements.length;\n\n    for (var _a = 0, _b = loci.bonds; _a < _b.length; _a++) {\n      var b = _b[_a];\n      var unitIdx = group.unitIndexMap.get(b.aUnit.id);\n\n      if (unitIdx !== undefined) {\n        var idxA = OrderedSet.indexOf(b.aUnit.gapElements, b.aUnit.elements[b.aIndex]);\n        var idxB = OrderedSet.indexOf(b.bUnit.gapElements, b.bUnit.elements[b.bIndex]);\n\n        if (idxA !== -1 && idxB !== -1) {\n          if (apply(Interval.ofSingleton(unitIdx * groupCount + idxA))) changed = true;\n        }\n      }\n    }\n  } else if (StructureElement.Loci.is(loci)) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n    loci = StructureElement.Loci.remap(loci, structure);\n    var groupCount_1 = group.units[0].gapElements.length;\n\n    var _loop_1 = function (e) {\n      var unitIdx = group.unitIndexMap.get(e.unit.id);\n\n      if (unitIdx !== undefined) {\n        OrderedSet.forEach(e.indices, function (v) {\n          var idx = OrderedSet.indexOf(e.unit.gapElements, e.unit.elements[v]);\n\n          if (idx !== -1) {\n            if (apply(Interval.ofSingleton(unitIdx * groupCount_1 + idx))) changed = true;\n          }\n        });\n      }\n    };\n\n    for (var _c = 0, _d = loci.elements; _c < _d.length; _c++) {\n      var e = _d[_c];\n\n      _loop_1(e);\n    }\n  }\n\n  return changed;\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/polymer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Unit, StructureElement, Bond, Structure } from '../../../../mol-model/structure';\r\nimport { OrderedSet, Interval } from '../../../../mol-data/int';\r\nimport { EmptyLoci } from '../../../../mol-model/loci';\r\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\r\nimport { getResidueLoci } from './common';\r\nexport * from './polymer/backbone';\r\nexport * from './polymer/gap-iterator';\r\nexport * from './polymer/trace-iterator';\r\nexport * from './polymer/curve-segment';\r\nexport var StandardTension = 0.5;\r\nexport var HelixTension = 0.9;\r\nexport var StandardShift = 0.5;\r\nexport var NucleicShift = 0.3;\r\nexport var OverhangFactor = 2;\r\nexport function getPolymerRanges(unit) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return unit.model.atomicRanges.polymerRanges;\r\n        case 1 /* Spheres */: return unit.model.coarseHierarchy.spheres.polymerRanges;\r\n        case 2 /* Gaussians */: return unit.model.coarseHierarchy.gaussians.polymerRanges;\r\n    }\r\n}\r\nexport function getGapRanges(unit) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return unit.model.atomicRanges.gapRanges;\r\n        case 1 /* Spheres */: return unit.model.coarseHierarchy.spheres.gapRanges;\r\n        case 2 /* Gaussians */: return unit.model.coarseHierarchy.gaussians.gapRanges;\r\n    }\r\n}\r\nexport var PolymerLocationIterator;\r\n(function (PolymerLocationIterator) {\r\n    function fromGroup(structureGroup) {\r\n        var group = structureGroup.group, structure = structureGroup.structure;\r\n        var polymerElements = group.units[0].polymerElements;\r\n        var groupCount = polymerElements.length;\r\n        var instanceCount = group.units.length;\r\n        var location = StructureElement.Location.create(structure);\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var unit = group.units[instanceIndex];\r\n            location.unit = unit;\r\n            location.element = polymerElements[groupIndex];\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    PolymerLocationIterator.fromGroup = fromGroup;\r\n})(PolymerLocationIterator || (PolymerLocationIterator = {}));\r\nexport var PolymerGapLocationIterator;\r\n(function (PolymerGapLocationIterator) {\r\n    function fromGroup(structureGroup) {\r\n        var group = structureGroup.group, structure = structureGroup.structure;\r\n        var gapElements = group.units[0].gapElements;\r\n        var groupCount = gapElements.length;\r\n        var instanceCount = group.units.length;\r\n        var location = StructureElement.Location.create(structure);\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var unit = group.units[instanceIndex];\r\n            location.unit = unit;\r\n            location.element = gapElements[groupIndex];\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    PolymerGapLocationIterator.fromGroup = fromGroup;\r\n})(PolymerGapLocationIterator || (PolymerGapLocationIterator = {}));\r\n/** Return a Loci for the elements of the whole residue of a polymer element. */\r\nexport function getPolymerElementLoci(pickingId, structureGroup, id) {\r\n    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        var unit = group.units[instanceId];\r\n        if (Unit.isAtomic(unit)) {\r\n            return getResidueLoci(structure, unit, unit.polymerElements[groupId]);\r\n        }\r\n        else {\r\n            var elements = unit.elements;\r\n            var elementIndex = unit.polymerElements[groupId];\r\n            var unitIndex = OrderedSet.indexOf(elements, elementIndex);\r\n            if (unitIndex !== -1) {\r\n                var indices = OrderedSet.ofSingleton(unitIndex);\r\n                return StructureElement.Loci(structure, [{ unit: unit, indices: indices }]);\r\n            }\r\n        }\r\n    }\r\n    return EmptyLoci;\r\n}\r\nfunction tryApplyResidueInterval(offset, elements, traceElementIndex, apply, r1, r2) {\r\n    var start = -1, startIdx = -1;\r\n    for (var rI = r1; rI <= r2; rI++) {\r\n        var eI = traceElementIndex[rI];\r\n        if (eI < 0)\r\n            continue;\r\n        start = OrderedSet.indexOf(elements, eI);\r\n        if (start >= 0) {\r\n            startIdx = rI;\r\n            break;\r\n        }\r\n    }\r\n    if (start < 0) {\r\n        return false;\r\n    }\r\n    var end = start;\r\n    for (var rI = r2; rI > startIdx; rI--) {\r\n        var eI = traceElementIndex[rI];\r\n        if (eI < 0)\r\n            continue;\r\n        var e = OrderedSet.indexOf(elements, eI);\r\n        if (e >= 0) {\r\n            end = e;\r\n            break;\r\n        }\r\n    }\r\n    return apply(Interval.ofRange(offset + start, offset + end));\r\n}\r\nexport function eachAtomicUnitTracedElement(offset, groupSize, elementsSelector, apply, e) {\r\n    var changed = false;\r\n    var elements = e.unit.elements;\r\n    var traceElementIndex = e.unit.model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var resIndex = e.unit.model.atomicHierarchy.residueAtomSegments.index;\r\n    var tracedElements = elementsSelector(e.unit);\r\n    if (Interval.is(e.indices)) {\r\n        if (Interval.start(e.indices) === 0 && Interval.end(e.indices) === e.unit.elements.length) {\r\n            // full unit here\r\n            changed = apply(Interval.ofBounds(offset, offset + groupSize)) || changed;\r\n        }\r\n        else {\r\n            var r1 = resIndex[elements[Interval.min(e.indices)]];\r\n            var r2 = resIndex[elements[Interval.max(e.indices)]];\r\n            changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;\r\n        }\r\n    }\r\n    else {\r\n        var indices = e.indices;\r\n        for (var i = 0, _i = indices.length; i < _i; i++) {\r\n            var r1 = resIndex[elements[indices[i]]];\r\n            var r2 = r1;\r\n            var endI = i + 1;\r\n            while (endI < _i) {\r\n                var _r = resIndex[elements[indices[endI]]];\r\n                if (_r - r2 > 1)\r\n                    break;\r\n                r2 = _r;\r\n                endI++;\r\n            }\r\n            i = endI - 1;\r\n            changed = tryApplyResidueInterval(offset, tracedElements, traceElementIndex, apply, r1, r2) || changed;\r\n        }\r\n    }\r\n    return changed;\r\n}\r\nfunction selectPolymerElements(u) { return u.polymerElements; }\r\n/** Mark a polymer element (e.g. part of a cartoon trace) */\r\nexport function eachPolymerElement(loci, structureGroup, apply) {\r\n    var changed = false;\r\n    if (!StructureElement.Loci.is(loci))\r\n        return false;\r\n    var structure = structureGroup.structure, group = structureGroup.group;\r\n    if (!Structure.areEquivalent(loci.structure, structure))\r\n        return false;\r\n    var groupCount = group.units[0].polymerElements.length;\r\n    for (var _a = 0, _b = loci.elements; _a < _b.length; _a++) {\r\n        var e = _b[_a];\r\n        if (!group.unitIndexMap.has(e.unit.id))\r\n            continue;\r\n        var offset = group.unitIndexMap.get(e.unit.id) * groupCount; // to target unit instance\r\n        if (Unit.isAtomic(e.unit)) {\r\n            changed = eachAtomicUnitTracedElement(offset, groupCount, selectPolymerElements, apply, e) || changed;\r\n        }\r\n        else {\r\n            if (Interval.is(e.indices)) {\r\n                var start = offset + Interval.start(e.indices);\r\n                var end = offset + Interval.end(e.indices);\r\n                changed = apply(Interval.ofBounds(start, end)) || changed;\r\n            }\r\n            else {\r\n                for (var i = 0, _i = e.indices.length; i < _i; i++) {\r\n                    var start = e.indices[i];\r\n                    var endI = i + 1;\r\n                    while (endI < _i && e.indices[endI] === start)\r\n                        endI++;\r\n                    i = endI - 1;\r\n                    var end = e.indices[i];\r\n                    changed = apply(Interval.ofRange(offset + start, offset + end)) || changed;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n/** Return a Loci for both directions of the polymer gap element. */\r\nexport function getPolymerGapElementLoci(pickingId, structureGroup, id) {\r\n    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        var unit = group.units[instanceId];\r\n        var unitIndexA = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId]);\r\n        var unitIndexB = OrderedSet.indexOf(unit.elements, unit.gapElements[groupId % 2 ? groupId - 1 : groupId + 1]);\r\n        if (unitIndexA !== -1 && unitIndexB !== -1) {\r\n            return Bond.Loci(structure, [\r\n                Bond.Location(structure, unit, unitIndexA, structure, unit, unitIndexB),\r\n                Bond.Location(structure, unit, unitIndexB, structure, unit, unitIndexA)\r\n            ]);\r\n        }\r\n    }\r\n    return EmptyLoci;\r\n}\r\nexport function eachPolymerGapElement(loci, structureGroup, apply) {\r\n    var changed = false;\r\n    if (Bond.isLoci(loci)) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n            return false;\r\n        loci = Bond.remapLoci(loci, structure);\r\n        var groupCount = group.units[0].gapElements.length;\r\n        for (var _a = 0, _b = loci.bonds; _a < _b.length; _a++) {\r\n            var b = _b[_a];\r\n            var unitIdx = group.unitIndexMap.get(b.aUnit.id);\r\n            if (unitIdx !== undefined) {\r\n                var idxA = OrderedSet.indexOf(b.aUnit.gapElements, b.aUnit.elements[b.aIndex]);\r\n                var idxB = OrderedSet.indexOf(b.bUnit.gapElements, b.bUnit.elements[b.bIndex]);\r\n                if (idxA !== -1 && idxB !== -1) {\r\n                    if (apply(Interval.ofSingleton(unitIdx * groupCount + idxA)))\r\n                        changed = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (StructureElement.Loci.is(loci)) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n            return false;\r\n        loci = StructureElement.Loci.remap(loci, structure);\r\n        var groupCount_1 = group.units[0].gapElements.length;\r\n        var _loop_1 = function (e) {\r\n            var unitIdx = group.unitIndexMap.get(e.unit.id);\r\n            if (unitIdx !== undefined) {\r\n                OrderedSet.forEach(e.indices, function (v) {\r\n                    var idx = OrderedSet.indexOf(e.unit.gapElements, e.unit.elements[v]);\r\n                    if (idx !== -1) {\r\n                        if (apply(Interval.ofSingleton(unitIdx * groupCount_1 + idx)))\r\n                            changed = true;\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        for (var _c = 0, _d = loci.elements; _c < _d.length; _c++) {\r\n            var e = _d[_c];\r\n            _loop_1(e);\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n//# sourceMappingURL=polymer.js.map"]},"metadata":{},"sourceType":"module"}