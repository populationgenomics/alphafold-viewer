{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport * as Impl from './impl/interval';\nvar Interval;\n\n(function (Interval) {\n  Interval.Empty = Impl.Empty;\n\n  Interval.ofSingleton = function (v) {\n    return Impl.ofRange(v, v);\n  };\n  /** Create interval from range [min, max] */\n\n\n  Interval.ofRange = Impl.ofRange;\n  /** Create interval from bounds [start, end), i.e. [start, end - 1] */\n\n  Interval.ofBounds = Impl.ofBounds;\n  /** Create interval from length [0, length), i.e. [0, length - 1] */\n\n  Interval.ofLength = Impl.ofLength;\n  Interval.is = Impl.is;\n  /** Test if a value is within the bounds of the interval */\n\n  Interval.has = Impl.has;\n  /** Returns the index of `x` in `set` or -1 if not found. */\n\n  Interval.indexOf = Impl.indexOf;\n  Interval.getAt = Impl.getAt;\n  /** Start value of the Interval<T>, same as min value */\n\n  Interval.start = Impl.start;\n  /** End value of the Interval<T>, same as max + 1 */\n\n  Interval.end = Impl.end;\n  /** Min value of the Interval<T>, same as start value */\n\n  Interval.min = Impl.min;\n  /** Max value of the Interval<T>, same as end - 1 */\n\n  Interval.max = Impl.max;\n  /** Number of values in the interval */\n\n  Interval.size = Impl.size;\n  /** Hash code describing the interval */\n\n  Interval.hashCode = Impl.hashCode;\n  /** String representation of the interval */\n\n  Interval.toString = Impl.toString;\n  /** Test if two intervals are identical */\n\n  Interval.areEqual = Impl.areEqual;\n  /** Test if two intervals are intersecting, i.e. their bounds overlap */\n\n  Interval.areIntersecting = Impl.areIntersecting;\n  /** Test if interval b is fully included in interval a */\n\n  Interval.isSubInterval = Impl.isSubInterval;\n  Interval.findPredecessorIndex = Impl.findPredecessorIndex;\n  Interval.findPredecessorIndexInInterval = Impl.findPredecessorIndexInInterval;\n  Interval.findRange = Impl.findRange;\n  /** Size of the intersection of the two intervals */\n\n  Interval.intersectionSize = Impl.intersectionSize;\n  /** Get a new interval that is the intersection of the two intervals */\n\n  Interval.intersect = Impl.intersect;\n})(Interval || (Interval = {}));\n\nexport { Interval };","map":{"version":3,"sources":["../../../src/mol-data/int/interval.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,OAAO,KAAK,IAAZ,MAAsB,iBAAtB;AAEA,IAAU,QAAV;;AAAA,CAAA,UAAU,QAAV,EAAkB;AACD,EAAA,QAAA,CAAA,KAAA,GAAkB,IAAI,CAAC,KAAvB;;AAEA,EAAA,QAAA,CAAA,WAAA,GAAoE,UAAC,CAAD,EAAE;AAAK,WAAA,IAAI,CAAC,OAAL,CAAa,CAAb,EAAA,CAAA,CAAA;AAAyB,GAApG;AACb;;;AACa,EAAA,QAAA,CAAA,OAAA,GAAsE,IAAI,CAAC,OAA3E;AACb;;AACa,EAAA,QAAA,CAAA,QAAA,GAAyE,IAAI,CAAC,QAA9E;AACb;;AACa,EAAA,QAAA,CAAA,QAAA,GAAkE,IAAI,CAAC,QAAvE;AACA,EAAA,QAAA,CAAA,EAAA,GAA8D,IAAI,CAAC,EAAnE;AAEb;;AACa,EAAA,QAAA,CAAA,GAAA,GAA2E,IAAI,CAAC,GAAhF;AACb;;AACa,EAAA,QAAA,CAAA,OAAA,GAA8E,IAAI,CAAC,OAAnF;AACA,EAAA,QAAA,CAAA,KAAA,GAA4E,IAAI,CAAC,KAAjF;AAEb;;AACa,EAAA,QAAA,CAAA,KAAA,GAAiE,IAAI,CAAC,KAAtE;AACb;;AACa,EAAA,QAAA,CAAA,GAAA,GAA+D,IAAI,CAAC,GAApE;AACb;;AACa,EAAA,QAAA,CAAA,GAAA,GAA+D,IAAI,CAAC,GAApE;AACb;;AACa,EAAA,QAAA,CAAA,GAAA,GAA+D,IAAI,CAAC,GAApE;AACb;;AACa,EAAA,QAAA,CAAA,IAAA,GAAqE,IAAI,CAAC,IAA1E;AACb;;AACa,EAAA,QAAA,CAAA,QAAA,GAAyE,IAAI,CAAC,QAA9E;AACb;;AACa,EAAA,QAAA,CAAA,QAAA,GAAyE,IAAI,CAAC,QAA9E;AAEb;;AACa,EAAA,QAAA,CAAA,QAAA,GAAmF,IAAI,CAAC,QAAxF;AACb;;AACa,EAAA,QAAA,CAAA,eAAA,GAA0F,IAAI,CAAC,eAA/F;AAEb;;AACa,EAAA,QAAA,CAAA,aAAA,GAAwF,IAAI,CAAC,aAA7F;AAEA,EAAA,QAAA,CAAA,oBAAA,GAA2F,IAAI,CAAC,oBAAhG;AACA,EAAA,QAAA,CAAA,8BAAA,GAAuH,IAAI,CAAC,8BAA5H;AACA,EAAA,QAAA,CAAA,SAAA,GAA4F,IAAI,CAAC,SAAjG;AACb;;AACa,EAAA,QAAA,CAAA,gBAAA,GAA0F,IAAI,CAAC,gBAA/F;AAEb;;AACa,EAAA,QAAA,CAAA,SAAA,GAAwF,IAAI,CAAC,SAA7F;AAChB,CAjDD,EAAU,QAAQ,KAAR,QAAQ,GAAA,EAAA,CAAlB;;AAsDA,SAAS,QAAT","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport * as Impl from './impl/interval';\r\nvar Interval;\r\n(function (Interval) {\r\n    Interval.Empty = Impl.Empty;\r\n    Interval.ofSingleton = function (v) { return Impl.ofRange(v, v); };\r\n    /** Create interval from range [min, max] */\r\n    Interval.ofRange = Impl.ofRange;\r\n    /** Create interval from bounds [start, end), i.e. [start, end - 1] */\r\n    Interval.ofBounds = Impl.ofBounds;\r\n    /** Create interval from length [0, length), i.e. [0, length - 1] */\r\n    Interval.ofLength = Impl.ofLength;\r\n    Interval.is = Impl.is;\r\n    /** Test if a value is within the bounds of the interval */\r\n    Interval.has = Impl.has;\r\n    /** Returns the index of `x` in `set` or -1 if not found. */\r\n    Interval.indexOf = Impl.indexOf;\r\n    Interval.getAt = Impl.getAt;\r\n    /** Start value of the Interval<T>, same as min value */\r\n    Interval.start = Impl.start;\r\n    /** End value of the Interval<T>, same as max + 1 */\r\n    Interval.end = Impl.end;\r\n    /** Min value of the Interval<T>, same as start value */\r\n    Interval.min = Impl.min;\r\n    /** Max value of the Interval<T>, same as end - 1 */\r\n    Interval.max = Impl.max;\r\n    /** Number of values in the interval */\r\n    Interval.size = Impl.size;\r\n    /** Hash code describing the interval */\r\n    Interval.hashCode = Impl.hashCode;\r\n    /** String representation of the interval */\r\n    Interval.toString = Impl.toString;\r\n    /** Test if two intervals are identical */\r\n    Interval.areEqual = Impl.areEqual;\r\n    /** Test if two intervals are intersecting, i.e. their bounds overlap */\r\n    Interval.areIntersecting = Impl.areIntersecting;\r\n    /** Test if interval b is fully included in interval a */\r\n    Interval.isSubInterval = Impl.isSubInterval;\r\n    Interval.findPredecessorIndex = Impl.findPredecessorIndex;\r\n    Interval.findPredecessorIndexInInterval = Impl.findPredecessorIndexInInterval;\r\n    Interval.findRange = Impl.findRange;\r\n    /** Size of the intersection of the two intervals */\r\n    Interval.intersectionSize = Impl.intersectionSize;\r\n    /** Get a new interval that is the intersection of the two intervals */\r\n    Interval.intersect = Impl.intersect;\r\n})(Interval || (Interval = {}));\r\nexport { Interval };\r\n//# sourceMappingURL=interval.js.map"]},"metadata":{},"sourceType":"module"}