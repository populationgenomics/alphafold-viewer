{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Unit, Bond } from '../../../mol-model/structure';\nimport { isMetal } from '../../../mol-model/structure/model/properties/atomic/types';\nimport { assignGeometry } from './geometry';\nimport { bondCount, typeSymbol, formalCharge, bondToElementCount } from './util';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { isDebugMode } from '../../../mol-util/debug';\nimport { SortedArray } from '../../../mol-data/int';\nimport { BondType } from '../../../mol-model/structure/model/types';\n/**\r\n * TODO:\r\n *   Ensure proper treatment of disorder/models. e.g. V257 N in 5vim\r\n *   Formal charge of 255 for SO4 anion (e.g. 5ghl)\r\n *   Have removed a lot of explicit features (as I think they're more\r\n *   generally captured by better VM).\r\n *     Could we instead have a \"delocalised negative/positive\" charge\r\n *     feature and flag these up?\r\n *\r\n */\n\nvar tmpConjBondItA = new Bond.ElementBondIterator();\nvar tmpConjBondItB = new Bond.ElementBondIterator();\n/**\r\n * Are we involved in some kind of pi system. Either explicitly forming\r\n * double bond or N, O next to a double bond, except:\r\n *\r\n *   N,O with degree 4 cannot be conjugated.\r\n *   N,O adjacent to P=O or S=O do not qualify (keeps sulfonamide N sp3 geom)\r\n */\n\nfunction isConjugated(structure, unit, index) {\n  var element = typeSymbol(unit, index);\n  var hetero = element === \"O\"\n  /* O */\n  || element === \"N\"\n  /* N */\n  ;\n  if (hetero && bondCount(structure, unit, index) === 4) return false;\n  tmpConjBondItA.setElement(structure, unit, index);\n\n  while (tmpConjBondItA.hasNext) {\n    var bA = tmpConjBondItA.move();\n    if (bA.order > 1) return true;\n\n    if (hetero) {\n      var elementB = typeSymbol(bA.otherUnit, bA.otherIndex);\n      tmpConjBondItB.setElement(structure, bA.otherUnit, bA.otherIndex);\n\n      while (tmpConjBondItB.hasNext) {\n        var bB = tmpConjBondItB.move();\n\n        if (bB.order > 1) {\n          if ((elementB === \"P\"\n          /* P */\n          || elementB === \"S\"\n          /* S */\n          ) && typeSymbol(bB.otherUnit, bB.otherIndex) === \"O\"\n          /* O */\n          ) {\n            continue;\n          }\n\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function explicitValence(structure, unit, index) {\n  var v = 0; // intra-unit bonds\n\n  var _a = unit.bonds,\n      offset = _a.offset,\n      _b = _a.edgeProps,\n      flags = _b.flags,\n      order = _b.order;\n\n  for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\n    if (BondType.isCovalent(flags[i])) v += order[i];\n  } // inter-unit bonds\n\n\n  structure.interUnitBonds.getEdgeIndices(index, unit.id).forEach(function (i) {\n    var b = structure.interUnitBonds.edges[i];\n    if (BondType.isCovalent(b.props.flag)) v += b.props.order;\n  });\n  return v;\n}\nvar tmpChargeBondItA = new Bond.ElementBondIterator();\nvar tmpChargeBondItB = new Bond.ElementBondIterator();\n/**\r\n * Attempts to produce a consistent charge and implicit\r\n * H-count for an atom.\r\n *\r\n * If both props.assignCharge and props.assignH, this\r\n * approximately follows the rules described in\r\n * https://docs.eyesopen.com/toolkits/python/oechemtk/valence.html#openeye-hydrogen-count-model\r\n *\r\n * If only charge or hydrogens are to be assigned it takes\r\n * a much simpler view and deduces one from the other\r\n */\n\nexport function calculateHydrogensCharge(structure, unit, index, props) {\n  var hydrogenCount = bondToElementCount(structure, unit, index, \"H\"\n  /* H */\n  );\n  var element = typeSymbol(unit, index);\n  var charge = formalCharge(unit, index);\n  var assignCharge = props.assignCharge === 'always' || props.assignCharge === 'auto' && charge === 0;\n  var assignH = props.assignH === 'always' || props.assignH === 'auto' && hydrogenCount === 0;\n  var degree = bondCount(structure, unit, index);\n  var valence = explicitValence(structure, unit, index);\n  var conjugated = isConjugated(structure, unit, index);\n  var multiBond = valence - degree > 0;\n  var implicitHCount = 0;\n  var geom = 8\n  /* Unknown */\n  ;\n\n  switch (element) {\n    case \"H\"\n    /* H */\n    :\n      if (assignCharge) {\n        if (degree === 0) {\n          charge = 1;\n          geom = 0\n          /* Spherical */\n          ;\n        } else if (degree === 1) {\n          charge = 0;\n          geom = 1\n          /* Terminal */\n          ;\n        }\n      }\n\n      break;\n\n    case \"C\"\n    /* C */\n    :\n      // TODO: Isocyanide?\n      if (assignCharge) {\n        charge = 0; // Assume carbon always neutral\n      }\n\n      if (assignH) {\n        // Carbocation/carbanion are 3-valent\n        implicitHCount = Math.max(0, 4 - valence - Math.abs(charge));\n      } // Carbocation is planar, carbanion is tetrahedral\n\n\n      geom = assignGeometry(degree + implicitHCount + Math.max(0, -charge));\n      break;\n\n    case \"N\"\n    /* N */\n    :\n      if (assignCharge) {\n        if (!assignH) {\n          // Trust input H explicitly:\n          charge = valence - 3;\n        } else if (conjugated && valence < 4) {\n          // Neutral unless amidine/guanidine double-bonded N:\n          if (degree - hydrogenCount === 1 && valence - hydrogenCount === 2) {\n            charge = 1;\n          } else {\n            charge = 0;\n          }\n        } else {\n          // Sulfonamide nitrogen and classed as sp3 in conjugation model but\n          // they won't be charged\n          // Don't assign charge to nitrogens bound to metals\n          tmpChargeBondItA.setElement(structure, unit, index);\n\n          while (tmpChargeBondItA.hasNext) {\n            var b = tmpChargeBondItA.move();\n            var elementB = typeSymbol(b.otherUnit, b.otherIndex);\n\n            if (elementB === \"S\"\n            /* S */\n            || isMetal(elementB)) {\n              charge = 0;\n              break;\n            } else {\n              charge = 1;\n            }\n          } // TODO: Planarity sanity check?\n\n        }\n      }\n\n      if (assignH) {\n        // NH4+ -> 4, 1' amide -> 2, nitro N/N+ depiction -> 0\n        implicitHCount = Math.max(0, 3 - valence + charge);\n      }\n\n      if (conjugated && !multiBond) {\n        // Amide, anilinic N etc. cannot consider lone-pair for geometry purposes\n        // Anilinic N geometry is depenent on ring electronics, for our purposes we\n        // assume it's trigonal!\n        geom = assignGeometry(degree + implicitHCount - charge);\n      } else {\n        // Everything else, pyridine, amine, nitrile, lp plays normal role:\n        geom = assignGeometry(degree + implicitHCount + 1 - charge);\n      }\n\n      break;\n\n    case \"O\"\n    /* O */\n    :\n      if (assignCharge) {\n        if (!assignH) {\n          charge = valence - 2;\n        }\n\n        if (valence === 1) {\n          tmpChargeBondItA.setElement(structure, unit, index);\n\n          b1: while (tmpChargeBondItA.hasNext) {\n            var bA = tmpChargeBondItA.move();\n            tmpChargeBondItB.setElement(structure, bA.otherUnit, bA.otherIndex);\n\n            while (tmpChargeBondItB.hasNext) {\n              var bB = tmpChargeBondItB.move();\n\n              if (!(bB.otherUnit === unit && bB.otherIndex === index) && typeSymbol(bB.otherUnit, bB.otherIndex) === \"O\"\n              /* O */\n              && bB.order === 2) {\n                charge = -1;\n                break b1;\n              }\n            }\n          }\n        }\n      }\n\n      if (assignH) {\n        // ethanol -> 1, carboxylate -> -1\n        implicitHCount = Math.max(0, 2 - valence + charge);\n      }\n\n      if (conjugated && !multiBond) {\n        // carboxylate OH, phenol OH, one lone-pair taken up with conjugation\n        geom = assignGeometry(degree + implicitHCount - charge + 1);\n      } else {\n        // Carbonyl (trigonal)\n        geom = assignGeometry(degree + implicitHCount - charge + 2);\n      }\n\n      break;\n    // Only handles thiols/thiolates/thioether/sulfonium. Sulfoxides and higher\n    // oxidiation states are assumed neutral S (charge carried on O if required)\n\n    case \"S\"\n    /* S */\n    :\n      if (assignCharge) {\n        if (!assignH) {\n          if (valence <= 3 && bondToElementCount(structure, unit, index, \"O\"\n          /* O */\n          ) === 0) {\n            charge = valence - 2; // e.g. explicitly deprotonated thiol\n          } else {\n            charge = 0;\n          }\n        }\n      }\n\n      if (assignH) {\n        if (valence < 2) {\n          implicitHCount = Math.max(0, 2 - valence + charge);\n        }\n      }\n\n      if (valence <= 3) {\n        // Thiol, thiolate, tioether -> tetrahedral\n        geom = assignGeometry(degree + implicitHCount - charge + 2);\n      }\n\n      break;\n\n    case \"F\"\n    /* F */\n    :\n    case \"CL\"\n    /* CL */\n    :\n    case \"BR\"\n    /* BR */\n    :\n    case \"I\"\n    /* I */\n    :\n    case \"AT\"\n    /* AT */\n    :\n      // Never implicitly protonate halides\n      if (assignCharge) {\n        charge = valence - 1;\n      }\n\n      break;\n\n    case \"LI\"\n    /* LI */\n    :\n    case \"NA\"\n    /* NA */\n    :\n    case \"K\"\n    /* K */\n    :\n    case \"RB\"\n    /* RB */\n    :\n    case \"CS\"\n    /* CS */\n    :\n    case \"FR\"\n    /* FR */\n    :\n      if (assignCharge) {\n        charge = 1 - valence;\n      }\n\n      break;\n\n    case \"BE\"\n    /* BE */\n    :\n    case \"MG\"\n    /* MG */\n    :\n    case \"CA\"\n    /* CA */\n    :\n    case \"SR\"\n    /* SR */\n    :\n    case \"BA\"\n    /* BA */\n    :\n    case \"RA\"\n    /* RA */\n    :\n      if (assignCharge) {\n        charge = 2 - valence;\n      }\n\n      break;\n\n    default:\n      if (isDebugMode) {\n        console.warn('Requested charge, protonation for an unhandled element', element);\n      }\n\n  }\n\n  return [charge, implicitHCount, implicitHCount + hydrogenCount, geom];\n}\n\nfunction calcUnitValenceModel(structure, unit, props) {\n  var n = unit.elements.length;\n  var charge = new Int8Array(n);\n  var implicitH = new Int8Array(n);\n  var totalH = new Int8Array(n);\n  var idealGeometry = new Int8Array(n); // always use root UnitIndex to take the topology of the whole structure in account\n\n  var hasParent = !!structure.parent;\n  var mapping;\n\n  if (hasParent) {\n    var rootUnit = structure.root.unitMap.get(unit.id);\n    mapping = SortedArray.indicesOf(rootUnit.elements, unit.elements);\n\n    if (mapping.length !== unit.elements.length) {\n      throw new Error('expected to find an index for every element');\n    }\n\n    unit = rootUnit;\n    structure = structure.root;\n  }\n\n  for (var i = 0; i < n; ++i) {\n    var j = hasParent ? mapping[i] : i;\n\n    var _a = calculateHydrogensCharge(structure, unit, j, props),\n        chg = _a[0],\n        implH = _a[1],\n        totH = _a[2],\n        geom = _a[3];\n\n    charge[i] = chg;\n    implicitH[i] = implH;\n    totalH[i] = totH;\n    idealGeometry[i] = geom;\n  }\n\n  return {\n    charge: charge,\n    implicitH: implicitH,\n    totalH: totalH,\n    idealGeometry: idealGeometry\n  };\n}\n\nexport var ValenceModelParams = {\n  assignCharge: PD.Select('auto', [['always', 'always'], ['auto', 'auto'], ['never', 'never']]),\n  assignH: PD.Select('auto', [['always', 'always'], ['auto', 'auto'], ['never', 'never']])\n};\nexport function calcValenceModel(ctx, structure, props) {\n  return __awaiter(this, void 0, void 0, function () {\n    var p, map, i, il, u, valenceModel;\n    return __generator(this, function (_a) {\n      p = __assign(__assign({}, PD.getDefaultValues(ValenceModelParams)), props);\n      map = new Map();\n\n      for (i = 0, il = structure.units.length; i < il; ++i) {\n        u = structure.units[i];\n\n        if (Unit.isAtomic(u)) {\n          valenceModel = calcUnitValenceModel(structure, u, p);\n          map.set(u.id, valenceModel);\n        }\n      }\n\n      return [2\n      /*return*/\n      , map];\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/chemistry/valence-model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Unit, Bond } from '../../../mol-model/structure';\r\nimport { isMetal } from '../../../mol-model/structure/model/properties/atomic/types';\r\nimport { assignGeometry } from './geometry';\r\nimport { bondCount, typeSymbol, formalCharge, bondToElementCount } from './util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { isDebugMode } from '../../../mol-util/debug';\r\nimport { SortedArray } from '../../../mol-data/int';\r\nimport { BondType } from '../../../mol-model/structure/model/types';\r\n/**\r\n * TODO:\r\n *   Ensure proper treatment of disorder/models. e.g. V257 N in 5vim\r\n *   Formal charge of 255 for SO4 anion (e.g. 5ghl)\r\n *   Have removed a lot of explicit features (as I think they're more\r\n *   generally captured by better VM).\r\n *     Could we instead have a \"delocalised negative/positive\" charge\r\n *     feature and flag these up?\r\n *\r\n */\r\nvar tmpConjBondItA = new Bond.ElementBondIterator();\r\nvar tmpConjBondItB = new Bond.ElementBondIterator();\r\n/**\r\n * Are we involved in some kind of pi system. Either explicitly forming\r\n * double bond or N, O next to a double bond, except:\r\n *\r\n *   N,O with degree 4 cannot be conjugated.\r\n *   N,O adjacent to P=O or S=O do not qualify (keeps sulfonamide N sp3 geom)\r\n */\r\nfunction isConjugated(structure, unit, index) {\r\n    var element = typeSymbol(unit, index);\r\n    var hetero = element === \"O\" /* O */ || element === \"N\" /* N */;\r\n    if (hetero && bondCount(structure, unit, index) === 4)\r\n        return false;\r\n    tmpConjBondItA.setElement(structure, unit, index);\r\n    while (tmpConjBondItA.hasNext) {\r\n        var bA = tmpConjBondItA.move();\r\n        if (bA.order > 1)\r\n            return true;\r\n        if (hetero) {\r\n            var elementB = typeSymbol(bA.otherUnit, bA.otherIndex);\r\n            tmpConjBondItB.setElement(structure, bA.otherUnit, bA.otherIndex);\r\n            while (tmpConjBondItB.hasNext) {\r\n                var bB = tmpConjBondItB.move();\r\n                if (bB.order > 1) {\r\n                    if ((elementB === \"P\" /* P */ || elementB === \"S\" /* S */) &&\r\n                        typeSymbol(bB.otherUnit, bB.otherIndex) === \"O\" /* O */) {\r\n                        continue;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nexport function explicitValence(structure, unit, index) {\r\n    var v = 0;\r\n    // intra-unit bonds\r\n    var _a = unit.bonds, offset = _a.offset, _b = _a.edgeProps, flags = _b.flags, order = _b.order;\r\n    for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\r\n        if (BondType.isCovalent(flags[i]))\r\n            v += order[i];\r\n    }\r\n    // inter-unit bonds\r\n    structure.interUnitBonds.getEdgeIndices(index, unit.id).forEach(function (i) {\r\n        var b = structure.interUnitBonds.edges[i];\r\n        if (BondType.isCovalent(b.props.flag))\r\n            v += b.props.order;\r\n    });\r\n    return v;\r\n}\r\nvar tmpChargeBondItA = new Bond.ElementBondIterator();\r\nvar tmpChargeBondItB = new Bond.ElementBondIterator();\r\n/**\r\n * Attempts to produce a consistent charge and implicit\r\n * H-count for an atom.\r\n *\r\n * If both props.assignCharge and props.assignH, this\r\n * approximately follows the rules described in\r\n * https://docs.eyesopen.com/toolkits/python/oechemtk/valence.html#openeye-hydrogen-count-model\r\n *\r\n * If only charge or hydrogens are to be assigned it takes\r\n * a much simpler view and deduces one from the other\r\n */\r\nexport function calculateHydrogensCharge(structure, unit, index, props) {\r\n    var hydrogenCount = bondToElementCount(structure, unit, index, \"H\" /* H */);\r\n    var element = typeSymbol(unit, index);\r\n    var charge = formalCharge(unit, index);\r\n    var assignCharge = (props.assignCharge === 'always' || (props.assignCharge === 'auto' && charge === 0));\r\n    var assignH = (props.assignH === 'always' || (props.assignH === 'auto' && hydrogenCount === 0));\r\n    var degree = bondCount(structure, unit, index);\r\n    var valence = explicitValence(structure, unit, index);\r\n    var conjugated = isConjugated(structure, unit, index);\r\n    var multiBond = (valence - degree > 0);\r\n    var implicitHCount = 0;\r\n    var geom = 8 /* Unknown */;\r\n    switch (element) {\r\n        case \"H\" /* H */:\r\n            if (assignCharge) {\r\n                if (degree === 0) {\r\n                    charge = 1;\r\n                    geom = 0 /* Spherical */;\r\n                }\r\n                else if (degree === 1) {\r\n                    charge = 0;\r\n                    geom = 1 /* Terminal */;\r\n                }\r\n            }\r\n            break;\r\n        case \"C\" /* C */:\r\n            // TODO: Isocyanide?\r\n            if (assignCharge) {\r\n                charge = 0; // Assume carbon always neutral\r\n            }\r\n            if (assignH) {\r\n                // Carbocation/carbanion are 3-valent\r\n                implicitHCount = Math.max(0, 4 - valence - Math.abs(charge));\r\n            }\r\n            // Carbocation is planar, carbanion is tetrahedral\r\n            geom = assignGeometry(degree + implicitHCount + Math.max(0, -charge));\r\n            break;\r\n        case \"N\" /* N */:\r\n            if (assignCharge) {\r\n                if (!assignH) { // Trust input H explicitly:\r\n                    charge = valence - 3;\r\n                }\r\n                else if (conjugated && valence < 4) {\r\n                    // Neutral unless amidine/guanidine double-bonded N:\r\n                    if (degree - hydrogenCount === 1 && valence - hydrogenCount === 2) {\r\n                        charge = 1;\r\n                    }\r\n                    else {\r\n                        charge = 0;\r\n                    }\r\n                }\r\n                else {\r\n                    // Sulfonamide nitrogen and classed as sp3 in conjugation model but\r\n                    // they won't be charged\r\n                    // Don't assign charge to nitrogens bound to metals\r\n                    tmpChargeBondItA.setElement(structure, unit, index);\r\n                    while (tmpChargeBondItA.hasNext) {\r\n                        var b = tmpChargeBondItA.move();\r\n                        var elementB = typeSymbol(b.otherUnit, b.otherIndex);\r\n                        if (elementB === \"S\" /* S */ || isMetal(elementB)) {\r\n                            charge = 0;\r\n                            break;\r\n                        }\r\n                        else {\r\n                            charge = 1;\r\n                        }\r\n                    }\r\n                    // TODO: Planarity sanity check?\r\n                }\r\n            }\r\n            if (assignH) {\r\n                // NH4+ -> 4, 1' amide -> 2, nitro N/N+ depiction -> 0\r\n                implicitHCount = Math.max(0, 3 - valence + charge);\r\n            }\r\n            if (conjugated && !multiBond) {\r\n                // Amide, anilinic N etc. cannot consider lone-pair for geometry purposes\r\n                // Anilinic N geometry is depenent on ring electronics, for our purposes we\r\n                // assume it's trigonal!\r\n                geom = assignGeometry(degree + implicitHCount - charge);\r\n            }\r\n            else {\r\n                // Everything else, pyridine, amine, nitrile, lp plays normal role:\r\n                geom = assignGeometry(degree + implicitHCount + 1 - charge);\r\n            }\r\n            break;\r\n        case \"O\" /* O */:\r\n            if (assignCharge) {\r\n                if (!assignH) {\r\n                    charge = valence - 2;\r\n                }\r\n                if (valence === 1) {\r\n                    tmpChargeBondItA.setElement(structure, unit, index);\r\n                    b1: while (tmpChargeBondItA.hasNext) {\r\n                        var bA = tmpChargeBondItA.move();\r\n                        tmpChargeBondItB.setElement(structure, bA.otherUnit, bA.otherIndex);\r\n                        while (tmpChargeBondItB.hasNext) {\r\n                            var bB = tmpChargeBondItB.move();\r\n                            if (!(bB.otherUnit === unit && bB.otherIndex === index) &&\r\n                                typeSymbol(bB.otherUnit, bB.otherIndex) === \"O\" /* O */ &&\r\n                                bB.order === 2) {\r\n                                charge = -1;\r\n                                break b1;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (assignH) {\r\n                // ethanol -> 1, carboxylate -> -1\r\n                implicitHCount = Math.max(0, 2 - valence + charge);\r\n            }\r\n            if (conjugated && !multiBond) {\r\n                // carboxylate OH, phenol OH, one lone-pair taken up with conjugation\r\n                geom = assignGeometry(degree + implicitHCount - charge + 1);\r\n            }\r\n            else {\r\n                // Carbonyl (trigonal)\r\n                geom = assignGeometry(degree + implicitHCount - charge + 2);\r\n            }\r\n            break;\r\n        // Only handles thiols/thiolates/thioether/sulfonium. Sulfoxides and higher\r\n        // oxidiation states are assumed neutral S (charge carried on O if required)\r\n        case \"S\" /* S */:\r\n            if (assignCharge) {\r\n                if (!assignH) {\r\n                    if (valence <= 3 && bondToElementCount(structure, unit, index, \"O\" /* O */) === 0) {\r\n                        charge = valence - 2; // e.g. explicitly deprotonated thiol\r\n                    }\r\n                    else {\r\n                        charge = 0;\r\n                    }\r\n                }\r\n            }\r\n            if (assignH) {\r\n                if (valence < 2) {\r\n                    implicitHCount = Math.max(0, 2 - valence + charge);\r\n                }\r\n            }\r\n            if (valence <= 3) {\r\n                // Thiol, thiolate, tioether -> tetrahedral\r\n                geom = assignGeometry(degree + implicitHCount - charge + 2);\r\n            }\r\n            break;\r\n        case \"F\" /* F */:\r\n        case \"CL\" /* CL */:\r\n        case \"BR\" /* BR */:\r\n        case \"I\" /* I */:\r\n        case \"AT\" /* AT */:\r\n            // Never implicitly protonate halides\r\n            if (assignCharge) {\r\n                charge = valence - 1;\r\n            }\r\n            break;\r\n        case \"LI\" /* LI */:\r\n        case \"NA\" /* NA */:\r\n        case \"K\" /* K */:\r\n        case \"RB\" /* RB */:\r\n        case \"CS\" /* CS */:\r\n        case \"FR\" /* FR */:\r\n            if (assignCharge) {\r\n                charge = 1 - valence;\r\n            }\r\n            break;\r\n        case \"BE\" /* BE */:\r\n        case \"MG\" /* MG */:\r\n        case \"CA\" /* CA */:\r\n        case \"SR\" /* SR */:\r\n        case \"BA\" /* BA */:\r\n        case \"RA\" /* RA */:\r\n            if (assignCharge) {\r\n                charge = 2 - valence;\r\n            }\r\n            break;\r\n        default:\r\n            if (isDebugMode) {\r\n                console.warn('Requested charge, protonation for an unhandled element', element);\r\n            }\r\n    }\r\n    return [charge, implicitHCount, implicitHCount + hydrogenCount, geom];\r\n}\r\nfunction calcUnitValenceModel(structure, unit, props) {\r\n    var n = unit.elements.length;\r\n    var charge = new Int8Array(n);\r\n    var implicitH = new Int8Array(n);\r\n    var totalH = new Int8Array(n);\r\n    var idealGeometry = new Int8Array(n);\r\n    // always use root UnitIndex to take the topology of the whole structure in account\r\n    var hasParent = !!structure.parent;\r\n    var mapping;\r\n    if (hasParent) {\r\n        var rootUnit = structure.root.unitMap.get(unit.id);\r\n        mapping = SortedArray.indicesOf(rootUnit.elements, unit.elements);\r\n        if (mapping.length !== unit.elements.length) {\r\n            throw new Error('expected to find an index for every element');\r\n        }\r\n        unit = rootUnit;\r\n        structure = structure.root;\r\n    }\r\n    for (var i = 0; i < n; ++i) {\r\n        var j = (hasParent ? mapping[i] : i);\r\n        var _a = calculateHydrogensCharge(structure, unit, j, props), chg = _a[0], implH = _a[1], totH = _a[2], geom = _a[3];\r\n        charge[i] = chg;\r\n        implicitH[i] = implH;\r\n        totalH[i] = totH;\r\n        idealGeometry[i] = geom;\r\n    }\r\n    return { charge: charge, implicitH: implicitH, totalH: totalH, idealGeometry: idealGeometry };\r\n}\r\nexport var ValenceModelParams = {\r\n    assignCharge: PD.Select('auto', [['always', 'always'], ['auto', 'auto'], ['never', 'never']]),\r\n    assignH: PD.Select('auto', [['always', 'always'], ['auto', 'auto'], ['never', 'never']]),\r\n};\r\nexport function calcValenceModel(ctx, structure, props) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var p, map, i, il, u, valenceModel;\r\n        return __generator(this, function (_a) {\r\n            p = __assign(__assign({}, PD.getDefaultValues(ValenceModelParams)), props);\r\n            map = new Map();\r\n            for (i = 0, il = structure.units.length; i < il; ++i) {\r\n                u = structure.units[i];\r\n                if (Unit.isAtomic(u)) {\r\n                    valenceModel = calcUnitValenceModel(structure, u, p);\r\n                    map.set(u.id, valenceModel);\r\n                }\r\n            }\r\n            return [2 /*return*/, map];\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=valence-model.js.map"]},"metadata":{},"sourceType":"module"}