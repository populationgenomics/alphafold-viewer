{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Unit, StructureElement, Structure } from '../../../../mol-model/structure';\nimport { EmptyLoci } from '../../../../mol-model/loci';\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\nimport { getResidueLoci } from './common';\nimport { eachAtomicUnitTracedElement } from './polymer';\nexport var NucleotideLocationIterator;\n\n(function (NucleotideLocationIterator) {\n  function fromGroup(structureGroup) {\n    var group = structureGroup.group,\n        structure = structureGroup.structure;\n    var u = group.units[0];\n    var nucleotideElementIndices = Unit.isAtomic(u) ? u.nucleotideElements : [];\n    var groupCount = nucleotideElementIndices.length;\n    var instanceCount = group.units.length;\n    var location = StructureElement.Location.create(structure);\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var unit = group.units[instanceIndex];\n      location.unit = unit;\n      location.element = nucleotideElementIndices[groupIndex];\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  NucleotideLocationIterator.fromGroup = fromGroup;\n})(NucleotideLocationIterator || (NucleotideLocationIterator = {}));\n\nexport function getNucleotideElementLoci(pickingId, structureGroup, id) {\n  var objectId = pickingId.objectId,\n      instanceId = pickingId.instanceId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    var unit = group.units[instanceId];\n\n    if (Unit.isAtomic(unit)) {\n      return getResidueLoci(structure, unit, unit.nucleotideElements[groupId]);\n    }\n  }\n\n  return EmptyLoci;\n}\n\nfunction selectNuclotideElements(u) {\n  return u.nucleotideElements;\n}\n/**\r\n * Mark a nucleotide element (e.g. part of a cartoon block)\r\n * - mark only when all its residue's elements are in a loci\r\n */\n\n\nexport function eachNucleotideElement(loci, structureGroup, apply) {\n  var changed = false;\n  if (!StructureElement.Loci.is(loci)) return false;\n  var structure = structureGroup.structure,\n      group = structureGroup.group;\n  if (!Structure.areEquivalent(loci.structure, structure)) return false;\n  var unit = group.units[0];\n  if (!Unit.isAtomic(unit)) return false;\n  var nucleotideElements = unit.nucleotideElements;\n  var groupCount = nucleotideElements.length;\n\n  for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\n    var e = _a[_i];\n    if (!Unit.isAtomic(e.unit)) continue;\n    if (!group.unitIndexMap.has(e.unit.id)) continue;\n    var intervalOffset = group.unitIndexMap.get(e.unit.id) * groupCount;\n\n    if (Unit.isAtomic(e.unit)) {\n      changed = eachAtomicUnitTracedElement(intervalOffset, groupCount, selectNuclotideElements, apply, e) || changed;\n    }\n  }\n\n  return changed;\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/nucleotide.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Unit, StructureElement, Structure } from '../../../../mol-model/structure';\r\nimport { EmptyLoci } from '../../../../mol-model/loci';\r\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\r\nimport { getResidueLoci } from './common';\r\nimport { eachAtomicUnitTracedElement } from './polymer';\r\nexport var NucleotideLocationIterator;\r\n(function (NucleotideLocationIterator) {\r\n    function fromGroup(structureGroup) {\r\n        var group = structureGroup.group, structure = structureGroup.structure;\r\n        var u = group.units[0];\r\n        var nucleotideElementIndices = Unit.isAtomic(u) ? u.nucleotideElements : [];\r\n        var groupCount = nucleotideElementIndices.length;\r\n        var instanceCount = group.units.length;\r\n        var location = StructureElement.Location.create(structure);\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var unit = group.units[instanceIndex];\r\n            location.unit = unit;\r\n            location.element = nucleotideElementIndices[groupIndex];\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    NucleotideLocationIterator.fromGroup = fromGroup;\r\n})(NucleotideLocationIterator || (NucleotideLocationIterator = {}));\r\nexport function getNucleotideElementLoci(pickingId, structureGroup, id) {\r\n    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        var unit = group.units[instanceId];\r\n        if (Unit.isAtomic(unit)) {\r\n            return getResidueLoci(structure, unit, unit.nucleotideElements[groupId]);\r\n        }\r\n    }\r\n    return EmptyLoci;\r\n}\r\nfunction selectNuclotideElements(u) { return u.nucleotideElements; }\r\n/**\r\n * Mark a nucleotide element (e.g. part of a cartoon block)\r\n * - mark only when all its residue's elements are in a loci\r\n */\r\nexport function eachNucleotideElement(loci, structureGroup, apply) {\r\n    var changed = false;\r\n    if (!StructureElement.Loci.is(loci))\r\n        return false;\r\n    var structure = structureGroup.structure, group = structureGroup.group;\r\n    if (!Structure.areEquivalent(loci.structure, structure))\r\n        return false;\r\n    var unit = group.units[0];\r\n    if (!Unit.isAtomic(unit))\r\n        return false;\r\n    var nucleotideElements = unit.nucleotideElements;\r\n    var groupCount = nucleotideElements.length;\r\n    for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\r\n        var e = _a[_i];\r\n        if (!Unit.isAtomic(e.unit))\r\n            continue;\r\n        if (!group.unitIndexMap.has(e.unit.id))\r\n            continue;\r\n        var intervalOffset = group.unitIndexMap.get(e.unit.id) * groupCount;\r\n        if (Unit.isAtomic(e.unit)) {\r\n            changed = eachAtomicUnitTracedElement(intervalOffset, groupCount, selectNuclotideElements, apply, e) || changed;\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n//# sourceMappingURL=nucleotide.js.map"]},"metadata":{},"sourceType":"module"}