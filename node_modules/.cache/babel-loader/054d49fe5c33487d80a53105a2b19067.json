{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../mol-task';\nimport { SpacegroupCell, Box3D } from '../../mol-math/geometry';\nimport { Tensor, Vec3 } from '../../mol-math/linear-algebra';\nimport { degToRad } from '../../mol-math/misc';\nimport { getCcp4ValueType } from '../../mol-io/reader/ccp4/parser';\nimport { TypedArrayValueType } from '../../mol-io/common/typed-array';\nimport { arrayMin, arrayRms, arrayMean, arrayMax } from '../../mol-util/array';\nimport { CustomProperties } from '../../mol-model/custom-property';\n/** When available (e.g. in MRC files) use ORIGIN records instead of N[CRS]START */\n\nexport function getCcp4Origin(header) {\n  if (header.originX === 0.0 && header.originY === 0.0 && header.originZ === 0.0) {\n    return Vec3.create(header.NCSTART, header.NRSTART, header.NSSTART);\n  } else {\n    return Vec3.create(header.originX / (header.xLength / header.NX), header.originY / (header.yLength / header.NY), header.originZ / (header.zLength / header.NZ));\n  }\n}\n\nfunction getTypedArrayCtor(header) {\n  var valueType = getCcp4ValueType(header);\n\n  switch (valueType) {\n    case TypedArrayValueType.Float32:\n      return Float32Array;\n\n    case TypedArrayValueType.Int8:\n      return Int8Array;\n\n    case TypedArrayValueType.Int16:\n      return Int16Array;\n\n    case TypedArrayValueType.Uint16:\n      return Uint16Array;\n  }\n\n  throw Error(valueType + \" is not a supported value format.\");\n}\n\nexport function volumeFromCcp4(source, params) {\n  var _this = this;\n\n  return Task.create('Create Volume', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var header, values, size, angles, spacegroup, cell, axis_order_fast_to_slow, normalizeOrder, grid, extent, origin, gridOrigin, origin_frac, dimensions_frac, space, data, calcStats;\n      return __generator(this, function (_a) {\n        header = source.header, values = source.values;\n        size = Vec3.create(header.xLength, header.yLength, header.zLength);\n        if (params && params.voxelSize) Vec3.mul(size, size, params.voxelSize);\n        angles = Vec3.create(degToRad(header.alpha), degToRad(header.beta), degToRad(header.gamma));\n        spacegroup = header.ISPG > 65536 ? 0 : header.ISPG;\n        cell = SpacegroupCell.create(spacegroup || 'P 1', size, angles);\n        axis_order_fast_to_slow = Vec3.create(header.MAPC - 1, header.MAPR - 1, header.MAPS - 1);\n        normalizeOrder = Tensor.convertToCanonicalAxisIndicesFastToSlow(axis_order_fast_to_slow);\n        grid = [header.NX, header.NY, header.NZ];\n        extent = normalizeOrder([header.NC, header.NR, header.NS]);\n        origin = getCcp4Origin(header);\n        if (params === null || params === void 0 ? void 0 : params.offset) Vec3.add(origin, origin, params.offset);\n        gridOrigin = normalizeOrder(origin);\n        origin_frac = Vec3.create(gridOrigin[0] / grid[0], gridOrigin[1] / grid[1], gridOrigin[2] / grid[2]);\n        dimensions_frac = Vec3.create(extent[0] / grid[0], extent[1] / grid[1], extent[2] / grid[2]);\n        space = Tensor.Space(extent, Tensor.invertAxisOrder(axis_order_fast_to_slow), getTypedArrayCtor(header));\n        data = Tensor.create(space, Tensor.Data1(values));\n        calcStats = header.AMIN === 0 && header.AMAX === 0 && header.AMEAN === 0 && header.ARMS === 0;\n        return [2\n        /*return*/\n        , {\n          label: params === null || params === void 0 ? void 0 : params.label,\n          entryId: params === null || params === void 0 ? void 0 : params.entryId,\n          grid: {\n            transform: {\n              kind: 'spacegroup',\n              cell: cell,\n              fractionalBox: Box3D.create(origin_frac, Vec3.add(Vec3.zero(), origin_frac, dimensions_frac))\n            },\n            cells: data,\n            stats: {\n              min: isNaN(header.AMIN) || calcStats ? arrayMin(values) : header.AMIN,\n              max: isNaN(header.AMAX) || calcStats ? arrayMax(values) : header.AMAX,\n              mean: isNaN(header.AMEAN) || calcStats ? arrayMean(values) : header.AMEAN,\n              sigma: isNaN(header.ARMS) || header.ARMS === 0 ? arrayRms(values) : header.ARMS\n            }\n          },\n          sourceData: Ccp4Format.create(source),\n          customProperties: new CustomProperties(),\n          _propertyData: Object.create(null)\n        }];\n      });\n    });\n  });\n} //\n\nexport { Ccp4Format };\nvar Ccp4Format;\n\n(function (Ccp4Format) {\n  function is(x) {\n    return (x === null || x === void 0 ? void 0 : x.kind) === 'ccp4';\n  }\n\n  Ccp4Format.is = is;\n\n  function create(ccp4) {\n    return {\n      kind: 'ccp4',\n      name: ccp4.name,\n      data: ccp4\n    };\n  }\n\n  Ccp4Format.create = create;\n})(Ccp4Format || (Ccp4Format = {}));","map":{"version":3,"sources":["../../../src/mol-model-formats/volume/ccp4.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../mol-task';\r\nimport { SpacegroupCell, Box3D } from '../../mol-math/geometry';\r\nimport { Tensor, Vec3 } from '../../mol-math/linear-algebra';\r\nimport { degToRad } from '../../mol-math/misc';\r\nimport { getCcp4ValueType } from '../../mol-io/reader/ccp4/parser';\r\nimport { TypedArrayValueType } from '../../mol-io/common/typed-array';\r\nimport { arrayMin, arrayRms, arrayMean, arrayMax } from '../../mol-util/array';\r\nimport { CustomProperties } from '../../mol-model/custom-property';\r\n/** When available (e.g. in MRC files) use ORIGIN records instead of N[CRS]START */\r\nexport function getCcp4Origin(header) {\r\n    if (header.originX === 0.0 && header.originY === 0.0 && header.originZ === 0.0) {\r\n        return Vec3.create(header.NCSTART, header.NRSTART, header.NSSTART);\r\n    }\r\n    else {\r\n        return Vec3.create(header.originX / (header.xLength / header.NX), header.originY / (header.yLength / header.NY), header.originZ / (header.zLength / header.NZ));\r\n    }\r\n}\r\nfunction getTypedArrayCtor(header) {\r\n    var valueType = getCcp4ValueType(header);\r\n    switch (valueType) {\r\n        case TypedArrayValueType.Float32: return Float32Array;\r\n        case TypedArrayValueType.Int8: return Int8Array;\r\n        case TypedArrayValueType.Int16: return Int16Array;\r\n        case TypedArrayValueType.Uint16: return Uint16Array;\r\n    }\r\n    throw Error(valueType + \" is not a supported value format.\");\r\n}\r\nexport function volumeFromCcp4(source, params) {\r\n    var _this = this;\r\n    return Task.create('Create Volume', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var header, values, size, angles, spacegroup, cell, axis_order_fast_to_slow, normalizeOrder, grid, extent, origin, gridOrigin, origin_frac, dimensions_frac, space, data, calcStats;\r\n        return __generator(this, function (_a) {\r\n            header = source.header, values = source.values;\r\n            size = Vec3.create(header.xLength, header.yLength, header.zLength);\r\n            if (params && params.voxelSize)\r\n                Vec3.mul(size, size, params.voxelSize);\r\n            angles = Vec3.create(degToRad(header.alpha), degToRad(header.beta), degToRad(header.gamma));\r\n            spacegroup = header.ISPG > 65536 ? 0 : header.ISPG;\r\n            cell = SpacegroupCell.create(spacegroup || 'P 1', size, angles);\r\n            axis_order_fast_to_slow = Vec3.create(header.MAPC - 1, header.MAPR - 1, header.MAPS - 1);\r\n            normalizeOrder = Tensor.convertToCanonicalAxisIndicesFastToSlow(axis_order_fast_to_slow);\r\n            grid = [header.NX, header.NY, header.NZ];\r\n            extent = normalizeOrder([header.NC, header.NR, header.NS]);\r\n            origin = getCcp4Origin(header);\r\n            if (params === null || params === void 0 ? void 0 : params.offset)\r\n                Vec3.add(origin, origin, params.offset);\r\n            gridOrigin = normalizeOrder(origin);\r\n            origin_frac = Vec3.create(gridOrigin[0] / grid[0], gridOrigin[1] / grid[1], gridOrigin[2] / grid[2]);\r\n            dimensions_frac = Vec3.create(extent[0] / grid[0], extent[1] / grid[1], extent[2] / grid[2]);\r\n            space = Tensor.Space(extent, Tensor.invertAxisOrder(axis_order_fast_to_slow), getTypedArrayCtor(header));\r\n            data = Tensor.create(space, Tensor.Data1(values));\r\n            calcStats = header.AMIN === 0 && header.AMAX === 0 && header.AMEAN === 0 && header.ARMS === 0;\r\n            return [2 /*return*/, {\r\n                    label: params === null || params === void 0 ? void 0 : params.label,\r\n                    entryId: params === null || params === void 0 ? void 0 : params.entryId,\r\n                    grid: {\r\n                        transform: { kind: 'spacegroup', cell: cell, fractionalBox: Box3D.create(origin_frac, Vec3.add(Vec3.zero(), origin_frac, dimensions_frac)) },\r\n                        cells: data,\r\n                        stats: {\r\n                            min: (isNaN(header.AMIN) || calcStats) ? arrayMin(values) : header.AMIN,\r\n                            max: (isNaN(header.AMAX) || calcStats) ? arrayMax(values) : header.AMAX,\r\n                            mean: (isNaN(header.AMEAN) || calcStats) ? arrayMean(values) : header.AMEAN,\r\n                            sigma: (isNaN(header.ARMS) || header.ARMS === 0) ? arrayRms(values) : header.ARMS\r\n                        },\r\n                    },\r\n                    sourceData: Ccp4Format.create(source),\r\n                    customProperties: new CustomProperties(),\r\n                    _propertyData: Object.create(null),\r\n                }];\r\n        });\r\n    }); });\r\n}\r\n//\r\nexport { Ccp4Format };\r\nvar Ccp4Format;\r\n(function (Ccp4Format) {\r\n    function is(x) {\r\n        return (x === null || x === void 0 ? void 0 : x.kind) === 'ccp4';\r\n    }\r\n    Ccp4Format.is = is;\r\n    function create(ccp4) {\r\n        return { kind: 'ccp4', name: ccp4.name, data: ccp4 };\r\n    }\r\n    Ccp4Format.create = create;\r\n})(Ccp4Format || (Ccp4Format = {}));\r\n//# sourceMappingURL=ccp4.js.map"]},"metadata":{},"sourceType":"module"}