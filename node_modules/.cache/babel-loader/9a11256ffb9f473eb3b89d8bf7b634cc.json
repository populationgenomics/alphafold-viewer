{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { sort, arraySwap } from './sort';\n\nfunction sortAsc(bs, i, j) {\n  return bs[i].key < bs[j].key ? -1 : 1;\n}\n\nfunction _makeBuckets(indices, getKey, sortBuckets, start, end) {\n  var buckets = new Map();\n  var bucketList = [];\n  var prevKey = getKey(indices[0]);\n  var isBucketed = true;\n\n  for (var i = start; i < end; i++) {\n    var key = getKey(indices[i]);\n\n    if (buckets.has(key)) {\n      buckets.get(key).count++;\n      if (prevKey !== key) isBucketed = false;\n    } else {\n      var bucket = {\n        key: key,\n        count: 1,\n        offset: i\n      };\n      buckets.set(key, bucket);\n      bucketList[bucketList.length] = bucket;\n    }\n\n    prevKey = key;\n  }\n\n  var bucketOffsets = new Int32Array(bucketList.length + 1);\n  bucketOffsets[bucketList.length] = end;\n  var sorted = true;\n\n  if (sortBuckets) {\n    for (var i = 1, _i = bucketList.length; i < _i; i++) {\n      if (bucketList[i - 1].key > bucketList[i].key) {\n        sorted = false;\n        break;\n      }\n    }\n  }\n\n  if (isBucketed && sorted) {\n    for (var i = 0; i < bucketList.length; i++) bucketOffsets[i] = bucketList[i].offset;\n\n    return bucketOffsets;\n  }\n\n  if (sortBuckets && !sorted) {\n    sort(bucketList, 0, bucketList.length, sortAsc, arraySwap);\n  }\n\n  var offset = 0;\n\n  for (var i = 0; i < bucketList.length; i++) {\n    var b = bucketList[i];\n    b.offset = offset;\n    offset += b.count;\n  }\n\n  var reorderedIndices = new Int32Array(end - start);\n\n  for (var i = start; i < end; i++) {\n    var key = getKey(indices[i]);\n    var bucket = buckets.get(key);\n    reorderedIndices[bucket.offset++] = indices[i];\n  }\n\n  for (var i = 0, _i = reorderedIndices.length; i < _i; i++) {\n    indices[i + start] = reorderedIndices[i];\n  }\n\n  bucketOffsets[0] = start;\n\n  for (var i = 1; i < bucketList.length; i++) bucketOffsets[i] = bucketList[i - 1].offset + start;\n\n  return bucketOffsets;\n}\n/**\r\n * Reorders indices so that the same keys are next to each other, [start, end)\r\n * Returns the offsets of buckets. So that [offsets[i], offsets[i + 1]) determines the range.\r\n */\n\n\nexport function makeBuckets(indices, getKey, options) {\n  var s = options && options.start || 0;\n  var e = options && options.end || indices.length;\n  if (e - s <= 0) throw new Error('Can only bucket non-empty collections.');\n  return _makeBuckets(indices, getKey, !!(options && options.sort), s, e);\n}","map":{"version":3,"sources":["../../../src/mol-data/util/buckets.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { sort, arraySwap } from './sort';\r\nfunction sortAsc(bs, i, j) { return bs[i].key < bs[j].key ? -1 : 1; }\r\nfunction _makeBuckets(indices, getKey, sortBuckets, start, end) {\r\n    var buckets = new Map();\r\n    var bucketList = [];\r\n    var prevKey = getKey(indices[0]);\r\n    var isBucketed = true;\r\n    for (var i = start; i < end; i++) {\r\n        var key = getKey(indices[i]);\r\n        if (buckets.has(key)) {\r\n            buckets.get(key).count++;\r\n            if (prevKey !== key)\r\n                isBucketed = false;\r\n        }\r\n        else {\r\n            var bucket = { key: key, count: 1, offset: i };\r\n            buckets.set(key, bucket);\r\n            bucketList[bucketList.length] = bucket;\r\n        }\r\n        prevKey = key;\r\n    }\r\n    var bucketOffsets = new Int32Array(bucketList.length + 1);\r\n    bucketOffsets[bucketList.length] = end;\r\n    var sorted = true;\r\n    if (sortBuckets) {\r\n        for (var i = 1, _i = bucketList.length; i < _i; i++) {\r\n            if (bucketList[i - 1].key > bucketList[i].key) {\r\n                sorted = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (isBucketed && sorted) {\r\n        for (var i = 0; i < bucketList.length; i++)\r\n            bucketOffsets[i] = bucketList[i].offset;\r\n        return bucketOffsets;\r\n    }\r\n    if (sortBuckets && !sorted) {\r\n        sort(bucketList, 0, bucketList.length, sortAsc, arraySwap);\r\n    }\r\n    var offset = 0;\r\n    for (var i = 0; i < bucketList.length; i++) {\r\n        var b = bucketList[i];\r\n        b.offset = offset;\r\n        offset += b.count;\r\n    }\r\n    var reorderedIndices = new Int32Array(end - start);\r\n    for (var i = start; i < end; i++) {\r\n        var key = getKey(indices[i]);\r\n        var bucket = buckets.get(key);\r\n        reorderedIndices[bucket.offset++] = indices[i];\r\n    }\r\n    for (var i = 0, _i = reorderedIndices.length; i < _i; i++) {\r\n        indices[i + start] = reorderedIndices[i];\r\n    }\r\n    bucketOffsets[0] = start;\r\n    for (var i = 1; i < bucketList.length; i++)\r\n        bucketOffsets[i] = bucketList[i - 1].offset + start;\r\n    return bucketOffsets;\r\n}\r\n/**\r\n * Reorders indices so that the same keys are next to each other, [start, end)\r\n * Returns the offsets of buckets. So that [offsets[i], offsets[i + 1]) determines the range.\r\n */\r\nexport function makeBuckets(indices, getKey, options) {\r\n    var s = (options && options.start) || 0;\r\n    var e = (options && options.end) || indices.length;\r\n    if (e - s <= 0)\r\n        throw new Error('Can only bucket non-empty collections.');\r\n    return _makeBuckets(indices, getKey, !!(options && options.sort), s, e);\r\n}\r\n//# sourceMappingURL=buckets.js.map"]},"metadata":{},"sourceType":"module"}