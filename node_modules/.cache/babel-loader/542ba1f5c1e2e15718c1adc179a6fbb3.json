{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Column } from '../../../../mol-data/db';\nimport { Sequence } from '../../../sequence';\nvar StructureSequence;\n\n(function (StructureSequence) {\n  var Empty = {\n    byEntityKey: {},\n    sequences: []\n  };\n\n  function merge() {\n    var entitySeqs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      entitySeqs[_i] = arguments[_i];\n    }\n\n    var sequences = [];\n    var byEntityKey = {};\n\n    for (var i = 0, il = entitySeqs.length; i < il; ++i) {\n      sequences.push.apply(sequences, entitySeqs[i].sequences);\n      Object.assign(byEntityKey, entitySeqs[i].byEntityKey);\n    }\n\n    return {\n      sequences: sequences,\n      byEntityKey: byEntityKey\n    };\n  }\n\n  function fromHierarchy(entities, atomicHierarchy, coarseHierarchy) {\n    var atomic = fromAtomicHierarchy(entities, atomicHierarchy);\n    var coarse = coarseHierarchy.isDefined ? fromCoarseHierarchy(entities, coarseHierarchy) : Empty;\n    return merge(atomic, coarse);\n  }\n\n  StructureSequence.fromHierarchy = fromHierarchy;\n\n  function fromAtomicHierarchy(entities, hierarchy) {\n    var label_comp_id = hierarchy.atoms.label_comp_id;\n    var label_seq_id = hierarchy.residues.label_seq_id;\n    var chainAtomSegments = hierarchy.chainAtomSegments,\n        residueAtomSegments = hierarchy.residueAtomSegments;\n    var count = chainAtomSegments.count,\n        offsets = chainAtomSegments.offsets;\n    var byEntityKey = {};\n    var sequences = []; // check if chain segments are empty\n\n    if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {\n      return {\n        byEntityKey: byEntityKey,\n        sequences: sequences\n      };\n    }\n\n    for (var cI = 0, _cI = hierarchy.chains._rowCount; cI < _cI; cI++) {\n      var entityKey = hierarchy.index.getEntityFromChain(cI); // Only for polymers, trying to mirror _entity_poly_seq\n\n      if (byEntityKey[entityKey] !== void 0 || entities.data.type.value(entityKey) !== 'polymer') continue;\n      var start = cI;\n      cI++;\n\n      while (cI < _cI && entityKey === hierarchy.index.getEntityFromChain(cI) && entities.data.type.value(entityKey) !== 'polymer') {\n        cI++;\n      }\n\n      cI--;\n      var rStart = residueAtomSegments.index[offsets[start]];\n      var rEnd = residueAtomSegments.index[offsets[cI + 1] - 1] + 1;\n      var seqId = Column.window(label_seq_id, rStart, rEnd);\n      var _compId = [];\n\n      for (var rI = rStart; rI < rEnd; ++rI) {\n        _compId.push(label_comp_id.value(residueAtomSegments.offsets[rI]));\n      }\n\n      var compId = Column.ofStringArray(_compId);\n      byEntityKey[entityKey] = {\n        entityId: entities.data.id.value(entityKey),\n        sequence: Sequence.ofResidueNames(compId, seqId)\n      };\n      sequences.push(byEntityKey[entityKey]);\n    }\n\n    return {\n      byEntityKey: byEntityKey,\n      sequences: sequences\n    };\n  }\n\n  StructureSequence.fromAtomicHierarchy = fromAtomicHierarchy;\n\n  function fromCoarseHierarchy(entities, hierarchy) {\n    var spheres = fromCoarseElements(entities, hierarchy.spheres);\n    var gaussians = fromCoarseElements(entities, hierarchy.gaussians);\n    return merge(spheres, gaussians);\n  }\n\n  StructureSequence.fromCoarseHierarchy = fromCoarseHierarchy;\n\n  function fromCoarseElements(entities, elements) {\n    var chainElementSegments = elements.chainElementSegments,\n        seq_id_begin = elements.seq_id_begin,\n        seq_id_end = elements.seq_id_end;\n    var count = chainElementSegments.count,\n        offsets = chainElementSegments.offsets;\n    var byEntityKey = {};\n    var sequences = []; // check if chain segments are empty\n\n    if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {\n      return {\n        byEntityKey: byEntityKey,\n        sequences: sequences\n      };\n    }\n\n    for (var cI = 0, _cI = count; cI < _cI; cI++) {\n      var eK = elements.getEntityFromChain(cI);\n      if (byEntityKey[eK] !== void 0) continue;\n      var start = cI;\n      cI++;\n\n      while (cI < _cI && eK === elements.getEntityFromChain(cI)) {\n        cI++;\n      }\n\n      cI--;\n      var eStart = offsets[start];\n      var eEnd = offsets[cI + 1] - 1;\n      var seqIdBegin = Column.window(seq_id_begin, eStart, eEnd);\n      var seqIdEnd = Column.window(seq_id_end, eStart, eEnd);\n      byEntityKey[eK] = {\n        entityId: entities.data.id.value(eK),\n        sequence: Sequence.ofSequenceRanges(seqIdBegin, seqIdEnd)\n      };\n      sequences.push(byEntityKey[eK]);\n    }\n\n    return {\n      byEntityKey: byEntityKey,\n      sequences: sequences\n    };\n  }\n\n  StructureSequence.fromCoarseElements = fromCoarseElements;\n})(StructureSequence || (StructureSequence = {}));\n\nexport { StructureSequence };","map":{"version":3,"sources":["../../../../../src/mol-model/structure/model/properties/sequence.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Column } from '../../../../mol-data/db';\r\nimport { Sequence } from '../../../sequence';\r\nvar StructureSequence;\r\n(function (StructureSequence) {\r\n    var Empty = { byEntityKey: {}, sequences: [] };\r\n    function merge() {\r\n        var entitySeqs = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            entitySeqs[_i] = arguments[_i];\r\n        }\r\n        var sequences = [];\r\n        var byEntityKey = {};\r\n        for (var i = 0, il = entitySeqs.length; i < il; ++i) {\r\n            sequences.push.apply(sequences, entitySeqs[i].sequences);\r\n            Object.assign(byEntityKey, entitySeqs[i].byEntityKey);\r\n        }\r\n        return { sequences: sequences, byEntityKey: byEntityKey };\r\n    }\r\n    function fromHierarchy(entities, atomicHierarchy, coarseHierarchy) {\r\n        var atomic = fromAtomicHierarchy(entities, atomicHierarchy);\r\n        var coarse = coarseHierarchy.isDefined ? fromCoarseHierarchy(entities, coarseHierarchy) : Empty;\r\n        return merge(atomic, coarse);\r\n    }\r\n    StructureSequence.fromHierarchy = fromHierarchy;\r\n    function fromAtomicHierarchy(entities, hierarchy) {\r\n        var label_comp_id = hierarchy.atoms.label_comp_id;\r\n        var label_seq_id = hierarchy.residues.label_seq_id;\r\n        var chainAtomSegments = hierarchy.chainAtomSegments, residueAtomSegments = hierarchy.residueAtomSegments;\r\n        var count = chainAtomSegments.count, offsets = chainAtomSegments.offsets;\r\n        var byEntityKey = {};\r\n        var sequences = [];\r\n        // check if chain segments are empty\r\n        if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {\r\n            return { byEntityKey: byEntityKey, sequences: sequences };\r\n        }\r\n        for (var cI = 0, _cI = hierarchy.chains._rowCount; cI < _cI; cI++) {\r\n            var entityKey = hierarchy.index.getEntityFromChain(cI);\r\n            // Only for polymers, trying to mirror _entity_poly_seq\r\n            if (byEntityKey[entityKey] !== void 0 || entities.data.type.value(entityKey) !== 'polymer')\r\n                continue;\r\n            var start = cI;\r\n            cI++;\r\n            while (cI < _cI && entityKey === hierarchy.index.getEntityFromChain(cI) && entities.data.type.value(entityKey) !== 'polymer') {\r\n                cI++;\r\n            }\r\n            cI--;\r\n            var rStart = residueAtomSegments.index[offsets[start]];\r\n            var rEnd = residueAtomSegments.index[offsets[cI + 1] - 1] + 1;\r\n            var seqId = Column.window(label_seq_id, rStart, rEnd);\r\n            var _compId = [];\r\n            for (var rI = rStart; rI < rEnd; ++rI) {\r\n                _compId.push(label_comp_id.value(residueAtomSegments.offsets[rI]));\r\n            }\r\n            var compId = Column.ofStringArray(_compId);\r\n            byEntityKey[entityKey] = {\r\n                entityId: entities.data.id.value(entityKey),\r\n                sequence: Sequence.ofResidueNames(compId, seqId)\r\n            };\r\n            sequences.push(byEntityKey[entityKey]);\r\n        }\r\n        return { byEntityKey: byEntityKey, sequences: sequences };\r\n    }\r\n    StructureSequence.fromAtomicHierarchy = fromAtomicHierarchy;\r\n    function fromCoarseHierarchy(entities, hierarchy) {\r\n        var spheres = fromCoarseElements(entities, hierarchy.spheres);\r\n        var gaussians = fromCoarseElements(entities, hierarchy.gaussians);\r\n        return merge(spheres, gaussians);\r\n    }\r\n    StructureSequence.fromCoarseHierarchy = fromCoarseHierarchy;\r\n    function fromCoarseElements(entities, elements) {\r\n        var chainElementSegments = elements.chainElementSegments, seq_id_begin = elements.seq_id_begin, seq_id_end = elements.seq_id_end;\r\n        var count = chainElementSegments.count, offsets = chainElementSegments.offsets;\r\n        var byEntityKey = {};\r\n        var sequences = [];\r\n        // check if chain segments are empty\r\n        if (count === 1 && offsets[0] === 0 && offsets[1] === 0) {\r\n            return { byEntityKey: byEntityKey, sequences: sequences };\r\n        }\r\n        for (var cI = 0, _cI = count; cI < _cI; cI++) {\r\n            var eK = elements.getEntityFromChain(cI);\r\n            if (byEntityKey[eK] !== void 0)\r\n                continue;\r\n            var start = cI;\r\n            cI++;\r\n            while (cI < _cI && eK === elements.getEntityFromChain(cI)) {\r\n                cI++;\r\n            }\r\n            cI--;\r\n            var eStart = offsets[start];\r\n            var eEnd = offsets[cI + 1] - 1;\r\n            var seqIdBegin = Column.window(seq_id_begin, eStart, eEnd);\r\n            var seqIdEnd = Column.window(seq_id_end, eStart, eEnd);\r\n            byEntityKey[eK] = {\r\n                entityId: entities.data.id.value(eK),\r\n                sequence: Sequence.ofSequenceRanges(seqIdBegin, seqIdEnd)\r\n            };\r\n            sequences.push(byEntityKey[eK]);\r\n        }\r\n        return { byEntityKey: byEntityKey, sequences: sequences };\r\n    }\r\n    StructureSequence.fromCoarseElements = fromCoarseElements;\r\n})(StructureSequence || (StructureSequence = {}));\r\nexport { StructureSequence };\r\n//# sourceMappingURL=sequence.js.map"]},"metadata":{},"sourceType":"module"}