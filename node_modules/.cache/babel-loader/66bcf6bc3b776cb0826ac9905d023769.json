{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nimport { IntAdjacencyGraph } from '../../../../mol-math/graph';\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\n/** max distance between two C-alpha atoms to check for hbond */\n\nvar caMaxDist = 9.0;\n/**\r\n * Constant for electrostatic energy in kcal/mol\r\n *      f  *  q1 *   q2\r\n * Q = -332 * 0.42 * 0.20\r\n *\r\n * f is the dimensional factor\r\n *\r\n * q1 and q2 are partial charges which are placed on the C,O\r\n * (+q1,-q1) and N,H (-q2,+q2)\r\n */\n\nvar Q = -27.888;\n/** cutoff for hbonds in kcal/mol, must be lower to be consider as an hbond */\n\nvar hbondEnergyCutoff = -0.5;\n/** prevent extremely low hbond energies */\n\nvar hbondEnergyMinimal = -9.9;\n/**\r\n * E = Q * (1/r(ON) + l/r(CH) - l/r(OH) - l/r(CN))\r\n */\n\nfunction calcHbondEnergy(oPos, cPos, nPos, hPos) {\n  var distOH = Vec3.distance(oPos, hPos);\n  var distCH = Vec3.distance(cPos, hPos);\n  var distCN = Vec3.distance(cPos, nPos);\n  var distON = Vec3.distance(oPos, nPos);\n  var e1 = Q / distOH - Q / distCH;\n  var e2 = Q / distCN - Q / distON;\n  var e = e1 + e2; // cap lowest possible energy\n\n  if (e < hbondEnergyMinimal) return hbondEnergyMinimal;\n  return e;\n}\n\nexport function calcUnitBackboneHbonds(unit, proteinInfo, lookup3d) {\n  var residueIndices = proteinInfo.residueIndices,\n      cIndices = proteinInfo.cIndices,\n      hIndices = proteinInfo.hIndices,\n      nIndices = proteinInfo.nIndices,\n      oIndices = proteinInfo.oIndices;\n  var index = unit.model.atomicHierarchy.index;\n  var invariantPosition = unit.conformation.invariantPosition;\n  var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\n  var residueCount = residueIndices.length;\n  var oAtomResidues = [];\n  var nAtomResidues = [];\n  var energies = [];\n  var oPos = Vec3();\n  var cPos = Vec3();\n  var caPos = Vec3();\n  var nPos = Vec3();\n  var hPos = Vec3();\n  var cPosPrev = Vec3();\n  var oPosPrev = Vec3();\n\n  for (var i = 0, il = residueIndices.length; i < il; ++i) {\n    var oPI = i;\n    var oRI = residueIndices[i];\n    var oAtom = oIndices[oPI];\n    var cAtom = cIndices[oPI];\n    var caAtom = traceElementIndex[oRI]; // continue if residue is missing O or C atom\n\n    if (oAtom === -1 || cAtom === -1) continue; // ignore C-terminal residue as acceptor\n\n    if (index.findAtomOnResidue(oRI, 'OXT') !== -1) continue;\n    invariantPosition(oAtom, oPos);\n    invariantPosition(cAtom, cPos);\n    invariantPosition(caAtom, caPos);\n\n    var _a = lookup3d.find(caPos[0], caPos[1], caPos[2], caMaxDist),\n        indices = _a.indices,\n        count = _a.count;\n\n    for (var j = 0; j < count; ++j) {\n      var nPI = indices[j]; // ignore bonds within a residue or to prev or next residue\n\n      if (nPI === oPI || nPI - 1 === oPI || nPI + 1 === oPI) continue;\n      var nAtom = nIndices[nPI];\n      if (nAtom === -1) continue;\n      invariantPosition(nAtom, nPos);\n      var hAtom = hIndices[nPI];\n\n      if (hAtom === -1) {\n        // approximate calculation of H position, TODO factor out\n        if (nPI === 0) continue;\n        var nPIprev = nPI - 1;\n        var oAtomPrev = oIndices[nPIprev];\n        var cAtomPrev = cIndices[nPIprev];\n        if (oAtomPrev === -1 || cAtomPrev === -1) continue;\n        invariantPosition(oAtomPrev, oPosPrev);\n        invariantPosition(cAtomPrev, cPosPrev);\n        Vec3.sub(hPos, cPosPrev, oPosPrev);\n        var dist = Vec3.distance(oPosPrev, cPosPrev);\n        Vec3.scaleAndAdd(hPos, nPos, hPos, 1 / dist);\n      } else {\n        invariantPosition(hAtom, hPos);\n      }\n\n      var e = calcHbondEnergy(oPos, cPos, nPos, hPos);\n      if (e > hbondEnergyCutoff) continue;\n      oAtomResidues[oAtomResidues.length] = oPI;\n      nAtomResidues[nAtomResidues.length] = nPI;\n      energies[energies.length] = e;\n    }\n  }\n\n  return buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies);\n}\n\nfunction buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies) {\n  var builder = new IntAdjacencyGraph.DirectedEdgeBuilder(residueCount, oAtomResidues, nAtomResidues);\n\n  var _energies = new Float32Array(builder.slotCount);\n\n  for (var i = 0, _i = builder.edgeCount; i < _i; i++) {\n    builder.addNextEdge();\n    builder.assignProperty(_energies, energies[i]);\n  }\n\n  return builder.createGraph({\n    energies: energies\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/backbone-hbonds.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nimport { IntAdjacencyGraph } from '../../../../mol-math/graph';\r\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\r\n/** max distance between two C-alpha atoms to check for hbond */\r\nvar caMaxDist = 9.0;\r\n/**\r\n * Constant for electrostatic energy in kcal/mol\r\n *      f  *  q1 *   q2\r\n * Q = -332 * 0.42 * 0.20\r\n *\r\n * f is the dimensional factor\r\n *\r\n * q1 and q2 are partial charges which are placed on the C,O\r\n * (+q1,-q1) and N,H (-q2,+q2)\r\n */\r\nvar Q = -27.888;\r\n/** cutoff for hbonds in kcal/mol, must be lower to be consider as an hbond */\r\nvar hbondEnergyCutoff = -0.5;\r\n/** prevent extremely low hbond energies */\r\nvar hbondEnergyMinimal = -9.9;\r\n/**\r\n * E = Q * (1/r(ON) + l/r(CH) - l/r(OH) - l/r(CN))\r\n */\r\nfunction calcHbondEnergy(oPos, cPos, nPos, hPos) {\r\n    var distOH = Vec3.distance(oPos, hPos);\r\n    var distCH = Vec3.distance(cPos, hPos);\r\n    var distCN = Vec3.distance(cPos, nPos);\r\n    var distON = Vec3.distance(oPos, nPos);\r\n    var e1 = Q / distOH - Q / distCH;\r\n    var e2 = Q / distCN - Q / distON;\r\n    var e = e1 + e2;\r\n    // cap lowest possible energy\r\n    if (e < hbondEnergyMinimal)\r\n        return hbondEnergyMinimal;\r\n    return e;\r\n}\r\nexport function calcUnitBackboneHbonds(unit, proteinInfo, lookup3d) {\r\n    var residueIndices = proteinInfo.residueIndices, cIndices = proteinInfo.cIndices, hIndices = proteinInfo.hIndices, nIndices = proteinInfo.nIndices, oIndices = proteinInfo.oIndices;\r\n    var index = unit.model.atomicHierarchy.index;\r\n    var invariantPosition = unit.conformation.invariantPosition;\r\n    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var residueCount = residueIndices.length;\r\n    var oAtomResidues = [];\r\n    var nAtomResidues = [];\r\n    var energies = [];\r\n    var oPos = Vec3();\r\n    var cPos = Vec3();\r\n    var caPos = Vec3();\r\n    var nPos = Vec3();\r\n    var hPos = Vec3();\r\n    var cPosPrev = Vec3();\r\n    var oPosPrev = Vec3();\r\n    for (var i = 0, il = residueIndices.length; i < il; ++i) {\r\n        var oPI = i;\r\n        var oRI = residueIndices[i];\r\n        var oAtom = oIndices[oPI];\r\n        var cAtom = cIndices[oPI];\r\n        var caAtom = traceElementIndex[oRI];\r\n        // continue if residue is missing O or C atom\r\n        if (oAtom === -1 || cAtom === -1)\r\n            continue;\r\n        // ignore C-terminal residue as acceptor\r\n        if (index.findAtomOnResidue(oRI, 'OXT') !== -1)\r\n            continue;\r\n        invariantPosition(oAtom, oPos);\r\n        invariantPosition(cAtom, cPos);\r\n        invariantPosition(caAtom, caPos);\r\n        var _a = lookup3d.find(caPos[0], caPos[1], caPos[2], caMaxDist), indices = _a.indices, count = _a.count;\r\n        for (var j = 0; j < count; ++j) {\r\n            var nPI = indices[j];\r\n            // ignore bonds within a residue or to prev or next residue\r\n            if (nPI === oPI || nPI - 1 === oPI || nPI + 1 === oPI)\r\n                continue;\r\n            var nAtom = nIndices[nPI];\r\n            if (nAtom === -1)\r\n                continue;\r\n            invariantPosition(nAtom, nPos);\r\n            var hAtom = hIndices[nPI];\r\n            if (hAtom === -1) {\r\n                // approximate calculation of H position, TODO factor out\r\n                if (nPI === 0)\r\n                    continue;\r\n                var nPIprev = nPI - 1;\r\n                var oAtomPrev = oIndices[nPIprev];\r\n                var cAtomPrev = cIndices[nPIprev];\r\n                if (oAtomPrev === -1 || cAtomPrev === -1)\r\n                    continue;\r\n                invariantPosition(oAtomPrev, oPosPrev);\r\n                invariantPosition(cAtomPrev, cPosPrev);\r\n                Vec3.sub(hPos, cPosPrev, oPosPrev);\r\n                var dist = Vec3.distance(oPosPrev, cPosPrev);\r\n                Vec3.scaleAndAdd(hPos, nPos, hPos, 1 / dist);\r\n            }\r\n            else {\r\n                invariantPosition(hAtom, hPos);\r\n            }\r\n            var e = calcHbondEnergy(oPos, cPos, nPos, hPos);\r\n            if (e > hbondEnergyCutoff)\r\n                continue;\r\n            oAtomResidues[oAtomResidues.length] = oPI;\r\n            nAtomResidues[nAtomResidues.length] = nPI;\r\n            energies[energies.length] = e;\r\n        }\r\n    }\r\n    return buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies);\r\n}\r\nfunction buildHbondGraph(residueCount, oAtomResidues, nAtomResidues, energies) {\r\n    var builder = new IntAdjacencyGraph.DirectedEdgeBuilder(residueCount, oAtomResidues, nAtomResidues);\r\n    var _energies = new Float32Array(builder.slotCount);\r\n    for (var i = 0, _i = builder.edgeCount; i < _i; i++) {\r\n        builder.addNextEdge();\r\n        builder.assignProperty(_energies, energies[i]);\r\n    }\r\n    return builder.createGraph({ energies: energies });\r\n}\r\n//# sourceMappingURL=backbone-hbonds.js.map"]},"metadata":{},"sourceType":"module"}