{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { createAttributeBuffers } from './buffer';\nimport { createTextures } from './texture';\nimport { checkError } from './context';\nimport { AttributeSpec, getValueVersions, splitValues, DefineSpec } from '../renderable/schema';\nimport { idFactory } from '../../mol-util/id-factory';\nimport { ValueCell } from '../../mol-util';\nimport { checkFramebufferStatus } from './framebuffer';\nimport { isDebugMode } from '../../mol-util/debug';\nimport { fillSerial } from '../../mol-util/array';\nimport { deepClone } from '../../mol-util/object';\nimport { cloneUniformValues } from './uniform';\nvar getNextRenderItemId = idFactory();\nexport function getDrawMode(ctx, drawMode) {\n  var gl = ctx.gl;\n\n  switch (drawMode) {\n    case 'points':\n      return gl.POINTS;\n\n    case 'lines':\n      return gl.LINES;\n\n    case 'line-strip':\n      return gl.LINE_STRIP;\n\n    case 'line-loop':\n      return gl.LINE_LOOP;\n\n    case 'triangles':\n      return gl.TRIANGLES;\n\n    case 'triangle-strip':\n      return gl.TRIANGLE_STRIP;\n\n    case 'triangle-fan':\n      return gl.TRIANGLE_FAN;\n  }\n} //\n\nvar GraphicsRenderVariant = {\n  'colorBlended': '',\n  'colorWboit': '',\n  'pickObject': '',\n  'pickInstance': '',\n  'pickGroup': '',\n  'depth': '',\n  'markingDepth': '',\n  'markingMask': ''\n};\nvar GraphicsRenderVariants = Object.keys(GraphicsRenderVariant);\nvar ComputeRenderVariant = {\n  'compute': ''\n};\nvar ComputeRenderVariants = Object.keys(ComputeRenderVariant);\n\nfunction createProgramVariant(ctx, variant, defineValues, shaderCode, schema) {\n  defineValues = __assign(__assign({}, defineValues), {\n    dRenderVariant: ValueCell.create(variant)\n  });\n\n  if (schema.dRenderVariant === undefined) {\n    Object.defineProperty(schema, 'dRenderVariant', {\n      value: DefineSpec('string')\n    });\n  }\n\n  return ctx.resources.program(defineValues, shaderCode, schema);\n}\n\nfunction createValueChanges() {\n  return {\n    attributes: false,\n    defines: false,\n    elements: false,\n    textures: false\n  };\n}\n\nfunction resetValueChanges(valueChanges) {\n  valueChanges.attributes = false;\n  valueChanges.defines = false;\n  valueChanges.elements = false;\n  valueChanges.textures = false;\n}\n\nexport function createGraphicsRenderItem(ctx, drawMode, shaderCode, schema, values, materialId) {\n  return createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, GraphicsRenderVariants);\n}\nexport function createComputeRenderItem(ctx, drawMode, shaderCode, schema, values, materialId) {\n  if (materialId === void 0) {\n    materialId = -1;\n  }\n\n  return createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, ComputeRenderVariants);\n}\n/**\r\n * Creates a render item\r\n *\r\n * - assumes that `values.drawCount` and `values.instanceCount` exist\r\n */\n\nexport function createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, renderVariants) {\n  var id = getNextRenderItemId();\n  var stats = ctx.stats,\n      state = ctx.state,\n      resources = ctx.resources;\n  var _a = ctx.extensions,\n      instancedArrays = _a.instancedArrays,\n      vertexArrayObject = _a.vertexArrayObject; // emulate gl_VertexID when needed\n  // if (!ctx.isWebGL2 && values.uVertexCount) {\n  // not using gl_VertexID in WebGL2 but aVertex to ensure there is an active attribute with divisor 0\n  // since FF 85 this is not needed anymore but lets keep it for backwards compatibility\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1679693\n  // see also note in src/mol-gl/shader/chunks/common-vert-params.glsl.ts\n\n  if (values.uVertexCount) {\n    var vertexCount = values.uVertexCount.ref.value;\n    values.aVertex = ValueCell.create(fillSerial(new Float32Array(vertexCount)));\n    schema.aVertex = AttributeSpec('float32', 1, 0);\n  }\n\n  var _b = splitValues(schema, values),\n      attributeValues = _b.attributeValues,\n      defineValues = _b.defineValues,\n      textureValues = _b.textureValues,\n      uniformValues = _b.uniformValues,\n      materialUniformValues = _b.materialUniformValues,\n      bufferedUniformValues = _b.bufferedUniformValues;\n\n  var uniformValueEntries = Object.entries(uniformValues);\n  var materialUniformValueEntries = Object.entries(materialUniformValues);\n  var backBufferUniformValueEntries = Object.entries(bufferedUniformValues);\n  var frontBufferUniformValueEntries = Object.entries(cloneUniformValues(bufferedUniformValues));\n  var defineValueEntries = Object.entries(defineValues);\n  var versions = getValueVersions(values);\n  var glDrawMode = getDrawMode(ctx, drawMode);\n  var programs = {};\n\n  for (var _i = 0, renderVariants_1 = renderVariants; _i < renderVariants_1.length; _i++) {\n    var k = renderVariants_1[_i];\n    programs[k] = createProgramVariant(ctx, k, defineValues, shaderCode, schema);\n  }\n\n  var textures = createTextures(ctx, schema, textureValues);\n  var attributeBuffers = createAttributeBuffers(ctx, schema, attributeValues);\n  var elementsBuffer;\n  var elements = values.elements;\n\n  if (elements && elements.ref.value) {\n    elementsBuffer = resources.elements(elements.ref.value);\n  }\n\n  var vertexArrays = {};\n\n  for (var _c = 0, renderVariants_2 = renderVariants; _c < renderVariants_2.length; _c++) {\n    var k = renderVariants_2[_c];\n    vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;\n  }\n\n  var drawCount = values.drawCount.ref.value;\n  var instanceCount = values.instanceCount.ref.value;\n  stats.drawCount += drawCount;\n  stats.instanceCount += instanceCount;\n  stats.instancedDrawCount += instanceCount * drawCount;\n  var valueChanges = createValueChanges();\n  var destroyed = false;\n  var currentProgramId = -1;\n  return {\n    id: id,\n    materialId: materialId,\n    getProgram: function (variant) {\n      return programs[variant];\n    },\n    render: function (variant, sharedTexturesList) {\n      if (drawCount === 0 || instanceCount === 0 || ctx.isContextLost) return;\n      var program = programs[variant];\n\n      if (program.id === currentProgramId && state.currentRenderItemId === id) {\n        program.setUniforms(uniformValueEntries);\n\n        if (sharedTexturesList && sharedTexturesList.length > 0) {\n          program.bindTextures(sharedTexturesList, 0);\n          program.bindTextures(textures, sharedTexturesList.length);\n        } else {\n          program.bindTextures(textures, 0);\n        }\n      } else {\n        var vertexArray = vertexArrays[variant];\n\n        if (program.id !== state.currentProgramId || program.id !== currentProgramId || materialId === -1 || materialId !== state.currentMaterialId) {\n          // console.log('program.id changed or materialId changed/-1', materialId)\n          if (program.id !== state.currentProgramId) program.use();\n          program.setUniforms(materialUniformValueEntries);\n          state.currentMaterialId = materialId;\n          currentProgramId = program.id;\n        }\n\n        program.setUniforms(uniformValueEntries);\n        program.setUniforms(frontBufferUniformValueEntries);\n\n        if (sharedTexturesList && sharedTexturesList.length > 0) {\n          program.bindTextures(sharedTexturesList, 0);\n          program.bindTextures(textures, sharedTexturesList.length);\n        } else {\n          program.bindTextures(textures, 0);\n        }\n\n        if (vertexArray) {\n          vertexArray.bind(); // need to bind elements buffer explicitly since it is not always recorded in the VAO\n\n          if (elementsBuffer) elementsBuffer.bind();\n        } else {\n          if (elementsBuffer) elementsBuffer.bind();\n          program.bindAttributes(attributeBuffers);\n        }\n\n        state.currentRenderItemId = id;\n      }\n\n      if (isDebugMode) {\n        try {\n          checkFramebufferStatus(ctx.gl);\n        } catch (e) {\n          throw new Error(\"Framebuffer error rendering item id \" + id + \": '\" + e + \"'\");\n        }\n      }\n\n      if (elementsBuffer) {\n        instancedArrays.drawElementsInstanced(glDrawMode, drawCount, elementsBuffer._dataType, 0, instanceCount);\n      } else {\n        instancedArrays.drawArraysInstanced(glDrawMode, 0, drawCount, instanceCount);\n      }\n\n      if (isDebugMode) {\n        try {\n          checkError(ctx.gl);\n        } catch (e) {\n          throw new Error(\"Draw error rendering item id \" + id + \": '\" + e + \"'\");\n        }\n      }\n    },\n    update: function () {\n      resetValueChanges(valueChanges);\n\n      if (values.aVertex) {\n        var vertexCount = values.uVertexCount.ref.value;\n\n        if (values.aVertex.ref.value.length < vertexCount) {\n          ValueCell.update(values.aVertex, fillSerial(new Float32Array(vertexCount)));\n        }\n      }\n\n      for (var i = 0, il = defineValueEntries.length; i < il; ++i) {\n        var _a = defineValueEntries[i],\n            k = _a[0],\n            value = _a[1];\n\n        if (value.ref.version !== versions[k]) {\n          // console.log('define version changed', k);\n          valueChanges.defines = true;\n          versions[k] = value.ref.version;\n        }\n      }\n\n      if (valueChanges.defines) {\n        // console.log('some defines changed, need to rebuild programs');\n        for (var _i = 0, renderVariants_3 = renderVariants; _i < renderVariants_3.length; _i++) {\n          var k = renderVariants_3[_i];\n          programs[k].destroy();\n          programs[k] = createProgramVariant(ctx, k, defineValues, shaderCode, schema);\n        }\n      }\n\n      if (values.drawCount.ref.version !== versions.drawCount) {\n        // console.log('drawCount version changed');\n        stats.drawCount += values.drawCount.ref.value - drawCount;\n        stats.instancedDrawCount += instanceCount * values.drawCount.ref.value - instanceCount * drawCount;\n        drawCount = values.drawCount.ref.value;\n        versions.drawCount = values.drawCount.ref.version;\n      }\n\n      if (values.instanceCount.ref.version !== versions.instanceCount) {\n        // console.log('instanceCount version changed');\n        stats.instanceCount += values.instanceCount.ref.value - instanceCount;\n        stats.instancedDrawCount += values.instanceCount.ref.value * drawCount - instanceCount * drawCount;\n        instanceCount = values.instanceCount.ref.value;\n        versions.instanceCount = values.instanceCount.ref.version;\n      }\n\n      for (var i = 0, il = attributeBuffers.length; i < il; ++i) {\n        var _b = attributeBuffers[i],\n            k = _b[0],\n            buffer = _b[1];\n        var value = attributeValues[k];\n\n        if (value.ref.version !== versions[k]) {\n          if (buffer.length >= value.ref.value.length) {\n            // console.log('attribute array large enough to update', buffer.id, k, value.ref.id, value.ref.version);\n            buffer.updateSubData(value.ref.value, 0, buffer.length);\n          } else {\n            // console.log('attribute array too small, need to create new attribute', buffer.id, k, value.ref.id, value.ref.version);\n            buffer.destroy();\n            var _c = schema[k],\n                itemSize = _c.itemSize,\n                divisor = _c.divisor;\n            attributeBuffers[i][1] = resources.attribute(value.ref.value, itemSize, divisor);\n            valueChanges.attributes = true;\n          }\n\n          versions[k] = value.ref.version;\n        }\n      }\n\n      if (elementsBuffer && values.elements.ref.version !== versions.elements) {\n        if (elementsBuffer.length >= values.elements.ref.value.length) {\n          // console.log('elements array large enough to update', values.elements.ref.id, values.elements.ref.version);\n          elementsBuffer.updateSubData(values.elements.ref.value, 0, elementsBuffer.length);\n        } else {\n          // console.log('elements array to small, need to create new elements', values.elements.ref.id, values.elements.ref.version);\n          elementsBuffer.destroy();\n          elementsBuffer = resources.elements(values.elements.ref.value);\n          valueChanges.elements = true;\n        }\n\n        versions.elements = values.elements.ref.version;\n      }\n\n      if (valueChanges.attributes || valueChanges.defines || valueChanges.elements) {\n        // console.log('program/defines or buffers changed, update vaos');\n        for (var _d = 0, renderVariants_4 = renderVariants; _d < renderVariants_4.length; _d++) {\n          var k = renderVariants_4[_d];\n          var vertexArray = vertexArrays[k];\n          if (vertexArray) vertexArray.destroy();\n          vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;\n        }\n      }\n\n      for (var i = 0, il = textures.length; i < il; ++i) {\n        var _e = textures[i],\n            k = _e[0],\n            texture = _e[1];\n        var value = textureValues[k];\n\n        if (value.ref.version !== versions[k]) {\n          // update of textures with kind 'texture' is done externally\n          if (schema[k].kind !== 'texture') {\n            // console.log('texture version changed, uploading image', k);\n            texture.load(value.ref.value);\n            valueChanges.textures = true;\n          } else {\n            textures[i][1] = value.ref.value;\n          }\n\n          versions[k] = value.ref.version;\n        }\n      }\n\n      for (var i = 0, il = backBufferUniformValueEntries.length; i < il; ++i) {\n        var _f = backBufferUniformValueEntries[i],\n            k = _f[0],\n            uniform = _f[1];\n\n        if (uniform.ref.version !== versions[k]) {\n          // console.log('back-buffer uniform version changed, updating front-buffer', k);\n          ValueCell.update(frontBufferUniformValueEntries[i][1], deepClone(uniform.ref.value));\n          versions[k] = uniform.ref.version;\n        }\n      }\n\n      return valueChanges;\n    },\n    destroy: function () {\n      if (!destroyed) {\n        for (var _i = 0, renderVariants_5 = renderVariants; _i < renderVariants_5.length; _i++) {\n          var k = renderVariants_5[_i];\n          programs[k].destroy();\n          var vertexArray = vertexArrays[k];\n          if (vertexArray) vertexArray.destroy();\n        }\n\n        textures.forEach(function (_a) {\n          var k = _a[0],\n              texture = _a[1]; // lifetime of textures with kind 'texture' is defined externally\n\n          if (schema[k].kind !== 'texture') {\n            texture.destroy();\n          }\n        });\n        attributeBuffers.forEach(function (_a) {\n          var _ = _a[0],\n              buffer = _a[1];\n          return buffer.destroy();\n        });\n        if (elementsBuffer) elementsBuffer.destroy();\n        stats.drawCount -= drawCount;\n        stats.instanceCount -= instanceCount;\n        stats.instancedDrawCount -= instanceCount * drawCount;\n        destroyed = true;\n      }\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/mol-gl/webgl/render-item.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { createAttributeBuffers } from './buffer';\r\nimport { createTextures } from './texture';\r\nimport { checkError } from './context';\r\nimport { AttributeSpec, getValueVersions, splitValues, DefineSpec } from '../renderable/schema';\r\nimport { idFactory } from '../../mol-util/id-factory';\r\nimport { ValueCell } from '../../mol-util';\r\nimport { checkFramebufferStatus } from './framebuffer';\r\nimport { isDebugMode } from '../../mol-util/debug';\r\nimport { fillSerial } from '../../mol-util/array';\r\nimport { deepClone } from '../../mol-util/object';\r\nimport { cloneUniformValues } from './uniform';\r\nvar getNextRenderItemId = idFactory();\r\nexport function getDrawMode(ctx, drawMode) {\r\n    var gl = ctx.gl;\r\n    switch (drawMode) {\r\n        case 'points': return gl.POINTS;\r\n        case 'lines': return gl.LINES;\r\n        case 'line-strip': return gl.LINE_STRIP;\r\n        case 'line-loop': return gl.LINE_LOOP;\r\n        case 'triangles': return gl.TRIANGLES;\r\n        case 'triangle-strip': return gl.TRIANGLE_STRIP;\r\n        case 'triangle-fan': return gl.TRIANGLE_FAN;\r\n    }\r\n}\r\n//\r\nvar GraphicsRenderVariant = { 'colorBlended': '', 'colorWboit': '', 'pickObject': '', 'pickInstance': '', 'pickGroup': '', 'depth': '', 'markingDepth': '', 'markingMask': '' };\r\nvar GraphicsRenderVariants = Object.keys(GraphicsRenderVariant);\r\nvar ComputeRenderVariant = { 'compute': '' };\r\nvar ComputeRenderVariants = Object.keys(ComputeRenderVariant);\r\nfunction createProgramVariant(ctx, variant, defineValues, shaderCode, schema) {\r\n    defineValues = __assign(__assign({}, defineValues), { dRenderVariant: ValueCell.create(variant) });\r\n    if (schema.dRenderVariant === undefined) {\r\n        Object.defineProperty(schema, 'dRenderVariant', { value: DefineSpec('string') });\r\n    }\r\n    return ctx.resources.program(defineValues, shaderCode, schema);\r\n}\r\nfunction createValueChanges() {\r\n    return {\r\n        attributes: false,\r\n        defines: false,\r\n        elements: false,\r\n        textures: false,\r\n    };\r\n}\r\nfunction resetValueChanges(valueChanges) {\r\n    valueChanges.attributes = false;\r\n    valueChanges.defines = false;\r\n    valueChanges.elements = false;\r\n    valueChanges.textures = false;\r\n}\r\nexport function createGraphicsRenderItem(ctx, drawMode, shaderCode, schema, values, materialId) {\r\n    return createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, GraphicsRenderVariants);\r\n}\r\nexport function createComputeRenderItem(ctx, drawMode, shaderCode, schema, values, materialId) {\r\n    if (materialId === void 0) { materialId = -1; }\r\n    return createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, ComputeRenderVariants);\r\n}\r\n/**\r\n * Creates a render item\r\n *\r\n * - assumes that `values.drawCount` and `values.instanceCount` exist\r\n */\r\nexport function createRenderItem(ctx, drawMode, shaderCode, schema, values, materialId, renderVariants) {\r\n    var id = getNextRenderItemId();\r\n    var stats = ctx.stats, state = ctx.state, resources = ctx.resources;\r\n    var _a = ctx.extensions, instancedArrays = _a.instancedArrays, vertexArrayObject = _a.vertexArrayObject;\r\n    // emulate gl_VertexID when needed\r\n    // if (!ctx.isWebGL2 && values.uVertexCount) {\r\n    // not using gl_VertexID in WebGL2 but aVertex to ensure there is an active attribute with divisor 0\r\n    // since FF 85 this is not needed anymore but lets keep it for backwards compatibility\r\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1679693\r\n    // see also note in src/mol-gl/shader/chunks/common-vert-params.glsl.ts\r\n    if (values.uVertexCount) {\r\n        var vertexCount = values.uVertexCount.ref.value;\r\n        values.aVertex = ValueCell.create(fillSerial(new Float32Array(vertexCount)));\r\n        schema.aVertex = AttributeSpec('float32', 1, 0);\r\n    }\r\n    var _b = splitValues(schema, values), attributeValues = _b.attributeValues, defineValues = _b.defineValues, textureValues = _b.textureValues, uniformValues = _b.uniformValues, materialUniformValues = _b.materialUniformValues, bufferedUniformValues = _b.bufferedUniformValues;\r\n    var uniformValueEntries = Object.entries(uniformValues);\r\n    var materialUniformValueEntries = Object.entries(materialUniformValues);\r\n    var backBufferUniformValueEntries = Object.entries(bufferedUniformValues);\r\n    var frontBufferUniformValueEntries = Object.entries(cloneUniformValues(bufferedUniformValues));\r\n    var defineValueEntries = Object.entries(defineValues);\r\n    var versions = getValueVersions(values);\r\n    var glDrawMode = getDrawMode(ctx, drawMode);\r\n    var programs = {};\r\n    for (var _i = 0, renderVariants_1 = renderVariants; _i < renderVariants_1.length; _i++) {\r\n        var k = renderVariants_1[_i];\r\n        programs[k] = createProgramVariant(ctx, k, defineValues, shaderCode, schema);\r\n    }\r\n    var textures = createTextures(ctx, schema, textureValues);\r\n    var attributeBuffers = createAttributeBuffers(ctx, schema, attributeValues);\r\n    var elementsBuffer;\r\n    var elements = values.elements;\r\n    if (elements && elements.ref.value) {\r\n        elementsBuffer = resources.elements(elements.ref.value);\r\n    }\r\n    var vertexArrays = {};\r\n    for (var _c = 0, renderVariants_2 = renderVariants; _c < renderVariants_2.length; _c++) {\r\n        var k = renderVariants_2[_c];\r\n        vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;\r\n    }\r\n    var drawCount = values.drawCount.ref.value;\r\n    var instanceCount = values.instanceCount.ref.value;\r\n    stats.drawCount += drawCount;\r\n    stats.instanceCount += instanceCount;\r\n    stats.instancedDrawCount += instanceCount * drawCount;\r\n    var valueChanges = createValueChanges();\r\n    var destroyed = false;\r\n    var currentProgramId = -1;\r\n    return {\r\n        id: id,\r\n        materialId: materialId,\r\n        getProgram: function (variant) { return programs[variant]; },\r\n        render: function (variant, sharedTexturesList) {\r\n            if (drawCount === 0 || instanceCount === 0 || ctx.isContextLost)\r\n                return;\r\n            var program = programs[variant];\r\n            if (program.id === currentProgramId && state.currentRenderItemId === id) {\r\n                program.setUniforms(uniformValueEntries);\r\n                if (sharedTexturesList && sharedTexturesList.length > 0) {\r\n                    program.bindTextures(sharedTexturesList, 0);\r\n                    program.bindTextures(textures, sharedTexturesList.length);\r\n                }\r\n                else {\r\n                    program.bindTextures(textures, 0);\r\n                }\r\n            }\r\n            else {\r\n                var vertexArray = vertexArrays[variant];\r\n                if (program.id !== state.currentProgramId || program.id !== currentProgramId ||\r\n                    materialId === -1 || materialId !== state.currentMaterialId) {\r\n                    // console.log('program.id changed or materialId changed/-1', materialId)\r\n                    if (program.id !== state.currentProgramId)\r\n                        program.use();\r\n                    program.setUniforms(materialUniformValueEntries);\r\n                    state.currentMaterialId = materialId;\r\n                    currentProgramId = program.id;\r\n                }\r\n                program.setUniforms(uniformValueEntries);\r\n                program.setUniforms(frontBufferUniformValueEntries);\r\n                if (sharedTexturesList && sharedTexturesList.length > 0) {\r\n                    program.bindTextures(sharedTexturesList, 0);\r\n                    program.bindTextures(textures, sharedTexturesList.length);\r\n                }\r\n                else {\r\n                    program.bindTextures(textures, 0);\r\n                }\r\n                if (vertexArray) {\r\n                    vertexArray.bind();\r\n                    // need to bind elements buffer explicitly since it is not always recorded in the VAO\r\n                    if (elementsBuffer)\r\n                        elementsBuffer.bind();\r\n                }\r\n                else {\r\n                    if (elementsBuffer)\r\n                        elementsBuffer.bind();\r\n                    program.bindAttributes(attributeBuffers);\r\n                }\r\n                state.currentRenderItemId = id;\r\n            }\r\n            if (isDebugMode) {\r\n                try {\r\n                    checkFramebufferStatus(ctx.gl);\r\n                }\r\n                catch (e) {\r\n                    throw new Error(\"Framebuffer error rendering item id \" + id + \": '\" + e + \"'\");\r\n                }\r\n            }\r\n            if (elementsBuffer) {\r\n                instancedArrays.drawElementsInstanced(glDrawMode, drawCount, elementsBuffer._dataType, 0, instanceCount);\r\n            }\r\n            else {\r\n                instancedArrays.drawArraysInstanced(glDrawMode, 0, drawCount, instanceCount);\r\n            }\r\n            if (isDebugMode) {\r\n                try {\r\n                    checkError(ctx.gl);\r\n                }\r\n                catch (e) {\r\n                    throw new Error(\"Draw error rendering item id \" + id + \": '\" + e + \"'\");\r\n                }\r\n            }\r\n        },\r\n        update: function () {\r\n            resetValueChanges(valueChanges);\r\n            if (values.aVertex) {\r\n                var vertexCount = values.uVertexCount.ref.value;\r\n                if (values.aVertex.ref.value.length < vertexCount) {\r\n                    ValueCell.update(values.aVertex, fillSerial(new Float32Array(vertexCount)));\r\n                }\r\n            }\r\n            for (var i = 0, il = defineValueEntries.length; i < il; ++i) {\r\n                var _a = defineValueEntries[i], k = _a[0], value = _a[1];\r\n                if (value.ref.version !== versions[k]) {\r\n                    // console.log('define version changed', k);\r\n                    valueChanges.defines = true;\r\n                    versions[k] = value.ref.version;\r\n                }\r\n            }\r\n            if (valueChanges.defines) {\r\n                // console.log('some defines changed, need to rebuild programs');\r\n                for (var _i = 0, renderVariants_3 = renderVariants; _i < renderVariants_3.length; _i++) {\r\n                    var k = renderVariants_3[_i];\r\n                    programs[k].destroy();\r\n                    programs[k] = createProgramVariant(ctx, k, defineValues, shaderCode, schema);\r\n                }\r\n            }\r\n            if (values.drawCount.ref.version !== versions.drawCount) {\r\n                // console.log('drawCount version changed');\r\n                stats.drawCount += values.drawCount.ref.value - drawCount;\r\n                stats.instancedDrawCount += instanceCount * values.drawCount.ref.value - instanceCount * drawCount;\r\n                drawCount = values.drawCount.ref.value;\r\n                versions.drawCount = values.drawCount.ref.version;\r\n            }\r\n            if (values.instanceCount.ref.version !== versions.instanceCount) {\r\n                // console.log('instanceCount version changed');\r\n                stats.instanceCount += values.instanceCount.ref.value - instanceCount;\r\n                stats.instancedDrawCount += values.instanceCount.ref.value * drawCount - instanceCount * drawCount;\r\n                instanceCount = values.instanceCount.ref.value;\r\n                versions.instanceCount = values.instanceCount.ref.version;\r\n            }\r\n            for (var i = 0, il = attributeBuffers.length; i < il; ++i) {\r\n                var _b = attributeBuffers[i], k = _b[0], buffer = _b[1];\r\n                var value = attributeValues[k];\r\n                if (value.ref.version !== versions[k]) {\r\n                    if (buffer.length >= value.ref.value.length) {\r\n                        // console.log('attribute array large enough to update', buffer.id, k, value.ref.id, value.ref.version);\r\n                        buffer.updateSubData(value.ref.value, 0, buffer.length);\r\n                    }\r\n                    else {\r\n                        // console.log('attribute array too small, need to create new attribute', buffer.id, k, value.ref.id, value.ref.version);\r\n                        buffer.destroy();\r\n                        var _c = schema[k], itemSize = _c.itemSize, divisor = _c.divisor;\r\n                        attributeBuffers[i][1] = resources.attribute(value.ref.value, itemSize, divisor);\r\n                        valueChanges.attributes = true;\r\n                    }\r\n                    versions[k] = value.ref.version;\r\n                }\r\n            }\r\n            if (elementsBuffer && values.elements.ref.version !== versions.elements) {\r\n                if (elementsBuffer.length >= values.elements.ref.value.length) {\r\n                    // console.log('elements array large enough to update', values.elements.ref.id, values.elements.ref.version);\r\n                    elementsBuffer.updateSubData(values.elements.ref.value, 0, elementsBuffer.length);\r\n                }\r\n                else {\r\n                    // console.log('elements array to small, need to create new elements', values.elements.ref.id, values.elements.ref.version);\r\n                    elementsBuffer.destroy();\r\n                    elementsBuffer = resources.elements(values.elements.ref.value);\r\n                    valueChanges.elements = true;\r\n                }\r\n                versions.elements = values.elements.ref.version;\r\n            }\r\n            if (valueChanges.attributes || valueChanges.defines || valueChanges.elements) {\r\n                // console.log('program/defines or buffers changed, update vaos');\r\n                for (var _d = 0, renderVariants_4 = renderVariants; _d < renderVariants_4.length; _d++) {\r\n                    var k = renderVariants_4[_d];\r\n                    var vertexArray = vertexArrays[k];\r\n                    if (vertexArray)\r\n                        vertexArray.destroy();\r\n                    vertexArrays[k] = vertexArrayObject ? resources.vertexArray(programs[k], attributeBuffers, elementsBuffer) : null;\r\n                }\r\n            }\r\n            for (var i = 0, il = textures.length; i < il; ++i) {\r\n                var _e = textures[i], k = _e[0], texture = _e[1];\r\n                var value = textureValues[k];\r\n                if (value.ref.version !== versions[k]) {\r\n                    // update of textures with kind 'texture' is done externally\r\n                    if (schema[k].kind !== 'texture') {\r\n                        // console.log('texture version changed, uploading image', k);\r\n                        texture.load(value.ref.value);\r\n                        valueChanges.textures = true;\r\n                    }\r\n                    else {\r\n                        textures[i][1] = value.ref.value;\r\n                    }\r\n                    versions[k] = value.ref.version;\r\n                }\r\n            }\r\n            for (var i = 0, il = backBufferUniformValueEntries.length; i < il; ++i) {\r\n                var _f = backBufferUniformValueEntries[i], k = _f[0], uniform = _f[1];\r\n                if (uniform.ref.version !== versions[k]) {\r\n                    // console.log('back-buffer uniform version changed, updating front-buffer', k);\r\n                    ValueCell.update(frontBufferUniformValueEntries[i][1], deepClone(uniform.ref.value));\r\n                    versions[k] = uniform.ref.version;\r\n                }\r\n            }\r\n            return valueChanges;\r\n        },\r\n        destroy: function () {\r\n            if (!destroyed) {\r\n                for (var _i = 0, renderVariants_5 = renderVariants; _i < renderVariants_5.length; _i++) {\r\n                    var k = renderVariants_5[_i];\r\n                    programs[k].destroy();\r\n                    var vertexArray = vertexArrays[k];\r\n                    if (vertexArray)\r\n                        vertexArray.destroy();\r\n                }\r\n                textures.forEach(function (_a) {\r\n                    var k = _a[0], texture = _a[1];\r\n                    // lifetime of textures with kind 'texture' is defined externally\r\n                    if (schema[k].kind !== 'texture') {\r\n                        texture.destroy();\r\n                    }\r\n                });\r\n                attributeBuffers.forEach(function (_a) {\r\n                    var _ = _a[0], buffer = _a[1];\r\n                    return buffer.destroy();\r\n                });\r\n                if (elementsBuffer)\r\n                    elementsBuffer.destroy();\r\n                stats.drawCount -= drawCount;\r\n                stats.instanceCount -= instanceCount;\r\n                stats.instancedDrawCount -= instanceCount * drawCount;\r\n                destroyed = true;\r\n            }\r\n        }\r\n    };\r\n}\r\n//# sourceMappingURL=render-item.js.map"]},"metadata":{},"sourceType":"module"}