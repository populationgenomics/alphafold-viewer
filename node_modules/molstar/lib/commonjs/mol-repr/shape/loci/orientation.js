"use strict";
/**
 * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrientationRepresentation = exports.OrientationParams = void 0;
var tslib_1 = require("tslib");
var loci_1 = require("../../../mol-model/loci");
var param_definition_1 = require("../../../mol-util/param-definition");
var names_1 = require("../../../mol-util/color/names");
var representation_1 = require("../representation");
var representation_2 = require("../../representation");
var shape_1 = require("../../../mol-model/shape");
var mesh_1 = require("../../../mol-geo/geometry/mesh/mesh");
var mesh_builder_1 = require("../../../mol-geo/geometry/mesh/mesh-builder");
var label_1 = require("../../../mol-theme/label");
var axes_1 = require("../../../mol-geo/geometry/mesh/builder/axes");
var box_1 = require("../../../mol-geo/geometry/mesh/builder/box");
var ellipsoid_1 = require("../../../mol-geo/geometry/mesh/builder/ellipsoid");
var geometry_1 = require("../../../mol-math/geometry");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var marker_action_1 = require("../../../mol-util/marker-action");
var SharedParams = {
    color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.orange),
    scale: param_definition_1.ParamDefinition.Numeric(2, { min: 0.1, max: 10, step: 0.1 })
};
var AxesParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), SharedParams);
var BoxParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), SharedParams);
var EllipsoidParams = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, mesh_1.Mesh.Params), SharedParams);
var OrientationVisuals = {
    'axes': function (ctx, getParams) { return (0, representation_1.ShapeRepresentation)(getAxesShape, mesh_1.Mesh.Utils); },
    'box': function (ctx, getParams) { return (0, representation_1.ShapeRepresentation)(getBoxShape, mesh_1.Mesh.Utils); },
    'ellipsoid': function (ctx, getParams) { return (0, representation_1.ShapeRepresentation)(getEllipsoidShape, mesh_1.Mesh.Utils); },
};
exports.OrientationParams = (0, tslib_1.__assign)((0, tslib_1.__assign)((0, tslib_1.__assign)({}, AxesParams), BoxParams), { visuals: param_definition_1.ParamDefinition.MultiSelect(['box'], param_definition_1.ParamDefinition.objectToOptions(OrientationVisuals)), color: param_definition_1.ParamDefinition.Color(names_1.ColorNames.orange), scale: param_definition_1.ParamDefinition.Numeric(2, { min: 0.1, max: 5, step: 0.1 }) });
//
function orientationLabel(loci) {
    var label = (0, label_1.lociLabel)(loci, { countsOnly: true });
    return "Principal Axes of " + label;
}
function getOrientationName(data) {
    return data.locis.length === 1 ? orientationLabel(data.locis[0]) : data.locis.length + " Orientations";
}
//
function buildAxesMesh(data, props, mesh) {
    var state = mesh_builder_1.MeshBuilder.createState(256, 128, mesh);
    for (var i = 0, il = data.locis.length; i < il; ++i) {
        var principalAxes = loci_1.Loci.getPrincipalAxes(data.locis[i]);
        if (principalAxes) {
            state.currentGroup = i;
            (0, axes_1.addAxes)(state, principalAxes.momentsAxes, props.scale, 2, 20);
        }
    }
    return mesh_builder_1.MeshBuilder.getMesh(state);
}
function getAxesShape(ctx, data, props, shape) {
    var mesh = buildAxesMesh(data, props, shape && shape.geometry);
    var name = getOrientationName(data);
    var getLabel = function (groupId) {
        return orientationLabel(data.locis[groupId]);
    };
    return shape_1.Shape.create(name, data, mesh, function () { return props.color; }, function () { return 1; }, getLabel);
}
//
function buildBoxMesh(data, props, mesh) {
    var state = mesh_builder_1.MeshBuilder.createState(256, 128, mesh);
    for (var i = 0, il = data.locis.length; i < il; ++i) {
        var principalAxes = loci_1.Loci.getPrincipalAxes(data.locis[i]);
        if (principalAxes) {
            state.currentGroup = i;
            (0, box_1.addOrientedBox)(state, principalAxes.boxAxes, props.scale, 2, 20);
        }
    }
    return mesh_builder_1.MeshBuilder.getMesh(state);
}
function getBoxShape(ctx, data, props, shape) {
    var mesh = buildBoxMesh(data, props, shape && shape.geometry);
    var name = getOrientationName(data);
    var getLabel = function (groupId) {
        return orientationLabel(data.locis[groupId]);
    };
    return shape_1.Shape.create(name, data, mesh, function () { return props.color; }, function () { return 1; }, getLabel);
}
//
function buildEllipsoidMesh(data, props, mesh) {
    var state = mesh_builder_1.MeshBuilder.createState(256, 128, mesh);
    for (var i = 0, il = data.locis.length; i < il; ++i) {
        var principalAxes = loci_1.Loci.getPrincipalAxes(data.locis[i]);
        if (principalAxes) {
            var axes = principalAxes.boxAxes;
            var origin_1 = axes.origin, dirA = axes.dirA, dirB = axes.dirB;
            var size = geometry_1.Axes3D.size((0, linear_algebra_1.Vec3)(), axes);
            linear_algebra_1.Vec3.scale(size, size, 0.5);
            var radiusScale = linear_algebra_1.Vec3.create(size[2], size[1], size[0]);
            state.currentGroup = i;
            (0, ellipsoid_1.addEllipsoid)(state, origin_1, dirA, dirB, radiusScale, 2);
        }
    }
    return mesh_builder_1.MeshBuilder.getMesh(state);
}
function getEllipsoidShape(ctx, data, props, shape) {
    var mesh = buildEllipsoidMesh(data, props, shape && shape.geometry);
    var name = getOrientationName(data);
    var getLabel = function (groupId) {
        return orientationLabel(data.locis[groupId]);
    };
    return shape_1.Shape.create(name, data, mesh, function () { return props.color; }, function () { return 1; }, getLabel);
}
function OrientationRepresentation(ctx, getParams) {
    var repr = representation_2.Representation.createMulti('Orientation', ctx, getParams, representation_2.Representation.StateBuilder, OrientationVisuals);
    repr.setState({ markerActions: marker_action_1.MarkerActions.Highlighting });
    return repr;
}
exports.OrientationRepresentation = OrientationRepresentation;
//# sourceMappingURL=orientation.js.map