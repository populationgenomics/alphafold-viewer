{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { CoarseHierarchy } from '../../../mol-model/structure/model/properties/coarse';\nimport { getCoarseKeys } from '../../../mol-model/structure/model/properties/utils/coarse-keys';\nimport { UUID } from '../../../mol-util';\nimport { Segmentation, Interval } from '../../../mol-data/int';\nimport { Mat3, Tensor } from '../../../mol-math/linear-algebra';\nimport { getCoarseRanges } from '../../../mol-model/structure/model/properties/utils/coarse-ranges';\nimport { BasicSchema } from './schema';\nexport var EmptyCoarse = {\n  hierarchy: CoarseHierarchy.Empty,\n  conformation: void 0\n};\nexport function getCoarse(data, properties) {\n  var ihm_sphere_obj_site = data.ihm_sphere_obj_site,\n      ihm_gaussian_obj_site = data.ihm_gaussian_obj_site;\n  if (ihm_sphere_obj_site._rowCount === 0 && ihm_gaussian_obj_site._rowCount === 0) return EmptyCoarse;\n  var sphereData = getData(ihm_sphere_obj_site);\n  var sphereConformation = getSphereConformation(ihm_sphere_obj_site);\n  var sphereKeys = getCoarseKeys(sphereData, data.entities);\n  var sphereRanges = getCoarseRanges(sphereData, properties.chemicalComponentMap);\n  var gaussianData = getData(ihm_gaussian_obj_site);\n  var gaussianConformation = getGaussianConformation(ihm_gaussian_obj_site);\n  var gaussianKeys = getCoarseKeys(gaussianData, data.entities);\n  var gaussianRanges = getCoarseRanges(gaussianData, properties.chemicalComponentMap);\n  return {\n    hierarchy: {\n      isDefined: true,\n      spheres: __assign(__assign(__assign({}, sphereData), sphereKeys), sphereRanges),\n      gaussians: __assign(__assign(__assign({}, gaussianData), gaussianKeys), gaussianRanges)\n    },\n    conformation: {\n      id: UUID.create22(),\n      spheres: sphereConformation,\n      gaussians: gaussianConformation\n    }\n  };\n}\n\nfunction getSphereConformation(data) {\n  return {\n    x: data.Cartn_x.toArray({\n      array: Float32Array\n    }),\n    y: data.Cartn_y.toArray({\n      array: Float32Array\n    }),\n    z: data.Cartn_z.toArray({\n      array: Float32Array\n    }),\n    radius: data.object_radius.toArray({\n      array: Float32Array\n    }),\n    rmsf: data.rmsf.toArray({\n      array: Float32Array\n    })\n  };\n}\n\nfunction getGaussianConformation(data) {\n  var matrix_space = BasicSchema.ihm_gaussian_obj_site.covariance_matrix.space;\n  var covariance_matrix = [];\n  var cm = data.covariance_matrix;\n\n  for (var i = 0, _i = cm.rowCount; i < _i; i++) {\n    covariance_matrix[i] = Tensor.toMat3(Mat3(), matrix_space, cm.value(i));\n  }\n\n  return {\n    x: data.mean_Cartn_x.toArray({\n      array: Float32Array\n    }),\n    y: data.mean_Cartn_y.toArray({\n      array: Float32Array\n    }),\n    z: data.mean_Cartn_z.toArray({\n      array: Float32Array\n    }),\n    weight: data.weight.toArray({\n      array: Float32Array\n    }),\n    covariance_matrix: covariance_matrix\n  };\n}\n\nfunction getSegments(asym_id, seq_id_begin, seq_id_end) {\n  var chainOffsets = [0];\n\n  for (var i = 1, _i = asym_id.rowCount; i < _i; i++) {\n    var newChain = !asym_id.areValuesEqual(i - 1, i);\n    if (newChain) chainOffsets[chainOffsets.length] = i;\n  }\n\n  return {\n    chainElementSegments: Segmentation.ofOffsets(chainOffsets, Interval.ofBounds(0, asym_id.rowCount))\n  };\n}\n\nfunction getData(data) {\n  var entity_id = data.entity_id,\n      seq_id_begin = data.seq_id_begin,\n      seq_id_end = data.seq_id_end,\n      asym_id = data.asym_id;\n  return __assign({\n    count: entity_id.rowCount,\n    entity_id: entity_id,\n    asym_id: asym_id,\n    seq_id_begin: seq_id_begin,\n    seq_id_end: seq_id_end\n  }, getSegments(asym_id, seq_id_begin, seq_id_end));\n}","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/basic/coarse.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { CoarseHierarchy } from '../../../mol-model/structure/model/properties/coarse';\r\nimport { getCoarseKeys } from '../../../mol-model/structure/model/properties/utils/coarse-keys';\r\nimport { UUID } from '../../../mol-util';\r\nimport { Segmentation, Interval } from '../../../mol-data/int';\r\nimport { Mat3, Tensor } from '../../../mol-math/linear-algebra';\r\nimport { getCoarseRanges } from '../../../mol-model/structure/model/properties/utils/coarse-ranges';\r\nimport { BasicSchema } from './schema';\r\nexport var EmptyCoarse = { hierarchy: CoarseHierarchy.Empty, conformation: void 0 };\r\nexport function getCoarse(data, properties) {\r\n    var ihm_sphere_obj_site = data.ihm_sphere_obj_site, ihm_gaussian_obj_site = data.ihm_gaussian_obj_site;\r\n    if (ihm_sphere_obj_site._rowCount === 0 && ihm_gaussian_obj_site._rowCount === 0)\r\n        return EmptyCoarse;\r\n    var sphereData = getData(ihm_sphere_obj_site);\r\n    var sphereConformation = getSphereConformation(ihm_sphere_obj_site);\r\n    var sphereKeys = getCoarseKeys(sphereData, data.entities);\r\n    var sphereRanges = getCoarseRanges(sphereData, properties.chemicalComponentMap);\r\n    var gaussianData = getData(ihm_gaussian_obj_site);\r\n    var gaussianConformation = getGaussianConformation(ihm_gaussian_obj_site);\r\n    var gaussianKeys = getCoarseKeys(gaussianData, data.entities);\r\n    var gaussianRanges = getCoarseRanges(gaussianData, properties.chemicalComponentMap);\r\n    return {\r\n        hierarchy: {\r\n            isDefined: true,\r\n            spheres: __assign(__assign(__assign({}, sphereData), sphereKeys), sphereRanges),\r\n            gaussians: __assign(__assign(__assign({}, gaussianData), gaussianKeys), gaussianRanges),\r\n        },\r\n        conformation: {\r\n            id: UUID.create22(),\r\n            spheres: sphereConformation,\r\n            gaussians: gaussianConformation\r\n        }\r\n    };\r\n}\r\nfunction getSphereConformation(data) {\r\n    return {\r\n        x: data.Cartn_x.toArray({ array: Float32Array }),\r\n        y: data.Cartn_y.toArray({ array: Float32Array }),\r\n        z: data.Cartn_z.toArray({ array: Float32Array }),\r\n        radius: data.object_radius.toArray({ array: Float32Array }),\r\n        rmsf: data.rmsf.toArray({ array: Float32Array })\r\n    };\r\n}\r\nfunction getGaussianConformation(data) {\r\n    var matrix_space = BasicSchema.ihm_gaussian_obj_site.covariance_matrix.space;\r\n    var covariance_matrix = [];\r\n    var cm = data.covariance_matrix;\r\n    for (var i = 0, _i = cm.rowCount; i < _i; i++) {\r\n        covariance_matrix[i] = Tensor.toMat3(Mat3(), matrix_space, cm.value(i));\r\n    }\r\n    return {\r\n        x: data.mean_Cartn_x.toArray({ array: Float32Array }),\r\n        y: data.mean_Cartn_y.toArray({ array: Float32Array }),\r\n        z: data.mean_Cartn_z.toArray({ array: Float32Array }),\r\n        weight: data.weight.toArray({ array: Float32Array }),\r\n        covariance_matrix: covariance_matrix\r\n    };\r\n}\r\nfunction getSegments(asym_id, seq_id_begin, seq_id_end) {\r\n    var chainOffsets = [0];\r\n    for (var i = 1, _i = asym_id.rowCount; i < _i; i++) {\r\n        var newChain = !asym_id.areValuesEqual(i - 1, i);\r\n        if (newChain)\r\n            chainOffsets[chainOffsets.length] = i;\r\n    }\r\n    return {\r\n        chainElementSegments: Segmentation.ofOffsets(chainOffsets, Interval.ofBounds(0, asym_id.rowCount))\r\n    };\r\n}\r\nfunction getData(data) {\r\n    var entity_id = data.entity_id, seq_id_begin = data.seq_id_begin, seq_id_end = data.seq_id_end, asym_id = data.asym_id;\r\n    return __assign({ count: entity_id.rowCount, entity_id: entity_id, asym_id: asym_id, seq_id_begin: seq_id_begin, seq_id_end: seq_id_end }, getSegments(asym_id, seq_id_begin, seq_id_end));\r\n}\r\n//# sourceMappingURL=coarse.js.map"]},"metadata":{},"sourceType":"module"}