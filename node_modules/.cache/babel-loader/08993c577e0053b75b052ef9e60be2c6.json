{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { PluginCommands } from '../../../mol-plugin/commands';\nimport { StateSelection } from '../../../mol-state';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { PluginStateObject } from '../../objects';\nimport { StateTransforms } from '../../transforms';\nimport { PluginStateAnimation } from '../model';\nexport var AnimateModelIndex = PluginStateAnimation.create({\n  name: 'built-in.animate-model-index',\n  display: {\n    name: 'Animate Trajectory'\n  },\n  isExportable: true,\n  params: function () {\n    return {\n      mode: PD.MappedStatic('loop', {\n        palindrome: PD.Group({}),\n        loop: PD.Group({\n          direction: PD.Select('forward', [['forward', 'Forward'], ['backward', 'Backward']])\n        }),\n        once: PD.Group({\n          direction: PD.Select('forward', [['forward', 'Forward'], ['backward', 'Backward']])\n        }, {\n          isFlat: true\n        })\n      }, {\n        options: [['palindrome', 'Palindrome'], ['loop', 'Loop'], ['once', 'Once']]\n      }),\n      duration: PD.MappedStatic('fixed', {\n        fixed: PD.Group({\n          durationInS: PD.Numeric(5, {\n            min: 1,\n            max: 120,\n            step: 0.1\n          }, {\n            description: 'Duration in seconds'\n          })\n        }, {\n          isFlat: true\n        }),\n        computed: PD.Group({\n          targetFps: PD.Numeric(30, {\n            min: 5,\n            max: 250,\n            step: 1\n          }, {\n            label: 'Target FPS'\n          })\n        }, {\n          isFlat: true\n        }),\n        sequential: PD.Group({\n          maxFps: PD.Numeric(30, {\n            min: 5,\n            max: 60,\n            step: 1\n          })\n        }, {\n          isFlat: true\n        })\n      })\n    };\n  },\n  canApply: function (ctx) {\n    var state = ctx.state.data;\n    var models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\n\n    for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {\n      var m = models_1[_i];\n      var parent_1 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\n      if (parent_1 && parent_1.obj && parent_1.obj.data.frameCount > 1) return {\n        canApply: true\n      };\n    }\n\n    return {\n      canApply: false,\n      reason: 'No trajectory to animate'\n    };\n  },\n  getDuration: function (p, ctx) {\n    var _a;\n\n    if (((_a = p.duration) === null || _a === void 0 ? void 0 : _a.name) === 'fixed') {\n      return {\n        kind: 'fixed',\n        durationMs: p.duration.params.durationInS * 1000\n      };\n    } else if (p.duration.name === 'computed') {\n      var state = ctx.state.data;\n      var models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\n      var maxDuration = 0;\n\n      for (var _i = 0, models_2 = models; _i < models_2.length; _i++) {\n        var m = models_2[_i];\n        var parent_2 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\n        if (!parent_2 || !parent_2.obj) continue;\n        var traj = parent_2.obj;\n        maxDuration = Math.max(Math.ceil(1000 * traj.data.frameCount / p.duration.params.targetFps), maxDuration);\n      }\n\n      return {\n        kind: 'fixed',\n        durationMs: maxDuration\n      };\n    }\n\n    return {\n      kind: 'unknown'\n    };\n  },\n  initialState: function () {\n    return {};\n  },\n  apply: function (animState, t, ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var state, models, update, params, palindromeDirections, isEnd, allSingles, _loop_1, _i, models_3, m;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // limit fps\n            if (ctx.params.duration.name === 'sequential' && t.current > 0 && t.current - t.lastApplied < 1000 / ctx.params.duration.params.maxFps) {\n              return [2\n              /*return*/\n              , {\n                kind: 'skip'\n              }];\n            }\n\n            state = ctx.plugin.state.data;\n            models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\n\n            if (models.length === 0) {\n              // nothing more to do here\n              return [2\n              /*return*/\n              , {\n                kind: 'finished'\n              }];\n            }\n\n            update = state.build();\n            params = ctx.params;\n            palindromeDirections = animState.palindromeDirections || {};\n            isEnd = false, allSingles = true;\n\n            _loop_1 = function (m) {\n              var parent_3 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\n              if (!parent_3 || !parent_3.obj) return \"continue\";\n              var traj = parent_3.obj;\n              if (traj.data.frameCount <= 1) return \"continue\";\n              update.to(m).update(function (old) {\n                var len = traj.data.frameCount;\n\n                if (len !== 1) {\n                  allSingles = false;\n                } else {\n                  return old;\n                }\n\n                if (params.duration.name === 'sequential') {\n                  var dir = 1;\n\n                  if (params.mode.name === 'once') {\n                    dir = params.mode.params.direction === 'backward' ? -1 : 1; // if we are at start or end already, do nothing.\n\n                    if (dir === -1 && old.modelIndex === 0 || dir === 1 && old.modelIndex === len - 1) {\n                      isEnd = true;\n                      return old;\n                    }\n                  } else if (params.mode.name === 'palindrome') {\n                    if (old.modelIndex === 0) dir = 1;else if (old.modelIndex === len - 1) dir = -1;else dir = palindromeDirections[m.transform.ref] || 1;\n                  }\n\n                  palindromeDirections[m.transform.ref] = dir;\n                  var modelIndex = (old.modelIndex + dir) % len;\n                  if (modelIndex < 0) modelIndex += len;\n                  isEnd = isEnd || dir === -1 && modelIndex === 0 || dir === 1 && modelIndex === len - 1;\n                  return {\n                    modelIndex: modelIndex\n                  };\n                } else {\n                  var durationInMs = params.duration.name === 'fixed' ? params.duration.params.durationInS * 1000 : Math.ceil(1000 * traj.data.frameCount / params.duration.params.targetFps);\n                  var phase = t.current % durationInMs / durationInMs;\n\n                  if (params.mode.name === 'loop') {\n                    if (params.mode.params.direction === 'backward') {\n                      phase = 1 - phase;\n                    }\n                  }\n\n                  if (params.mode.name === 'palindrome') {\n                    phase = 2 * phase;\n                    if (phase > 1) phase = 2 - phase;\n                  }\n\n                  var modelIndex = Math.min(Math.floor(traj.data.frameCount * phase), traj.data.frameCount - 1);\n                  isEnd = isEnd || modelIndex === traj.data.frameCount - 1;\n                  return {\n                    modelIndex: modelIndex\n                  };\n                }\n              });\n            };\n\n            for (_i = 0, models_3 = models; _i < models_3.length; _i++) {\n              m = models_3[_i];\n\n              _loop_1(m);\n            }\n\n            if (!!allSingles) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , PluginCommands.State.Update(ctx.plugin, {\n              state: state,\n              tree: update,\n              options: {\n                doNotLogTiming: true\n              }\n            })];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (allSingles || params.mode.name === 'once' && isEnd) return [2\n            /*return*/\n            , {\n              kind: 'finished'\n            }];\n            if (params.mode.name === 'palindrome') return [2\n            /*return*/\n            , {\n              kind: 'next',\n              state: {\n                palindromeDirections: palindromeDirections\n              }\n            }];\n            return [2\n            /*return*/\n            , {\n              kind: 'next',\n              state: {}\n            }];\n        }\n      });\n    });\n  }\n});","map":{"version":3,"sources":["../../../../src/mol-plugin-state/animation/built-in/model-index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { PluginCommands } from '../../../mol-plugin/commands';\r\nimport { StateSelection } from '../../../mol-state';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { PluginStateObject } from '../../objects';\r\nimport { StateTransforms } from '../../transforms';\r\nimport { PluginStateAnimation } from '../model';\r\nexport var AnimateModelIndex = PluginStateAnimation.create({\r\n    name: 'built-in.animate-model-index',\r\n    display: { name: 'Animate Trajectory' },\r\n    isExportable: true,\r\n    params: function () { return ({\r\n        mode: PD.MappedStatic('loop', {\r\n            palindrome: PD.Group({}),\r\n            loop: PD.Group({ direction: PD.Select('forward', [['forward', 'Forward'], ['backward', 'Backward']]) }),\r\n            once: PD.Group({ direction: PD.Select('forward', [['forward', 'Forward'], ['backward', 'Backward']]) }, { isFlat: true })\r\n        }, { options: [['palindrome', 'Palindrome'], ['loop', 'Loop'], ['once', 'Once']] }),\r\n        duration: PD.MappedStatic('fixed', {\r\n            fixed: PD.Group({\r\n                durationInS: PD.Numeric(5, { min: 1, max: 120, step: 0.1 }, { description: 'Duration in seconds' })\r\n            }, { isFlat: true }),\r\n            computed: PD.Group({\r\n                targetFps: PD.Numeric(30, { min: 5, max: 250, step: 1 }, { label: 'Target FPS' })\r\n            }, { isFlat: true }),\r\n            sequential: PD.Group({\r\n                maxFps: PD.Numeric(30, { min: 5, max: 60, step: 1 })\r\n            }, { isFlat: true })\r\n        })\r\n    }); },\r\n    canApply: function (ctx) {\r\n        var state = ctx.state.data;\r\n        var models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\r\n        for (var _i = 0, models_1 = models; _i < models_1.length; _i++) {\r\n            var m = models_1[_i];\r\n            var parent_1 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\r\n            if (parent_1 && parent_1.obj && parent_1.obj.data.frameCount > 1)\r\n                return { canApply: true };\r\n        }\r\n        return { canApply: false, reason: 'No trajectory to animate' };\r\n    },\r\n    getDuration: function (p, ctx) {\r\n        var _a;\r\n        if (((_a = p.duration) === null || _a === void 0 ? void 0 : _a.name) === 'fixed') {\r\n            return { kind: 'fixed', durationMs: p.duration.params.durationInS * 1000 };\r\n        }\r\n        else if (p.duration.name === 'computed') {\r\n            var state = ctx.state.data;\r\n            var models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\r\n            var maxDuration = 0;\r\n            for (var _i = 0, models_2 = models; _i < models_2.length; _i++) {\r\n                var m = models_2[_i];\r\n                var parent_2 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\r\n                if (!parent_2 || !parent_2.obj)\r\n                    continue;\r\n                var traj = parent_2.obj;\r\n                maxDuration = Math.max(Math.ceil(1000 * traj.data.frameCount / p.duration.params.targetFps), maxDuration);\r\n            }\r\n            return { kind: 'fixed', durationMs: maxDuration };\r\n        }\r\n        return { kind: 'unknown' };\r\n    },\r\n    initialState: function () { return ({}); },\r\n    apply: function (animState, t, ctx) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var state, models, update, params, palindromeDirections, isEnd, allSingles, _loop_1, _i, models_3, m;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        // limit fps\r\n                        if (ctx.params.duration.name === 'sequential' && t.current > 0 && t.current - t.lastApplied < 1000 / ctx.params.duration.params.maxFps) {\r\n                            return [2 /*return*/, { kind: 'skip' }];\r\n                        }\r\n                        state = ctx.plugin.state.data;\r\n                        models = state.select(StateSelection.Generators.ofTransformer(StateTransforms.Model.ModelFromTrajectory));\r\n                        if (models.length === 0) {\r\n                            // nothing more to do here\r\n                            return [2 /*return*/, { kind: 'finished' }];\r\n                        }\r\n                        update = state.build();\r\n                        params = ctx.params;\r\n                        palindromeDirections = animState.palindromeDirections || {};\r\n                        isEnd = false, allSingles = true;\r\n                        _loop_1 = function (m) {\r\n                            var parent_3 = StateSelection.findAncestorOfType(state.tree, state.cells, m.transform.ref, PluginStateObject.Molecule.Trajectory);\r\n                            if (!parent_3 || !parent_3.obj)\r\n                                return \"continue\";\r\n                            var traj = parent_3.obj;\r\n                            if (traj.data.frameCount <= 1)\r\n                                return \"continue\";\r\n                            update.to(m).update(function (old) {\r\n                                var len = traj.data.frameCount;\r\n                                if (len !== 1) {\r\n                                    allSingles = false;\r\n                                }\r\n                                else {\r\n                                    return old;\r\n                                }\r\n                                if (params.duration.name === 'sequential') {\r\n                                    var dir = 1;\r\n                                    if (params.mode.name === 'once') {\r\n                                        dir = params.mode.params.direction === 'backward' ? -1 : 1;\r\n                                        // if we are at start or end already, do nothing.\r\n                                        if ((dir === -1 && old.modelIndex === 0) || (dir === 1 && old.modelIndex === len - 1)) {\r\n                                            isEnd = true;\r\n                                            return old;\r\n                                        }\r\n                                    }\r\n                                    else if (params.mode.name === 'palindrome') {\r\n                                        if (old.modelIndex === 0)\r\n                                            dir = 1;\r\n                                        else if (old.modelIndex === len - 1)\r\n                                            dir = -1;\r\n                                        else\r\n                                            dir = palindromeDirections[m.transform.ref] || 1;\r\n                                    }\r\n                                    palindromeDirections[m.transform.ref] = dir;\r\n                                    var modelIndex = (old.modelIndex + dir) % len;\r\n                                    if (modelIndex < 0)\r\n                                        modelIndex += len;\r\n                                    isEnd = isEnd || (dir === -1 && modelIndex === 0) || (dir === 1 && modelIndex === len - 1);\r\n                                    return { modelIndex: modelIndex };\r\n                                }\r\n                                else {\r\n                                    var durationInMs = params.duration.name === 'fixed'\r\n                                        ? params.duration.params.durationInS * 1000\r\n                                        : Math.ceil(1000 * traj.data.frameCount / params.duration.params.targetFps);\r\n                                    var phase = (t.current % durationInMs) / durationInMs;\r\n                                    if (params.mode.name === 'loop') {\r\n                                        if (params.mode.params.direction === 'backward') {\r\n                                            phase = 1 - phase;\r\n                                        }\r\n                                    }\r\n                                    if (params.mode.name === 'palindrome') {\r\n                                        phase = 2 * phase;\r\n                                        if (phase > 1)\r\n                                            phase = 2 - phase;\r\n                                    }\r\n                                    var modelIndex = Math.min(Math.floor(traj.data.frameCount * phase), traj.data.frameCount - 1);\r\n                                    isEnd = isEnd || modelIndex === traj.data.frameCount - 1;\r\n                                    return { modelIndex: modelIndex };\r\n                                }\r\n                            });\r\n                        };\r\n                        for (_i = 0, models_3 = models; _i < models_3.length; _i++) {\r\n                            m = models_3[_i];\r\n                            _loop_1(m);\r\n                        }\r\n                        if (!!allSingles) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, PluginCommands.State.Update(ctx.plugin, { state: state, tree: update, options: { doNotLogTiming: true } })];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        if (allSingles || (params.mode.name === 'once' && isEnd))\r\n                            return [2 /*return*/, { kind: 'finished' }];\r\n                        if (params.mode.name === 'palindrome')\r\n                            return [2 /*return*/, { kind: 'next', state: { palindromeDirections: palindromeDirections } }];\r\n                        return [2 /*return*/, { kind: 'next', state: {} }];\r\n                }\r\n            });\r\n        });\r\n    }\r\n});\r\n//# sourceMappingURL=model-index.js.map"]},"metadata":{},"sourceType":"module"}