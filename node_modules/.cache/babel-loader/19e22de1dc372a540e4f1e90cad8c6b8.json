{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../../mol-task'; // import { BitFlags } from '../../../mol-util';\n\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { StructureProperties } from '../../../mol-model/structure';\nimport { assignRadiusForHeavyAtoms } from './shrake-rupley/radii';\nimport { VdWLookup, MaxAsa, DefaultMaxAsa } from './shrake-rupley/common';\nimport { computeArea } from './shrake-rupley/area';\nimport { SortedArray } from '../../../mol-data/int';\nexport var ShrakeRupleyComputationParams = {\n  numberOfSpherePoints: PD.Numeric(92, {\n    min: 12,\n    max: 360,\n    step: 1\n  }, {\n    description: 'Number of sphere points to sample per atom: 92 (original paper), 960 (BioJava), 3000 (EPPIC) - see Shrake A, Rupley JA: Environment and exposure to solvent of protein atoms. Lysozyme and insulin. J Mol Biol 1973.'\n  }),\n  probeSize: PD.Numeric(1.4, {\n    min: 0.1,\n    max: 4,\n    step: 0.01\n  }, {\n    description: 'Corresponds to the size of a water molecule: 1.4 (original paper), 1.5 (occassionally used)'\n  }),\n  // buriedRasaThreshold: PD.Numeric(0.16, { min: 0.0, max: 1.0 }, { description: 'below this cutoff of relative accessible surface area a residue will be considered buried - see: Rost B, Sander C: Conservation and prediction of solvent accessibility in protein families. Proteins 1994.' }),\n  nonPolymer: PD.Boolean(false, {\n    description: 'Include non-polymer atoms as occluders.'\n  }),\n  traceOnly: PD.Boolean(false, {\n    description: 'Compute only using alpha-carbons, if true increase probeSize accordingly (e.g., 4 A). Considers only canonical amino acids.'\n  })\n}; // TODO\n// - add back buried and relative asa\n\nexport { AccessibleSurfaceArea };\nvar AccessibleSurfaceArea;\n\n(function (AccessibleSurfaceArea) {\n  /**\r\n   * Adapts the BioJava implementation by Jose Duarte. That implementation is based on the publication by Shrake, A., and\r\n   * J. A. Rupley. \"Environment and Exposure to Solvent of Protein Atoms. Lysozyme and Insulin.\" JMB (1973).\r\n   */\n  function compute(structure, props) {\n    var _this = this;\n\n    if (props === void 0) {\n      props = {};\n    }\n\n    var p = __assign(__assign({}, PD.getDefaultValues(ShrakeRupleyComputationParams)), props);\n\n    return Task.create('Compute Accessible Surface Area', function (runtime) {\n      return __awaiter(_this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , calculate(runtime, structure, p)];\n\n            case 1:\n              return [2\n              /*return*/\n              , _a.sent()];\n          }\n        });\n      });\n    });\n  }\n\n  AccessibleSurfaceArea.compute = compute;\n\n  function calculate(runtime, structure, props) {\n    return __awaiter(this, void 0, void 0, function () {\n      var ctx, area, serialResidueIndex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            ctx = initialize(structure, props);\n            assignRadiusForHeavyAtoms(ctx);\n            return [4\n            /*yield*/\n            , computeArea(runtime, ctx)];\n\n          case 1:\n            _a.sent();\n\n            area = ctx.area, serialResidueIndex = ctx.serialResidueIndex;\n            return [2\n            /*return*/\n            , {\n              area: area,\n              serialResidueIndex: serialResidueIndex\n            }];\n        }\n      });\n    });\n  }\n\n  function initialize(structure, props) {\n    var elementCount = structure.elementCount,\n        atomicResidueCount = structure.atomicResidueCount;\n    var probeSize = props.probeSize,\n        nonPolymer = props.nonPolymer,\n        traceOnly = props.traceOnly,\n        numberOfSpherePoints = props.numberOfSpherePoints;\n    return {\n      structure: structure,\n      probeSize: probeSize,\n      nonPolymer: nonPolymer,\n      traceOnly: traceOnly,\n      spherePoints: generateSpherePoints(numberOfSpherePoints),\n      scalingConstant: 4.0 * Math.PI / numberOfSpherePoints,\n      maxLookupRadius: 2 * props.probeSize + 2 * VdWLookup[2],\n      atomRadiusType: new Int8Array(elementCount),\n      serialResidueIndex: new Int32Array(elementCount),\n      area: new Float32Array(atomicResidueCount)\n    };\n  }\n  /** Creates a collection of points on a sphere by the Golden Section Spiral algorithm. */\n\n\n  function generateSpherePoints(numberOfSpherePoints) {\n    var points = [];\n    var inc = Math.PI * (3.0 - Math.sqrt(5.0));\n    var offset = 2.0 / numberOfSpherePoints;\n\n    for (var k = 0; k < numberOfSpherePoints; ++k) {\n      var y = k * offset - 1.0 + offset / 2.0;\n      var r = Math.sqrt(1.0 - y * y);\n      var phi = k * inc;\n      points[points.length] = Vec3.create(Math.cos(phi) * r, y, Math.sin(phi) * r);\n    }\n\n    return points;\n  }\n  /** Get relative area for a given component id */\n\n\n  function normalize(compId, asa) {\n    var maxAsa = MaxAsa[compId] || DefaultMaxAsa;\n    return asa / maxAsa;\n  }\n\n  AccessibleSurfaceArea.normalize = normalize;\n\n  function getValue(location, accessibleSurfaceArea) {\n    var area = accessibleSurfaceArea.area,\n        serialResidueIndex = accessibleSurfaceArea.serialResidueIndex;\n    var rSI = serialResidueIndex[SortedArray.indexOf(SortedArray.ofSortedArray(location.structure.root.serialMapping.elementIndices), location.element)];\n    if (rSI === -1) return -1;\n    return area[rSI];\n  }\n\n  AccessibleSurfaceArea.getValue = getValue;\n\n  function getNormalizedValue(location, accessibleSurfaceArea) {\n    var value = getValue(location, accessibleSurfaceArea);\n    return value === -1 ? -1 : normalize(StructureProperties.atom.label_comp_id(location), value);\n  }\n\n  AccessibleSurfaceArea.getNormalizedValue = getNormalizedValue;\n\n  function getFlag(location, accessibleSurfaceArea) {\n    var value = getNormalizedValue(location, accessibleSurfaceArea);\n    return value === -1 ? 0\n    /* NA */\n    : value < 0.16 ? 1\n    /* Buried */\n    : 2\n    /* Accessible */\n    ;\n  }\n\n  AccessibleSurfaceArea.getFlag = getFlag;\n})(AccessibleSurfaceArea || (AccessibleSurfaceArea = {}));","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/accessible-surface-area/shrake-rupley.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;;AAEH,SAAS,IAAT,QAAqC,mBAArC,C,CACA;;AACA,SAAS,eAAe,IAAI,EAA5B,QAAsC,oCAAtC;AACA,SAAS,IAAT,QAAqB,kCAArB;AACA,SAAsC,mBAAtC,QAAiE,8BAAjE;AACA,SAAS,yBAAT,QAA0C,uBAA1C;AACA,SAA8B,SAA9B,EAAyC,MAAzC,EAAiD,aAAjD,QAAsE,wBAAtE;AACA,SAAS,WAAT,QAA4B,sBAA5B;AACA,SAAS,WAAT,QAA4B,uBAA5B;AAEA,OAAO,IAAM,6BAA6B,GAAG;AACzC,EAAA,oBAAoB,EAAE,EAAE,CAAC,OAAH,CAAW,EAAX,EAAe;AAAE,IAAA,GAAG,EAAE,EAAP;AAAW,IAAA,GAAG,EAAE,GAAhB;AAAqB,IAAA,IAAI,EAAE;AAA3B,GAAf,EAA+C;AAAE,IAAA,WAAW,EAAE;AAAf,GAA/C,CADmB;AAEzC,EAAA,SAAS,EAAE,EAAE,CAAC,OAAH,CAAW,GAAX,EAAgB;AAAE,IAAA,GAAG,EAAE,GAAP;AAAY,IAAA,GAAG,EAAE,CAAjB;AAAoB,IAAA,IAAI,EAAE;AAA1B,GAAhB,EAAkD;AAAE,IAAA,WAAW,EAAE;AAAf,GAAlD,CAF8B;AAGzC;AACA,EAAA,UAAU,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB;AAAE,IAAA,WAAW,EAAE;AAAf,GAAlB,CAJ6B;AAKzC,EAAA,SAAS,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB;AAAE,IAAA,WAAW,EAAE;AAAf,GAAlB;AAL8B,CAAtC,C,CAUP;AACA;;AAEA,SAAS,qBAAT;AAOA,IAAU,qBAAV;;AAAA,CAAA,UAAU,qBAAV,EAA+B;AAC3B;;;AAGG;AACH,WAAgB,OAAhB,CAAwB,SAAxB,EAA8C,KAA9C,EAA+F;AAA/F,QAAA,KAAA,GAAA,IAAA;;AAA8C,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,EAAA;AAAiD;;AAC3F,QAAM,CAAC,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,EAAE,CAAC,gBAAH,CAAoB,6BAApB,CAAR,CAAA,EAA+D,KAA/D,CAAP;;AACA,WAAO,IAAI,CAAC,MAAL,CAAY,iCAAZ,EAA+C,UAAM,OAAN,EAAa;AAAA,aAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;AACxD,qBAAA,CAAA;AAAA;AAAA,gBAAM,SAAS,CAAC,OAAD,EAAU,SAAV,EAAqB,CAArB,CAAf,CAAA;;;AAAP,qBAAA,CAAA;AAAA;AAAA,gBAAO,EAAA,CAAA,IAAA,EAAP,CAAA;;;OAD+D,CAAA;AAElE,KAFM,CAAP;AAGH;;AALe,EAAA,qBAAA,CAAA,OAAA,GAAO,OAAP;;AAOhB,WAAe,SAAf,CAAyB,OAAzB,EAAkD,SAAlD,EAAwE,KAAxE,EAA2G;;;;;;AACjG,YAAA,GAAG,GAAG,UAAU,CAAC,SAAD,EAAY,KAAZ,CAAhB;AAEN,YAAA,yBAAyB,CAAC,GAAD,CAAzB;AACA,mBAAA,CAAA;AAAA;AAAA,cAAM,WAAW,CAAC,OAAD,EAAU,GAAV,CAAjB,CAAA;;;AAAA,YAAA,EAAA,CAAA,IAAA;;AAEQ,YAAA,IAAI,GAAyB,GAAG,CAA5B,IAAJ,EAAM,kBAAkB,GAAK,GAAG,CAAR,kBAAxB;AACR,mBAAA,CAAA;AAAA;AAAA,cAAO;AAAE,cAAA,IAAI,EAAA,IAAN;AAAQ,cAAA,kBAAkB,EAAA;AAA1B,aAAP,CAAA;;;;AACH;;AAED,WAAS,UAAT,CAAoB,SAApB,EAA0C,KAA1C,EAA6E;AACjE,QAAA,YAAY,GAAyB,SAAS,CAAlC,YAAZ;AAAA,QAAc,kBAAkB,GAAK,SAAS,CAAd,kBAAhC;AACA,QAAA,SAAS,GAAkD,KAAK,CAAvD,SAAT;AAAA,QAAW,UAAU,GAAsC,KAAK,CAA3C,UAArB;AAAA,QAAuB,SAAS,GAA2B,KAAK,CAAhC,SAAhC;AAAA,QAAkC,oBAAoB,GAAK,KAAK,CAAV,oBAAtD;AAER,WAAO;AACH,MAAA,SAAS,EAAA,SADN;AAEH,MAAA,SAAS,EAAA,SAFN;AAGH,MAAA,UAAU,EAAA,UAHP;AAIH,MAAA,SAAS,EAAA,SAJN;AAKH,MAAA,YAAY,EAAE,oBAAoB,CAAC,oBAAD,CAL/B;AAMH,MAAA,eAAe,EAAE,MAAM,IAAI,CAAC,EAAX,GAAgB,oBAN9B;AAOH,MAAA,eAAe,EAAE,IAAI,KAAK,CAAC,SAAV,GAAsB,IAAI,SAAS,CAAC,CAAD,CAPjD;AAQH,MAAA,cAAc,EAAE,IAAI,SAAJ,CAAc,YAAd,CARb;AASH,MAAA,kBAAkB,EAAE,IAAI,UAAJ,CAAe,YAAf,CATjB;AAUH,MAAA,IAAI,EAAE,IAAI,YAAJ,CAAiB,kBAAjB;AAVH,KAAP;AAYH;AAED;;;AACA,WAAS,oBAAT,CAA8B,oBAA9B,EAA0D;AACtD,QAAM,MAAM,GAAW,EAAvB;AACA,QAAM,GAAG,GAAG,IAAI,CAAC,EAAL,IAAW,MAAM,IAAI,CAAC,IAAL,CAAU,GAAV,CAAjB,CAAZ;AACA,QAAM,MAAM,GAAG,MAAM,oBAArB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,oBAApB,EAA0C,EAAE,CAA5C,EAA+C;AAC3C,UAAM,CAAC,GAAG,CAAC,GAAG,MAAJ,GAAa,GAAb,GAAoB,MAAM,GAAG,GAAvC;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,MAAM,CAAC,GAAG,CAApB,CAAV;AACA,UAAM,GAAG,GAAG,CAAC,GAAG,GAAhB;AACA,MAAA,MAAM,CAAC,MAAM,CAAC,MAAR,CAAN,GAAwB,IAAI,CAAC,MAAL,CAAY,IAAI,CAAC,GAAL,CAAS,GAAT,IAAgB,CAA5B,EAA+B,CAA/B,EAAkC,IAAI,CAAC,GAAL,CAAS,GAAT,IAAgB,CAAlD,CAAxB;AACH;;AACD,WAAO,MAAP;AACH;AAQD;;;AACA,WAAgB,SAAhB,CAA0B,MAA1B,EAA0C,GAA1C,EAAqD;AACjD,QAAM,MAAM,GAAG,MAAM,CAAC,MAAD,CAAN,IAAkB,aAAjC;AACA,WAAO,GAAG,GAAG,MAAb;AACH;;AAHe,EAAA,qBAAA,CAAA,SAAA,GAAS,SAAT;;AAKhB,WAAgB,QAAhB,CAAyB,QAAzB,EAA8D,qBAA9D,EAA0G;AAC9F,QAAA,IAAI,GAAyB,qBAAqB,CAA9C,IAAJ;AAAA,QAAM,kBAAkB,GAAK,qBAAqB,CAA1B,kBAAxB;AACR,QAAM,GAAG,GAAG,kBAAkB,CAAC,WAAW,CAAC,OAAZ,CAAoB,WAAW,CAAC,aAAZ,CAA0B,QAAQ,CAAC,SAAT,CAAmB,IAAnB,CAAwB,aAAxB,CAAsC,cAAhE,CAApB,EAAqG,QAAQ,CAAC,OAA9G,CAAD,CAA9B;AACA,QAAI,GAAG,KAAK,CAAC,CAAb,EAAgB,OAAO,CAAC,CAAR;AAChB,WAAO,IAAI,CAAC,GAAD,CAAX;AACH;;AALe,EAAA,qBAAA,CAAA,QAAA,GAAQ,QAAR;;AAOhB,WAAgB,kBAAhB,CAAmC,QAAnC,EAAwE,qBAAxE,EAAoH;AAChH,QAAM,KAAK,GAAG,QAAQ,CAAC,QAAD,EAAW,qBAAX,CAAtB;AACA,WAAO,KAAK,KAAK,CAAC,CAAX,GAAe,CAAC,CAAhB,GAAoB,SAAS,CAAC,mBAAmB,CAAC,IAApB,CAAyB,aAAzB,CAAuC,QAAvC,CAAD,EAAmD,KAAnD,CAApC;AACH;;AAHe,EAAA,qBAAA,CAAA,kBAAA,GAAkB,kBAAlB;;AAKhB,WAAgB,OAAhB,CAAwB,QAAxB,EAA6D,qBAA7D,EAAyG;AACrG,QAAM,KAAK,GAAG,kBAAkB,CAAC,QAAD,EAAW,qBAAX,CAAhC;AACA,WAAO,KAAK,KAAK,CAAC,CAAX,GAAc;AAAA;AAAd,MACH,KAAK,GAAG,IAAR,GAAc;AAAA;AAAd,M;AACmB;AAFvB;AAGH;;AALe,EAAA,qBAAA,CAAA,OAAA,GAAO,OAAP;AAMnB,CApFD,EAAU,qBAAqB,KAArB,qBAAqB,GAAA,EAAA,CAA/B","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../../mol-task';\r\n// import { BitFlags } from '../../../mol-util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { StructureProperties } from '../../../mol-model/structure';\r\nimport { assignRadiusForHeavyAtoms } from './shrake-rupley/radii';\r\nimport { VdWLookup, MaxAsa, DefaultMaxAsa } from './shrake-rupley/common';\r\nimport { computeArea } from './shrake-rupley/area';\r\nimport { SortedArray } from '../../../mol-data/int';\r\nexport var ShrakeRupleyComputationParams = {\r\n    numberOfSpherePoints: PD.Numeric(92, { min: 12, max: 360, step: 1 }, { description: 'Number of sphere points to sample per atom: 92 (original paper), 960 (BioJava), 3000 (EPPIC) - see Shrake A, Rupley JA: Environment and exposure to solvent of protein atoms. Lysozyme and insulin. J Mol Biol 1973.' }),\r\n    probeSize: PD.Numeric(1.4, { min: 0.1, max: 4, step: 0.01 }, { description: 'Corresponds to the size of a water molecule: 1.4 (original paper), 1.5 (occassionally used)' }),\r\n    // buriedRasaThreshold: PD.Numeric(0.16, { min: 0.0, max: 1.0 }, { description: 'below this cutoff of relative accessible surface area a residue will be considered buried - see: Rost B, Sander C: Conservation and prediction of solvent accessibility in protein families. Proteins 1994.' }),\r\n    nonPolymer: PD.Boolean(false, { description: 'Include non-polymer atoms as occluders.' }),\r\n    traceOnly: PD.Boolean(false, { description: 'Compute only using alpha-carbons, if true increase probeSize accordingly (e.g., 4 A). Considers only canonical amino acids.' })\r\n};\r\n// TODO\r\n// - add back buried and relative asa\r\nexport { AccessibleSurfaceArea };\r\nvar AccessibleSurfaceArea;\r\n(function (AccessibleSurfaceArea) {\r\n    /**\r\n     * Adapts the BioJava implementation by Jose Duarte. That implementation is based on the publication by Shrake, A., and\r\n     * J. A. Rupley. \"Environment and Exposure to Solvent of Protein Atoms. Lysozyme and Insulin.\" JMB (1973).\r\n     */\r\n    function compute(structure, props) {\r\n        var _this = this;\r\n        if (props === void 0) { props = {}; }\r\n        var p = __assign(__assign({}, PD.getDefaultValues(ShrakeRupleyComputationParams)), props);\r\n        return Task.create('Compute Accessible Surface Area', function (runtime) { return __awaiter(_this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, calculate(runtime, structure, p)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        }); });\r\n    }\r\n    AccessibleSurfaceArea.compute = compute;\r\n    function calculate(runtime, structure, props) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var ctx, area, serialResidueIndex;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        ctx = initialize(structure, props);\r\n                        assignRadiusForHeavyAtoms(ctx);\r\n                        return [4 /*yield*/, computeArea(runtime, ctx)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        area = ctx.area, serialResidueIndex = ctx.serialResidueIndex;\r\n                        return [2 /*return*/, { area: area, serialResidueIndex: serialResidueIndex }];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    function initialize(structure, props) {\r\n        var elementCount = structure.elementCount, atomicResidueCount = structure.atomicResidueCount;\r\n        var probeSize = props.probeSize, nonPolymer = props.nonPolymer, traceOnly = props.traceOnly, numberOfSpherePoints = props.numberOfSpherePoints;\r\n        return {\r\n            structure: structure,\r\n            probeSize: probeSize,\r\n            nonPolymer: nonPolymer,\r\n            traceOnly: traceOnly,\r\n            spherePoints: generateSpherePoints(numberOfSpherePoints),\r\n            scalingConstant: 4.0 * Math.PI / numberOfSpherePoints,\r\n            maxLookupRadius: 2 * props.probeSize + 2 * VdWLookup[2],\r\n            atomRadiusType: new Int8Array(elementCount),\r\n            serialResidueIndex: new Int32Array(elementCount),\r\n            area: new Float32Array(atomicResidueCount)\r\n        };\r\n    }\r\n    /** Creates a collection of points on a sphere by the Golden Section Spiral algorithm. */\r\n    function generateSpherePoints(numberOfSpherePoints) {\r\n        var points = [];\r\n        var inc = Math.PI * (3.0 - Math.sqrt(5.0));\r\n        var offset = 2.0 / numberOfSpherePoints;\r\n        for (var k = 0; k < numberOfSpherePoints; ++k) {\r\n            var y = k * offset - 1.0 + (offset / 2.0);\r\n            var r = Math.sqrt(1.0 - y * y);\r\n            var phi = k * inc;\r\n            points[points.length] = Vec3.create(Math.cos(phi) * r, y, Math.sin(phi) * r);\r\n        }\r\n        return points;\r\n    }\r\n    /** Get relative area for a given component id */\r\n    function normalize(compId, asa) {\r\n        var maxAsa = MaxAsa[compId] || DefaultMaxAsa;\r\n        return asa / maxAsa;\r\n    }\r\n    AccessibleSurfaceArea.normalize = normalize;\r\n    function getValue(location, accessibleSurfaceArea) {\r\n        var area = accessibleSurfaceArea.area, serialResidueIndex = accessibleSurfaceArea.serialResidueIndex;\r\n        var rSI = serialResidueIndex[SortedArray.indexOf(SortedArray.ofSortedArray(location.structure.root.serialMapping.elementIndices), location.element)];\r\n        if (rSI === -1)\r\n            return -1;\r\n        return area[rSI];\r\n    }\r\n    AccessibleSurfaceArea.getValue = getValue;\r\n    function getNormalizedValue(location, accessibleSurfaceArea) {\r\n        var value = getValue(location, accessibleSurfaceArea);\r\n        return value === -1 ? -1 : normalize(StructureProperties.atom.label_comp_id(location), value);\r\n    }\r\n    AccessibleSurfaceArea.getNormalizedValue = getNormalizedValue;\r\n    function getFlag(location, accessibleSurfaceArea) {\r\n        var value = getNormalizedValue(location, accessibleSurfaceArea);\r\n        return value === -1 ? 0 /* NA */ :\r\n            value < 0.16 ? 1 /* Buried */ :\r\n                2 /* Accessible */;\r\n    }\r\n    AccessibleSurfaceArea.getFlag = getFlag;\r\n})(AccessibleSurfaceArea || (AccessibleSurfaceArea = {}));\r\n//# sourceMappingURL=shrake-rupley.js.map"]},"metadata":{},"sourceType":"module"}