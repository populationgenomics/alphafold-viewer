{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { IntTuple as Tuple } from '../tuple';\nexport var Empty = Tuple.Zero;\nexport function ofRange(min, max) {\n  return max < min ? Tuple.create(min, min) : Tuple.create(min, max + 1);\n}\nexport function ofBounds(start, end) {\n  return end <= start ? Tuple.create(start, start) : Tuple.create(start, end);\n}\nexport function ofLength(length) {\n  return length < 0 ? Tuple.create(0, 0) : Tuple.create(0, length);\n}\nexport var is = Tuple.is;\nexport var start = Tuple.fst;\nexport var end = Tuple.snd;\nexport var min = Tuple.fst;\nexport function max(i) {\n  return Tuple.snd(i) - 1;\n}\nexport var size = Tuple.diff;\nexport var hashCode = Tuple.hashCode;\nexport var toString = Tuple.toString;\nexport function has(int, v) {\n  return Tuple.fst(int) <= v && v < Tuple.snd(int);\n}\n/** Returns the index of `x` in `set` or -1 if not found. */\n\nexport function indexOf(int, x) {\n  var m = start(int);\n  return x >= m && x < end(int) ? x - m : -1;\n}\nexport function getAt(int, i) {\n  return Tuple.fst(int) + i;\n}\nexport var areEqual = Tuple.areEqual;\nexport function areIntersecting(a, b) {\n  var sa = size(a),\n      sb = size(b);\n  if (sa === 0 && sb === 0) return true;\n  return sa > 0 && sb > 0 && max(a) >= min(b) && min(a) <= max(b);\n}\nexport function isSubInterval(a, b) {\n  if (!size(a)) return size(b) === 0;\n  if (!size(b)) return true;\n  return start(a) <= start(b) && end(a) >= end(b);\n}\nexport function findPredecessorIndex(int, v) {\n  var s = start(int);\n  if (v <= s) return 0;\n  var e = end(int);\n  if (v >= e) return e - s;\n  return v - s;\n}\nexport function findPredecessorIndexInInterval(int, v, bounds) {\n  var bS = start(bounds);\n  var s = start(int);\n  if (v <= bS + s) return bS;\n  var bE = end(bounds);\n  if (v >= bE + s) return bE;\n  return v - s;\n}\nexport function findRange(int, min, max) {\n  return ofBounds(findPredecessorIndex(int, min), findPredecessorIndex(int, max + 1));\n}\nexport function intersect(a, b) {\n  if (!areIntersecting(a, b)) return Empty;\n  return ofBounds(Math.max(start(a), start(b)), Math.min(end(a), end(b)));\n}\nexport function intersectionSize(a, b) {\n  return size(findRange(a, min(b), max(b)));\n}","map":{"version":3,"sources":["../../../../src/mol-data/int/impl/interval.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { IntTuple as Tuple } from '../tuple';\r\nexport var Empty = Tuple.Zero;\r\nexport function ofRange(min, max) { return max < min ? Tuple.create(min, min) : Tuple.create(min, max + 1); }\r\nexport function ofBounds(start, end) { return end <= start ? Tuple.create(start, start) : Tuple.create(start, end); }\r\nexport function ofLength(length) { return length < 0 ? Tuple.create(0, 0) : Tuple.create(0, length); }\r\nexport var is = Tuple.is;\r\nexport var start = Tuple.fst;\r\nexport var end = Tuple.snd;\r\nexport var min = Tuple.fst;\r\nexport function max(i) { return Tuple.snd(i) - 1; }\r\nexport var size = Tuple.diff;\r\nexport var hashCode = Tuple.hashCode;\r\nexport var toString = Tuple.toString;\r\nexport function has(int, v) { return Tuple.fst(int) <= v && v < Tuple.snd(int); }\r\n/** Returns the index of `x` in `set` or -1 if not found. */\r\nexport function indexOf(int, x) { var m = start(int); return x >= m && x < end(int) ? x - m : -1; }\r\nexport function getAt(int, i) { return Tuple.fst(int) + i; }\r\nexport var areEqual = Tuple.areEqual;\r\nexport function areIntersecting(a, b) {\r\n    var sa = size(a), sb = size(b);\r\n    if (sa === 0 && sb === 0)\r\n        return true;\r\n    return sa > 0 && sb > 0 && max(a) >= min(b) && min(a) <= max(b);\r\n}\r\nexport function isSubInterval(a, b) {\r\n    if (!size(a))\r\n        return size(b) === 0;\r\n    if (!size(b))\r\n        return true;\r\n    return start(a) <= start(b) && end(a) >= end(b);\r\n}\r\nexport function findPredecessorIndex(int, v) {\r\n    var s = start(int);\r\n    if (v <= s)\r\n        return 0;\r\n    var e = end(int);\r\n    if (v >= e)\r\n        return e - s;\r\n    return v - s;\r\n}\r\nexport function findPredecessorIndexInInterval(int, v, bounds) {\r\n    var bS = start(bounds);\r\n    var s = start(int);\r\n    if (v <= bS + s)\r\n        return bS;\r\n    var bE = end(bounds);\r\n    if (v >= bE + s)\r\n        return bE;\r\n    return v - s;\r\n}\r\nexport function findRange(int, min, max) {\r\n    return ofBounds(findPredecessorIndex(int, min), findPredecessorIndex(int, max + 1));\r\n}\r\nexport function intersect(a, b) {\r\n    if (!areIntersecting(a, b))\r\n        return Empty;\r\n    return ofBounds(Math.max(start(a), start(b)), Math.min(end(a), end(b)));\r\n}\r\nexport function intersectionSize(a, b) {\r\n    return size(findRange(a, min(b), max(b)));\r\n}\r\n//# sourceMappingURL=interval.js.map"]},"metadata":{},"sourceType":"module"}