{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\nimport { transformPositionArray, createGroupMapping } from '../../util';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { createSizes, getMaxSize } from '../size-data';\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { hashFnv32a } from '../../../mol-data/util';\nimport { createEmptyClipping } from '../clipping-data';\nexport var Cylinders;\n\n(function (Cylinders) {\n  function create(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) {\n    return cylinders ? update(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) : fromArrays(mappings, indices, groups, starts, ends, scales, caps, cylinderCount);\n  }\n\n  Cylinders.create = create;\n\n  function createEmpty(cylinders) {\n    var mb = cylinders ? cylinders.mappingBuffer.ref.value : new Float32Array(0);\n    var ib = cylinders ? cylinders.indexBuffer.ref.value : new Uint32Array(0);\n    var gb = cylinders ? cylinders.groupBuffer.ref.value : new Float32Array(0);\n    var sb = cylinders ? cylinders.startBuffer.ref.value : new Float32Array(0);\n    var eb = cylinders ? cylinders.endBuffer.ref.value : new Float32Array(0);\n    var ab = cylinders ? cylinders.scaleBuffer.ref.value : new Float32Array(0);\n    var cb = cylinders ? cylinders.capBuffer.ref.value : new Float32Array(0);\n    return create(mb, ib, gb, sb, eb, ab, cb, 0, cylinders);\n  }\n\n  Cylinders.createEmpty = createEmpty;\n\n  function hashCode(cylinders) {\n    return hashFnv32a([cylinders.cylinderCount, cylinders.mappingBuffer.ref.version, cylinders.indexBuffer.ref.version, cylinders.groupBuffer.ref.version, cylinders.startBuffer.ref.version, cylinders.endBuffer.ref.version, cylinders.scaleBuffer.ref.version, cylinders.capBuffer.ref.version]);\n  }\n\n  function fromArrays(mappings, indices, groups, starts, ends, scales, caps, cylinderCount) {\n    var boundingSphere = Sphere3D();\n    var groupMapping;\n    var currentHash = -1;\n    var currentGroup = -1;\n    var cylinders = {\n      kind: 'cylinders',\n      cylinderCount: cylinderCount,\n      mappingBuffer: ValueCell.create(mappings),\n      indexBuffer: ValueCell.create(indices),\n      groupBuffer: ValueCell.create(groups),\n      startBuffer: ValueCell.create(starts),\n      endBuffer: ValueCell.create(ends),\n      scaleBuffer: ValueCell.create(scales),\n      capBuffer: ValueCell.create(caps),\n\n      get boundingSphere() {\n        var newHash = hashCode(cylinders);\n\n        if (newHash !== currentHash) {\n          var s = calculateInvariantBoundingSphere(cylinders.startBuffer.ref.value, cylinders.cylinderCount * 6, 6);\n          var e = calculateInvariantBoundingSphere(cylinders.endBuffer.ref.value, cylinders.cylinderCount * 6, 6);\n          Sphere3D.expandBySphere(boundingSphere, s, e);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      },\n\n      get groupMapping() {\n        if (cylinders.groupBuffer.ref.version !== currentGroup) {\n          groupMapping = createGroupMapping(cylinders.groupBuffer.ref.value, cylinders.cylinderCount, 6);\n          currentGroup = cylinders.groupBuffer.ref.version;\n        }\n\n        return groupMapping;\n      },\n\n      setBoundingSphere: function (sphere) {\n        Sphere3D.copy(boundingSphere, sphere);\n        currentHash = hashCode(cylinders);\n      }\n    };\n    return cylinders;\n  }\n\n  function update(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) {\n    if (cylinderCount > cylinders.cylinderCount) {\n      ValueCell.update(cylinders.mappingBuffer, mappings);\n      ValueCell.update(cylinders.indexBuffer, indices);\n    }\n\n    cylinders.cylinderCount = cylinderCount;\n    ValueCell.update(cylinders.groupBuffer, groups);\n    ValueCell.update(cylinders.startBuffer, starts);\n    ValueCell.update(cylinders.endBuffer, ends);\n    ValueCell.update(cylinders.scaleBuffer, scales);\n    ValueCell.update(cylinders.capBuffer, caps);\n    return cylinders;\n  }\n\n  function transform(cylinders, t) {\n    var start = cylinders.startBuffer.ref.value;\n    transformPositionArray(t, start, 0, cylinders.cylinderCount * 6);\n    ValueCell.update(cylinders.startBuffer, start);\n    var end = cylinders.endBuffer.ref.value;\n    transformPositionArray(t, end, 0, cylinders.cylinderCount * 6);\n    ValueCell.update(cylinders.endBuffer, end);\n  }\n\n  Cylinders.transform = transform; //\n\n  Cylinders.Params = __assign(__assign({}, BaseGeometry.Params), {\n    sizeFactor: PD.Numeric(1, {\n      min: 0,\n      max: 10,\n      step: 0.1\n    }),\n    sizeAspectRatio: PD.Numeric(1, {\n      min: 0,\n      max: 3,\n      step: 0.01\n    }),\n    doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo),\n    ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory)\n  });\n  Cylinders.Utils = {\n    Params: Cylinders.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: createRenderableState,\n    updateRenderableState: updateRenderableState,\n    createPositionIterator: createPositionIterator\n  };\n\n  function createPositionIterator(cylinders, transform) {\n    var groupCount = cylinders.cylinderCount * 6;\n    var instanceCount = transform.instanceCount.ref.value;\n    var location = PositionLocation();\n    var p = location.position;\n    var s = cylinders.startBuffer.ref.value;\n    var e = cylinders.endBuffer.ref.value;\n    var m = transform.aTransform.ref.value;\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var v = groupIndex % 6 === 0 ? s : e;\n\n      if (instanceIndex < 0) {\n        Vec3.fromArray(p, v, groupIndex * 3);\n      } else {\n        Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\n      }\n\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 2, getLocation);\n  }\n\n  function createValues(cylinders, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = createPositionIterator(cylinders, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var size = createSizes(locationIt, theme.size);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: cylinders.cylinderCount * 4 * 3,\n      vertexCount: cylinders.cylinderCount * 6,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var padding = getMaxSize(size) * props.sizeFactor;\n    var invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      aMapping: cylinders.mappingBuffer,\n      aGroup: cylinders.groupBuffer,\n      aStart: cylinders.startBuffer,\n      aEnd: cylinders.endBuffer,\n      aScale: cylinders.scaleBuffer,\n      aCap: cylinders.capBuffer,\n      elements: cylinders.indexBuffer,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), size), marker), overpaint), transparency), clipping), transform), {\n      padding: ValueCell.create(padding)\n    }), BaseGeometry.createValues(props, counts)), {\n      uSizeFactor: ValueCell.create(props.sizeFactor * props.sizeAspectRatio),\n      dDoubleSided: ValueCell.create(props.doubleSided),\n      dIgnoreLight: ValueCell.create(props.ignoreLight),\n      dXrayShaded: ValueCell.create(props.xrayShaded)\n    });\n  }\n\n  function createValuesSimple(cylinders, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Cylinders.Params)), props);\n\n    return createValues(cylinders, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor * props.sizeAspectRatio);\n    ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\n    ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\n    ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\n  }\n\n  function updateBoundingSphere(values, cylinders) {\n    var invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n\n  function createRenderableState(props) {\n    var state = BaseGeometry.createRenderableState(props);\n    updateRenderableState(state, props);\n    return state;\n  }\n\n  function updateRenderableState(state, props) {\n    BaseGeometry.updateRenderableState(state, props);\n    state.opaque = state.opaque && !props.xrayShaded;\n    state.writeDepth = state.opaque;\n  }\n})(Cylinders || (Cylinders = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/cylinders/cylinders.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { transformPositionArray, createGroupMapping } from '../../util';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { createSizes, getMaxSize } from '../size-data';\r\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { hashFnv32a } from '../../../mol-data/util';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nexport var Cylinders;\r\n(function (Cylinders) {\r\n    function create(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) {\r\n        return cylinders ?\r\n            update(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) :\r\n            fromArrays(mappings, indices, groups, starts, ends, scales, caps, cylinderCount);\r\n    }\r\n    Cylinders.create = create;\r\n    function createEmpty(cylinders) {\r\n        var mb = cylinders ? cylinders.mappingBuffer.ref.value : new Float32Array(0);\r\n        var ib = cylinders ? cylinders.indexBuffer.ref.value : new Uint32Array(0);\r\n        var gb = cylinders ? cylinders.groupBuffer.ref.value : new Float32Array(0);\r\n        var sb = cylinders ? cylinders.startBuffer.ref.value : new Float32Array(0);\r\n        var eb = cylinders ? cylinders.endBuffer.ref.value : new Float32Array(0);\r\n        var ab = cylinders ? cylinders.scaleBuffer.ref.value : new Float32Array(0);\r\n        var cb = cylinders ? cylinders.capBuffer.ref.value : new Float32Array(0);\r\n        return create(mb, ib, gb, sb, eb, ab, cb, 0, cylinders);\r\n    }\r\n    Cylinders.createEmpty = createEmpty;\r\n    function hashCode(cylinders) {\r\n        return hashFnv32a([\r\n            cylinders.cylinderCount, cylinders.mappingBuffer.ref.version, cylinders.indexBuffer.ref.version,\r\n            cylinders.groupBuffer.ref.version, cylinders.startBuffer.ref.version, cylinders.endBuffer.ref.version, cylinders.scaleBuffer.ref.version, cylinders.capBuffer.ref.version\r\n        ]);\r\n    }\r\n    function fromArrays(mappings, indices, groups, starts, ends, scales, caps, cylinderCount) {\r\n        var boundingSphere = Sphere3D();\r\n        var groupMapping;\r\n        var currentHash = -1;\r\n        var currentGroup = -1;\r\n        var cylinders = {\r\n            kind: 'cylinders',\r\n            cylinderCount: cylinderCount,\r\n            mappingBuffer: ValueCell.create(mappings),\r\n            indexBuffer: ValueCell.create(indices),\r\n            groupBuffer: ValueCell.create(groups),\r\n            startBuffer: ValueCell.create(starts),\r\n            endBuffer: ValueCell.create(ends),\r\n            scaleBuffer: ValueCell.create(scales),\r\n            capBuffer: ValueCell.create(caps),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(cylinders);\r\n                if (newHash !== currentHash) {\r\n                    var s = calculateInvariantBoundingSphere(cylinders.startBuffer.ref.value, cylinders.cylinderCount * 6, 6);\r\n                    var e = calculateInvariantBoundingSphere(cylinders.endBuffer.ref.value, cylinders.cylinderCount * 6, 6);\r\n                    Sphere3D.expandBySphere(boundingSphere, s, e);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n            get groupMapping() {\r\n                if (cylinders.groupBuffer.ref.version !== currentGroup) {\r\n                    groupMapping = createGroupMapping(cylinders.groupBuffer.ref.value, cylinders.cylinderCount, 6);\r\n                    currentGroup = cylinders.groupBuffer.ref.version;\r\n                }\r\n                return groupMapping;\r\n            },\r\n            setBoundingSphere: function (sphere) {\r\n                Sphere3D.copy(boundingSphere, sphere);\r\n                currentHash = hashCode(cylinders);\r\n            }\r\n        };\r\n        return cylinders;\r\n    }\r\n    function update(mappings, indices, groups, starts, ends, scales, caps, cylinderCount, cylinders) {\r\n        if (cylinderCount > cylinders.cylinderCount) {\r\n            ValueCell.update(cylinders.mappingBuffer, mappings);\r\n            ValueCell.update(cylinders.indexBuffer, indices);\r\n        }\r\n        cylinders.cylinderCount = cylinderCount;\r\n        ValueCell.update(cylinders.groupBuffer, groups);\r\n        ValueCell.update(cylinders.startBuffer, starts);\r\n        ValueCell.update(cylinders.endBuffer, ends);\r\n        ValueCell.update(cylinders.scaleBuffer, scales);\r\n        ValueCell.update(cylinders.capBuffer, caps);\r\n        return cylinders;\r\n    }\r\n    function transform(cylinders, t) {\r\n        var start = cylinders.startBuffer.ref.value;\r\n        transformPositionArray(t, start, 0, cylinders.cylinderCount * 6);\r\n        ValueCell.update(cylinders.startBuffer, start);\r\n        var end = cylinders.endBuffer.ref.value;\r\n        transformPositionArray(t, end, 0, cylinders.cylinderCount * 6);\r\n        ValueCell.update(cylinders.endBuffer, end);\r\n    }\r\n    Cylinders.transform = transform;\r\n    //\r\n    Cylinders.Params = __assign(__assign({}, BaseGeometry.Params), { sizeFactor: PD.Numeric(1, { min: 0, max: 10, step: 0.1 }), sizeAspectRatio: PD.Numeric(1, { min: 0, max: 3, step: 0.01 }), doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo), ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory), xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory) });\r\n    Cylinders.Utils = {\r\n        Params: Cylinders.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: createRenderableState,\r\n        updateRenderableState: updateRenderableState,\r\n        createPositionIterator: createPositionIterator\r\n    };\r\n    function createPositionIterator(cylinders, transform) {\r\n        var groupCount = cylinders.cylinderCount * 6;\r\n        var instanceCount = transform.instanceCount.ref.value;\r\n        var location = PositionLocation();\r\n        var p = location.position;\r\n        var s = cylinders.startBuffer.ref.value;\r\n        var e = cylinders.endBuffer.ref.value;\r\n        var m = transform.aTransform.ref.value;\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var v = groupIndex % 6 === 0 ? s : e;\r\n            if (instanceIndex < 0) {\r\n                Vec3.fromArray(p, v, groupIndex * 3);\r\n            }\r\n            else {\r\n                Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\r\n            }\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 2, getLocation);\r\n    }\r\n    function createValues(cylinders, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = createPositionIterator(cylinders, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var size = createSizes(locationIt, theme.size);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: cylinders.cylinderCount * 4 * 3, vertexCount: cylinders.cylinderCount * 6, groupCount: groupCount, instanceCount: instanceCount };\r\n        var padding = getMaxSize(size) * props.sizeFactor;\r\n        var invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ aMapping: cylinders.mappingBuffer, aGroup: cylinders.groupBuffer, aStart: cylinders.startBuffer, aEnd: cylinders.endBuffer, aScale: cylinders.scaleBuffer, aCap: cylinders.capBuffer, elements: cylinders.indexBuffer, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), size), marker), overpaint), transparency), clipping), transform), { padding: ValueCell.create(padding) }), BaseGeometry.createValues(props, counts)), { uSizeFactor: ValueCell.create(props.sizeFactor * props.sizeAspectRatio), dDoubleSided: ValueCell.create(props.doubleSided), dIgnoreLight: ValueCell.create(props.ignoreLight), dXrayShaded: ValueCell.create(props.xrayShaded) });\r\n    }\r\n    function createValuesSimple(cylinders, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Cylinders.Params)), props);\r\n        return createValues(cylinders, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor * props.sizeAspectRatio);\r\n        ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\r\n        ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\r\n        ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\r\n    }\r\n    function updateBoundingSphere(values, cylinders) {\r\n        var invariantBoundingSphere = Sphere3D.clone(cylinders.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n    function createRenderableState(props) {\r\n        var state = BaseGeometry.createRenderableState(props);\r\n        updateRenderableState(state, props);\r\n        return state;\r\n    }\r\n    function updateRenderableState(state, props) {\r\n        BaseGeometry.updateRenderableState(state, props);\r\n        state.opaque = state.opaque && !props.xrayShaded;\r\n        state.writeDepth = state.opaque;\r\n    }\r\n})(Cylinders || (Cylinders = {}));\r\n//# sourceMappingURL=cylinders.js.map"]},"metadata":{},"sourceType":"module"}