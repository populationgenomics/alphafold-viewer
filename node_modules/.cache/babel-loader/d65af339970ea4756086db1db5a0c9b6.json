{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { BondType } from '../../../mol-model/structure/model/types';\nimport { SortedArray } from '../../../mol-data/int';\nexport function typeSymbol(unit, index) {\n  return unit.model.atomicHierarchy.atoms.type_symbol.value(unit.elements[index]);\n}\nexport function formalCharge(unit, index) {\n  return unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(unit.elements[index]);\n}\nexport function atomId(unit, index) {\n  return unit.model.atomicHierarchy.atoms.label_atom_id.value(unit.elements[index]);\n}\nexport function altLoc(unit, index) {\n  return unit.model.atomicHierarchy.atoms.label_alt_id.value(unit.elements[index]);\n}\nexport function compId(unit, index) {\n  return unit.model.atomicHierarchy.atoms.label_comp_id.value(unit.elements[index]);\n} //\n\nexport function interBondCount(structure, unit, index) {\n  var count = 0;\n  var indices = structure.interUnitBonds.getEdgeIndices(index, unit.id);\n\n  for (var i = 0, il = indices.length; i < il; ++i) {\n    var b = structure.interUnitBonds.edges[indices[i]];\n    if (BondType.isCovalent(b.props.flag)) count += 1;\n  }\n\n  return count;\n}\nexport function intraBondCount(unit, index) {\n  var count = 0;\n  var _a = unit.bonds,\n      offset = _a.offset,\n      flags = _a.edgeProps.flags;\n\n  for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\n    if (BondType.isCovalent(flags[i])) count += 1;\n  }\n\n  return count;\n}\nexport function bondCount(structure, unit, index) {\n  return interBondCount(structure, unit, index) + intraBondCount(unit, index);\n}\nexport function bondToElementCount(structure, unit, index, element) {\n  var count = 0;\n  eachBondedAtom(structure, unit, index, function (unit, index) {\n    if (typeSymbol(unit, index) === element) count += 1;\n  });\n  return count;\n} //\n\nexport function intraConnectedTo(unit, indexA, indexB) {\n  var _a = unit.bonds,\n      offset = _a.offset,\n      b = _a.b,\n      flags = _a.edgeProps.flags;\n  BondType.is;\n\n  for (var i = offset[indexA], il = offset[indexA + 1]; i < il; ++i) {\n    if (b[i] === indexB && BondType.isCovalent(flags[i])) return true;\n  }\n\n  return false;\n}\nexport function interConnectedTo(structure, unitA, indexA, unitB, indexB) {\n  var b = structure.interUnitBonds.getEdge(indexA, unitA.id, indexB, unitB.id);\n  return b && BondType.isCovalent(b.props.flag);\n}\nexport function connectedTo(structure, unitA, indexA, unitB, indexB) {\n  return unitA === unitB ? intraConnectedTo(unitA, indexA, indexB) : interConnectedTo(structure, unitA, indexA, unitB, indexB);\n} //\n\nexport function eachInterBondedAtom(structure, unit, index, cb) {\n  var indices = structure.interUnitBonds.getEdgeIndices(index, unit.id);\n\n  for (var i = 0, il = indices.length; i < il; ++i) {\n    var b = structure.interUnitBonds.edges[indices[i]];\n    var uB = structure.unitMap.get(b.unitB);\n    if (BondType.isCovalent(b.props.flag)) cb(uB, b.indexB);\n  }\n}\nexport function eachIntraBondedAtom(unit, index, cb) {\n  var _a = unit.bonds,\n      offset = _a.offset,\n      b = _a.b,\n      flags = _a.edgeProps.flags;\n\n  for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\n    if (BondType.isCovalent(flags[i])) cb(unit, b[i]);\n  }\n}\nexport function eachBondedAtom(structure, unit, index, cb) {\n  eachInterBondedAtom(structure, unit, index, cb);\n  eachIntraBondedAtom(unit, index, cb);\n} //\n\nexport function eachResidueAtom(unit, index, cb) {\n  var offsets = unit.model.atomicHierarchy.residueAtomSegments.offsets;\n  var rI = unit.getResidueIndex(index);\n\n  for (var i = offsets[rI], il = offsets[rI + 1]; i < il; ++i) {\n    // TODO optimize, avoid search with .indexOf\n    var idx = SortedArray.indexOf(unit.elements, i);\n    if (idx !== -1) cb(idx);\n  }\n}","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/chemistry/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { BondType } from '../../../mol-model/structure/model/types';\r\nimport { SortedArray } from '../../../mol-data/int';\r\nexport function typeSymbol(unit, index) {\r\n    return unit.model.atomicHierarchy.atoms.type_symbol.value(unit.elements[index]);\r\n}\r\nexport function formalCharge(unit, index) {\r\n    return unit.model.atomicHierarchy.atoms.pdbx_formal_charge.value(unit.elements[index]);\r\n}\r\nexport function atomId(unit, index) {\r\n    return unit.model.atomicHierarchy.atoms.label_atom_id.value(unit.elements[index]);\r\n}\r\nexport function altLoc(unit, index) {\r\n    return unit.model.atomicHierarchy.atoms.label_alt_id.value(unit.elements[index]);\r\n}\r\nexport function compId(unit, index) {\r\n    return unit.model.atomicHierarchy.atoms.label_comp_id.value(unit.elements[index]);\r\n}\r\n//\r\nexport function interBondCount(structure, unit, index) {\r\n    var count = 0;\r\n    var indices = structure.interUnitBonds.getEdgeIndices(index, unit.id);\r\n    for (var i = 0, il = indices.length; i < il; ++i) {\r\n        var b = structure.interUnitBonds.edges[indices[i]];\r\n        if (BondType.isCovalent(b.props.flag))\r\n            count += 1;\r\n    }\r\n    return count;\r\n}\r\nexport function intraBondCount(unit, index) {\r\n    var count = 0;\r\n    var _a = unit.bonds, offset = _a.offset, flags = _a.edgeProps.flags;\r\n    for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\r\n        if (BondType.isCovalent(flags[i]))\r\n            count += 1;\r\n    }\r\n    return count;\r\n}\r\nexport function bondCount(structure, unit, index) {\r\n    return interBondCount(structure, unit, index) + intraBondCount(unit, index);\r\n}\r\nexport function bondToElementCount(structure, unit, index, element) {\r\n    var count = 0;\r\n    eachBondedAtom(structure, unit, index, function (unit, index) {\r\n        if (typeSymbol(unit, index) === element)\r\n            count += 1;\r\n    });\r\n    return count;\r\n}\r\n//\r\nexport function intraConnectedTo(unit, indexA, indexB) {\r\n    var _a = unit.bonds, offset = _a.offset, b = _a.b, flags = _a.edgeProps.flags;\r\n    BondType.is;\r\n    for (var i = offset[indexA], il = offset[indexA + 1]; i < il; ++i) {\r\n        if (b[i] === indexB && BondType.isCovalent(flags[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nexport function interConnectedTo(structure, unitA, indexA, unitB, indexB) {\r\n    var b = structure.interUnitBonds.getEdge(indexA, unitA.id, indexB, unitB.id);\r\n    return b && BondType.isCovalent(b.props.flag);\r\n}\r\nexport function connectedTo(structure, unitA, indexA, unitB, indexB) {\r\n    return unitA === unitB ? intraConnectedTo(unitA, indexA, indexB) : interConnectedTo(structure, unitA, indexA, unitB, indexB);\r\n}\r\n//\r\nexport function eachInterBondedAtom(structure, unit, index, cb) {\r\n    var indices = structure.interUnitBonds.getEdgeIndices(index, unit.id);\r\n    for (var i = 0, il = indices.length; i < il; ++i) {\r\n        var b = structure.interUnitBonds.edges[indices[i]];\r\n        var uB = structure.unitMap.get(b.unitB);\r\n        if (BondType.isCovalent(b.props.flag))\r\n            cb(uB, b.indexB);\r\n    }\r\n}\r\nexport function eachIntraBondedAtom(unit, index, cb) {\r\n    var _a = unit.bonds, offset = _a.offset, b = _a.b, flags = _a.edgeProps.flags;\r\n    for (var i = offset[index], il = offset[index + 1]; i < il; ++i) {\r\n        if (BondType.isCovalent(flags[i]))\r\n            cb(unit, b[i]);\r\n    }\r\n}\r\nexport function eachBondedAtom(structure, unit, index, cb) {\r\n    eachInterBondedAtom(structure, unit, index, cb);\r\n    eachIntraBondedAtom(unit, index, cb);\r\n}\r\n//\r\nexport function eachResidueAtom(unit, index, cb) {\r\n    var offsets = unit.model.atomicHierarchy.residueAtomSegments.offsets;\r\n    var rI = unit.getResidueIndex(index);\r\n    for (var i = offsets[rI], il = offsets[rI + 1]; i < il; ++i) {\r\n        // TODO optimize, avoid search with .indexOf\r\n        var idx = SortedArray.indexOf(unit.elements, i);\r\n        if (idx !== -1)\r\n            cb(idx);\r\n    }\r\n}\r\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}