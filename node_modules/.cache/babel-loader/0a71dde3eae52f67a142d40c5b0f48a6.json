{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { QuadSchema, QuadValues } from '../../mol-gl/compute/util';\nimport { TextureSpec, UniformSpec } from '../../mol-gl/renderable/schema';\nimport { ValueCell } from '../../mol-util';\nimport { Vec2 } from '../../mol-math/linear-algebra';\nimport { ShaderCode } from '../../mol-gl/shader-code';\nimport { createComputeRenderItem } from '../../mol-gl/webgl/render-item';\nimport { createComputeRenderable } from '../../mol-gl/renderable';\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\nimport { Camera } from '../../mol-canvas3d/camera';\nimport { quad_vert } from '../../mol-gl/shader/quad.vert';\nimport { compose_frag } from '../../mol-gl/shader/compose.frag';\n\nvar ComposeSchema = __assign(__assign({}, QuadSchema), {\n  tColor: TextureSpec('texture', 'rgba', 'ubyte', 'nearest'),\n  uTexSize: UniformSpec('v2'),\n  uWeight: UniformSpec('f')\n});\n\nvar ComposeShaderCode = ShaderCode('compose', quad_vert, compose_frag);\n\nfunction getComposeRenderable(ctx, colorTexture) {\n  var values = __assign(__assign({}, QuadValues), {\n    tColor: ValueCell.create(colorTexture),\n    uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())),\n    uWeight: ValueCell.create(1.0)\n  });\n\n  var schema = __assign({}, ComposeSchema);\n\n  var renderItem = createComputeRenderItem(ctx, 'triangles', ComposeShaderCode, schema, values);\n  return createComputeRenderable(renderItem, values);\n}\n\nexport var MultiSampleParams = {\n  mode: PD.Select('off', [['off', 'Off'], ['on', 'On'], ['temporal', 'Temporal']]),\n  sampleLevel: PD.Numeric(2, {\n    min: 0,\n    max: 5,\n    step: 1\n  })\n};\n\nvar MultiSamplePass =\n/** @class */\nfunction () {\n  function MultiSamplePass(webgl, drawPass) {\n    this.webgl = webgl;\n    this.drawPass = drawPass;\n    var _a = webgl.extensions,\n        colorBufferFloat = _a.colorBufferFloat,\n        textureFloat = _a.textureFloat,\n        colorBufferHalfFloat = _a.colorBufferHalfFloat,\n        textureHalfFloat = _a.textureHalfFloat;\n    var width = drawPass.colorTarget.getWidth();\n    var height = drawPass.colorTarget.getHeight();\n    this.colorTarget = webgl.createRenderTarget(width, height, false);\n    var type = colorBufferHalfFloat && textureHalfFloat ? 'fp16' : colorBufferFloat && textureFloat ? 'float32' : 'uint8';\n    this.composeTarget = webgl.createRenderTarget(width, height, false, type);\n    this.holdTarget = webgl.createRenderTarget(width, height, false);\n    this.compose = getComposeRenderable(webgl, drawPass.colorTarget.texture);\n  }\n\n  MultiSamplePass.isEnabled = function (props) {\n    return props.mode !== 'off';\n  };\n\n  MultiSamplePass.prototype.syncSize = function () {\n    var width = this.drawPass.colorTarget.getWidth();\n    var height = this.drawPass.colorTarget.getHeight();\n    var _a = this.compose.values.uTexSize.ref.value,\n        w = _a[0],\n        h = _a[1];\n\n    if (width !== w || height !== h) {\n      this.colorTarget.setSize(width, height);\n      this.composeTarget.setSize(width, height);\n      this.holdTarget.setSize(width, height);\n      ValueCell.update(this.compose.values.uTexSize, Vec2.set(this.compose.values.uTexSize.ref.value, width, height));\n    }\n  };\n\n  MultiSamplePass.prototype.render = function (sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\n    if (props.multiSample.mode === 'temporal') {\n      return this.renderTemporalMultiSample(sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\n    } else {\n      this.renderMultiSample(renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\n      return sampleIndex;\n    }\n  };\n\n  MultiSamplePass.prototype.bindOutputTarget = function (toDrawingBuffer) {\n    if (toDrawingBuffer) {\n      this.webgl.unbindFramebuffer();\n    } else {\n      this.colorTarget.bind();\n    }\n  };\n\n  MultiSamplePass.prototype.renderMultiSample = function (renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\n    var _a = this,\n        compose = _a.compose,\n        composeTarget = _a.composeTarget,\n        drawPass = _a.drawPass,\n        webgl = _a.webgl;\n\n    var gl = webgl.gl,\n        state = webgl.state; // based on the Multisample Anti-Aliasing Render Pass\n    // contributed to three.js by bhouston / http://clara.io/\n    //\n    // This manual approach to MSAA re-renders the scene once for\n    // each sample with camera jitter and accumulates the results.\n\n    var offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];\n    var _b = camera.viewport,\n        x = _b.x,\n        y = _b.y,\n        width = _b.width,\n        height = _b.height;\n    var baseSampleWeight = 1.0 / offsetList.length;\n    var roundingRange = 1 / 32;\n    camera.viewOffset.enabled = true;\n    ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\n    compose.update(); // render the scene multiple times, each slightly jitter offset\n    // from the last and accumulate the results.\n\n    for (var i = 0; i < offsetList.length; ++i) {\n      var offset = offsetList[i];\n      Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);\n      camera.update(); // the theory is that equal weights for each sample lead to an accumulation of rounding\n      // errors. The following equation varies the sampleWeight per sample so that it is uniformly\n      // distributed across a range of values whose rounding errors cancel each other out.\n\n      var uniformCenteredDistribution = -0.5 + (i + 0.5) / offsetList.length;\n      var sampleWeight = baseSampleWeight + roundingRange * uniformCenteredDistribution;\n      ValueCell.update(compose.values.uWeight, sampleWeight); // render scene\n\n      drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking); // compose rendered scene with compose target\n\n      composeTarget.bind();\n      state.enable(gl.BLEND);\n      state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n      state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\n      state.disable(gl.DEPTH_TEST);\n      state.depthMask(false);\n      gl.viewport(x, y, width, height);\n      gl.scissor(x, y, width, height);\n\n      if (i === 0) {\n        state.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      }\n\n      compose.render();\n    }\n\n    ValueCell.update(compose.values.uWeight, 1.0);\n    ValueCell.update(compose.values.tColor, composeTarget.texture);\n    compose.update();\n    this.bindOutputTarget(toDrawingBuffer);\n    gl.viewport(x, y, width, height);\n    gl.scissor(x, y, width, height);\n    state.disable(gl.BLEND);\n    compose.render();\n    camera.viewOffset.enabled = false;\n    camera.update();\n  };\n\n  MultiSamplePass.prototype.renderTemporalMultiSample = function (sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\n    var _a = this,\n        compose = _a.compose,\n        composeTarget = _a.composeTarget,\n        holdTarget = _a.holdTarget,\n        drawPass = _a.drawPass,\n        webgl = _a.webgl;\n\n    var gl = webgl.gl,\n        state = webgl.state; // based on the Multisample Anti-Aliasing Render Pass\n    // contributed to three.js by bhouston / http://clara.io/\n    //\n    // This manual approach to MSAA re-renders the scene once for\n    // each sample with camera jitter and accumulates the results.\n\n    var offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];\n    if (sampleIndex === -2 || sampleIndex >= offsetList.length) return -2;\n    var _b = camera.viewport,\n        x = _b.x,\n        y = _b.y,\n        width = _b.width,\n        height = _b.height;\n    var sampleWeight = 1.0 / offsetList.length;\n\n    if (sampleIndex === -1) {\n      drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking);\n      ValueCell.update(compose.values.uWeight, 1.0);\n      ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\n      compose.update();\n      holdTarget.bind();\n      state.disable(gl.BLEND);\n      state.disable(gl.DEPTH_TEST);\n      state.depthMask(false);\n      gl.viewport(x, y, width, height);\n      gl.scissor(x, y, width, height);\n      compose.render();\n      sampleIndex += 1;\n    } else {\n      camera.viewOffset.enabled = true;\n      ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\n      ValueCell.update(compose.values.uWeight, sampleWeight);\n      compose.update(); // render the scene multiple times, each slightly jitter offset\n      // from the last and accumulate the results.\n\n      var numSamplesPerFrame = Math.pow(2, Math.max(0, props.multiSample.sampleLevel - 2));\n\n      for (var i = 0; i < numSamplesPerFrame; ++i) {\n        var offset = offsetList[sampleIndex];\n        Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);\n        camera.update(); // render scene\n\n        drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking); // compose rendered scene with compose target\n\n        composeTarget.bind();\n        state.enable(gl.BLEND);\n        state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\n        state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\n        state.disable(gl.DEPTH_TEST);\n        state.depthMask(false);\n        gl.viewport(x, y, width, height);\n        gl.scissor(x, y, width, height);\n\n        if (sampleIndex === 0) {\n          state.clearColor(0, 0, 0, 0);\n          gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n\n        compose.render();\n        sampleIndex += 1;\n        if (sampleIndex >= offsetList.length) break;\n      }\n    }\n\n    this.bindOutputTarget(toDrawingBuffer);\n    gl.viewport(x, y, width, height);\n    gl.scissor(x, y, width, height);\n    var accumulationWeight = sampleIndex * sampleWeight;\n\n    if (accumulationWeight > 0) {\n      ValueCell.update(compose.values.uWeight, 1.0);\n      ValueCell.update(compose.values.tColor, composeTarget.texture);\n      compose.update();\n      state.disable(gl.BLEND);\n      compose.render();\n    }\n\n    if (accumulationWeight < 1.0) {\n      ValueCell.update(compose.values.uWeight, 1.0 - accumulationWeight);\n      ValueCell.update(compose.values.tColor, holdTarget.texture);\n      compose.update();\n      if (accumulationWeight === 0) state.disable(gl.BLEND);else state.enable(gl.BLEND);\n      compose.render();\n    }\n\n    camera.viewOffset.enabled = false;\n    camera.update();\n    return sampleIndex >= offsetList.length ? -2 : sampleIndex;\n  };\n\n  return MultiSamplePass;\n}();\n\nexport { MultiSamplePass };\nvar JitterVectors = [[[0, 0]], [[4, 4], [-4, -4]], [[-2, -6], [6, -2], [-6, 2], [2, 6]], [[1, -3], [-1, 3], [5, 1], [-3, -5], [-5, 5], [-7, -1], [3, 7], [7, -7]], [[1, 1], [-1, -3], [-3, 2], [4, -1], [-5, -2], [2, 5], [5, 3], [3, -5], [-2, 6], [0, -7], [-4, -6], [-6, 4], [-8, 0], [7, -4], [6, 7], [-7, -8]], [[-4, -7], [-7, -5], [-3, -5], [-5, -4], [-1, -4], [-2, -2], [-6, -1], [-4, 0], [-7, 1], [-1, 2], [-6, 3], [-3, 3], [-7, 6], [-3, 6], [-5, 7], [-1, 7], [5, -7], [1, -6], [6, -5], [4, -4], [2, -3], [7, -2], [1, -1], [4, -1], [2, 1], [6, 2], [0, 4], [4, 4], [2, 5], [7, 5], [5, 6], [3, 7]]];\nJitterVectors.forEach(function (offsetList) {\n  offsetList.forEach(function (offset) {\n    // 0.0625 = 1 / 16\n    offset[0] *= 0.0625;\n    offset[1] *= 0.0625;\n  });\n});\n\nvar MultiSampleHelper =\n/** @class */\nfunction () {\n  function MultiSampleHelper(multiSamplePass) {\n    this.multiSamplePass = multiSamplePass;\n    this.sampleIndex = -2;\n  }\n\n  MultiSampleHelper.prototype.update = function (changed, props) {\n    if (changed) this.sampleIndex = -1;\n    return props.mode === 'temporal' ? this.sampleIndex !== -2 : false;\n  };\n\n  MultiSampleHelper.prototype.render = function (renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\n    this.sampleIndex = this.multiSamplePass.render(this.sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\n  };\n\n  return MultiSampleHelper;\n}();\n\nexport { MultiSampleHelper };","map":{"version":3,"sources":["../../../src/mol-canvas3d/passes/multi-sample.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { QuadSchema, QuadValues } from '../../mol-gl/compute/util';\r\nimport { TextureSpec, UniformSpec } from '../../mol-gl/renderable/schema';\r\nimport { ValueCell } from '../../mol-util';\r\nimport { Vec2 } from '../../mol-math/linear-algebra';\r\nimport { ShaderCode } from '../../mol-gl/shader-code';\r\nimport { createComputeRenderItem } from '../../mol-gl/webgl/render-item';\r\nimport { createComputeRenderable } from '../../mol-gl/renderable';\r\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\r\nimport { Camera } from '../../mol-canvas3d/camera';\r\nimport { quad_vert } from '../../mol-gl/shader/quad.vert';\r\nimport { compose_frag } from '../../mol-gl/shader/compose.frag';\r\nvar ComposeSchema = __assign(__assign({}, QuadSchema), { tColor: TextureSpec('texture', 'rgba', 'ubyte', 'nearest'), uTexSize: UniformSpec('v2'), uWeight: UniformSpec('f') });\r\nvar ComposeShaderCode = ShaderCode('compose', quad_vert, compose_frag);\r\nfunction getComposeRenderable(ctx, colorTexture) {\r\n    var values = __assign(__assign({}, QuadValues), { tColor: ValueCell.create(colorTexture), uTexSize: ValueCell.create(Vec2.create(colorTexture.getWidth(), colorTexture.getHeight())), uWeight: ValueCell.create(1.0) });\r\n    var schema = __assign({}, ComposeSchema);\r\n    var renderItem = createComputeRenderItem(ctx, 'triangles', ComposeShaderCode, schema, values);\r\n    return createComputeRenderable(renderItem, values);\r\n}\r\nexport var MultiSampleParams = {\r\n    mode: PD.Select('off', [['off', 'Off'], ['on', 'On'], ['temporal', 'Temporal']]),\r\n    sampleLevel: PD.Numeric(2, { min: 0, max: 5, step: 1 }),\r\n};\r\nvar MultiSamplePass = /** @class */ (function () {\r\n    function MultiSamplePass(webgl, drawPass) {\r\n        this.webgl = webgl;\r\n        this.drawPass = drawPass;\r\n        var _a = webgl.extensions, colorBufferFloat = _a.colorBufferFloat, textureFloat = _a.textureFloat, colorBufferHalfFloat = _a.colorBufferHalfFloat, textureHalfFloat = _a.textureHalfFloat;\r\n        var width = drawPass.colorTarget.getWidth();\r\n        var height = drawPass.colorTarget.getHeight();\r\n        this.colorTarget = webgl.createRenderTarget(width, height, false);\r\n        var type = colorBufferHalfFloat && textureHalfFloat ? 'fp16' :\r\n            colorBufferFloat && textureFloat ? 'float32' : 'uint8';\r\n        this.composeTarget = webgl.createRenderTarget(width, height, false, type);\r\n        this.holdTarget = webgl.createRenderTarget(width, height, false);\r\n        this.compose = getComposeRenderable(webgl, drawPass.colorTarget.texture);\r\n    }\r\n    MultiSamplePass.isEnabled = function (props) {\r\n        return props.mode !== 'off';\r\n    };\r\n    MultiSamplePass.prototype.syncSize = function () {\r\n        var width = this.drawPass.colorTarget.getWidth();\r\n        var height = this.drawPass.colorTarget.getHeight();\r\n        var _a = this.compose.values.uTexSize.ref.value, w = _a[0], h = _a[1];\r\n        if (width !== w || height !== h) {\r\n            this.colorTarget.setSize(width, height);\r\n            this.composeTarget.setSize(width, height);\r\n            this.holdTarget.setSize(width, height);\r\n            ValueCell.update(this.compose.values.uTexSize, Vec2.set(this.compose.values.uTexSize.ref.value, width, height));\r\n        }\r\n    };\r\n    MultiSamplePass.prototype.render = function (sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\r\n        if (props.multiSample.mode === 'temporal') {\r\n            return this.renderTemporalMultiSample(sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\r\n        }\r\n        else {\r\n            this.renderMultiSample(renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\r\n            return sampleIndex;\r\n        }\r\n    };\r\n    MultiSamplePass.prototype.bindOutputTarget = function (toDrawingBuffer) {\r\n        if (toDrawingBuffer) {\r\n            this.webgl.unbindFramebuffer();\r\n        }\r\n        else {\r\n            this.colorTarget.bind();\r\n        }\r\n    };\r\n    MultiSamplePass.prototype.renderMultiSample = function (renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\r\n        var _a = this, compose = _a.compose, composeTarget = _a.composeTarget, drawPass = _a.drawPass, webgl = _a.webgl;\r\n        var gl = webgl.gl, state = webgl.state;\r\n        // based on the Multisample Anti-Aliasing Render Pass\r\n        // contributed to three.js by bhouston / http://clara.io/\r\n        //\r\n        // This manual approach to MSAA re-renders the scene once for\r\n        // each sample with camera jitter and accumulates the results.\r\n        var offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];\r\n        var _b = camera.viewport, x = _b.x, y = _b.y, width = _b.width, height = _b.height;\r\n        var baseSampleWeight = 1.0 / offsetList.length;\r\n        var roundingRange = 1 / 32;\r\n        camera.viewOffset.enabled = true;\r\n        ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\r\n        compose.update();\r\n        // render the scene multiple times, each slightly jitter offset\r\n        // from the last and accumulate the results.\r\n        for (var i = 0; i < offsetList.length; ++i) {\r\n            var offset = offsetList[i];\r\n            Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);\r\n            camera.update();\r\n            // the theory is that equal weights for each sample lead to an accumulation of rounding\r\n            // errors. The following equation varies the sampleWeight per sample so that it is uniformly\r\n            // distributed across a range of values whose rounding errors cancel each other out.\r\n            var uniformCenteredDistribution = -0.5 + (i + 0.5) / offsetList.length;\r\n            var sampleWeight = baseSampleWeight + roundingRange * uniformCenteredDistribution;\r\n            ValueCell.update(compose.values.uWeight, sampleWeight);\r\n            // render scene\r\n            drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking);\r\n            // compose rendered scene with compose target\r\n            composeTarget.bind();\r\n            state.enable(gl.BLEND);\r\n            state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n            state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\r\n            state.disable(gl.DEPTH_TEST);\r\n            state.depthMask(false);\r\n            gl.viewport(x, y, width, height);\r\n            gl.scissor(x, y, width, height);\r\n            if (i === 0) {\r\n                state.clearColor(0, 0, 0, 0);\r\n                gl.clear(gl.COLOR_BUFFER_BIT);\r\n            }\r\n            compose.render();\r\n        }\r\n        ValueCell.update(compose.values.uWeight, 1.0);\r\n        ValueCell.update(compose.values.tColor, composeTarget.texture);\r\n        compose.update();\r\n        this.bindOutputTarget(toDrawingBuffer);\r\n        gl.viewport(x, y, width, height);\r\n        gl.scissor(x, y, width, height);\r\n        state.disable(gl.BLEND);\r\n        compose.render();\r\n        camera.viewOffset.enabled = false;\r\n        camera.update();\r\n    };\r\n    MultiSamplePass.prototype.renderTemporalMultiSample = function (sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\r\n        var _a = this, compose = _a.compose, composeTarget = _a.composeTarget, holdTarget = _a.holdTarget, drawPass = _a.drawPass, webgl = _a.webgl;\r\n        var gl = webgl.gl, state = webgl.state;\r\n        // based on the Multisample Anti-Aliasing Render Pass\r\n        // contributed to three.js by bhouston / http://clara.io/\r\n        //\r\n        // This manual approach to MSAA re-renders the scene once for\r\n        // each sample with camera jitter and accumulates the results.\r\n        var offsetList = JitterVectors[Math.max(0, Math.min(props.multiSample.sampleLevel, 5))];\r\n        if (sampleIndex === -2 || sampleIndex >= offsetList.length)\r\n            return -2;\r\n        var _b = camera.viewport, x = _b.x, y = _b.y, width = _b.width, height = _b.height;\r\n        var sampleWeight = 1.0 / offsetList.length;\r\n        if (sampleIndex === -1) {\r\n            drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking);\r\n            ValueCell.update(compose.values.uWeight, 1.0);\r\n            ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\r\n            compose.update();\r\n            holdTarget.bind();\r\n            state.disable(gl.BLEND);\r\n            state.disable(gl.DEPTH_TEST);\r\n            state.depthMask(false);\r\n            gl.viewport(x, y, width, height);\r\n            gl.scissor(x, y, width, height);\r\n            compose.render();\r\n            sampleIndex += 1;\r\n        }\r\n        else {\r\n            camera.viewOffset.enabled = true;\r\n            ValueCell.update(compose.values.tColor, drawPass.getColorTarget(props.postprocessing).texture);\r\n            ValueCell.update(compose.values.uWeight, sampleWeight);\r\n            compose.update();\r\n            // render the scene multiple times, each slightly jitter offset\r\n            // from the last and accumulate the results.\r\n            var numSamplesPerFrame = Math.pow(2, Math.max(0, props.multiSample.sampleLevel - 2));\r\n            for (var i = 0; i < numSamplesPerFrame; ++i) {\r\n                var offset = offsetList[sampleIndex];\r\n                Camera.setViewOffset(camera.viewOffset, width, height, offset[0], offset[1], width, height);\r\n                camera.update();\r\n                // render scene\r\n                drawPass.render(renderer, camera, scene, helper, false, transparentBackground, props.postprocessing, props.marking);\r\n                // compose rendered scene with compose target\r\n                composeTarget.bind();\r\n                state.enable(gl.BLEND);\r\n                state.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);\r\n                state.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);\r\n                state.disable(gl.DEPTH_TEST);\r\n                state.depthMask(false);\r\n                gl.viewport(x, y, width, height);\r\n                gl.scissor(x, y, width, height);\r\n                if (sampleIndex === 0) {\r\n                    state.clearColor(0, 0, 0, 0);\r\n                    gl.clear(gl.COLOR_BUFFER_BIT);\r\n                }\r\n                compose.render();\r\n                sampleIndex += 1;\r\n                if (sampleIndex >= offsetList.length)\r\n                    break;\r\n            }\r\n        }\r\n        this.bindOutputTarget(toDrawingBuffer);\r\n        gl.viewport(x, y, width, height);\r\n        gl.scissor(x, y, width, height);\r\n        var accumulationWeight = sampleIndex * sampleWeight;\r\n        if (accumulationWeight > 0) {\r\n            ValueCell.update(compose.values.uWeight, 1.0);\r\n            ValueCell.update(compose.values.tColor, composeTarget.texture);\r\n            compose.update();\r\n            state.disable(gl.BLEND);\r\n            compose.render();\r\n        }\r\n        if (accumulationWeight < 1.0) {\r\n            ValueCell.update(compose.values.uWeight, 1.0 - accumulationWeight);\r\n            ValueCell.update(compose.values.tColor, holdTarget.texture);\r\n            compose.update();\r\n            if (accumulationWeight === 0)\r\n                state.disable(gl.BLEND);\r\n            else\r\n                state.enable(gl.BLEND);\r\n            compose.render();\r\n        }\r\n        camera.viewOffset.enabled = false;\r\n        camera.update();\r\n        return sampleIndex >= offsetList.length ? -2 : sampleIndex;\r\n    };\r\n    return MultiSamplePass;\r\n}());\r\nexport { MultiSamplePass };\r\nvar JitterVectors = [\r\n    [\r\n        [0, 0]\r\n    ],\r\n    [\r\n        [4, 4], [-4, -4]\r\n    ],\r\n    [\r\n        [-2, -6], [6, -2], [-6, 2], [2, 6]\r\n    ],\r\n    [\r\n        [1, -3], [-1, 3], [5, 1], [-3, -5],\r\n        [-5, 5], [-7, -1], [3, 7], [7, -7]\r\n    ],\r\n    [\r\n        [1, 1], [-1, -3], [-3, 2], [4, -1],\r\n        [-5, -2], [2, 5], [5, 3], [3, -5],\r\n        [-2, 6], [0, -7], [-4, -6], [-6, 4],\r\n        [-8, 0], [7, -4], [6, 7], [-7, -8]\r\n    ],\r\n    [\r\n        [-4, -7], [-7, -5], [-3, -5], [-5, -4],\r\n        [-1, -4], [-2, -2], [-6, -1], [-4, 0],\r\n        [-7, 1], [-1, 2], [-6, 3], [-3, 3],\r\n        [-7, 6], [-3, 6], [-5, 7], [-1, 7],\r\n        [5, -7], [1, -6], [6, -5], [4, -4],\r\n        [2, -3], [7, -2], [1, -1], [4, -1],\r\n        [2, 1], [6, 2], [0, 4], [4, 4],\r\n        [2, 5], [7, 5], [5, 6], [3, 7]\r\n    ]\r\n];\r\nJitterVectors.forEach(function (offsetList) {\r\n    offsetList.forEach(function (offset) {\r\n        // 0.0625 = 1 / 16\r\n        offset[0] *= 0.0625;\r\n        offset[1] *= 0.0625;\r\n    });\r\n});\r\nvar MultiSampleHelper = /** @class */ (function () {\r\n    function MultiSampleHelper(multiSamplePass) {\r\n        this.multiSamplePass = multiSamplePass;\r\n        this.sampleIndex = -2;\r\n    }\r\n    MultiSampleHelper.prototype.update = function (changed, props) {\r\n        if (changed)\r\n            this.sampleIndex = -1;\r\n        return props.mode === 'temporal' ? this.sampleIndex !== -2 : false;\r\n    };\r\n    MultiSampleHelper.prototype.render = function (renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props) {\r\n        this.sampleIndex = this.multiSamplePass.render(this.sampleIndex, renderer, camera, scene, helper, toDrawingBuffer, transparentBackground, props);\r\n    };\r\n    return MultiSampleHelper;\r\n}());\r\nexport { MultiSampleHelper };\r\n//# sourceMappingURL=multi-sample.js.map"]},"metadata":{},"sourceType":"module"}