{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { Unit, StructureElement } from '../../../../mol-model/structure';\nimport { Mat4, Vec3 } from '../../../../mol-math/linear-algebra';\nimport { createTransform } from '../../../../mol-geo/geometry/transform-data';\nimport { OrderedSet, SortedArray } from '../../../../mol-data/int';\nimport { EmptyLoci } from '../../../../mol-model/loci';\nimport { PhysicalSizeTheme } from '../../../../mol-theme/size/physical';\nimport { AtomicNumbers } from '../../../../mol-model/structure/model/properties/atomic';\nimport { fillSerial } from '../../../../mol-util/array';\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\nimport { getBoundary } from '../../../../mol-math/geometry/boundary';\nimport { Box3D } from '../../../../mol-math/geometry';\n/** Return a Loci for the elements of a whole residue the elementIndex belongs to. */\n\nexport function getResidueLoci(structure, unit, elementIndex) {\n  var elements = unit.elements,\n      model = unit.model;\n\n  if (OrderedSet.indexOf(elements, elementIndex) !== -1) {\n    var _a = model.atomicHierarchy.residueAtomSegments,\n        index = _a.index,\n        offsets = _a.offsets;\n    var rI = index[elementIndex];\n    var _indices = [];\n\n    for (var i = offsets[rI], il = offsets[rI + 1]; i < il; ++i) {\n      var unitIndex = OrderedSet.indexOf(elements, i);\n      if (unitIndex !== -1) _indices.push(unitIndex);\n    }\n\n    var indices = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));\n    return StructureElement.Loci(structure, [{\n      unit: unit,\n      indices: indices\n    }]);\n  }\n\n  return EmptyLoci;\n}\n/**\r\n * Return a Loci for the elements of a whole residue the elementIndex belongs to but\r\n * restrict to elements that have the same label_alt_id or none\r\n */\n\nexport function getAltResidueLoci(structure, unit, elementIndex) {\n  var elements = unit.elements,\n      model = unit.model;\n  var label_alt_id = model.atomicHierarchy.atoms.label_alt_id;\n  var elementAltId = label_alt_id.value(elementIndex);\n\n  if (OrderedSet.indexOf(elements, elementIndex) !== -1) {\n    var index = model.atomicHierarchy.residueAtomSegments.index;\n    var rI = index[elementIndex];\n    return getAltResidueLociFromId(structure, unit, rI, elementAltId);\n  }\n\n  return StructureElement.Loci(structure, []);\n}\nexport function getAltResidueLociFromId(structure, unit, residueIndex, elementAltId) {\n  var elements = unit.elements,\n      model = unit.model;\n  var label_alt_id = model.atomicHierarchy.atoms.label_alt_id;\n  var offsets = model.atomicHierarchy.residueAtomSegments.offsets;\n  var _indices = [];\n\n  for (var i = offsets[residueIndex], il = offsets[residueIndex + 1]; i < il; ++i) {\n    var unitIndex = OrderedSet.indexOf(elements, i);\n\n    if (unitIndex !== -1) {\n      var altId = label_alt_id.value(i);\n\n      if (elementAltId === altId || altId === '') {\n        _indices.push(unitIndex);\n      }\n    }\n  }\n\n  var indices = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));\n  return StructureElement.Loci(structure, [{\n    unit: unit,\n    indices: indices\n  }]);\n}\nexport function createUnitsTransform(structureGroup, includeParent, transformData) {\n  var child = structureGroup.structure.child;\n  var units = includeParent && child ? structureGroup.group.units.filter(function (u) {\n    return child.unitMap.has(u.id);\n  }) : structureGroup.group.units;\n  var unitCount = units.length;\n  var n = unitCount * 16;\n  var array = transformData && transformData.aTransform.ref.value.length >= n ? transformData.aTransform.ref.value : new Float32Array(n);\n\n  for (var i = 0; i < unitCount; i++) {\n    Mat4.toArray(units[i].conformation.operator.matrix, array, i * 16);\n  }\n\n  return createTransform(array, unitCount, transformData);\n}\nexport var UnitKindInfo = {\n  'atomic': {},\n  'spheres': {},\n  'gaussians': {}\n};\nexport var UnitKindOptions = PD.objectToOptions(UnitKindInfo);\nexport function includesUnitKind(unitKinds, unit) {\n  for (var i = 0, il = unitKinds.length; i < il; ++i) {\n    if (Unit.isAtomic(unit) && unitKinds[i] === 'atomic') return true;\n    if (Unit.isSpheres(unit) && unitKinds[i] === 'spheres') return true;\n    if (Unit.isGaussians(unit) && unitKinds[i] === 'gaussians') return true;\n  }\n\n  return false;\n} //\n\nvar DefaultMaxCells = 500000000;\nexport function getVolumeSliceInfo(box, resolution, maxCells) {\n  if (maxCells === void 0) {\n    maxCells = DefaultMaxCells;\n  }\n\n  var size = Box3D.size(Vec3(), box);\n  Vec3.ceil(size, size);\n  size.sort(function (a, b) {\n    return b - a;\n  }); // descending\n\n  var maxAreaCells = Math.floor(Math.cbrt(maxCells) * Math.cbrt(maxCells));\n  var area = size[0] * size[1];\n  var areaCells = Math.ceil(area / (resolution * resolution));\n  return {\n    area: area,\n    areaCells: areaCells,\n    maxAreaCells: maxAreaCells\n  };\n}\n/**\r\n * Guard against overly high resolution for the given box size.\r\n * Internally it uses the largest 2d slice of the box to determine the\r\n * maximum resolution to account for the 2d texture layout on the GPU.\r\n */\n\nexport function ensureReasonableResolution(box, props, maxCells) {\n  if (maxCells === void 0) {\n    maxCells = DefaultMaxCells;\n  }\n\n  var _a = getVolumeSliceInfo(box, props.resolution, maxCells),\n      area = _a.area,\n      areaCells = _a.areaCells,\n      maxAreaCells = _a.maxAreaCells;\n\n  var resolution = areaCells > maxAreaCells ? Math.sqrt(area / maxAreaCells) : props.resolution;\n  return __assign(__assign({}, props), {\n    resolution: resolution\n  });\n}\nexport function getConformation(unit) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return unit.model.atomicConformation;\n\n    case 1\n    /* Spheres */\n    :\n      return unit.model.coarseConformation.spheres;\n\n    case 2\n    /* Gaussians */\n    :\n      return unit.model.coarseConformation.gaussians;\n  }\n}\nexport var CommonSurfaceParams = {\n  ignoreHydrogens: PD.Boolean(false, {\n    description: 'Whether or not to include hydrogen atoms in the surface calculation.'\n  }),\n  traceOnly: PD.Boolean(false, {\n    description: 'Whether or not to only use trace atoms in the surface calculation.'\n  }),\n  includeParent: PD.Boolean(false, {\n    description: 'Include elements of the parent structure in surface calculation to get a surface patch of the current structure.'\n  })\n};\nexport var DefaultCommonSurfaceProps = PD.getDefaultValues(CommonSurfaceParams);\nvar v = Vec3();\n\nfunction squaredDistance(x, y, z, center) {\n  return Vec3.squaredDistance(Vec3.set(v, x, y, z), center);\n}\n/** marks `indices` for filtering/ignoring in `id` when not in `elements` */\n\n\nfunction filterId(id, elements, indices) {\n  var start = 0;\n  var end = elements.length;\n\n  for (var i = 0, il = indices.length; i < il; ++i) {\n    var idx = SortedArray.indexOfInRange(elements, indices[i], start, end);\n\n    if (idx === -1) {\n      id[i] = -2;\n    } else {\n      id[i] = idx;\n      start = idx;\n    }\n  }\n}\n\nexport function getUnitConformationAndRadius(structure, unit, props) {\n  var ignoreHydrogens = props.ignoreHydrogens,\n      traceOnly = props.traceOnly,\n      includeParent = props.includeParent;\n  var rootUnit = includeParent ? structure.root.unitMap.get(unit.id) : unit;\n\n  var _a = getConformation(rootUnit),\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n\n  var elements = rootUnit.elements;\n  var _b = unit.boundary.sphere,\n      center = _b.center,\n      sphereRadius = _b.radius;\n  var extraRadius = (2 + 1.5) * 2; // TODO should be twice (the max vdW/sphere radius plus the probe radius)\n\n  var radiusSq = (sphereRadius + extraRadius) * (sphereRadius + extraRadius);\n  var indices;\n  var id;\n\n  if (ignoreHydrogens || traceOnly || includeParent && rootUnit !== unit) {\n    var _indices = [];\n    var _id = [];\n\n    for (var i = 0, il = elements.length; i < il; ++i) {\n      var eI = elements[i];\n      if (ignoreHydrogens && isHydrogen(rootUnit, eI)) continue;\n      if (traceOnly && !isTrace(rootUnit, eI)) continue;\n      if (includeParent && squaredDistance(x[eI], y[eI], z[eI], center) > radiusSq) continue;\n\n      _indices.push(eI);\n\n      _id.push(i);\n    }\n\n    indices = SortedArray.ofSortedArray(_indices);\n    id = _id;\n  } else {\n    indices = elements;\n    id = fillSerial(new Int32Array(indices.length));\n  }\n\n  if (includeParent && rootUnit !== unit) {\n    filterId(id, unit.elements, indices);\n  }\n\n  var position = {\n    indices: indices,\n    x: x,\n    y: y,\n    z: z,\n    id: id\n  };\n  var boundary = unit === rootUnit ? unit.boundary : getBoundary(position);\n  var l = StructureElement.Location.create(structure, rootUnit);\n  var sizeTheme = PhysicalSizeTheme({}, {\n    scale: 1\n  });\n\n  var radius = function (index) {\n    l.element = index;\n    return sizeTheme.size(l);\n  };\n\n  return {\n    position: position,\n    boundary: boundary,\n    radius: radius\n  };\n}\nexport function getStructureConformationAndRadius(structure, ignoreHydrogens, traceOnly) {\n  var l = StructureElement.Location.create(structure);\n  var sizeTheme = PhysicalSizeTheme({}, {\n    scale: 1\n  });\n  var xs;\n  var ys;\n  var zs;\n  var rs;\n  var id;\n\n  if (ignoreHydrogens || traceOnly) {\n    var _xs = [];\n    var _ys = [];\n    var _zs = [];\n    var _rs = [];\n    var _id = [];\n\n    for (var i = 0, m = 0, il = structure.units.length; i < il; ++i) {\n      var unit = structure.units[i];\n      var elements = unit.elements;\n      var _a = unit.conformation,\n          x = _a.x,\n          y = _a.y,\n          z = _a.z;\n      l.unit = unit;\n\n      for (var j = 0, jl = elements.length; j < jl; ++j) {\n        var eI = elements[j];\n        if (ignoreHydrogens && isHydrogen(unit, eI)) continue;\n        if (traceOnly && !isTrace(unit, eI)) continue;\n\n        _xs.push(x(eI));\n\n        _ys.push(y(eI));\n\n        _zs.push(z(eI));\n\n        l.element = eI;\n\n        _rs.push(sizeTheme.size(l));\n\n        _id.push(m + j);\n      }\n\n      m += elements.length;\n    }\n\n    xs = _xs, ys = _ys, zs = _zs, rs = _rs;\n    id = _id;\n  } else {\n    var elementCount = structure.elementCount;\n\n    var _xs = new Float32Array(elementCount);\n\n    var _ys = new Float32Array(elementCount);\n\n    var _zs = new Float32Array(elementCount);\n\n    var _rs = new Float32Array(elementCount);\n\n    for (var i = 0, m = 0, il = structure.units.length; i < il; ++i) {\n      var unit = structure.units[i];\n      var elements = unit.elements;\n      var _b = unit.conformation,\n          x = _b.x,\n          y = _b.y,\n          z = _b.z;\n      l.unit = unit;\n\n      for (var j = 0, jl = elements.length; j < jl; ++j) {\n        var eI = elements[j];\n        var mj = m + j;\n        _xs[mj] = x(eI);\n        _ys[mj] = y(eI);\n        _zs[mj] = z(eI);\n        l.element = eI;\n        _rs[mj] = sizeTheme.size(l);\n      }\n\n      m += elements.length;\n    }\n\n    xs = _xs, ys = _ys, zs = _zs, rs = _rs;\n    id = fillSerial(new Uint32Array(elementCount));\n  }\n\n  var position = {\n    indices: OrderedSet.ofRange(0, id.length),\n    x: xs,\n    y: ys,\n    z: zs,\n    id: id\n  };\n\n  var radius = function (index) {\n    return rs[index];\n  };\n\n  return {\n    position: position,\n    radius: radius\n  };\n}\nvar _H = AtomicNumbers['H'];\nexport function isHydrogen(unit, element) {\n  if (Unit.isCoarse(unit)) return false;\n  return unit.model.atomicHierarchy.derived.atom.atomicNumber[element] === _H;\n}\nexport function isH(atomicNumber, element) {\n  return atomicNumber[element] === _H;\n}\nexport function isTrace(unit, element) {\n  if (Unit.isCoarse(unit)) return true;\n  var atomId = unit.model.atomicHierarchy.atoms.label_atom_id.value(element);\n  if (atomId === 'CA' || atomId === 'BB' || atomId === 'P') return true;\n  return false;\n}\nexport function getUnitExtraRadius(unit) {\n  if (Unit.isAtomic(unit)) return 4;\n  var max = 0;\n  var elements = unit.elements;\n  var r = unit.conformation.r;\n\n  for (var i = 0, _i = elements.length; i < _i; i++) {\n    var _r = r(elements[i]);\n\n    if (_r > max) max = _r;\n  }\n\n  return max + 1;\n}\nexport function getStructureExtraRadius(structure) {\n  var max = 0;\n\n  for (var _a = 0, _b = structure.unitSymmetryGroups; _a < _b.length; _a++) {\n    var ug = _b[_a];\n    var r = getUnitExtraRadius(ug.units[0]);\n    if (r > max) max = r;\n  }\n\n  return max;\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/common.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { Unit, StructureElement } from '../../../../mol-model/structure';\r\nimport { Mat4, Vec3 } from '../../../../mol-math/linear-algebra';\r\nimport { createTransform } from '../../../../mol-geo/geometry/transform-data';\r\nimport { OrderedSet, SortedArray } from '../../../../mol-data/int';\r\nimport { EmptyLoci } from '../../../../mol-model/loci';\r\nimport { PhysicalSizeTheme } from '../../../../mol-theme/size/physical';\r\nimport { AtomicNumbers } from '../../../../mol-model/structure/model/properties/atomic';\r\nimport { fillSerial } from '../../../../mol-util/array';\r\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\r\nimport { getBoundary } from '../../../../mol-math/geometry/boundary';\r\nimport { Box3D } from '../../../../mol-math/geometry';\r\n/** Return a Loci for the elements of a whole residue the elementIndex belongs to. */\r\nexport function getResidueLoci(structure, unit, elementIndex) {\r\n    var elements = unit.elements, model = unit.model;\r\n    if (OrderedSet.indexOf(elements, elementIndex) !== -1) {\r\n        var _a = model.atomicHierarchy.residueAtomSegments, index = _a.index, offsets = _a.offsets;\r\n        var rI = index[elementIndex];\r\n        var _indices = [];\r\n        for (var i = offsets[rI], il = offsets[rI + 1]; i < il; ++i) {\r\n            var unitIndex = OrderedSet.indexOf(elements, i);\r\n            if (unitIndex !== -1)\r\n                _indices.push(unitIndex);\r\n        }\r\n        var indices = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));\r\n        return StructureElement.Loci(structure, [{ unit: unit, indices: indices }]);\r\n    }\r\n    return EmptyLoci;\r\n}\r\n/**\r\n * Return a Loci for the elements of a whole residue the elementIndex belongs to but\r\n * restrict to elements that have the same label_alt_id or none\r\n */\r\nexport function getAltResidueLoci(structure, unit, elementIndex) {\r\n    var elements = unit.elements, model = unit.model;\r\n    var label_alt_id = model.atomicHierarchy.atoms.label_alt_id;\r\n    var elementAltId = label_alt_id.value(elementIndex);\r\n    if (OrderedSet.indexOf(elements, elementIndex) !== -1) {\r\n        var index = model.atomicHierarchy.residueAtomSegments.index;\r\n        var rI = index[elementIndex];\r\n        return getAltResidueLociFromId(structure, unit, rI, elementAltId);\r\n    }\r\n    return StructureElement.Loci(structure, []);\r\n}\r\nexport function getAltResidueLociFromId(structure, unit, residueIndex, elementAltId) {\r\n    var elements = unit.elements, model = unit.model;\r\n    var label_alt_id = model.atomicHierarchy.atoms.label_alt_id;\r\n    var offsets = model.atomicHierarchy.residueAtomSegments.offsets;\r\n    var _indices = [];\r\n    for (var i = offsets[residueIndex], il = offsets[residueIndex + 1]; i < il; ++i) {\r\n        var unitIndex = OrderedSet.indexOf(elements, i);\r\n        if (unitIndex !== -1) {\r\n            var altId = label_alt_id.value(i);\r\n            if (elementAltId === altId || altId === '') {\r\n                _indices.push(unitIndex);\r\n            }\r\n        }\r\n    }\r\n    var indices = OrderedSet.ofSortedArray(SortedArray.ofSortedArray(_indices));\r\n    return StructureElement.Loci(structure, [{ unit: unit, indices: indices }]);\r\n}\r\nexport function createUnitsTransform(structureGroup, includeParent, transformData) {\r\n    var child = structureGroup.structure.child;\r\n    var units = includeParent && child\r\n        ? structureGroup.group.units.filter(function (u) { return child.unitMap.has(u.id); })\r\n        : structureGroup.group.units;\r\n    var unitCount = units.length;\r\n    var n = unitCount * 16;\r\n    var array = transformData && transformData.aTransform.ref.value.length >= n ? transformData.aTransform.ref.value : new Float32Array(n);\r\n    for (var i = 0; i < unitCount; i++) {\r\n        Mat4.toArray(units[i].conformation.operator.matrix, array, i * 16);\r\n    }\r\n    return createTransform(array, unitCount, transformData);\r\n}\r\nexport var UnitKindInfo = {\r\n    'atomic': {},\r\n    'spheres': {},\r\n    'gaussians': {},\r\n};\r\nexport var UnitKindOptions = PD.objectToOptions(UnitKindInfo);\r\nexport function includesUnitKind(unitKinds, unit) {\r\n    for (var i = 0, il = unitKinds.length; i < il; ++i) {\r\n        if (Unit.isAtomic(unit) && unitKinds[i] === 'atomic')\r\n            return true;\r\n        if (Unit.isSpheres(unit) && unitKinds[i] === 'spheres')\r\n            return true;\r\n        if (Unit.isGaussians(unit) && unitKinds[i] === 'gaussians')\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n//\r\nvar DefaultMaxCells = 500000000;\r\nexport function getVolumeSliceInfo(box, resolution, maxCells) {\r\n    if (maxCells === void 0) { maxCells = DefaultMaxCells; }\r\n    var size = Box3D.size(Vec3(), box);\r\n    Vec3.ceil(size, size);\r\n    size.sort(function (a, b) { return b - a; }); // descending\r\n    var maxAreaCells = Math.floor(Math.cbrt(maxCells) * Math.cbrt(maxCells));\r\n    var area = size[0] * size[1];\r\n    var areaCells = Math.ceil(area / (resolution * resolution));\r\n    return { area: area, areaCells: areaCells, maxAreaCells: maxAreaCells };\r\n}\r\n/**\r\n * Guard against overly high resolution for the given box size.\r\n * Internally it uses the largest 2d slice of the box to determine the\r\n * maximum resolution to account for the 2d texture layout on the GPU.\r\n */\r\nexport function ensureReasonableResolution(box, props, maxCells) {\r\n    if (maxCells === void 0) { maxCells = DefaultMaxCells; }\r\n    var _a = getVolumeSliceInfo(box, props.resolution, maxCells), area = _a.area, areaCells = _a.areaCells, maxAreaCells = _a.maxAreaCells;\r\n    var resolution = areaCells > maxAreaCells ? Math.sqrt(area / maxAreaCells) : props.resolution;\r\n    return __assign(__assign({}, props), { resolution: resolution });\r\n}\r\nexport function getConformation(unit) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return unit.model.atomicConformation;\r\n        case 1 /* Spheres */: return unit.model.coarseConformation.spheres;\r\n        case 2 /* Gaussians */: return unit.model.coarseConformation.gaussians;\r\n    }\r\n}\r\nexport var CommonSurfaceParams = {\r\n    ignoreHydrogens: PD.Boolean(false, { description: 'Whether or not to include hydrogen atoms in the surface calculation.' }),\r\n    traceOnly: PD.Boolean(false, { description: 'Whether or not to only use trace atoms in the surface calculation.' }),\r\n    includeParent: PD.Boolean(false, { description: 'Include elements of the parent structure in surface calculation to get a surface patch of the current structure.' }),\r\n};\r\nexport var DefaultCommonSurfaceProps = PD.getDefaultValues(CommonSurfaceParams);\r\nvar v = Vec3();\r\nfunction squaredDistance(x, y, z, center) {\r\n    return Vec3.squaredDistance(Vec3.set(v, x, y, z), center);\r\n}\r\n/** marks `indices` for filtering/ignoring in `id` when not in `elements` */\r\nfunction filterId(id, elements, indices) {\r\n    var start = 0;\r\n    var end = elements.length;\r\n    for (var i = 0, il = indices.length; i < il; ++i) {\r\n        var idx = SortedArray.indexOfInRange(elements, indices[i], start, end);\r\n        if (idx === -1) {\r\n            id[i] = -2;\r\n        }\r\n        else {\r\n            id[i] = idx;\r\n            start = idx;\r\n        }\r\n    }\r\n}\r\nexport function getUnitConformationAndRadius(structure, unit, props) {\r\n    var ignoreHydrogens = props.ignoreHydrogens, traceOnly = props.traceOnly, includeParent = props.includeParent;\r\n    var rootUnit = includeParent ? structure.root.unitMap.get(unit.id) : unit;\r\n    var _a = getConformation(rootUnit), x = _a.x, y = _a.y, z = _a.z;\r\n    var elements = rootUnit.elements;\r\n    var _b = unit.boundary.sphere, center = _b.center, sphereRadius = _b.radius;\r\n    var extraRadius = (2 + 1.5) * 2; // TODO should be twice (the max vdW/sphere radius plus the probe radius)\r\n    var radiusSq = (sphereRadius + extraRadius) * (sphereRadius + extraRadius);\r\n    var indices;\r\n    var id;\r\n    if (ignoreHydrogens || traceOnly || (includeParent && rootUnit !== unit)) {\r\n        var _indices = [];\r\n        var _id = [];\r\n        for (var i = 0, il = elements.length; i < il; ++i) {\r\n            var eI = elements[i];\r\n            if (ignoreHydrogens && isHydrogen(rootUnit, eI))\r\n                continue;\r\n            if (traceOnly && !isTrace(rootUnit, eI))\r\n                continue;\r\n            if (includeParent && squaredDistance(x[eI], y[eI], z[eI], center) > radiusSq)\r\n                continue;\r\n            _indices.push(eI);\r\n            _id.push(i);\r\n        }\r\n        indices = SortedArray.ofSortedArray(_indices);\r\n        id = _id;\r\n    }\r\n    else {\r\n        indices = elements;\r\n        id = fillSerial(new Int32Array(indices.length));\r\n    }\r\n    if (includeParent && rootUnit !== unit) {\r\n        filterId(id, unit.elements, indices);\r\n    }\r\n    var position = { indices: indices, x: x, y: y, z: z, id: id };\r\n    var boundary = unit === rootUnit ? unit.boundary : getBoundary(position);\r\n    var l = StructureElement.Location.create(structure, rootUnit);\r\n    var sizeTheme = PhysicalSizeTheme({}, { scale: 1 });\r\n    var radius = function (index) {\r\n        l.element = index;\r\n        return sizeTheme.size(l);\r\n    };\r\n    return { position: position, boundary: boundary, radius: radius };\r\n}\r\nexport function getStructureConformationAndRadius(structure, ignoreHydrogens, traceOnly) {\r\n    var l = StructureElement.Location.create(structure);\r\n    var sizeTheme = PhysicalSizeTheme({}, { scale: 1 });\r\n    var xs;\r\n    var ys;\r\n    var zs;\r\n    var rs;\r\n    var id;\r\n    if (ignoreHydrogens || traceOnly) {\r\n        var _xs = [];\r\n        var _ys = [];\r\n        var _zs = [];\r\n        var _rs = [];\r\n        var _id = [];\r\n        for (var i = 0, m = 0, il = structure.units.length; i < il; ++i) {\r\n            var unit = structure.units[i];\r\n            var elements = unit.elements;\r\n            var _a = unit.conformation, x = _a.x, y = _a.y, z = _a.z;\r\n            l.unit = unit;\r\n            for (var j = 0, jl = elements.length; j < jl; ++j) {\r\n                var eI = elements[j];\r\n                if (ignoreHydrogens && isHydrogen(unit, eI))\r\n                    continue;\r\n                if (traceOnly && !isTrace(unit, eI))\r\n                    continue;\r\n                _xs.push(x(eI));\r\n                _ys.push(y(eI));\r\n                _zs.push(z(eI));\r\n                l.element = eI;\r\n                _rs.push(sizeTheme.size(l));\r\n                _id.push(m + j);\r\n            }\r\n            m += elements.length;\r\n        }\r\n        xs = _xs, ys = _ys, zs = _zs, rs = _rs;\r\n        id = _id;\r\n    }\r\n    else {\r\n        var elementCount = structure.elementCount;\r\n        var _xs = new Float32Array(elementCount);\r\n        var _ys = new Float32Array(elementCount);\r\n        var _zs = new Float32Array(elementCount);\r\n        var _rs = new Float32Array(elementCount);\r\n        for (var i = 0, m = 0, il = structure.units.length; i < il; ++i) {\r\n            var unit = structure.units[i];\r\n            var elements = unit.elements;\r\n            var _b = unit.conformation, x = _b.x, y = _b.y, z = _b.z;\r\n            l.unit = unit;\r\n            for (var j = 0, jl = elements.length; j < jl; ++j) {\r\n                var eI = elements[j];\r\n                var mj = m + j;\r\n                _xs[mj] = x(eI);\r\n                _ys[mj] = y(eI);\r\n                _zs[mj] = z(eI);\r\n                l.element = eI;\r\n                _rs[mj] = sizeTheme.size(l);\r\n            }\r\n            m += elements.length;\r\n        }\r\n        xs = _xs, ys = _ys, zs = _zs, rs = _rs;\r\n        id = fillSerial(new Uint32Array(elementCount));\r\n    }\r\n    var position = { indices: OrderedSet.ofRange(0, id.length), x: xs, y: ys, z: zs, id: id };\r\n    var radius = function (index) { return rs[index]; };\r\n    return { position: position, radius: radius };\r\n}\r\nvar _H = AtomicNumbers['H'];\r\nexport function isHydrogen(unit, element) {\r\n    if (Unit.isCoarse(unit))\r\n        return false;\r\n    return unit.model.atomicHierarchy.derived.atom.atomicNumber[element] === _H;\r\n}\r\nexport function isH(atomicNumber, element) {\r\n    return atomicNumber[element] === _H;\r\n}\r\nexport function isTrace(unit, element) {\r\n    if (Unit.isCoarse(unit))\r\n        return true;\r\n    var atomId = unit.model.atomicHierarchy.atoms.label_atom_id.value(element);\r\n    if (atomId === 'CA' || atomId === 'BB' || atomId === 'P')\r\n        return true;\r\n    return false;\r\n}\r\nexport function getUnitExtraRadius(unit) {\r\n    if (Unit.isAtomic(unit))\r\n        return 4;\r\n    var max = 0;\r\n    var elements = unit.elements;\r\n    var r = unit.conformation.r;\r\n    for (var i = 0, _i = elements.length; i < _i; i++) {\r\n        var _r = r(elements[i]);\r\n        if (_r > max)\r\n            max = _r;\r\n    }\r\n    return max + 1;\r\n}\r\nexport function getStructureExtraRadius(structure) {\r\n    var max = 0;\r\n    for (var _a = 0, _b = structure.unitSymmetryGroups; _a < _b.length; _a++) {\r\n        var ug = _b[_a];\r\n        var r = getUnitExtraRadius(ug.units[0]);\r\n        if (r > max)\r\n            max = r;\r\n    }\r\n    return max;\r\n}\r\n//# sourceMappingURL=common.js.map"]},"metadata":{},"sourceType":"module"}