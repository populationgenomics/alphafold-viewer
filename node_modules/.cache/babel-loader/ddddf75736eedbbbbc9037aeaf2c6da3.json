{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { ValueCell } from '../../mol-util';\nimport { Mat4, Mat3 } from '../../mol-math/linear-algebra';\nimport { fillSerial } from '../../mol-util/array';\n\nvar _m3 = Mat3();\n\nvar _m4 = Mat4();\n\nfunction checkReflection(transformArray, instanceCount) {\n  for (var i = 0; i < instanceCount; i++) {\n    Mat3.fromMat4(_m3, Mat4.fromArray(_m4, transformArray, i * 16));\n    if (Mat3.determinant(_m3) < 0) return true;\n  }\n\n  return false;\n}\n\nexport function createTransform(transformArray, instanceCount, transformData) {\n  var hasReflection = checkReflection(transformArray, instanceCount);\n\n  if (transformData) {\n    ValueCell.update(transformData.matrix, transformData.matrix.ref.value);\n    var transform = transformData.transform.ref.value.length >= instanceCount * 16 ? transformData.transform.ref.value : new Float32Array(instanceCount * 16);\n    transform.set(transformArray);\n    ValueCell.update(transformData.transform, transform);\n    ValueCell.updateIfChanged(transformData.uInstanceCount, instanceCount);\n    ValueCell.updateIfChanged(transformData.instanceCount, instanceCount);\n    var aTransform = transformData.aTransform.ref.value.length >= instanceCount * 16 ? transformData.aTransform.ref.value : new Float32Array(instanceCount * 16);\n    ValueCell.update(transformData.aTransform, aTransform); // Note that this sets `extraTransform` to identity transforms\n\n    var extraTransform = transformData.extraTransform.ref.value.length >= instanceCount * 16 ? transformData.extraTransform.ref.value : new Float32Array(instanceCount * 16);\n    ValueCell.update(transformData.extraTransform, fillIdentityTransform(extraTransform, instanceCount));\n    var aInstance = transformData.aInstance.ref.value.length >= instanceCount ? transformData.aInstance.ref.value : new Float32Array(instanceCount);\n    ValueCell.update(transformData.aInstance, fillSerial(aInstance, instanceCount));\n    ValueCell.update(transformData.hasReflection, hasReflection);\n  } else {\n    transformData = {\n      aTransform: ValueCell.create(new Float32Array(instanceCount * 16)),\n      matrix: ValueCell.create(Mat4.identity()),\n      transform: ValueCell.create(new Float32Array(transformArray)),\n      extraTransform: ValueCell.create(fillIdentityTransform(new Float32Array(instanceCount * 16), instanceCount)),\n      uInstanceCount: ValueCell.create(instanceCount),\n      instanceCount: ValueCell.create(instanceCount),\n      aInstance: ValueCell.create(fillSerial(new Float32Array(instanceCount))),\n      hasReflection: ValueCell.create(hasReflection)\n    };\n  }\n\n  updateTransformData(transformData);\n  return transformData;\n}\nvar identityTransform = new Float32Array(16);\nMat4.toArray(Mat4.identity(), identityTransform, 0);\nexport function createIdentityTransform(transformData) {\n  return createTransform(new Float32Array(identityTransform), 1, transformData);\n}\nexport function fillIdentityTransform(transform, count) {\n  for (var i = 0; i < count; i++) {\n    transform.set(identityTransform, i * 16);\n  }\n\n  return transform;\n}\n/**\r\n * updates per-instance transform calculated for instance `i` as\r\n * `aTransform[i] = matrix * transform[i] * extraTransform[i]`\r\n */\n\nexport function updateTransformData(transformData) {\n  var aTransform = transformData.aTransform.ref.value;\n  var instanceCount = transformData.instanceCount.ref.value;\n  var matrix = transformData.matrix.ref.value;\n  var transform = transformData.transform.ref.value;\n  var extraTransform = transformData.extraTransform.ref.value;\n\n  for (var i = 0; i < instanceCount; i++) {\n    var i16 = i * 16;\n    Mat4.mulOffset(aTransform, extraTransform, transform, i16, i16, i16);\n    Mat4.mulOffset(aTransform, matrix, aTransform, i16, 0, i16);\n  }\n\n  ValueCell.update(transformData.aTransform, aTransform);\n}","map":{"version":3,"sources":["../../../src/mol-geo/geometry/transform-data.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { ValueCell } from '../../mol-util';\r\nimport { Mat4, Mat3 } from '../../mol-math/linear-algebra';\r\nimport { fillSerial } from '../../mol-util/array';\r\nvar _m3 = Mat3();\r\nvar _m4 = Mat4();\r\nfunction checkReflection(transformArray, instanceCount) {\r\n    for (var i = 0; i < instanceCount; i++) {\r\n        Mat3.fromMat4(_m3, Mat4.fromArray(_m4, transformArray, i * 16));\r\n        if (Mat3.determinant(_m3) < 0)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nexport function createTransform(transformArray, instanceCount, transformData) {\r\n    var hasReflection = checkReflection(transformArray, instanceCount);\r\n    if (transformData) {\r\n        ValueCell.update(transformData.matrix, transformData.matrix.ref.value);\r\n        var transform = transformData.transform.ref.value.length >= instanceCount * 16 ? transformData.transform.ref.value : new Float32Array(instanceCount * 16);\r\n        transform.set(transformArray);\r\n        ValueCell.update(transformData.transform, transform);\r\n        ValueCell.updateIfChanged(transformData.uInstanceCount, instanceCount);\r\n        ValueCell.updateIfChanged(transformData.instanceCount, instanceCount);\r\n        var aTransform = transformData.aTransform.ref.value.length >= instanceCount * 16 ? transformData.aTransform.ref.value : new Float32Array(instanceCount * 16);\r\n        ValueCell.update(transformData.aTransform, aTransform);\r\n        // Note that this sets `extraTransform` to identity transforms\r\n        var extraTransform = transformData.extraTransform.ref.value.length >= instanceCount * 16 ? transformData.extraTransform.ref.value : new Float32Array(instanceCount * 16);\r\n        ValueCell.update(transformData.extraTransform, fillIdentityTransform(extraTransform, instanceCount));\r\n        var aInstance = transformData.aInstance.ref.value.length >= instanceCount ? transformData.aInstance.ref.value : new Float32Array(instanceCount);\r\n        ValueCell.update(transformData.aInstance, fillSerial(aInstance, instanceCount));\r\n        ValueCell.update(transformData.hasReflection, hasReflection);\r\n    }\r\n    else {\r\n        transformData = {\r\n            aTransform: ValueCell.create(new Float32Array(instanceCount * 16)),\r\n            matrix: ValueCell.create(Mat4.identity()),\r\n            transform: ValueCell.create(new Float32Array(transformArray)),\r\n            extraTransform: ValueCell.create(fillIdentityTransform(new Float32Array(instanceCount * 16), instanceCount)),\r\n            uInstanceCount: ValueCell.create(instanceCount),\r\n            instanceCount: ValueCell.create(instanceCount),\r\n            aInstance: ValueCell.create(fillSerial(new Float32Array(instanceCount))),\r\n            hasReflection: ValueCell.create(hasReflection),\r\n        };\r\n    }\r\n    updateTransformData(transformData);\r\n    return transformData;\r\n}\r\nvar identityTransform = new Float32Array(16);\r\nMat4.toArray(Mat4.identity(), identityTransform, 0);\r\nexport function createIdentityTransform(transformData) {\r\n    return createTransform(new Float32Array(identityTransform), 1, transformData);\r\n}\r\nexport function fillIdentityTransform(transform, count) {\r\n    for (var i = 0; i < count; i++) {\r\n        transform.set(identityTransform, i * 16);\r\n    }\r\n    return transform;\r\n}\r\n/**\r\n * updates per-instance transform calculated for instance `i` as\r\n * `aTransform[i] = matrix * transform[i] * extraTransform[i]`\r\n */\r\nexport function updateTransformData(transformData) {\r\n    var aTransform = transformData.aTransform.ref.value;\r\n    var instanceCount = transformData.instanceCount.ref.value;\r\n    var matrix = transformData.matrix.ref.value;\r\n    var transform = transformData.transform.ref.value;\r\n    var extraTransform = transformData.extraTransform.ref.value;\r\n    for (var i = 0; i < instanceCount; i++) {\r\n        var i16 = i * 16;\r\n        Mat4.mulOffset(aTransform, extraTransform, transform, i16, i16, i16);\r\n        Mat4.mulOffset(aTransform, matrix, aTransform, i16, 0, i16);\r\n    }\r\n    ValueCell.update(transformData.aTransform, aTransform);\r\n}\r\n//# sourceMappingURL=transform-data.js.map"]},"metadata":{},"sourceType":"module"}