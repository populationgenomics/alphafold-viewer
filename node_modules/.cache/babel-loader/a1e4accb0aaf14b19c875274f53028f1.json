{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\n/**\r\n * mmCIF parser.\r\n *\r\n * Trying to be as close to the specification http://www.iucr.org/resources/cif/spec/version1.1/cifsyntax\r\n *\r\n * Differences I'm aware of:\r\n * - Except keywords (data_, loop_, save_) everything is case sensitive.\r\n * - The tokens . and ? are treated the same as the values '.' and '?'.\r\n * - Ignores \\ in the multiline values:\r\n *     ;abc\\\r\n *     efg\r\n *     ;\r\n *   should have the value 'abcefg' but will have the value 'abc\\\\nefg' instead.\r\n *   Post processing of this is left to the consumer of the data.\r\n * - Similarly, things like punctuation (\\', ..) are left to be processed by the user if needed.\r\n *\r\n */\n\nimport * as Data from '../data-model';\nimport { TokenBuilder, Tokenizer } from '../../common/text/tokenizer';\nimport { ReaderResult as Result } from '../../result';\nimport { Task, chunkedSubtask } from '../../../../mol-task';\n/**\r\n * Eat everything until a whitespace/newline occurs.\r\n */\n\nfunction eatValue(state) {\n  while (state.position < state.length) {\n    switch (state.data.charCodeAt(state.position)) {\n      case 9: // \\t\n\n      case 10: // \\n\n\n      case 13: // \\r\n\n      case 32:\n        // ' '\n        state.tokenEnd = state.position;\n        return;\n\n      default:\n        ++state.position;\n        break;\n    }\n  }\n\n  state.tokenEnd = state.position;\n}\n/**\r\n * Eats an escaped value. Handles the \"degenerate\" cases as well.\r\n *\r\n * \"Degenerate\" cases:\r\n * - 'xx'x' => xx'x\r\n * - 'xxxNEWLINE => 'xxx\r\n *\r\n */\n\n\nfunction eatEscaped(state, esc) {\n  var next, c;\n  ++state.position;\n\n  while (state.position < state.length) {\n    c = state.data.charCodeAt(state.position);\n\n    if (c === esc) {\n      next = state.data.charCodeAt(state.position + 1);\n\n      switch (next) {\n        case 9: // \\t\n\n        case 10: // \\n\n\n        case 13: // \\r\n\n        case 32:\n          // ' '\n          // get rid of the quotes.\n          state.tokenStart++;\n          state.tokenEnd = state.position;\n          state.isEscaped = true;\n          ++state.position;\n          return;\n\n        default:\n          if (next === void 0) {\n            // = \"end of stream\"\n            // get rid of the quotes.\n            state.tokenStart++;\n            state.tokenEnd = state.position;\n            state.isEscaped = true;\n            ++state.position;\n            return;\n          }\n\n          ++state.position;\n          break;\n      }\n    } else {\n      // handle 'xxxNEWLINE => 'xxx\n      if (c === 10 || c === 13) {\n        state.tokenEnd = state.position;\n        return;\n      }\n\n      ++state.position;\n    }\n  }\n\n  state.tokenEnd = state.position;\n}\n/**\r\n * Eats an escaped value \"triple quote\" (''') value.\r\n */\n\n\nfunction eatTripleQuote(state) {\n  // skip the '''\n  state.position += 3;\n\n  while (state.position < state.length) {\n    if (state.data.charCodeAt(state.position) === 39\n    /* ' */\n    && isTripleQuoteAtPosition(state)) {\n      // get rid of the quotes.\n      state.tokenStart += 3;\n      state.tokenEnd = state.position;\n      state.isEscaped = true;\n      state.position += 3;\n      return;\n    }\n\n    ++state.position;\n  }\n\n  state.tokenEnd = state.position;\n}\n/**\r\n * Eats a multiline token of the form NL;....NL;\r\n */\n\n\nfunction eatMultiline(state) {\n  var prev = 59,\n      pos = state.position + 1,\n      c;\n\n  while (pos < state.length) {\n    c = state.data.charCodeAt(pos);\n\n    if (c === 59 && (prev === 10 || prev === 13)) {\n      // ;, \\n \\r\n      state.position = pos + 1; // get rid of the ;\n\n      state.tokenStart++; // remove trailing newlines\n\n      pos--;\n      c = state.data.charCodeAt(pos);\n\n      while (c === 10 || c === 13) {\n        pos--;\n        c = state.data.charCodeAt(pos);\n      }\n\n      state.tokenEnd = pos + 1;\n      state.isEscaped = true;\n      return;\n    } else {\n      // handle line numbers\n      if (c === 13) {\n        // \\r\n        state.lineNumber++;\n      } else if (c === 10 && prev !== 13) {\n        // \\r\\n\n        state.lineNumber++;\n      }\n\n      prev = c;\n      ++pos;\n    }\n  }\n\n  state.position = pos;\n  return prev;\n}\n\nfunction eatImportGet(state) {\n  // _import.get [{'save':orient_matrix  'file':templ_attr.cif}]\n  // skipWhitespace(state)\n  while (state.position < state.length) {\n    switch (state.data.charCodeAt(state.position)) {\n      case 93:\n        // ]\n        ++state.position;\n        state.tokenEnd = state.position;\n        state.isImportGet = false;\n        return;\n\n      default:\n        ++state.position;\n        break;\n    }\n  }\n}\n/**\r\n * Skips until \\n or \\r occurs -- therefore the newlines get handled by the \"skipWhitespace\" function.\r\n */\n\n\nfunction skipCommentLine(state) {\n  while (state.position < state.length) {\n    var c = state.data.charCodeAt(state.position);\n\n    if (c === 10 || c === 13) {\n      return;\n    }\n\n    ++state.position;\n  }\n}\n/**\r\n * Skips all the whitespace - space, tab, newline, CR\r\n * Handles incrementing line count.\r\n */\n\n\nfunction skipWhitespace(state) {\n  var prev = 10;\n\n  while (state.position < state.length) {\n    var c = state.data.charCodeAt(state.position);\n\n    switch (c) {\n      case 9: // '\\t'\n\n      case 32:\n        // ' '\n        prev = c;\n        ++state.position;\n        break;\n\n      case 10:\n        // \\n\n        // handle \\r\\n\n        if (prev !== 13) {\n          ++state.lineNumber;\n        }\n\n        prev = c;\n        ++state.position;\n        break;\n\n      case 13:\n        // \\r\n        prev = c;\n        ++state.position;\n        ++state.lineNumber;\n        break;\n\n      default:\n        return prev;\n    }\n  }\n\n  return prev;\n}\n/**\r\n * Returns true if there are two consecutive ' in +1 and +2 positions.\r\n */\n\n\nfunction isTripleQuoteAtPosition(state) {\n  if (state.length - state.position < 2) return false;\n  if (state.data.charCodeAt(state.position + 1) !== 39) return false; // '\n\n  if (state.data.charCodeAt(state.position + 2) !== 39) return false; // '\n\n  return true;\n}\n\nfunction isData(state) {\n  // here we already assume the 5th char is _ and that the length >= 5\n  // d/D\n  var c = state.data.charCodeAt(state.tokenStart);\n  if (c !== 68 && c !== 100) return false; // a/A\n\n  c = state.data.charCodeAt(state.tokenStart + 1);\n  if (c !== 65 && c !== 97) return false; // t/t\n\n  c = state.data.charCodeAt(state.tokenStart + 2);\n  if (c !== 84 && c !== 116) return false; // a/A\n\n  c = state.data.charCodeAt(state.tokenStart + 3);\n  if (c !== 65 && c !== 97) return false;\n  return true;\n}\n\nfunction isSave(state) {\n  // here we already assume the 5th char is _ and that the length >= 5\n  // s/S\n  var c = state.data.charCodeAt(state.tokenStart);\n  if (c !== 83 && c !== 115) return false; // a/A\n\n  c = state.data.charCodeAt(state.tokenStart + 1);\n  if (c !== 65 && c !== 97) return false; // v/V\n\n  c = state.data.charCodeAt(state.tokenStart + 2);\n  if (c !== 86 && c !== 118) return false; // e/E\n\n  c = state.data.charCodeAt(state.tokenStart + 3);\n  if (c !== 69 && c !== 101) return false;\n  return true;\n}\n\nfunction isLoop(state) {\n  // here we already assume the 5th char is _ and that the length >= 5\n  if (state.tokenEnd - state.tokenStart !== 5) return false; // l/L\n\n  var c = state.data.charCodeAt(state.tokenStart);\n  if (c !== 76 && c !== 108) return false; // o/O\n\n  c = state.data.charCodeAt(state.tokenStart + 1);\n  if (c !== 79 && c !== 111) return false; // o/O\n\n  c = state.data.charCodeAt(state.tokenStart + 2);\n  if (c !== 79 && c !== 111) return false; // p/P\n\n  c = state.data.charCodeAt(state.tokenStart + 3);\n  if (c !== 80 && c !== 112) return false;\n  return true;\n}\n\nfunction isImportGet(state) {\n  // _import.get [{'save':orient_matrix  'file':templ_attr.cif}]\n  if (state.tokenEnd - state.tokenStart !== 11) return false;\n  if (state.data.charCodeAt(state.tokenStart + 1) !== 105) return false; // i\n\n  if (state.data.charCodeAt(state.tokenStart + 2) !== 109) return false; // m\n\n  if (state.data.charCodeAt(state.tokenStart + 3) !== 112) return false; // p\n\n  if (state.data.charCodeAt(state.tokenStart + 4) !== 111) return false; // o\n\n  if (state.data.charCodeAt(state.tokenStart + 5) !== 114) return false; // r\n\n  if (state.data.charCodeAt(state.tokenStart + 6) !== 116) return false; // t\n\n  if (state.data.charCodeAt(state.tokenStart + 7) !== 46) return false; // .\n\n  if (state.data.charCodeAt(state.tokenStart + 8) !== 103) return false; // g\n\n  if (state.data.charCodeAt(state.tokenStart + 9) !== 101) return false; // e\n\n  if (state.data.charCodeAt(state.tokenStart + 10) !== 116) return false; // t\n\n  return true;\n}\n/**\r\n * Checks if the current token shares the namespace with string at <start,end).\r\n */\n\n\nfunction isNamespace(state, start, end) {\n  var i;\n  var nsLen = end - start;\n  var offset = state.tokenStart - start;\n  var tokenLen = state.tokenEnd - state.tokenStart;\n  if (tokenLen < nsLen) return false;\n\n  for (i = start; i < end; ++i) {\n    if (state.data.charCodeAt(i) !== state.data.charCodeAt(i + offset)) return false;\n  }\n\n  if (nsLen === tokenLen) return true;\n\n  if (state.data.charCodeAt(i + offset) === 46) {\n    // .\n    return true;\n  }\n\n  return false;\n}\n/**\r\n * Returns the index of '.' in the current token. If no '.' is present, returns currentTokenEnd.\r\n */\n\n\nfunction getNamespaceEnd(state) {\n  var i;\n\n  for (i = state.tokenStart; i < state.tokenEnd; ++i) {\n    if (state.data.charCodeAt(i) === 46) return i;\n  }\n\n  return i;\n}\n/**\r\n * Get the namespace string. endIndex is obtained by the getNamespaceEnd() function.\r\n */\n\n\nfunction getNamespace(state, endIndex) {\n  return state.data.substring(state.tokenStart, endIndex);\n}\n/**\r\n * Returns true if the current token contain no '.', otherwise returns false.\r\n */\n\n\nfunction isFlatNamespace(state) {\n  var i;\n\n  for (i = state.tokenStart; i < state.tokenEnd; ++i) {\n    if (state.data.charCodeAt(i) === 46) return false;\n  }\n\n  return true;\n}\n/**\r\n * String representation of the current token.\r\n */\n\n\nfunction getTokenString(state) {\n  return state.data.substring(state.tokenStart, state.tokenEnd);\n}\n/**\r\n * Move to the next token.\r\n */\n\n\nfunction moveNextInternal(state) {\n  var prev = skipWhitespace(state);\n\n  if (state.position >= state.length) {\n    state.tokenType = 6\n    /* End */\n    ;\n    return;\n  }\n\n  state.tokenStart = state.position;\n  state.tokenEnd = state.position;\n  state.isEscaped = false;\n  var c = state.data.charCodeAt(state.position);\n\n  switch (c) {\n    case 35:\n      // #, comment\n      skipCommentLine(state);\n      state.tokenType = 5\n      /* Comment */\n      ;\n      break;\n\n    case 39:\n      // ', escaped value\n      if (isTripleQuoteAtPosition(state)) {\n        eatTripleQuote(state);\n        state.tokenType = 3\n        /* Value */\n        ;\n        break;\n      }\n\n    case 34:\n      // \", escaped value\n      eatEscaped(state, c);\n      state.tokenType = 3\n      /* Value */\n      ;\n      break;\n\n    case 59:\n      // ;, possible multiline value\n      // multiline value must start at the beginning of the line.\n      if (prev === 10 || prev === 13) {\n        // /n or /r\n        eatMultiline(state);\n      } else {\n        eatValue(state);\n      }\n\n      state.tokenType = 3\n      /* Value */\n      ;\n      break;\n\n    default:\n      if (state.isImportGet) {\n        eatImportGet(state);\n      } else {\n        eatValue(state);\n      } // escaped is always Value\n\n\n      if (state.isEscaped) {\n        state.tokenType = 3\n        /* Value */\n        ; // _ means column name, including _import.get\n      } else if (state.data.charCodeAt(state.tokenStart) === 95) {\n        // _\n        if (state.inSaveFrame && isImportGet(state)) {\n          state.isImportGet = true;\n        }\n\n        state.tokenType = 4\n        /* ColumnName */\n        ; // 5th char needs to be _ for data_, save_ or loop_\n      } else if (state.tokenEnd - state.tokenStart >= 5 && state.data.charCodeAt(state.tokenStart + 4) === 95) {\n        if (isData(state)) state.tokenType = 0\n        /* Data */\n        ;else if (isSave(state)) state.tokenType = 1\n        /* Save */\n        ;else if (isLoop(state)) state.tokenType = 2\n        /* Loop */\n        ;else state.tokenType = 3\n        /* Value */\n        ; // all other tests failed, we are at Value token.\n      } else {\n        state.tokenType = 3\n        /* Value */\n        ;\n      }\n\n      break;\n  }\n}\n/**\r\n * Moves to the next non-comment token.\r\n */\n\n\nfunction moveNext(state) {\n  moveNextInternal(state);\n\n  while (state.tokenType === 5\n  /* Comment */\n  ) moveNextInternal(state);\n}\n\nfunction createTokenizer(data, runtimeCtx) {\n  return {\n    data: data,\n    length: data.length,\n    position: 0,\n    tokenStart: 0,\n    tokenEnd: 0,\n    tokenType: 6\n    /* End */\n    ,\n    lineNumber: 1,\n    isEscaped: false,\n    isImportGet: false,\n    inSaveFrame: false,\n    runtimeCtx: runtimeCtx\n  };\n}\n\nfunction FrameContext() {\n  return {\n    categoryNames: [],\n    categoryData: Object.create(null)\n  };\n}\n\nfunction CifCategories(categoryNames, categoryData) {\n  var categories = Object.create(null);\n\n  for (var _i = 0, categoryNames_1 = categoryNames; _i < categoryNames_1.length; _i++) {\n    var name_1 = categoryNames_1[_i];\n    var d = categoryData[name_1];\n    categories[name_1] = Data.CifCategory(d.name, d.rowCount, d.fieldNames, d.fields);\n  }\n\n  return categories;\n}\n\nfunction CifBlock(ctx, header, saveFrames) {\n  return Data.CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header, saveFrames);\n}\n\nfunction CifSaveFrame(ctx, header) {\n  return Data.CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header);\n}\n\nfunction addFields(ctx, name, rowCount, fieldNames, fields) {\n  var _a;\n\n  if (name in ctx.categoryData) {\n    var cat = ctx.categoryData[name];\n\n    (_a = cat.fieldNames).push.apply(_a, fieldNames);\n\n    Object.assign(cat.fields, fields);\n  } else {\n    ctx.categoryData[name] = {\n      name: name,\n      rowCount: rowCount,\n      fieldNames: fieldNames,\n      fields: fields\n    };\n    ctx.categoryNames.push(name);\n  }\n}\n/**\r\n * Reads a category containing a single row.\r\n */\n\n\nfunction handleSingle(tokenizer, ctx) {\n  var nsStart = tokenizer.tokenStart,\n      nsEnd = getNamespaceEnd(tokenizer);\n  var name = getNamespace(tokenizer, nsEnd);\n  var fields = Object.create(null);\n  var fieldNames = [];\n  var readingNames = true;\n\n  while (readingNames) {\n    if (tokenizer.tokenType !== 4\n    /* ColumnName */\n    || !isNamespace(tokenizer, nsStart, nsEnd)) {\n      readingNames = false;\n      break;\n    }\n\n    var fieldName = getTokenString(tokenizer).substring(name.length + 1);\n    moveNext(tokenizer);\n\n    if (tokenizer.tokenType !== 3\n    /* Value */\n    ) {\n      return {\n        hasError: true,\n        errorLine: tokenizer.lineNumber,\n        errorMessage: 'Expected value.'\n      };\n    }\n\n    fields[fieldName] = Data.CifField.ofTokens({\n      data: tokenizer.data,\n      indices: [tokenizer.tokenStart, tokenizer.tokenEnd],\n      count: 1\n    });\n    fieldNames[fieldNames.length] = fieldName;\n    moveNext(tokenizer);\n  }\n\n  addFields(ctx, name.substr(1), 1, fieldNames, fields);\n  return {\n    hasError: false,\n    errorLine: 0,\n    errorMessage: ''\n  };\n}\n\nfunction readLoopChunk(chunkSize, state) {\n  var tokenizer = state.tokenizer,\n      tokens = state.tokens,\n      fieldCount = state.fieldCount;\n  var tokenCount = state.tokenCount;\n  var counter = 0;\n\n  while (tokenizer.tokenType === 3\n  /* Value */\n  && counter < chunkSize) {\n    TokenBuilder.add(tokens[tokenCount++ % fieldCount], tokenizer.tokenStart, tokenizer.tokenEnd);\n    moveNext(tokenizer);\n    counter++;\n  }\n\n  state.tokenCount = tokenCount;\n  return counter;\n}\n\nfunction updateLoopChunk(ctx, state) {\n  return ctx.update({\n    message: 'Parsing...',\n    current: state.tokenizer.position,\n    max: state.tokenizer.data.length\n  });\n} // const readLoopChunks = ChunkedSubtask(1000000,\n//     (size, state: LoopReadState) => readLoopChunk(state, size),\n//     (ctx, state) => ctx.update({ message: 'Parsing...', current: state.tokenizer.position, max: state.tokenizer.data.length }));\n\n/**\r\n * Reads a loop.\r\n */\n\n\nfunction handleLoop(tokenizer, ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var loopLine, name, isFlat, fieldNames, rowCountEstimate, tokens, fieldCount, i, state, rowCount, i, fields, fields, i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          loopLine = tokenizer.lineNumber;\n          moveNext(tokenizer);\n          name = getNamespace(tokenizer, getNamespaceEnd(tokenizer));\n          isFlat = isFlatNamespace(tokenizer);\n          fieldNames = [];\n\n          while (tokenizer.tokenType === 4\n          /* ColumnName */\n          ) {\n            fieldNames[fieldNames.length] = isFlat ? getTokenString(tokenizer) : getTokenString(tokenizer).substring(name.length + 1);\n            moveNext(tokenizer);\n          }\n\n          rowCountEstimate = name === '_atom_site' ? tokenizer.data.length / 100 | 0 : 32;\n          tokens = [];\n          fieldCount = fieldNames.length;\n\n          for (i = 0; i < fieldCount; i++) tokens[i] = TokenBuilder.create(tokenizer.data, rowCountEstimate);\n\n          state = {\n            fieldCount: fieldCount,\n            tokenCount: 0,\n            tokenizer: tokenizer,\n            tokens: tokens\n          };\n          return [4\n          /*yield*/\n          , chunkedSubtask(tokenizer.runtimeCtx, 1000000, state, readLoopChunk, updateLoopChunk)];\n\n        case 1:\n          _a.sent();\n\n          if (state.tokenCount % fieldCount !== 0) {\n            return [2\n            /*return*/\n            , {\n              hasError: true,\n              errorLine: tokenizer.lineNumber,\n              errorMessage: \"The number of values for loop starting at line \" + loopLine + \" is not a multiple of the number of columns.\"\n            }];\n          }\n\n          rowCount = state.tokenCount / fieldCount | 0;\n\n          if (isFlat) {\n            for (i = 0; i < fieldCount; i++) {\n              fields = {\n                '': Data.CifField.ofTokens(tokens[i])\n              };\n              addFields(ctx, fieldNames[i].substr(1), rowCount, [''], fields);\n            }\n          } else {\n            fields = Object.create(null);\n\n            for (i = 0; i < fieldCount; i++) {\n              fields[fieldNames[i]] = Data.CifField.ofTokens(tokens[i]);\n            }\n\n            addFields(ctx, name.substr(1), rowCount, fieldNames, fields);\n          }\n\n          return [2\n          /*return*/\n          , {\n            hasError: false,\n            errorLine: 0,\n            errorMessage: ''\n          }];\n      }\n    });\n  });\n}\n/**\r\n * Creates an error result.\r\n */\n\n\nfunction error(line, message) {\n  return Result.error(message, line);\n}\n/**\r\n * Creates a data result.\r\n */\n\n\nfunction result(data) {\n  return Result.success(data);\n}\n/**\r\n * Parses an mmCIF file.\r\n *\r\n * @returns CifParserResult wrapper of the result.\r\n */\n\n\nfunction parseInternal(data, runtimeCtx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var dataBlocks, tokenizer, blockHeader, blockCtx, saveFrames, saveCtx, saveFrame, saveHeader, token, cat, cat;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          dataBlocks = [];\n          tokenizer = createTokenizer(data, runtimeCtx);\n          blockHeader = '';\n          blockCtx = FrameContext();\n          saveFrames = [];\n          saveCtx = FrameContext();\n          saveFrame = Data.CifSaveFrame(saveCtx.categoryNames, CifCategories(saveCtx.categoryNames, saveCtx.categoryData), '');\n          saveHeader = '';\n          runtimeCtx.update({\n            message: 'Parsing...',\n            current: 0,\n            max: data.length\n          });\n          moveNext(tokenizer);\n          _a.label = 1;\n\n        case 1:\n          if (!(tokenizer.tokenType !== 6\n          /* End */\n          )) return [3\n          /*break*/\n          , 7];\n          token = tokenizer.tokenType;\n          if (!(token === 0\n          /* Data */\n          )) return [3\n          /*break*/\n          , 2];\n\n          if (tokenizer.inSaveFrame) {\n            return [2\n            /*return*/\n            , error(tokenizer.lineNumber, 'Unexpected data block inside a save frame.')];\n          }\n\n          if (blockCtx.categoryNames.length > 0) {\n            dataBlocks.push(CifBlock(blockCtx, blockHeader, saveFrames));\n          }\n\n          blockHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);\n          blockCtx = FrameContext();\n          saveFrames = [];\n          moveNext(tokenizer);\n          return [3\n          /*break*/\n          , 6];\n\n        case 2:\n          if (!(token === 1\n          /* Save */\n          )) return [3\n          /*break*/\n          , 3];\n\n          if (tokenizer.tokenEnd - tokenizer.tokenStart === 5) {\n            // end of save frame\n            if (saveCtx.categoryNames.length > 0) {\n              saveFrames[saveFrames.length] = CifSaveFrame(saveCtx, saveHeader);\n            }\n\n            tokenizer.inSaveFrame = false;\n          } else {\n            // start of save frame\n            if (tokenizer.inSaveFrame) {\n              return [2\n              /*return*/\n              , error(tokenizer.lineNumber, 'Save frames cannot be nested.')];\n            }\n\n            tokenizer.inSaveFrame = true;\n            saveHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);\n            saveCtx = FrameContext(); // saveFrame = CifSaveFrame(saveCtx, saveHeader);\n          }\n\n          moveNext(tokenizer);\n          return [3\n          /*break*/\n          , 6];\n\n        case 3:\n          if (!(token === 2\n          /* Loop */\n          )) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , handleLoop(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx)];\n\n        case 4:\n          cat = _a.sent();\n\n          if (cat.hasError) {\n            return [2\n            /*return*/\n            , error(cat.errorLine, cat.errorMessage)];\n          }\n\n          return [3\n          /*break*/\n          , 6];\n\n        case 5:\n          if (token === 4\n          /* ColumnName */\n          ) {\n            cat = handleSingle(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx);\n\n            if (cat.hasError) {\n              return [2\n              /*return*/\n              , error(cat.errorLine, cat.errorMessage)];\n            } // Out of options\n\n          } else {\n            console.log(tokenizer.tokenType, Tokenizer.getTokenString(tokenizer));\n            return [2\n            /*return*/\n            , error(tokenizer.lineNumber, 'Unexpected token. Expected data_, loop_, or data name.')];\n          }\n\n          _a.label = 6;\n\n        case 6:\n          return [3\n          /*break*/\n          , 1];\n\n        case 7:\n          // Check if the latest save frame was closed.\n          if (tokenizer.inSaveFrame) {\n            return [2\n            /*return*/\n            , error(tokenizer.lineNumber, \"Unfinished save frame (\" + saveFrame.header + \").\")];\n          }\n\n          if (blockCtx.categoryNames.length > 0 || saveFrames.length > 0) {\n            dataBlocks.push(CifBlock(blockCtx, blockHeader, saveFrames));\n          }\n\n          return [2\n          /*return*/\n          , result(Data.CifFile(dataBlocks))];\n      }\n    });\n  });\n}\n\nexport function parseCifText(data) {\n  var _this = this;\n\n  return Task.create('Parse CIF', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , parseInternal(data, ctx)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-io/reader/cif/text/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\n/**\r\n * mmCIF parser.\r\n *\r\n * Trying to be as close to the specification http://www.iucr.org/resources/cif/spec/version1.1/cifsyntax\r\n *\r\n * Differences I'm aware of:\r\n * - Except keywords (data_, loop_, save_) everything is case sensitive.\r\n * - The tokens . and ? are treated the same as the values '.' and '?'.\r\n * - Ignores \\ in the multiline values:\r\n *     ;abc\\\r\n *     efg\r\n *     ;\r\n *   should have the value 'abcefg' but will have the value 'abc\\\\nefg' instead.\r\n *   Post processing of this is left to the consumer of the data.\r\n * - Similarly, things like punctuation (\\', ..) are left to be processed by the user if needed.\r\n *\r\n */\r\nimport * as Data from '../data-model';\r\nimport { TokenBuilder, Tokenizer } from '../../common/text/tokenizer';\r\nimport { ReaderResult as Result } from '../../result';\r\nimport { Task, chunkedSubtask } from '../../../../mol-task';\r\n/**\r\n * Eat everything until a whitespace/newline occurs.\r\n */\r\nfunction eatValue(state) {\r\n    while (state.position < state.length) {\r\n        switch (state.data.charCodeAt(state.position)) {\r\n            case 9: // \\t\r\n            case 10: // \\n\r\n            case 13: // \\r\r\n            case 32: // ' '\r\n                state.tokenEnd = state.position;\r\n                return;\r\n            default:\r\n                ++state.position;\r\n                break;\r\n        }\r\n    }\r\n    state.tokenEnd = state.position;\r\n}\r\n/**\r\n * Eats an escaped value. Handles the \"degenerate\" cases as well.\r\n *\r\n * \"Degenerate\" cases:\r\n * - 'xx'x' => xx'x\r\n * - 'xxxNEWLINE => 'xxx\r\n *\r\n */\r\nfunction eatEscaped(state, esc) {\r\n    var next, c;\r\n    ++state.position;\r\n    while (state.position < state.length) {\r\n        c = state.data.charCodeAt(state.position);\r\n        if (c === esc) {\r\n            next = state.data.charCodeAt(state.position + 1);\r\n            switch (next) {\r\n                case 9: // \\t\r\n                case 10: // \\n\r\n                case 13: // \\r\r\n                case 32: // ' '\r\n                    // get rid of the quotes.\r\n                    state.tokenStart++;\r\n                    state.tokenEnd = state.position;\r\n                    state.isEscaped = true;\r\n                    ++state.position;\r\n                    return;\r\n                default:\r\n                    if (next === void 0) { // = \"end of stream\"\r\n                        // get rid of the quotes.\r\n                        state.tokenStart++;\r\n                        state.tokenEnd = state.position;\r\n                        state.isEscaped = true;\r\n                        ++state.position;\r\n                        return;\r\n                    }\r\n                    ++state.position;\r\n                    break;\r\n            }\r\n        }\r\n        else {\r\n            // handle 'xxxNEWLINE => 'xxx\r\n            if (c === 10 || c === 13) {\r\n                state.tokenEnd = state.position;\r\n                return;\r\n            }\r\n            ++state.position;\r\n        }\r\n    }\r\n    state.tokenEnd = state.position;\r\n}\r\n/**\r\n * Eats an escaped value \"triple quote\" (''') value.\r\n */\r\nfunction eatTripleQuote(state) {\r\n    // skip the '''\r\n    state.position += 3;\r\n    while (state.position < state.length) {\r\n        if (state.data.charCodeAt(state.position) === 39 /* ' */ && isTripleQuoteAtPosition(state)) {\r\n            // get rid of the quotes.\r\n            state.tokenStart += 3;\r\n            state.tokenEnd = state.position;\r\n            state.isEscaped = true;\r\n            state.position += 3;\r\n            return;\r\n        }\r\n        ++state.position;\r\n    }\r\n    state.tokenEnd = state.position;\r\n}\r\n/**\r\n * Eats a multiline token of the form NL;....NL;\r\n */\r\nfunction eatMultiline(state) {\r\n    var prev = 59, pos = state.position + 1, c;\r\n    while (pos < state.length) {\r\n        c = state.data.charCodeAt(pos);\r\n        if (c === 59 && (prev === 10 || prev === 13)) { // ;, \\n \\r\r\n            state.position = pos + 1;\r\n            // get rid of the ;\r\n            state.tokenStart++;\r\n            // remove trailing newlines\r\n            pos--;\r\n            c = state.data.charCodeAt(pos);\r\n            while (c === 10 || c === 13) {\r\n                pos--;\r\n                c = state.data.charCodeAt(pos);\r\n            }\r\n            state.tokenEnd = pos + 1;\r\n            state.isEscaped = true;\r\n            return;\r\n        }\r\n        else {\r\n            // handle line numbers\r\n            if (c === 13) { // \\r\r\n                state.lineNumber++;\r\n            }\r\n            else if (c === 10 && prev !== 13) { // \\r\\n\r\n                state.lineNumber++;\r\n            }\r\n            prev = c;\r\n            ++pos;\r\n        }\r\n    }\r\n    state.position = pos;\r\n    return prev;\r\n}\r\nfunction eatImportGet(state) {\r\n    // _import.get [{'save':orient_matrix  'file':templ_attr.cif}]\r\n    // skipWhitespace(state)\r\n    while (state.position < state.length) {\r\n        switch (state.data.charCodeAt(state.position)) {\r\n            case 93: // ]\r\n                ++state.position;\r\n                state.tokenEnd = state.position;\r\n                state.isImportGet = false;\r\n                return;\r\n            default:\r\n                ++state.position;\r\n                break;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Skips until \\n or \\r occurs -- therefore the newlines get handled by the \"skipWhitespace\" function.\r\n */\r\nfunction skipCommentLine(state) {\r\n    while (state.position < state.length) {\r\n        var c = state.data.charCodeAt(state.position);\r\n        if (c === 10 || c === 13) {\r\n            return;\r\n        }\r\n        ++state.position;\r\n    }\r\n}\r\n/**\r\n * Skips all the whitespace - space, tab, newline, CR\r\n * Handles incrementing line count.\r\n */\r\nfunction skipWhitespace(state) {\r\n    var prev = 10;\r\n    while (state.position < state.length) {\r\n        var c = state.data.charCodeAt(state.position);\r\n        switch (c) {\r\n            case 9: // '\\t'\r\n            case 32: // ' '\r\n                prev = c;\r\n                ++state.position;\r\n                break;\r\n            case 10: // \\n\r\n                // handle \\r\\n\r\n                if (prev !== 13) {\r\n                    ++state.lineNumber;\r\n                }\r\n                prev = c;\r\n                ++state.position;\r\n                break;\r\n            case 13: // \\r\r\n                prev = c;\r\n                ++state.position;\r\n                ++state.lineNumber;\r\n                break;\r\n            default:\r\n                return prev;\r\n        }\r\n    }\r\n    return prev;\r\n}\r\n/**\r\n * Returns true if there are two consecutive ' in +1 and +2 positions.\r\n */\r\nfunction isTripleQuoteAtPosition(state) {\r\n    if (state.length - state.position < 2)\r\n        return false;\r\n    if (state.data.charCodeAt(state.position + 1) !== 39)\r\n        return false; // '\r\n    if (state.data.charCodeAt(state.position + 2) !== 39)\r\n        return false; // '\r\n    return true;\r\n}\r\nfunction isData(state) {\r\n    // here we already assume the 5th char is _ and that the length >= 5\r\n    // d/D\r\n    var c = state.data.charCodeAt(state.tokenStart);\r\n    if (c !== 68 && c !== 100)\r\n        return false;\r\n    // a/A\r\n    c = state.data.charCodeAt(state.tokenStart + 1);\r\n    if (c !== 65 && c !== 97)\r\n        return false;\r\n    // t/t\r\n    c = state.data.charCodeAt(state.tokenStart + 2);\r\n    if (c !== 84 && c !== 116)\r\n        return false;\r\n    // a/A\r\n    c = state.data.charCodeAt(state.tokenStart + 3);\r\n    if (c !== 65 && c !== 97)\r\n        return false;\r\n    return true;\r\n}\r\nfunction isSave(state) {\r\n    // here we already assume the 5th char is _ and that the length >= 5\r\n    // s/S\r\n    var c = state.data.charCodeAt(state.tokenStart);\r\n    if (c !== 83 && c !== 115)\r\n        return false;\r\n    // a/A\r\n    c = state.data.charCodeAt(state.tokenStart + 1);\r\n    if (c !== 65 && c !== 97)\r\n        return false;\r\n    // v/V\r\n    c = state.data.charCodeAt(state.tokenStart + 2);\r\n    if (c !== 86 && c !== 118)\r\n        return false;\r\n    // e/E\r\n    c = state.data.charCodeAt(state.tokenStart + 3);\r\n    if (c !== 69 && c !== 101)\r\n        return false;\r\n    return true;\r\n}\r\nfunction isLoop(state) {\r\n    // here we already assume the 5th char is _ and that the length >= 5\r\n    if (state.tokenEnd - state.tokenStart !== 5)\r\n        return false;\r\n    // l/L\r\n    var c = state.data.charCodeAt(state.tokenStart);\r\n    if (c !== 76 && c !== 108)\r\n        return false;\r\n    // o/O\r\n    c = state.data.charCodeAt(state.tokenStart + 1);\r\n    if (c !== 79 && c !== 111)\r\n        return false;\r\n    // o/O\r\n    c = state.data.charCodeAt(state.tokenStart + 2);\r\n    if (c !== 79 && c !== 111)\r\n        return false;\r\n    // p/P\r\n    c = state.data.charCodeAt(state.tokenStart + 3);\r\n    if (c !== 80 && c !== 112)\r\n        return false;\r\n    return true;\r\n}\r\nfunction isImportGet(state) {\r\n    // _import.get [{'save':orient_matrix  'file':templ_attr.cif}]\r\n    if (state.tokenEnd - state.tokenStart !== 11)\r\n        return false;\r\n    if (state.data.charCodeAt(state.tokenStart + 1) !== 105)\r\n        return false; // i\r\n    if (state.data.charCodeAt(state.tokenStart + 2) !== 109)\r\n        return false; // m\r\n    if (state.data.charCodeAt(state.tokenStart + 3) !== 112)\r\n        return false; // p\r\n    if (state.data.charCodeAt(state.tokenStart + 4) !== 111)\r\n        return false; // o\r\n    if (state.data.charCodeAt(state.tokenStart + 5) !== 114)\r\n        return false; // r\r\n    if (state.data.charCodeAt(state.tokenStart + 6) !== 116)\r\n        return false; // t\r\n    if (state.data.charCodeAt(state.tokenStart + 7) !== 46)\r\n        return false; // .\r\n    if (state.data.charCodeAt(state.tokenStart + 8) !== 103)\r\n        return false; // g\r\n    if (state.data.charCodeAt(state.tokenStart + 9) !== 101)\r\n        return false; // e\r\n    if (state.data.charCodeAt(state.tokenStart + 10) !== 116)\r\n        return false; // t\r\n    return true;\r\n}\r\n/**\r\n * Checks if the current token shares the namespace with string at <start,end).\r\n */\r\nfunction isNamespace(state, start, end) {\r\n    var i;\r\n    var nsLen = end - start;\r\n    var offset = state.tokenStart - start;\r\n    var tokenLen = state.tokenEnd - state.tokenStart;\r\n    if (tokenLen < nsLen)\r\n        return false;\r\n    for (i = start; i < end; ++i) {\r\n        if (state.data.charCodeAt(i) !== state.data.charCodeAt(i + offset))\r\n            return false;\r\n    }\r\n    if (nsLen === tokenLen)\r\n        return true;\r\n    if (state.data.charCodeAt(i + offset) === 46) { // .\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Returns the index of '.' in the current token. If no '.' is present, returns currentTokenEnd.\r\n */\r\nfunction getNamespaceEnd(state) {\r\n    var i;\r\n    for (i = state.tokenStart; i < state.tokenEnd; ++i) {\r\n        if (state.data.charCodeAt(i) === 46)\r\n            return i;\r\n    }\r\n    return i;\r\n}\r\n/**\r\n * Get the namespace string. endIndex is obtained by the getNamespaceEnd() function.\r\n */\r\nfunction getNamespace(state, endIndex) {\r\n    return state.data.substring(state.tokenStart, endIndex);\r\n}\r\n/**\r\n * Returns true if the current token contain no '.', otherwise returns false.\r\n */\r\nfunction isFlatNamespace(state) {\r\n    var i;\r\n    for (i = state.tokenStart; i < state.tokenEnd; ++i) {\r\n        if (state.data.charCodeAt(i) === 46)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * String representation of the current token.\r\n */\r\nfunction getTokenString(state) {\r\n    return state.data.substring(state.tokenStart, state.tokenEnd);\r\n}\r\n/**\r\n * Move to the next token.\r\n */\r\nfunction moveNextInternal(state) {\r\n    var prev = skipWhitespace(state);\r\n    if (state.position >= state.length) {\r\n        state.tokenType = 6 /* End */;\r\n        return;\r\n    }\r\n    state.tokenStart = state.position;\r\n    state.tokenEnd = state.position;\r\n    state.isEscaped = false;\r\n    var c = state.data.charCodeAt(state.position);\r\n    switch (c) {\r\n        case 35: // #, comment\r\n            skipCommentLine(state);\r\n            state.tokenType = 5 /* Comment */;\r\n            break;\r\n        case 39: // ', escaped value\r\n            if (isTripleQuoteAtPosition(state)) {\r\n                eatTripleQuote(state);\r\n                state.tokenType = 3 /* Value */;\r\n                break;\r\n            }\r\n        case 34: // \", escaped value\r\n            eatEscaped(state, c);\r\n            state.tokenType = 3 /* Value */;\r\n            break;\r\n        case 59: // ;, possible multiline value\r\n            // multiline value must start at the beginning of the line.\r\n            if (prev === 10 || prev === 13) { // /n or /r\r\n                eatMultiline(state);\r\n            }\r\n            else {\r\n                eatValue(state);\r\n            }\r\n            state.tokenType = 3 /* Value */;\r\n            break;\r\n        default:\r\n            if (state.isImportGet) {\r\n                eatImportGet(state);\r\n            }\r\n            else {\r\n                eatValue(state);\r\n            }\r\n            // escaped is always Value\r\n            if (state.isEscaped) {\r\n                state.tokenType = 3 /* Value */;\r\n                // _ means column name, including _import.get\r\n            }\r\n            else if (state.data.charCodeAt(state.tokenStart) === 95) { // _\r\n                if (state.inSaveFrame && isImportGet(state)) {\r\n                    state.isImportGet = true;\r\n                }\r\n                state.tokenType = 4 /* ColumnName */;\r\n                // 5th char needs to be _ for data_, save_ or loop_\r\n            }\r\n            else if (state.tokenEnd - state.tokenStart >= 5 && state.data.charCodeAt(state.tokenStart + 4) === 95) {\r\n                if (isData(state))\r\n                    state.tokenType = 0 /* Data */;\r\n                else if (isSave(state))\r\n                    state.tokenType = 1 /* Save */;\r\n                else if (isLoop(state))\r\n                    state.tokenType = 2 /* Loop */;\r\n                else\r\n                    state.tokenType = 3 /* Value */;\r\n                // all other tests failed, we are at Value token.\r\n            }\r\n            else {\r\n                state.tokenType = 3 /* Value */;\r\n            }\r\n            break;\r\n    }\r\n}\r\n/**\r\n * Moves to the next non-comment token.\r\n */\r\nfunction moveNext(state) {\r\n    moveNextInternal(state);\r\n    while (state.tokenType === 5 /* Comment */)\r\n        moveNextInternal(state);\r\n}\r\nfunction createTokenizer(data, runtimeCtx) {\r\n    return {\r\n        data: data,\r\n        length: data.length,\r\n        position: 0,\r\n        tokenStart: 0,\r\n        tokenEnd: 0,\r\n        tokenType: 6 /* End */,\r\n        lineNumber: 1,\r\n        isEscaped: false,\r\n        isImportGet: false,\r\n        inSaveFrame: false,\r\n        runtimeCtx: runtimeCtx\r\n    };\r\n}\r\nfunction FrameContext() {\r\n    return { categoryNames: [], categoryData: Object.create(null) };\r\n}\r\nfunction CifCategories(categoryNames, categoryData) {\r\n    var categories = Object.create(null);\r\n    for (var _i = 0, categoryNames_1 = categoryNames; _i < categoryNames_1.length; _i++) {\r\n        var name_1 = categoryNames_1[_i];\r\n        var d = categoryData[name_1];\r\n        categories[name_1] = Data.CifCategory(d.name, d.rowCount, d.fieldNames, d.fields);\r\n    }\r\n    return categories;\r\n}\r\nfunction CifBlock(ctx, header, saveFrames) {\r\n    return Data.CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header, saveFrames);\r\n}\r\nfunction CifSaveFrame(ctx, header) {\r\n    return Data.CifBlock(ctx.categoryNames, CifCategories(ctx.categoryNames, ctx.categoryData), header);\r\n}\r\nfunction addFields(ctx, name, rowCount, fieldNames, fields) {\r\n    var _a;\r\n    if (name in ctx.categoryData) {\r\n        var cat = ctx.categoryData[name];\r\n        (_a = cat.fieldNames).push.apply(_a, fieldNames);\r\n        Object.assign(cat.fields, fields);\r\n    }\r\n    else {\r\n        ctx.categoryData[name] = { name: name, rowCount: rowCount, fieldNames: fieldNames, fields: fields };\r\n        ctx.categoryNames.push(name);\r\n    }\r\n}\r\n/**\r\n * Reads a category containing a single row.\r\n */\r\nfunction handleSingle(tokenizer, ctx) {\r\n    var nsStart = tokenizer.tokenStart, nsEnd = getNamespaceEnd(tokenizer);\r\n    var name = getNamespace(tokenizer, nsEnd);\r\n    var fields = Object.create(null);\r\n    var fieldNames = [];\r\n    var readingNames = true;\r\n    while (readingNames) {\r\n        if (tokenizer.tokenType !== 4 /* ColumnName */ || !isNamespace(tokenizer, nsStart, nsEnd)) {\r\n            readingNames = false;\r\n            break;\r\n        }\r\n        var fieldName = getTokenString(tokenizer).substring(name.length + 1);\r\n        moveNext(tokenizer);\r\n        if (tokenizer.tokenType !== 3 /* Value */) {\r\n            return {\r\n                hasError: true,\r\n                errorLine: tokenizer.lineNumber,\r\n                errorMessage: 'Expected value.'\r\n            };\r\n        }\r\n        fields[fieldName] = Data.CifField.ofTokens({ data: tokenizer.data, indices: [tokenizer.tokenStart, tokenizer.tokenEnd], count: 1 });\r\n        fieldNames[fieldNames.length] = fieldName;\r\n        moveNext(tokenizer);\r\n    }\r\n    addFields(ctx, name.substr(1), 1, fieldNames, fields);\r\n    return {\r\n        hasError: false,\r\n        errorLine: 0,\r\n        errorMessage: ''\r\n    };\r\n}\r\nfunction readLoopChunk(chunkSize, state) {\r\n    var tokenizer = state.tokenizer, tokens = state.tokens, fieldCount = state.fieldCount;\r\n    var tokenCount = state.tokenCount;\r\n    var counter = 0;\r\n    while (tokenizer.tokenType === 3 /* Value */ && counter < chunkSize) {\r\n        TokenBuilder.add(tokens[(tokenCount++) % fieldCount], tokenizer.tokenStart, tokenizer.tokenEnd);\r\n        moveNext(tokenizer);\r\n        counter++;\r\n    }\r\n    state.tokenCount = tokenCount;\r\n    return counter;\r\n}\r\nfunction updateLoopChunk(ctx, state) {\r\n    return ctx.update({ message: 'Parsing...', current: state.tokenizer.position, max: state.tokenizer.data.length });\r\n}\r\n// const readLoopChunks = ChunkedSubtask(1000000,\r\n//     (size, state: LoopReadState) => readLoopChunk(state, size),\r\n//     (ctx, state) => ctx.update({ message: 'Parsing...', current: state.tokenizer.position, max: state.tokenizer.data.length }));\r\n/**\r\n * Reads a loop.\r\n */\r\nfunction handleLoop(tokenizer, ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var loopLine, name, isFlat, fieldNames, rowCountEstimate, tokens, fieldCount, i, state, rowCount, i, fields, fields, i;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    loopLine = tokenizer.lineNumber;\r\n                    moveNext(tokenizer);\r\n                    name = getNamespace(tokenizer, getNamespaceEnd(tokenizer));\r\n                    isFlat = isFlatNamespace(tokenizer);\r\n                    fieldNames = [];\r\n                    while (tokenizer.tokenType === 4 /* ColumnName */) {\r\n                        fieldNames[fieldNames.length] = isFlat\r\n                            ? getTokenString(tokenizer)\r\n                            : getTokenString(tokenizer).substring(name.length + 1);\r\n                        moveNext(tokenizer);\r\n                    }\r\n                    rowCountEstimate = name === '_atom_site' ? (tokenizer.data.length / 100) | 0 : 32;\r\n                    tokens = [];\r\n                    fieldCount = fieldNames.length;\r\n                    for (i = 0; i < fieldCount; i++)\r\n                        tokens[i] = TokenBuilder.create(tokenizer.data, rowCountEstimate);\r\n                    state = {\r\n                        fieldCount: fieldCount,\r\n                        tokenCount: 0,\r\n                        tokenizer: tokenizer,\r\n                        tokens: tokens\r\n                    };\r\n                    return [4 /*yield*/, chunkedSubtask(tokenizer.runtimeCtx, 1000000, state, readLoopChunk, updateLoopChunk)];\r\n                case 1:\r\n                    _a.sent();\r\n                    if (state.tokenCount % fieldCount !== 0) {\r\n                        return [2 /*return*/, {\r\n                                hasError: true,\r\n                                errorLine: tokenizer.lineNumber,\r\n                                errorMessage: \"The number of values for loop starting at line \" + loopLine + \" is not a multiple of the number of columns.\"\r\n                            }];\r\n                    }\r\n                    rowCount = (state.tokenCount / fieldCount) | 0;\r\n                    if (isFlat) {\r\n                        for (i = 0; i < fieldCount; i++) {\r\n                            fields = { '': Data.CifField.ofTokens(tokens[i]) };\r\n                            addFields(ctx, fieldNames[i].substr(1), rowCount, [''], fields);\r\n                        }\r\n                    }\r\n                    else {\r\n                        fields = Object.create(null);\r\n                        for (i = 0; i < fieldCount; i++) {\r\n                            fields[fieldNames[i]] = Data.CifField.ofTokens(tokens[i]);\r\n                        }\r\n                        addFields(ctx, name.substr(1), rowCount, fieldNames, fields);\r\n                    }\r\n                    return [2 /*return*/, {\r\n                            hasError: false,\r\n                            errorLine: 0,\r\n                            errorMessage: ''\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Creates an error result.\r\n */\r\nfunction error(line, message) {\r\n    return Result.error(message, line);\r\n}\r\n/**\r\n * Creates a data result.\r\n */\r\nfunction result(data) {\r\n    return Result.success(data);\r\n}\r\n/**\r\n * Parses an mmCIF file.\r\n *\r\n * @returns CifParserResult wrapper of the result.\r\n */\r\nfunction parseInternal(data, runtimeCtx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var dataBlocks, tokenizer, blockHeader, blockCtx, saveFrames, saveCtx, saveFrame, saveHeader, token, cat, cat;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    dataBlocks = [];\r\n                    tokenizer = createTokenizer(data, runtimeCtx);\r\n                    blockHeader = '';\r\n                    blockCtx = FrameContext();\r\n                    saveFrames = [];\r\n                    saveCtx = FrameContext();\r\n                    saveFrame = Data.CifSaveFrame(saveCtx.categoryNames, CifCategories(saveCtx.categoryNames, saveCtx.categoryData), '');\r\n                    saveHeader = '';\r\n                    runtimeCtx.update({ message: 'Parsing...', current: 0, max: data.length });\r\n                    moveNext(tokenizer);\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(tokenizer.tokenType !== 6 /* End */)) return [3 /*break*/, 7];\r\n                    token = tokenizer.tokenType;\r\n                    if (!(token === 0 /* Data */)) return [3 /*break*/, 2];\r\n                    if (tokenizer.inSaveFrame) {\r\n                        return [2 /*return*/, error(tokenizer.lineNumber, 'Unexpected data block inside a save frame.')];\r\n                    }\r\n                    if (blockCtx.categoryNames.length > 0) {\r\n                        dataBlocks.push(CifBlock(blockCtx, blockHeader, saveFrames));\r\n                    }\r\n                    blockHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);\r\n                    blockCtx = FrameContext();\r\n                    saveFrames = [];\r\n                    moveNext(tokenizer);\r\n                    return [3 /*break*/, 6];\r\n                case 2:\r\n                    if (!(token === 1 /* Save */)) return [3 /*break*/, 3];\r\n                    if (tokenizer.tokenEnd - tokenizer.tokenStart === 5) { // end of save frame\r\n                        if (saveCtx.categoryNames.length > 0) {\r\n                            saveFrames[saveFrames.length] = CifSaveFrame(saveCtx, saveHeader);\r\n                        }\r\n                        tokenizer.inSaveFrame = false;\r\n                    }\r\n                    else { // start of save frame\r\n                        if (tokenizer.inSaveFrame) {\r\n                            return [2 /*return*/, error(tokenizer.lineNumber, 'Save frames cannot be nested.')];\r\n                        }\r\n                        tokenizer.inSaveFrame = true;\r\n                        saveHeader = data.substring(tokenizer.tokenStart + 5, tokenizer.tokenEnd);\r\n                        saveCtx = FrameContext();\r\n                        // saveFrame = CifSaveFrame(saveCtx, saveHeader);\r\n                    }\r\n                    moveNext(tokenizer);\r\n                    return [3 /*break*/, 6];\r\n                case 3:\r\n                    if (!(token === 2 /* Loop */)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, handleLoop(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx)];\r\n                case 4:\r\n                    cat = _a.sent();\r\n                    if (cat.hasError) {\r\n                        return [2 /*return*/, error(cat.errorLine, cat.errorMessage)];\r\n                    }\r\n                    return [3 /*break*/, 6];\r\n                case 5:\r\n                    if (token === 4 /* ColumnName */) {\r\n                        cat = handleSingle(tokenizer, tokenizer.inSaveFrame ? saveCtx : blockCtx);\r\n                        if (cat.hasError) {\r\n                            return [2 /*return*/, error(cat.errorLine, cat.errorMessage)];\r\n                        }\r\n                        // Out of options\r\n                    }\r\n                    else {\r\n                        console.log(tokenizer.tokenType, Tokenizer.getTokenString(tokenizer));\r\n                        return [2 /*return*/, error(tokenizer.lineNumber, 'Unexpected token. Expected data_, loop_, or data name.')];\r\n                    }\r\n                    _a.label = 6;\r\n                case 6: return [3 /*break*/, 1];\r\n                case 7:\r\n                    // Check if the latest save frame was closed.\r\n                    if (tokenizer.inSaveFrame) {\r\n                        return [2 /*return*/, error(tokenizer.lineNumber, \"Unfinished save frame (\" + saveFrame.header + \").\")];\r\n                    }\r\n                    if (blockCtx.categoryNames.length > 0 || saveFrames.length > 0) {\r\n                        dataBlocks.push(CifBlock(blockCtx, blockHeader, saveFrames));\r\n                    }\r\n                    return [2 /*return*/, result(Data.CifFile(dataBlocks))];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function parseCifText(data) {\r\n    var _this = this;\r\n    return Task.create('Parse CIF', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, parseInternal(data, ctx)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}