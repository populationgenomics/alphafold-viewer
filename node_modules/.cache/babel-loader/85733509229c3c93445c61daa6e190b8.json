{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\nimport { transformPositionArray, createGroupMapping } from '../../util';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { createSizes } from '../size-data';\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { hashFnv32a } from '../../../mol-data/util';\nimport { createEmptyClipping } from '../clipping-data';\nexport var Points;\n\n(function (Points) {\n  function create(centers, groups, pointCount, points) {\n    return points ? update(centers, groups, pointCount, points) : fromArrays(centers, groups, pointCount);\n  }\n\n  Points.create = create;\n\n  function createEmpty(points) {\n    var cb = points ? points.centerBuffer.ref.value : new Float32Array(0);\n    var gb = points ? points.groupBuffer.ref.value : new Float32Array(0);\n    return create(cb, gb, 0, points);\n  }\n\n  Points.createEmpty = createEmpty;\n\n  function hashCode(points) {\n    return hashFnv32a([points.pointCount, points.centerBuffer.ref.version, points.groupBuffer.ref.version]);\n  }\n\n  function fromArrays(centers, groups, pointCount) {\n    var boundingSphere = Sphere3D();\n    var groupMapping;\n    var currentHash = -1;\n    var currentGroup = -1;\n    var points = {\n      kind: 'points',\n      pointCount: pointCount,\n      centerBuffer: ValueCell.create(centers),\n      groupBuffer: ValueCell.create(groups),\n\n      get boundingSphere() {\n        var newHash = hashCode(points);\n\n        if (newHash !== currentHash) {\n          var b = calculateInvariantBoundingSphere(points.centerBuffer.ref.value, points.pointCount, 1);\n          Sphere3D.copy(boundingSphere, b);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      },\n\n      get groupMapping() {\n        if (points.groupBuffer.ref.version !== currentGroup) {\n          groupMapping = createGroupMapping(points.groupBuffer.ref.value, points.pointCount);\n          currentGroup = points.groupBuffer.ref.version;\n        }\n\n        return groupMapping;\n      },\n\n      setBoundingSphere: function (sphere) {\n        Sphere3D.copy(boundingSphere, sphere);\n        currentHash = hashCode(points);\n      }\n    };\n    return points;\n  }\n\n  function update(centers, groups, pointCount, points) {\n    points.pointCount = pointCount;\n    ValueCell.update(points.centerBuffer, centers);\n    ValueCell.update(points.groupBuffer, groups);\n    return points;\n  }\n\n  function transform(points, t) {\n    var c = points.centerBuffer.ref.value;\n    transformPositionArray(t, c, 0, points.pointCount);\n    ValueCell.update(points.centerBuffer, c);\n  }\n\n  Points.transform = transform; //\n\n  Points.StyleTypes = {\n    'square': 'Square',\n    'circle': 'Circle',\n    'fuzzy': 'Fuzzy'\n  };\n  Points.StyleTypeNames = Object.keys(Points.StyleTypes);\n  Points.Params = __assign(__assign({}, BaseGeometry.Params), {\n    sizeFactor: PD.Numeric(3, {\n      min: 0,\n      max: 10,\n      step: 0.1\n    }),\n    pointSizeAttenuation: PD.Boolean(false),\n    pointStyle: PD.Select('square', PD.objectToOptions(Points.StyleTypes))\n  });\n  Points.Utils = {\n    Params: Points.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: createRenderableState,\n    updateRenderableState: updateRenderableState,\n    createPositionIterator: createPositionIterator\n  };\n\n  function createPositionIterator(points, transform) {\n    var groupCount = points.pointCount;\n    var instanceCount = transform.instanceCount.ref.value;\n    var location = PositionLocation();\n    var p = location.position;\n    var v = points.centerBuffer.ref.value;\n    var m = transform.aTransform.ref.value;\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      if (instanceIndex < 0) {\n        Vec3.fromArray(p, v, groupIndex * 3);\n      } else {\n        Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\n      }\n\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  function createValues(points, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = createPositionIterator(points, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var size = createSizes(locationIt, theme.size);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: points.pointCount,\n      vertexCount: points.pointCount,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var invariantBoundingSphere = Sphere3D.clone(points.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      aPosition: points.centerBuffer,\n      aGroup: points.groupBuffer,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), size), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), {\n      uSizeFactor: ValueCell.create(props.sizeFactor),\n      dPointSizeAttenuation: ValueCell.create(props.pointSizeAttenuation),\n      dPointStyle: ValueCell.create(props.pointStyle)\n    });\n  }\n\n  function createValuesSimple(points, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Points.Params)), props);\n\n    return createValues(points, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\n    ValueCell.updateIfChanged(values.dPointSizeAttenuation, props.pointSizeAttenuation);\n    ValueCell.updateIfChanged(values.dPointStyle, props.pointStyle);\n  }\n\n  function updateBoundingSphere(values, points) {\n    var invariantBoundingSphere = Sphere3D.clone(points.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n\n  function createRenderableState(props) {\n    var state = BaseGeometry.createRenderableState(props);\n    updateRenderableState(state, props);\n    return state;\n  }\n\n  function updateRenderableState(state, props) {\n    BaseGeometry.updateRenderableState(state, props);\n    state.opaque = state.opaque && props.pointStyle !== 'fuzzy';\n    state.writeDepth = state.opaque;\n  }\n})(Points || (Points = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/points/points.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { transformPositionArray, createGroupMapping } from '../../util';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { createSizes } from '../size-data';\r\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { hashFnv32a } from '../../../mol-data/util';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nexport var Points;\r\n(function (Points) {\r\n    function create(centers, groups, pointCount, points) {\r\n        return points ?\r\n            update(centers, groups, pointCount, points) :\r\n            fromArrays(centers, groups, pointCount);\r\n    }\r\n    Points.create = create;\r\n    function createEmpty(points) {\r\n        var cb = points ? points.centerBuffer.ref.value : new Float32Array(0);\r\n        var gb = points ? points.groupBuffer.ref.value : new Float32Array(0);\r\n        return create(cb, gb, 0, points);\r\n    }\r\n    Points.createEmpty = createEmpty;\r\n    function hashCode(points) {\r\n        return hashFnv32a([\r\n            points.pointCount, points.centerBuffer.ref.version, points.groupBuffer.ref.version,\r\n        ]);\r\n    }\r\n    function fromArrays(centers, groups, pointCount) {\r\n        var boundingSphere = Sphere3D();\r\n        var groupMapping;\r\n        var currentHash = -1;\r\n        var currentGroup = -1;\r\n        var points = {\r\n            kind: 'points',\r\n            pointCount: pointCount,\r\n            centerBuffer: ValueCell.create(centers),\r\n            groupBuffer: ValueCell.create(groups),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(points);\r\n                if (newHash !== currentHash) {\r\n                    var b = calculateInvariantBoundingSphere(points.centerBuffer.ref.value, points.pointCount, 1);\r\n                    Sphere3D.copy(boundingSphere, b);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n            get groupMapping() {\r\n                if (points.groupBuffer.ref.version !== currentGroup) {\r\n                    groupMapping = createGroupMapping(points.groupBuffer.ref.value, points.pointCount);\r\n                    currentGroup = points.groupBuffer.ref.version;\r\n                }\r\n                return groupMapping;\r\n            },\r\n            setBoundingSphere: function (sphere) {\r\n                Sphere3D.copy(boundingSphere, sphere);\r\n                currentHash = hashCode(points);\r\n            }\r\n        };\r\n        return points;\r\n    }\r\n    function update(centers, groups, pointCount, points) {\r\n        points.pointCount = pointCount;\r\n        ValueCell.update(points.centerBuffer, centers);\r\n        ValueCell.update(points.groupBuffer, groups);\r\n        return points;\r\n    }\r\n    function transform(points, t) {\r\n        var c = points.centerBuffer.ref.value;\r\n        transformPositionArray(t, c, 0, points.pointCount);\r\n        ValueCell.update(points.centerBuffer, c);\r\n    }\r\n    Points.transform = transform;\r\n    //\r\n    Points.StyleTypes = {\r\n        'square': 'Square',\r\n        'circle': 'Circle',\r\n        'fuzzy': 'Fuzzy',\r\n    };\r\n    Points.StyleTypeNames = Object.keys(Points.StyleTypes);\r\n    Points.Params = __assign(__assign({}, BaseGeometry.Params), { sizeFactor: PD.Numeric(3, { min: 0, max: 10, step: 0.1 }), pointSizeAttenuation: PD.Boolean(false), pointStyle: PD.Select('square', PD.objectToOptions(Points.StyleTypes)) });\r\n    Points.Utils = {\r\n        Params: Points.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: createRenderableState,\r\n        updateRenderableState: updateRenderableState,\r\n        createPositionIterator: createPositionIterator\r\n    };\r\n    function createPositionIterator(points, transform) {\r\n        var groupCount = points.pointCount;\r\n        var instanceCount = transform.instanceCount.ref.value;\r\n        var location = PositionLocation();\r\n        var p = location.position;\r\n        var v = points.centerBuffer.ref.value;\r\n        var m = transform.aTransform.ref.value;\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            if (instanceIndex < 0) {\r\n                Vec3.fromArray(p, v, groupIndex * 3);\r\n            }\r\n            else {\r\n                Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\r\n            }\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    function createValues(points, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = createPositionIterator(points, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var size = createSizes(locationIt, theme.size);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: points.pointCount, vertexCount: points.pointCount, groupCount: groupCount, instanceCount: instanceCount };\r\n        var invariantBoundingSphere = Sphere3D.clone(points.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ aPosition: points.centerBuffer, aGroup: points.groupBuffer, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), size), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), { uSizeFactor: ValueCell.create(props.sizeFactor), dPointSizeAttenuation: ValueCell.create(props.pointSizeAttenuation), dPointStyle: ValueCell.create(props.pointStyle) });\r\n    }\r\n    function createValuesSimple(points, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Points.Params)), props);\r\n        return createValues(points, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\r\n        ValueCell.updateIfChanged(values.dPointSizeAttenuation, props.pointSizeAttenuation);\r\n        ValueCell.updateIfChanged(values.dPointStyle, props.pointStyle);\r\n    }\r\n    function updateBoundingSphere(values, points) {\r\n        var invariantBoundingSphere = Sphere3D.clone(points.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n    function createRenderableState(props) {\r\n        var state = BaseGeometry.createRenderableState(props);\r\n        updateRenderableState(state, props);\r\n        return state;\r\n    }\r\n    function updateRenderableState(state, props) {\r\n        BaseGeometry.updateRenderableState(state, props);\r\n        state.opaque = state.opaque && props.pointStyle !== 'fuzzy';\r\n        state.writeDepth = state.opaque;\r\n    }\r\n})(Points || (Points = {}));\r\n//# sourceMappingURL=points.js.map"]},"metadata":{},"sourceType":"module"}