{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../mol-task';\nimport { Coordinates, Time } from '../../mol-model/structure/coordinates';\nimport { Vec3 } from '../../mol-math/linear-algebra';\nimport { degToRad, halfPI } from '../../mol-math/misc';\nimport { Cell } from '../../mol-math/geometry/spacegroup/cell';\nimport { EPSILON, equalEps } from '../../mol-math/linear-algebra/3d/common';\nvar charmmTimeUnitFactor = 20.45482949774598;\nexport function coordinatesFromDcd(dcdFile) {\n  var _this = this;\n\n  return Task.create('Parse DCD', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var header, deltaTime, offsetTime, frames, i, il, dcdFrame, frame, c;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , ctx.update('Converting to coordinates')];\n\n          case 1:\n            _a.sent();\n\n            header = dcdFile.header;\n            deltaTime = header.DELTA ? Time(header.DELTA * charmmTimeUnitFactor, 'ps') : Time(1, 'step');\n            offsetTime = header.ISTART >= 1 ? Time((header.ISTART - 1) * deltaTime.value, deltaTime.unit) : Time(0, deltaTime.unit);\n            frames = [];\n\n            for (i = 0, il = dcdFile.frames.length; i < il; ++i) {\n              dcdFrame = dcdFile.frames[i];\n              frame = {\n                elementCount: dcdFrame.elementCount,\n                time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit),\n                x: dcdFrame.x,\n                y: dcdFrame.y,\n                z: dcdFrame.z,\n                xyzOrdering: {\n                  isIdentity: true\n                }\n              };\n\n              if (dcdFrame.cell) {\n                c = dcdFrame.cell;\n\n                if (c[1] >= -1 && c[1] <= 1 && c[3] >= -1 && c[3] <= 1 && c[4] >= -1 && c[4] <= 1) {\n                  frame.cell = Cell.create(Vec3.create(c[0], c[2], c[5]), Vec3.create(degToRad(90 - Math.asin(c[1]) * 90 / halfPI), degToRad(90 - Math.asin(c[3]) * 90 / halfPI), degToRad(90 - Math.asin(c[4]) * 90 / halfPI)));\n                } else if (c[0] < 0 || c[1] < 0 || c[2] < 0 || c[3] < 0 || c[4] < 0 || c[5] < 0 || c[3] > 180 || c[4] > 180 || c[5] > 180) {\n                  frame.cell = Cell.fromBasis(Vec3.create(c[0], c[1], c[3]), Vec3.create(c[1], c[2], c[4]), Vec3.create(c[3], c[4], c[5]));\n                } else {\n                  frame.cell = Cell.create(Vec3.create(c[0], c[2], c[5]), // interpret angles very close to 0 as 90 deg\n                  Vec3.create(degToRad(equalEps(c[1], 0, EPSILON) ? 90 : c[1]), degToRad(equalEps(c[3], 0, EPSILON) ? 90 : c[3]), degToRad(equalEps(c[4], 0, EPSILON) ? 90 : c[4])));\n                }\n              }\n\n              frames.push(frame);\n            }\n\n            return [2\n            /*return*/\n            , Coordinates.create(frames, deltaTime, offsetTime)];\n        }\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/mol-model-formats/structure/dcd.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../mol-task';\r\nimport { Coordinates, Time } from '../../mol-model/structure/coordinates';\r\nimport { Vec3 } from '../../mol-math/linear-algebra';\r\nimport { degToRad, halfPI } from '../../mol-math/misc';\r\nimport { Cell } from '../../mol-math/geometry/spacegroup/cell';\r\nimport { EPSILON, equalEps } from '../../mol-math/linear-algebra/3d/common';\r\nvar charmmTimeUnitFactor = 20.45482949774598;\r\nexport function coordinatesFromDcd(dcdFile) {\r\n    var _this = this;\r\n    return Task.create('Parse DCD', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var header, deltaTime, offsetTime, frames, i, il, dcdFrame, frame, c;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, ctx.update('Converting to coordinates')];\r\n                case 1:\r\n                    _a.sent();\r\n                    header = dcdFile.header;\r\n                    deltaTime = header.DELTA\r\n                        ? Time(header.DELTA * charmmTimeUnitFactor, 'ps')\r\n                        : Time(1, 'step');\r\n                    offsetTime = header.ISTART >= 1\r\n                        ? Time((header.ISTART - 1) * deltaTime.value, deltaTime.unit)\r\n                        : Time(0, deltaTime.unit);\r\n                    frames = [];\r\n                    for (i = 0, il = dcdFile.frames.length; i < il; ++i) {\r\n                        dcdFrame = dcdFile.frames[i];\r\n                        frame = {\r\n                            elementCount: dcdFrame.elementCount,\r\n                            time: Time(offsetTime.value + deltaTime.value * i, deltaTime.unit),\r\n                            x: dcdFrame.x,\r\n                            y: dcdFrame.y,\r\n                            z: dcdFrame.z,\r\n                            xyzOrdering: { isIdentity: true }\r\n                        };\r\n                        if (dcdFrame.cell) {\r\n                            c = dcdFrame.cell;\r\n                            if (c[1] >= -1 && c[1] <= 1 && c[3] >= -1 && c[3] <= 1 && c[4] >= -1 && c[4] <= 1) {\r\n                                frame.cell = Cell.create(Vec3.create(c[0], c[2], c[5]), Vec3.create(degToRad(90 - Math.asin(c[1]) * 90 / halfPI), degToRad(90 - Math.asin(c[3]) * 90 / halfPI), degToRad(90 - Math.asin(c[4]) * 90 / halfPI)));\r\n                            }\r\n                            else if (c[0] < 0 || c[1] < 0 || c[2] < 0 || c[3] < 0 || c[4] < 0 || c[5] < 0 ||\r\n                                c[3] > 180 || c[4] > 180 || c[5] > 180) {\r\n                                frame.cell = Cell.fromBasis(Vec3.create(c[0], c[1], c[3]), Vec3.create(c[1], c[2], c[4]), Vec3.create(c[3], c[4], c[5]));\r\n                            }\r\n                            else {\r\n                                frame.cell = Cell.create(Vec3.create(c[0], c[2], c[5]), \r\n                                // interpret angles very close to 0 as 90 deg\r\n                                Vec3.create(degToRad(equalEps(c[1], 0, EPSILON) ? 90 : c[1]), degToRad(equalEps(c[3], 0, EPSILON) ? 90 : c[3]), degToRad(equalEps(c[4], 0, EPSILON) ? 90 : c[4])));\r\n                            }\r\n                        }\r\n                        frames.push(frame);\r\n                    }\r\n                    return [2 /*return*/, Coordinates.create(frames, deltaTime, offsetTime)];\r\n            }\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=dcd.js.map"]},"metadata":{},"sourceType":"module"}