{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { StateObject, StateObjectSelector } from './object';\nimport { StateTree } from './tree';\nimport { StateTransform } from './transform';\nimport { StateTransformer } from './transformer';\nimport { Task } from '../mol-task';\nimport { StateSelection } from './state/selection';\nimport { RxEventHelper } from '../mol-util/rx-event-helper';\nimport { StateBuilder } from './state/builder';\nimport { StateActionManager } from './action/manager';\nimport { LogEntry } from '../mol-util/log-entry';\nimport { now, formatTimespan } from '../mol-util/now';\nimport { ParamDefinition } from '../mol-util/param-definition';\nimport { StateTreeSpine } from './tree/spine';\nimport { AsyncQueue } from '../mol-util/async-queue';\nimport { isProductionMode } from '../mol-util/debug';\nimport { arraySetAdd, arraySetRemove } from '../mol-util/array';\nimport { UniqueArray } from '../mol-data/generic';\nimport { assignIfUndefined } from '../mol-util/object';\nexport { State };\n\nvar State =\n/** @class */\nfunction () {\n  function State(rootObject, params) {\n    var _this = this;\n\n    this.errorFree = true;\n    this.ev = RxEventHelper.create();\n    this.globalContext = void 0;\n    this.events = {\n      cell: {\n        stateUpdated: this.ev(),\n        created: this.ev(),\n        removed: this.ev()\n      },\n      object: {\n        updated: this.ev(),\n        created: this.ev(),\n        removed: this.ev()\n      },\n      log: this.ev(),\n      changed: this.ev(),\n      historyUpdated: this.ev()\n    };\n    this.behaviors = {\n      currentObject: this.ev.behavior({\n        state: this,\n        ref: StateTransform.RootRef\n      }),\n      isUpdating: this.ev.behavior(false)\n    };\n    this.actions = new StateActionManager();\n    this.cells = new Map();\n    this.spine = new StateTreeSpine.Impl(this.cells);\n\n    this.tryGetCellData = function (ref) {\n      var _a, _b;\n\n      var ret = (_b = (_a = _this.cells.get(ref)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;\n      if (!ref) throw new Error(\"Cell '\" + ref + \"' data undefined.\");\n      return ret;\n    };\n\n    this.historyCapacity = 5;\n    this.history = [];\n    this.undoingHistory = false;\n    this.inTransaction = false;\n    this.inTransactionError = false;\n    this._inUpdate = false;\n    this.reverted = false;\n    this.updateQueue = new AsyncQueue();\n    this._tree = StateTree.createEmpty(StateTransform.createRoot(params && params.rootState)).asTransient();\n    var tree = this._tree;\n    var root = tree.root;\n    this.runTask = params.runTask;\n    if ((params === null || params === void 0 ? void 0 : params.historyCapacity) !== void 0) this.historyCapacity = params.historyCapacity;\n    this.cells.set(root.ref, {\n      parent: this,\n      transform: root,\n      sourceRef: void 0,\n      obj: rootObject,\n      status: 'ok',\n      state: __assign({}, root.state),\n      errorText: void 0,\n      params: {\n        definition: {},\n        values: {}\n      },\n      paramsNormalizedVersion: root.version,\n      dependencies: {\n        dependentBy: [],\n        dependsOn: []\n      },\n      cache: {}\n    });\n    this.globalContext = params && params.globalContext;\n  }\n\n  Object.defineProperty(State.prototype, \"tree\", {\n    get: function () {\n      return this._tree;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State.prototype, \"transforms\", {\n    get: function () {\n      return this._tree.transforms;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State.prototype, \"current\", {\n    get: function () {\n      return this.behaviors.currentObject.value.ref;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State.prototype, \"root\", {\n    get: function () {\n      return this.cells.get(this._tree.root.ref);\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  State.prototype.build = function () {\n    return new StateBuilder.Root(this.tree, this);\n  };\n\n  State.prototype.addHistory = function (tree, label) {\n    if (this.historyCapacity === 0) return;\n    this.history.unshift([tree, label || 'Update']);\n    if (this.history.length > this.historyCapacity) this.history.pop();\n    this.events.historyUpdated.next({\n      state: this\n    });\n  };\n\n  State.prototype.clearHistory = function () {\n    if (this.history.length === 0) return;\n    this.history = [];\n    this.events.historyUpdated.next({\n      state: this\n    });\n  };\n\n  Object.defineProperty(State.prototype, \"latestUndoLabel\", {\n    get: function () {\n      return this.history.length > 0 ? this.history[0][1] : void 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(State.prototype, \"canUndo\", {\n    get: function () {\n      return this.history.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  State.prototype.undo = function () {\n    var _this = this;\n\n    return Task.create('Undo', function (ctx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var e;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              e = this.history.shift();\n              if (!e) return [2\n              /*return*/\n              ];\n              this.events.historyUpdated.next({\n                state: this\n              });\n              this.undoingHistory = true;\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1,, 3, 4]);\n\n              return [4\n              /*yield*/\n              , this.updateTree(e[0], {\n                canUndo: false\n              }).runInContext(ctx)];\n\n            case 2:\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 4];\n\n            case 3:\n              this.undoingHistory = false;\n              return [7\n              /*endfinally*/\n              ];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  State.prototype.getSnapshot = function () {\n    return {\n      tree: StateTree.toJSON(this._tree)\n    };\n  };\n\n  State.prototype.setSnapshot = function (snapshot) {\n    var tree = StateTree.fromJSON(snapshot.tree);\n    return this.updateTree(tree);\n  };\n\n  State.prototype.setCurrent = function (ref) {\n    this.behaviors.currentObject.next({\n      state: this,\n      ref: ref\n    });\n  };\n\n  State.prototype.updateCellState = function (ref, stateOrProvider) {\n    var cell = this.cells.get(ref);\n    if (!cell) return;\n    var update = typeof stateOrProvider === 'function' ? stateOrProvider(cell.state) : stateOrProvider;\n\n    if (StateTransform.assignState(cell.state, update)) {\n      cell.transform = this._tree.assignState(cell.transform.ref, update);\n      this.events.cell.stateUpdated.next({\n        state: this,\n        ref: ref,\n        cell: cell\n      });\n    }\n  };\n\n  State.prototype.dispose = function () {\n    this.ev.dispose();\n    this.actions.dispose();\n  };\n  /**\r\n   * Select Cells using the provided selector.\r\n   * @example state.query(StateSelection.Generators.byRef('test').ancestorOfType(type))\r\n   * @example state.query('test')\r\n   */\n\n\n  State.prototype.select = function (selector) {\n    return StateSelection.select(selector, this);\n  };\n  /**\r\n   * Select Cells by building a query generated on the fly.\r\n   * @example state.select(q => q.byRef('test').subtree())\r\n   */\n\n\n  State.prototype.selectQ = function (selector) {\n    if (typeof selector === 'string') return StateSelection.select(selector, this);\n    return StateSelection.select(selector(StateSelection.Generators), this);\n  };\n  /**\r\n   * Creates a Task that applies the specified StateAction (i.e. must use run* on the result)\r\n   * If no ref is specified, apply to root.\r\n   */\n\n\n  State.prototype.applyAction = function (action, params, ref) {\n    var _this = this;\n\n    if (ref === void 0) {\n      ref = StateTransform.RootRef;\n    }\n\n    return Task.create('Apply Action', function (ctx) {\n      var cell = _this.cells.get(ref);\n\n      if (!cell) throw new Error(\"'\" + ref + \"' does not exist.\");\n      if (cell.status !== 'ok') throw new Error(\"Action cannot be applied to a cell with status '\" + cell.status + \"'\");\n      return runTask(action.definition.run({\n        ref: ref,\n        cell: cell,\n        a: cell.obj,\n        params: params,\n        state: _this\n      }, _this.globalContext), ctx);\n    });\n  };\n  /** Apply series of updates to the state. If any of them fail, revert to the original state. */\n\n\n  State.prototype.transaction = function (edits, options) {\n    var _this = this;\n\n    return Task.create('State Transaction', function (ctx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var isNested, snapshot, restored, e_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              isNested = this.inTransaction;\n              snapshot = this._tree.asImmutable();\n              restored = false;\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 5, 8, 9]);\n\n              if (!isNested) this.behaviors.isUpdating.next(true);\n              this.inTransaction = true;\n              this.inTransactionError = false;\n              return [4\n              /*yield*/\n              , edits(ctx)];\n\n            case 2:\n              _a.sent();\n\n              if (!this.inTransactionError) return [3\n              /*break*/\n              , 4];\n              restored = true;\n              return [4\n              /*yield*/\n              , this.updateTree(snapshot).runInContext(ctx)];\n\n            case 3:\n              _a.sent();\n\n              _a.label = 4;\n\n            case 4:\n              return [3\n              /*break*/\n              , 9];\n\n            case 5:\n              e_1 = _a.sent();\n              if (!!restored) return [3\n              /*break*/\n              , 7];\n              restored = true;\n              return [4\n              /*yield*/\n              , this.updateTree(snapshot).runInContext(ctx)];\n\n            case 6:\n              _a.sent();\n\n              this.events.log.next(LogEntry.error('' + e_1));\n              _a.label = 7;\n\n            case 7:\n              if (isNested) {\n                this.inTransactionError = true;\n                throw e_1;\n              }\n\n              if (options === null || options === void 0 ? void 0 : options.rethrowErrors) throw e_1;\n              return [3\n              /*break*/\n              , 9];\n\n            case 8:\n              if (!isNested) {\n                this.inTransaction = false;\n                this.events.changed.next({\n                  state: this,\n                  inTransaction: false\n                });\n                this.behaviors.isUpdating.next(false);\n\n                if (!restored) {\n                  if (options === null || options === void 0 ? void 0 : options.canUndo) this.addHistory(snapshot, typeof options.canUndo === 'string' ? options.canUndo : void 0);else this.clearHistory();\n                }\n              }\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 9:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    });\n  };\n\n  Object.defineProperty(State.prototype, \"inUpdate\", {\n    /**\r\n     * Determines whether the state is currently \"inside\" updateTree function.\r\n     * This is different from \"isUpdating\" which wraps entire transactions.\r\n     */\n    get: function () {\n      return this._inUpdate;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  State.prototype.updateTree = function (tree, options) {\n    var _this = this;\n\n    var params = {\n      tree: tree,\n      options: options\n    };\n    return Task.create('Update Tree', function (taskCtx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var removed, snapshot, reverted, ret, _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.updateQueue.enqueue(params)];\n\n            case 1:\n              removed = _b.sent();\n              if (!removed) return [2\n              /*return*/\n              ];\n              this._inUpdate = true;\n              snapshot = (options === null || options === void 0 ? void 0 : options.canUndo) ? this._tree.asImmutable() : void 0;\n              reverted = false;\n              if (!this.inTransaction) this.behaviors.isUpdating.next(true);\n              _b.label = 2;\n\n            case 2:\n              _b.trys.push([2,, 7, 8]);\n\n              if (StateBuilder.is(tree)) {\n                if (tree.editInfo.applied) throw new Error('This builder has already been applied. Create a new builder for further state updates');\n                tree.editInfo.applied = true;\n              }\n\n              this.reverted = false;\n              if (!(options && (options.revertIfAborted || options.revertOnError))) return [3\n              /*break*/\n              , 4];\n              return [4\n              /*yield*/\n              , this._revertibleTreeUpdate(taskCtx, params, options)];\n\n            case 3:\n              _a = _b.sent();\n              return [3\n              /*break*/\n              , 6];\n\n            case 4:\n              return [4\n              /*yield*/\n              , this._updateTree(taskCtx, params)];\n\n            case 5:\n              _a = _b.sent();\n              _b.label = 6;\n\n            case 6:\n              ret = _a;\n              reverted = this.reverted;\n              if (ret.ctx.hadError) this.inTransactionError = true;\n              if (!ret.cell) return [2\n              /*return*/\n              ];\n              return [2\n              /*return*/\n              , new StateObjectSelector(ret.cell.transform.ref, this)];\n\n            case 7:\n              this._inUpdate = false;\n              this.updateQueue.handled(params);\n\n              if (!this.inTransaction) {\n                this.behaviors.isUpdating.next(false);\n\n                if (!(options === null || options === void 0 ? void 0 : options.canUndo)) {\n                  if (!this.undoingHistory) this.clearHistory();\n                } else if (!reverted) {\n                  this.addHistory(snapshot, typeof options.canUndo === 'string' ? options.canUndo : void 0);\n                }\n              }\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 8:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, function () {\n      _this.updateQueue.remove(params);\n    });\n  };\n\n  State.prototype._revertibleTreeUpdate = function (taskCtx, params, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var old, ret, revert;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            old = this.tree;\n            return [4\n            /*yield*/\n            , this._updateTree(taskCtx, params)];\n\n          case 1:\n            ret = _a.sent();\n            revert = (ret.ctx.hadError || ret.ctx.wasAborted) && options.revertOnError || ret.ctx.wasAborted && options.revertIfAborted;\n            if (!revert) return [3\n            /*break*/\n            , 3];\n            this.reverted = true;\n            return [4\n            /*yield*/\n            , this._updateTree(taskCtx, {\n              tree: old,\n              options: params.options\n            })];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            return [2\n            /*return*/\n            , ret];\n        }\n      });\n    });\n  };\n\n  State.prototype._updateTree = function (taskCtx, params) {\n    return __awaiter(this, void 0, void 0, function () {\n      var updated, ctx, cell;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            updated = false;\n            ctx = this.updateTreeAndCreateCtx(params.tree, taskCtx, params.options);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1,, 3, 4]);\n\n            return [4\n            /*yield*/\n            , update(ctx)];\n\n          case 2:\n            updated = _a.sent();\n\n            if (StateBuilder.isTo(params.tree)) {\n              cell = this.select(params.tree.ref)[0];\n              return [2\n              /*return*/\n              , {\n                ctx: ctx,\n                cell: cell\n              }];\n            }\n\n            return [2\n            /*return*/\n            , {\n              ctx: ctx\n            }];\n\n          case 3:\n            this.spine.current = undefined;\n            if (updated) this.events.changed.next({\n              state: this,\n              inTransaction: this.inTransaction\n            });\n            return [7\n            /*endfinally*/\n            ];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  State.prototype.updateTreeAndCreateCtx = function (tree, taskCtx, options) {\n    var _tree = (StateBuilder.is(tree) ? tree.getTree() : tree).asTransient();\n\n    var oldTree = this._tree;\n    this._tree = _tree;\n    var cells = this.cells;\n    var ctx = {\n      parent: this,\n      editInfo: StateBuilder.is(tree) ? tree.editInfo : void 0,\n      errorFree: this.errorFree,\n      taskCtx: taskCtx,\n      oldTree: oldTree,\n      tree: _tree,\n      cells: this.cells,\n      spine: this.spine,\n      results: [],\n      options: __assign(__assign({}, StateUpdateDefaultOptions), options),\n      changed: false,\n      hadError: false,\n      wasAborted: false,\n      newCurrent: void 0,\n      getCellData: function (ref) {\n        var _a;\n\n        return (_a = cells.get(ref).obj) === null || _a === void 0 ? void 0 : _a.data;\n      }\n    };\n    this.errorFree = true;\n    return ctx;\n  };\n\n  return State;\n}();\n\n(function (State) {\n  function create(rootObject, params) {\n    return new State(rootObject, params);\n  }\n\n  State.create = create;\n  var ObjectEvent;\n\n  (function (ObjectEvent) {\n    function isCell(e, cell) {\n      return !!cell && e.ref === cell.transform.ref && e.state === cell.parent;\n    }\n\n    ObjectEvent.isCell = isCell;\n  })(ObjectEvent = State.ObjectEvent || (State.ObjectEvent = {}));\n})(State || (State = {}));\n\nvar StateUpdateDefaultOptions = {\n  doNotLogTiming: false,\n  doNotUpdateCurrent: true,\n  revertIfAborted: false,\n  revertOnError: false,\n  canUndo: false\n};\n\nfunction update(ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var fastTrack, deletes, deletedObjects, roots, current, hasCurrent, _i, deletes_1, d, newCurrent_1, i, cell, _a, deletes_2, d, cell, obj, init, _b, _c, cell, i, d, parent_1, _d, _e, cell, _f, roots_1, root, newCurrent, _g, _h, update_1, transform, current, currentCell;\n\n    return __generator(this, function (_j) {\n      switch (_j.label) {\n        case 0:\n          fastTrack = !!(ctx.editInfo && ctx.editInfo.count === 1 && ctx.editInfo.lastUpdate && ctx.editInfo.sourceTree === ctx.oldTree);\n          deletedObjects = [];\n\n          if (fastTrack) {\n            deletes = [];\n            roots = [ctx.editInfo.lastUpdate];\n          } else {\n            // find all nodes that will definitely be deleted.\n            // this is done in \"post order\", meaning that leaves will be deleted first.\n            deletes = findDeletes(ctx);\n            current = ctx.parent.current;\n            hasCurrent = false;\n\n            for (_i = 0, deletes_1 = deletes; _i < deletes_1.length; _i++) {\n              d = deletes_1[_i];\n\n              if (d === current) {\n                hasCurrent = true;\n                break;\n              }\n            }\n\n            if (hasCurrent) {\n              newCurrent_1 = findNewCurrent(ctx.oldTree, current, deletes, ctx.cells);\n              ctx.parent.setCurrent(newCurrent_1);\n            }\n\n            for (i = deletes.length - 1; i >= 0; i--) {\n              cell = ctx.cells.get(deletes[i]);\n\n              if (cell) {\n                dispose(cell.transform, cell.obj, cell === null || cell === void 0 ? void 0 : cell.transform.params, cell.cache, ctx.parent.globalContext);\n              }\n            }\n\n            for (_a = 0, deletes_2 = deletes; _a < deletes_2.length; _a++) {\n              d = deletes_2[_a];\n              cell = ctx.cells.get(d);\n\n              if (cell) {\n                cell.parent = void 0;\n                unlinkCell(cell);\n              }\n\n              obj = cell && cell.obj;\n              ctx.cells.delete(d);\n              deletedObjects.push(obj);\n            } // Find roots where transform version changed or where nodes will be added.\n\n\n            roots = findUpdateRoots(ctx.cells, ctx.tree);\n          }\n\n          init = initCells(ctx, roots); // Notify additions of new cells.\n\n          for (_b = 0, _c = init.added; _b < _c.length; _b++) {\n            cell = _c[_b];\n            ctx.parent.events.cell.created.next({\n              state: ctx.parent,\n              ref: cell.transform.ref,\n              cell: cell\n            });\n          }\n\n          for (i = 0; i < deletes.length; i++) {\n            d = deletes[i];\n            parent_1 = ctx.oldTree.transforms.get(d).parent;\n            ctx.parent.events.object.removed.next({\n              state: ctx.parent,\n              ref: d,\n              obj: deletedObjects[i]\n            });\n            ctx.parent.events.cell.removed.next({\n              state: ctx.parent,\n              ref: d,\n              parent: parent_1\n            });\n          }\n\n          if (deletedObjects.length) deletedObjects = [];\n\n          if (init.dependent) {\n            for (_d = 0, _e = init.dependent; _d < _e.length; _d++) {\n              cell = _e[_d];\n              roots.push(cell.transform.ref);\n            }\n          } // Set status of cells that will be updated to 'pending'.\n\n\n          initCellStatus(ctx, roots);\n          _f = 0, roots_1 = roots;\n          _j.label = 1;\n\n        case 1:\n          if (!(_f < roots_1.length)) return [3\n          /*break*/\n          , 4];\n          root = roots_1[_f];\n          return [4\n          /*yield*/\n          , updateSubtree(ctx, root)];\n\n        case 2:\n          _j.sent();\n\n          _j.label = 3;\n\n        case 3:\n          _f++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 4:\n          // Sync cell states\n          if (!ctx.editInfo) {\n            syncNewStates(ctx);\n          }\n\n          newCurrent = ctx.newCurrent; // Raise object updated events\n\n          for (_g = 0, _h = ctx.results; _g < _h.length; _g++) {\n            update_1 = _h[_g];\n\n            if (update_1.action === 'created') {\n              ctx.parent.events.object.created.next({\n                state: ctx.parent,\n                ref: update_1.ref,\n                obj: update_1.obj\n              });\n\n              if (!ctx.newCurrent) {\n                transform = ctx.tree.transforms.get(update_1.ref);\n                if (!transform.state.isGhost && update_1.obj !== StateObject.Null) newCurrent = update_1.ref;\n              }\n            } else if (update_1.action === 'updated') {\n              ctx.parent.events.object.updated.next({\n                state: ctx.parent,\n                ref: update_1.ref,\n                action: 'in-place',\n                obj: update_1.obj,\n                oldData: update_1.oldData\n              });\n            } else if (update_1.action === 'replaced') {\n              ctx.parent.events.object.updated.next({\n                state: ctx.parent,\n                ref: update_1.ref,\n                action: 'recreate',\n                obj: update_1.obj,\n                oldObj: update_1.oldObj\n              });\n            }\n          }\n\n          if (newCurrent) {\n            if (!ctx.options.doNotUpdateCurrent) ctx.parent.setCurrent(newCurrent);\n          } else {\n            current = ctx.parent.current;\n            currentCell = ctx.cells.get(current);\n\n            if (currentCell && (currentCell.obj === StateObject.Null || currentCell.status === 'error' && currentCell.errorText === ParentNullErrorText)) {\n              newCurrent = findNewCurrent(ctx.oldTree, current, [], ctx.cells);\n              ctx.parent.setCurrent(newCurrent);\n            }\n          }\n\n          return [2\n          /*return*/\n          , deletes.length > 0 || roots.length > 0 || ctx.changed];\n      }\n    });\n  });\n}\n\nfunction findUpdateRoots(cells, tree) {\n  var findState = {\n    roots: [],\n    cells: cells\n  };\n  StateTree.doPreOrder(tree, tree.root, findState, findUpdateRootsVisitor);\n  return findState.roots;\n}\n\nfunction findUpdateRootsVisitor(n, _, s) {\n  var cell = s.cells.get(n.ref);\n\n  if (!cell || cell.transform.version !== n.version) {\n    s.roots.push(n.ref);\n    return false;\n  }\n\n  if (cell.status === 'error') return false; // nothing below a Null object can be an update root\n\n  if (cell && cell.obj === StateObject.Null) return false;\n  return true;\n}\n\nfunction checkDeleteVisitor(n, _, ctx) {\n  if (!ctx.newTree.transforms.has(n.ref) && ctx.cells.has(n.ref)) ctx.deletes.push(n.ref);\n}\n\nfunction findDeletes(ctx) {\n  var deleteCtx = {\n    newTree: ctx.tree,\n    cells: ctx.cells,\n    deletes: []\n  };\n  StateTree.doPostOrder(ctx.oldTree, ctx.oldTree.root, deleteCtx, checkDeleteVisitor);\n  return deleteCtx.deletes;\n}\n\nfunction syncNewStatesVisitor(n, tree, ctx) {\n  var cell = ctx.cells.get(n.ref);\n  if (!cell || !StateTransform.syncState(cell.state, n.state)) return;\n  ctx.parent.events.cell.stateUpdated.next({\n    state: ctx.parent,\n    ref: n.ref,\n    cell: cell\n  });\n}\n\nfunction syncNewStates(ctx) {\n  StateTree.doPreOrder(ctx.tree, ctx.tree.root, ctx, syncNewStatesVisitor);\n}\n\nfunction setCellStatus(ctx, ref, status, errorText) {\n  var cell = ctx.cells.get(ref);\n  var changed = cell.status !== status;\n  cell.status = status;\n  cell.errorText = errorText;\n  if (changed) ctx.parent.events.cell.stateUpdated.next({\n    state: ctx.parent,\n    ref: ref,\n    cell: cell\n  });\n}\n\nfunction initCellStatusVisitor(t, _, ctx) {\n  ctx.cells.get(t.ref).transform = t;\n  setCellStatus(ctx, t.ref, 'pending');\n}\n\nfunction initCellStatus(ctx, roots) {\n  for (var _i = 0, roots_2 = roots; _i < roots_2.length; _i++) {\n    var root = roots_2[_i];\n    StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), ctx, initCellStatusVisitor);\n  }\n}\n\nfunction unlinkCell(cell) {\n  for (var _i = 0, _a = cell.dependencies.dependsOn; _i < _a.length; _i++) {\n    var other = _a[_i];\n    arraySetRemove(other.dependencies.dependentBy, cell);\n  }\n}\n\nfunction addCellsVisitor(transform, _, _a) {\n  var ctx = _a.ctx,\n      added = _a.added,\n      visited = _a.visited;\n  visited.add(transform.ref);\n\n  if (ctx.cells.has(transform.ref)) {\n    return;\n  }\n\n  var cell = {\n    parent: ctx.parent,\n    transform: transform,\n    sourceRef: void 0,\n    status: 'pending',\n    state: __assign({}, transform.state),\n    errorText: void 0,\n    params: void 0,\n    paramsNormalizedVersion: '',\n    dependencies: {\n      dependentBy: [],\n      dependsOn: []\n    },\n    cache: void 0\n  };\n  ctx.cells.set(transform.ref, cell);\n  added.push(cell);\n} // type LinkCellsCtx = { ctx: UpdateContext, visited: Set<Ref>, dependent: UniqueArray<Ref, StateObjectCell> }\n\n\nfunction linkCells(target, ctx) {\n  if (!target.transform.dependsOn) return;\n\n  for (var _i = 0, _a = target.transform.dependsOn; _i < _a.length; _i++) {\n    var ref = _a[_i];\n    var t = ctx.tree.transforms.get(ref);\n\n    if (!t) {\n      throw new Error(\"Cannot depend on a non-existent transform.\");\n    }\n\n    var cell = ctx.cells.get(ref);\n    arraySetAdd(target.dependencies.dependsOn, cell);\n    arraySetAdd(cell.dependencies.dependentBy, target);\n  }\n}\n\nfunction initCells(ctx, roots) {\n  var initCtx = {\n    ctx: ctx,\n    visited: new Set(),\n    added: []\n  }; // Add new cells\n\n  for (var _i = 0, roots_3 = roots; _i < roots_3.length; _i++) {\n    var root = roots_3[_i];\n    StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), initCtx, addCellsVisitor);\n  } // Update links for newly added cells\n\n\n  for (var _a = 0, _b = initCtx.added; _a < _b.length; _a++) {\n    var cell = _b[_a];\n    linkCells(cell, ctx);\n  }\n\n  var dependent; // Find dependent cells\n\n  initCtx.visited.forEach(function (ref) {\n    var cell = ctx.cells.get(ref);\n\n    for (var _i = 0, _a = cell.dependencies.dependentBy; _i < _a.length; _i++) {\n      var by = _a[_i];\n      if (initCtx.visited.has(by.transform.ref)) continue;\n      if (!dependent) dependent = UniqueArray.create();\n      UniqueArray.add(dependent, by.transform.ref, by);\n    }\n  }); // TODO: check if dependent cells are all \"proper roots\"\n\n  return {\n    added: initCtx.added,\n    dependent: dependent ? dependent.array : void 0\n  };\n}\n\nfunction findNewCurrent(tree, start, deletes, cells) {\n  var deleteSet = new Set(deletes);\n  return _findNewCurrent(tree, start, deleteSet, cells);\n}\n\nfunction _findNewCurrent(tree, ref, deletes, cells) {\n  if (ref === StateTransform.RootRef) return ref;\n  var node = tree.transforms.get(ref);\n  var siblings = tree.children.get(node.parent).values();\n  var prevCandidate = void 0,\n      seenRef = false;\n\n  while (true) {\n    var s = siblings.next();\n    if (s.done) break;\n    if (deletes.has(s.value)) continue;\n    var cell = cells.get(s.value);\n\n    if (!cell || cell.status === 'error' || cell.obj === StateObject.Null) {\n      continue;\n    }\n\n    var t = tree.transforms.get(s.value);\n    if (t.state.isGhost) continue;\n\n    if (s.value === ref) {\n      seenRef = true;\n      if (!deletes.has(ref)) prevCandidate = ref;\n      continue;\n    }\n\n    if (seenRef) return t.ref;\n    prevCandidate = t.ref;\n  }\n\n  if (prevCandidate) return prevCandidate;\n  return _findNewCurrent(tree, node.parent, deletes, cells);\n}\n/** Set status and error text of the cell. Remove all existing objects in the subtree. */\n\n\nfunction doError(ctx, ref, errorObject, silent) {\n  if (!silent) {\n    ctx.hadError = true;\n    ctx.parent.errorFree = false;\n  }\n\n  var cell = ctx.cells.get(ref);\n\n  if (errorObject) {\n    ctx.wasAborted = ctx.wasAborted || Task.isAbort(errorObject);\n    var message = '' + errorObject;\n    setCellStatus(ctx, ref, 'error', message);\n    if (!silent) ctx.parent.events.log.next({\n      type: 'error',\n      timestamp: new Date(),\n      message: message\n    });\n  } else {\n    cell.params = void 0;\n  }\n\n  if (cell.obj) {\n    var obj = cell.obj;\n    cell.obj = void 0;\n    cell.cache = void 0;\n    ctx.parent.events.object.removed.next({\n      state: ctx.parent,\n      ref: ref,\n      obj: obj\n    });\n  } // remove the objects in the child nodes if they exist\n\n\n  var children = ctx.tree.children.get(ref).values();\n\n  while (true) {\n    var next = children.next();\n    if (next.done) return;\n    doError(ctx, next.value, void 0, silent);\n  }\n}\n\nvar ParentNullErrorText = 'Parent is null';\n\nfunction updateSubtree(ctx, root) {\n  return __awaiter(this, void 0, void 0, function () {\n    var isNull, start, update_2, time, e_2, children, next;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          setCellStatus(ctx, root, 'processing');\n          isNull = false;\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 4]);\n\n          start = now();\n          return [4\n          /*yield*/\n          , updateNode(ctx, root)];\n\n        case 2:\n          update_2 = _a.sent();\n          time = now() - start;\n          if (update_2.action !== 'none') ctx.changed = true;\n          setCellStatus(ctx, root, 'ok');\n          ctx.results.push(update_2);\n\n          if (update_2.action === 'created') {\n            isNull = update_2.obj === StateObject.Null;\n            if (!isNull && !ctx.options.doNotLogTiming) ctx.parent.events.log.next(LogEntry.info(\"Created \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\n          } else if (update_2.action === 'updated') {\n            isNull = update_2.obj === StateObject.Null;\n            if (!isNull && !ctx.options.doNotLogTiming) ctx.parent.events.log.next(LogEntry.info(\"Updated \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\n          } else if (update_2.action === 'replaced') {\n            isNull = update_2.obj === StateObject.Null;\n            if (!isNull && !ctx.options.doNotLogTiming) ctx.parent.events.log.next(LogEntry.info(\"Updated \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\n          }\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          e_2 = _a.sent();\n          ctx.changed = true;\n          if (!ctx.hadError) ctx.newCurrent = root;\n          doError(ctx, root, e_2, false);\n          if (!isProductionMode) console.error(e_2);\n          return [2\n          /*return*/\n          ];\n\n        case 4:\n          children = ctx.tree.children.get(root).values();\n          _a.label = 5;\n\n        case 5:\n          if (!true) return [3\n          /*break*/\n          , 9];\n          next = children.next();\n          if (next.done) return [2\n          /*return*/\n          ];\n          if (!isNull) return [3\n          /*break*/\n          , 6];\n          doError(ctx, next.value, void 0, true);\n          return [3\n          /*break*/\n          , 8];\n\n        case 6:\n          return [4\n          /*yield*/\n          , updateSubtree(ctx, next.value)];\n\n        case 7:\n          _a.sent();\n\n          _a.label = 8;\n\n        case 8:\n          return [3\n          /*break*/\n          , 5];\n\n        case 9:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction resolveParams(ctx, transform, src, cell) {\n  var prms = transform.transformer.definition.params;\n  var definition = prms ? prms(src, ctx.parent.globalContext) : {};\n\n  if (cell.paramsNormalizedVersion !== transform.version) {\n    transform.params = ParamDefinition.normalizeParams(definition, transform.params, 'all');\n    cell.paramsNormalizedVersion = transform.version;\n  } else {\n    var defaultValues = ParamDefinition.getDefaultValues(definition);\n    transform.params = transform.params ? assignIfUndefined(transform.params, defaultValues) : defaultValues;\n  }\n\n  ParamDefinition.resolveRefs(definition, transform.params, ctx.getCellData);\n  return {\n    definition: definition,\n    values: transform.params\n  };\n}\n\nfunction updateNode(ctx, currentRef) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function () {\n    var oldTree, tree, current, transform, parentCell, parent, params, obj, oldParams, oldCache, oldData, newParams, updateKind, _b, _c, oldObj, newObj;\n\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          oldTree = ctx.oldTree, tree = ctx.tree;\n          current = ctx.cells.get(currentRef);\n          transform = current.transform; // special case for Root\n\n          if (current.transform.ref === StateTransform.RootRef) {\n            return [2\n            /*return*/\n            , {\n              action: 'none'\n            }];\n          }\n\n          parentCell = transform.transformer.definition.from.length === 0 ? ctx.cells.get(current.transform.parent) : StateSelection.findAncestorOfType(tree, ctx.cells, currentRef, transform.transformer.definition.from);\n\n          if (!parentCell) {\n            throw new Error(\"No suitable parent found for '\" + currentRef + \"'\");\n          }\n\n          ctx.spine.current = current;\n          parent = parentCell.obj;\n          current.sourceRef = parentCell.transform.ref;\n          params = resolveParams(ctx, transform, parent, current);\n          if (!(!oldTree.transforms.has(currentRef) || !current.params)) return [3\n          /*break*/\n          , 2];\n          current.params = params;\n          return [4\n          /*yield*/\n          , createObject(ctx, current, transform.transformer, parent, params.values)];\n\n        case 1:\n          obj = _d.sent();\n          updateTag(obj, transform);\n          current.obj = obj;\n          return [2\n          /*return*/\n          , {\n            ref: currentRef,\n            action: 'created',\n            obj: obj\n          }];\n\n        case 2:\n          oldParams = current.params.values;\n          oldCache = current.cache;\n          oldData = (_a = current.obj) === null || _a === void 0 ? void 0 : _a.data;\n          newParams = params.values;\n          current.params = params;\n          if (!(!!current.obj && current.obj !== StateObject.Null)) return [3\n          /*break*/\n          , 4];\n          return [4\n          /*yield*/\n          , updateObject(ctx, current, transform.transformer, parent, current.obj, oldParams, newParams)];\n\n        case 3:\n          _b = _d.sent();\n          return [3\n          /*break*/\n          , 5];\n\n        case 4:\n          _b = StateTransformer.UpdateResult.Recreate;\n          _d.label = 5;\n\n        case 5:\n          updateKind = _b;\n          _c = updateKind;\n\n          switch (_c) {\n            case StateTransformer.UpdateResult.Recreate:\n              return [3\n              /*break*/\n              , 6];\n\n            case StateTransformer.UpdateResult.Updated:\n              return [3\n              /*break*/\n              , 8];\n\n            case StateTransformer.UpdateResult.Null:\n              return [3\n              /*break*/\n              , 9];\n          }\n\n          return [3\n          /*break*/\n          , 10];\n\n        case 6:\n          oldObj = current.obj;\n          dispose(transform, oldObj, oldParams, oldCache, ctx.parent.globalContext);\n          return [4\n          /*yield*/\n          , createObject(ctx, current, transform.transformer, parent, newParams)];\n\n        case 7:\n          newObj = _d.sent();\n          updateTag(newObj, transform);\n          current.obj = newObj;\n          return [2\n          /*return*/\n          , {\n            ref: currentRef,\n            action: 'replaced',\n            oldObj: oldObj,\n            obj: newObj\n          }];\n\n        case 8:\n          updateTag(current.obj, transform);\n          return [2\n          /*return*/\n          , {\n            ref: currentRef,\n            action: 'updated',\n            oldData: oldData,\n            obj: current.obj\n          }];\n\n        case 9:\n          {\n            dispose(transform, current.obj, oldParams, oldCache, ctx.parent.globalContext);\n            current.obj = StateObject.Null;\n            return [2\n            /*return*/\n            , {\n              ref: currentRef,\n              action: 'updated',\n              obj: current.obj\n            }];\n          }\n          _d.label = 10;\n\n        case 10:\n          return [2\n          /*return*/\n          , {\n            action: 'none'\n          }];\n      }\n    });\n  });\n}\n\nfunction dispose(transform, b, params, cache, globalContext) {\n  var _a, _b;\n\n  (_b = (_a = transform.transformer.definition).dispose) === null || _b === void 0 ? void 0 : _b.call(_a, {\n    b: b !== StateObject.Null ? b : void 0,\n    params: params,\n    cache: cache\n  }, globalContext);\n}\n\nfunction updateTag(obj, transform) {\n  if (!obj || obj === StateObject.Null) return;\n  obj.tags = transform.tags;\n}\n\nfunction runTask(t, ctx) {\n  if (typeof t.runInContext === 'function') return t.runInContext(ctx);\n  return t;\n}\n\nfunction resolveDependencies(cell) {\n  if (cell.dependencies.dependsOn.length === 0) return void 0;\n  var deps = Object.create(null);\n\n  for (var _i = 0, _a = cell.dependencies.dependsOn; _i < _a.length; _i++) {\n    var dep = _a[_i];\n\n    if (!dep.obj) {\n      throw new Error('Unresolved dependency.');\n    }\n\n    deps[dep.transform.ref] = dep.obj;\n  }\n\n  return deps;\n}\n\nfunction createObject(ctx, cell, transformer, a, params) {\n  if (!cell.cache) cell.cache = Object.create(null);\n  return runTask(transformer.definition.apply({\n    a: a,\n    params: params,\n    cache: cell.cache,\n    spine: ctx.spine,\n    dependencies: resolveDependencies(cell)\n  }, ctx.parent.globalContext), ctx.taskCtx);\n}\n\nfunction updateObject(ctx, cell, transformer, a, b, oldParams, newParams) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      if (!transformer.definition.update) {\n        return [2\n        /*return*/\n        , StateTransformer.UpdateResult.Recreate];\n      }\n\n      if (!cell.cache) cell.cache = Object.create(null);\n      return [2\n      /*return*/\n      , runTask(transformer.definition.update({\n        a: a,\n        oldParams: oldParams,\n        b: b,\n        newParams: newParams,\n        cache: cell.cache,\n        spine: ctx.spine,\n        dependencies: resolveDependencies(cell)\n      }, ctx.parent.globalContext), ctx.taskCtx)];\n    });\n  });\n}","map":{"version":3,"sources":["../../src/mol-state/state.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { StateObject, StateObjectSelector } from './object';\r\nimport { StateTree } from './tree';\r\nimport { StateTransform } from './transform';\r\nimport { StateTransformer } from './transformer';\r\nimport { Task } from '../mol-task';\r\nimport { StateSelection } from './state/selection';\r\nimport { RxEventHelper } from '../mol-util/rx-event-helper';\r\nimport { StateBuilder } from './state/builder';\r\nimport { StateActionManager } from './action/manager';\r\nimport { LogEntry } from '../mol-util/log-entry';\r\nimport { now, formatTimespan } from '../mol-util/now';\r\nimport { ParamDefinition } from '../mol-util/param-definition';\r\nimport { StateTreeSpine } from './tree/spine';\r\nimport { AsyncQueue } from '../mol-util/async-queue';\r\nimport { isProductionMode } from '../mol-util/debug';\r\nimport { arraySetAdd, arraySetRemove } from '../mol-util/array';\r\nimport { UniqueArray } from '../mol-data/generic';\r\nimport { assignIfUndefined } from '../mol-util/object';\r\nexport { State };\r\nvar State = /** @class */ (function () {\r\n    function State(rootObject, params) {\r\n        var _this = this;\r\n        this.errorFree = true;\r\n        this.ev = RxEventHelper.create();\r\n        this.globalContext = void 0;\r\n        this.events = {\r\n            cell: {\r\n                stateUpdated: this.ev(),\r\n                created: this.ev(),\r\n                removed: this.ev(),\r\n            },\r\n            object: {\r\n                updated: this.ev(),\r\n                created: this.ev(),\r\n                removed: this.ev()\r\n            },\r\n            log: this.ev(),\r\n            changed: this.ev(),\r\n            historyUpdated: this.ev()\r\n        };\r\n        this.behaviors = {\r\n            currentObject: this.ev.behavior({ state: this, ref: StateTransform.RootRef }),\r\n            isUpdating: this.ev.behavior(false),\r\n        };\r\n        this.actions = new StateActionManager();\r\n        this.cells = new Map();\r\n        this.spine = new StateTreeSpine.Impl(this.cells);\r\n        this.tryGetCellData = function (ref) {\r\n            var _a, _b;\r\n            var ret = (_b = (_a = _this.cells.get(ref)) === null || _a === void 0 ? void 0 : _a.obj) === null || _b === void 0 ? void 0 : _b.data;\r\n            if (!ref)\r\n                throw new Error(\"Cell '\" + ref + \"' data undefined.\");\r\n            return ret;\r\n        };\r\n        this.historyCapacity = 5;\r\n        this.history = [];\r\n        this.undoingHistory = false;\r\n        this.inTransaction = false;\r\n        this.inTransactionError = false;\r\n        this._inUpdate = false;\r\n        this.reverted = false;\r\n        this.updateQueue = new AsyncQueue();\r\n        this._tree = StateTree.createEmpty(StateTransform.createRoot(params && params.rootState)).asTransient();\r\n        var tree = this._tree;\r\n        var root = tree.root;\r\n        this.runTask = params.runTask;\r\n        if ((params === null || params === void 0 ? void 0 : params.historyCapacity) !== void 0)\r\n            this.historyCapacity = params.historyCapacity;\r\n        this.cells.set(root.ref, {\r\n            parent: this,\r\n            transform: root,\r\n            sourceRef: void 0,\r\n            obj: rootObject,\r\n            status: 'ok',\r\n            state: __assign({}, root.state),\r\n            errorText: void 0,\r\n            params: {\r\n                definition: {},\r\n                values: {}\r\n            },\r\n            paramsNormalizedVersion: root.version,\r\n            dependencies: { dependentBy: [], dependsOn: [] },\r\n            cache: {}\r\n        });\r\n        this.globalContext = params && params.globalContext;\r\n    }\r\n    Object.defineProperty(State.prototype, \"tree\", {\r\n        get: function () { return this._tree; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(State.prototype, \"transforms\", {\r\n        get: function () { return this._tree.transforms; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(State.prototype, \"current\", {\r\n        get: function () { return this.behaviors.currentObject.value.ref; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(State.prototype, \"root\", {\r\n        get: function () { return this.cells.get(this._tree.root.ref); },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    State.prototype.build = function () { return new StateBuilder.Root(this.tree, this); };\r\n    State.prototype.addHistory = function (tree, label) {\r\n        if (this.historyCapacity === 0)\r\n            return;\r\n        this.history.unshift([tree, label || 'Update']);\r\n        if (this.history.length > this.historyCapacity)\r\n            this.history.pop();\r\n        this.events.historyUpdated.next({ state: this });\r\n    };\r\n    State.prototype.clearHistory = function () {\r\n        if (this.history.length === 0)\r\n            return;\r\n        this.history = [];\r\n        this.events.historyUpdated.next({ state: this });\r\n    };\r\n    Object.defineProperty(State.prototype, \"latestUndoLabel\", {\r\n        get: function () {\r\n            return this.history.length > 0 ? this.history[0][1] : void 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(State.prototype, \"canUndo\", {\r\n        get: function () {\r\n            return this.history.length > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    State.prototype.undo = function () {\r\n        var _this = this;\r\n        return Task.create('Undo', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n            var e;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        e = this.history.shift();\r\n                        if (!e)\r\n                            return [2 /*return*/];\r\n                        this.events.historyUpdated.next({ state: this });\r\n                        this.undoingHistory = true;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, , 3, 4]);\r\n                        return [4 /*yield*/, this.updateTree(e[0], { canUndo: false }).runInContext(ctx)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        this.undoingHistory = false;\r\n                        return [7 /*endfinally*/];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n    };\r\n    State.prototype.getSnapshot = function () {\r\n        return { tree: StateTree.toJSON(this._tree) };\r\n    };\r\n    State.prototype.setSnapshot = function (snapshot) {\r\n        var tree = StateTree.fromJSON(snapshot.tree);\r\n        return this.updateTree(tree);\r\n    };\r\n    State.prototype.setCurrent = function (ref) {\r\n        this.behaviors.currentObject.next({ state: this, ref: ref });\r\n    };\r\n    State.prototype.updateCellState = function (ref, stateOrProvider) {\r\n        var cell = this.cells.get(ref);\r\n        if (!cell)\r\n            return;\r\n        var update = typeof stateOrProvider === 'function' ? stateOrProvider(cell.state) : stateOrProvider;\r\n        if (StateTransform.assignState(cell.state, update)) {\r\n            cell.transform = this._tree.assignState(cell.transform.ref, update);\r\n            this.events.cell.stateUpdated.next({ state: this, ref: ref, cell: cell });\r\n        }\r\n    };\r\n    State.prototype.dispose = function () {\r\n        this.ev.dispose();\r\n        this.actions.dispose();\r\n    };\r\n    /**\r\n     * Select Cells using the provided selector.\r\n     * @example state.query(StateSelection.Generators.byRef('test').ancestorOfType(type))\r\n     * @example state.query('test')\r\n     */\r\n    State.prototype.select = function (selector) {\r\n        return StateSelection.select(selector, this);\r\n    };\r\n    /**\r\n     * Select Cells by building a query generated on the fly.\r\n     * @example state.select(q => q.byRef('test').subtree())\r\n     */\r\n    State.prototype.selectQ = function (selector) {\r\n        if (typeof selector === 'string')\r\n            return StateSelection.select(selector, this);\r\n        return StateSelection.select(selector(StateSelection.Generators), this);\r\n    };\r\n    /**\r\n     * Creates a Task that applies the specified StateAction (i.e. must use run* on the result)\r\n     * If no ref is specified, apply to root.\r\n     */\r\n    State.prototype.applyAction = function (action, params, ref) {\r\n        var _this = this;\r\n        if (ref === void 0) { ref = StateTransform.RootRef; }\r\n        return Task.create('Apply Action', function (ctx) {\r\n            var cell = _this.cells.get(ref);\r\n            if (!cell)\r\n                throw new Error(\"'\" + ref + \"' does not exist.\");\r\n            if (cell.status !== 'ok')\r\n                throw new Error(\"Action cannot be applied to a cell with status '\" + cell.status + \"'\");\r\n            return runTask(action.definition.run({ ref: ref, cell: cell, a: cell.obj, params: params, state: _this }, _this.globalContext), ctx);\r\n        });\r\n    };\r\n    /** Apply series of updates to the state. If any of them fail, revert to the original state. */\r\n    State.prototype.transaction = function (edits, options) {\r\n        var _this = this;\r\n        return Task.create('State Transaction', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n            var isNested, snapshot, restored, e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        isNested = this.inTransaction;\r\n                        snapshot = this._tree.asImmutable();\r\n                        restored = false;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 5, 8, 9]);\r\n                        if (!isNested)\r\n                            this.behaviors.isUpdating.next(true);\r\n                        this.inTransaction = true;\r\n                        this.inTransactionError = false;\r\n                        return [4 /*yield*/, edits(ctx)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        if (!this.inTransactionError) return [3 /*break*/, 4];\r\n                        restored = true;\r\n                        return [4 /*yield*/, this.updateTree(snapshot).runInContext(ctx)];\r\n                    case 3:\r\n                        _a.sent();\r\n                        _a.label = 4;\r\n                    case 4: return [3 /*break*/, 9];\r\n                    case 5:\r\n                        e_1 = _a.sent();\r\n                        if (!!restored) return [3 /*break*/, 7];\r\n                        restored = true;\r\n                        return [4 /*yield*/, this.updateTree(snapshot).runInContext(ctx)];\r\n                    case 6:\r\n                        _a.sent();\r\n                        this.events.log.next(LogEntry.error('' + e_1));\r\n                        _a.label = 7;\r\n                    case 7:\r\n                        if (isNested) {\r\n                            this.inTransactionError = true;\r\n                            throw e_1;\r\n                        }\r\n                        if (options === null || options === void 0 ? void 0 : options.rethrowErrors)\r\n                            throw e_1;\r\n                        return [3 /*break*/, 9];\r\n                    case 8:\r\n                        if (!isNested) {\r\n                            this.inTransaction = false;\r\n                            this.events.changed.next({ state: this, inTransaction: false });\r\n                            this.behaviors.isUpdating.next(false);\r\n                            if (!restored) {\r\n                                if (options === null || options === void 0 ? void 0 : options.canUndo)\r\n                                    this.addHistory(snapshot, typeof options.canUndo === 'string' ? options.canUndo : void 0);\r\n                                else\r\n                                    this.clearHistory();\r\n                            }\r\n                        }\r\n                        return [7 /*endfinally*/];\r\n                    case 9: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); });\r\n    };\r\n    Object.defineProperty(State.prototype, \"inUpdate\", {\r\n        /**\r\n         * Determines whether the state is currently \"inside\" updateTree function.\r\n         * This is different from \"isUpdating\" which wraps entire transactions.\r\n         */\r\n        get: function () { return this._inUpdate; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    State.prototype.updateTree = function (tree, options) {\r\n        var _this = this;\r\n        var params = { tree: tree, options: options };\r\n        return Task.create('Update Tree', function (taskCtx) { return __awaiter(_this, void 0, void 0, function () {\r\n            var removed, snapshot, reverted, ret, _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.updateQueue.enqueue(params)];\r\n                    case 1:\r\n                        removed = _b.sent();\r\n                        if (!removed)\r\n                            return [2 /*return*/];\r\n                        this._inUpdate = true;\r\n                        snapshot = (options === null || options === void 0 ? void 0 : options.canUndo) ? this._tree.asImmutable() : void 0;\r\n                        reverted = false;\r\n                        if (!this.inTransaction)\r\n                            this.behaviors.isUpdating.next(true);\r\n                        _b.label = 2;\r\n                    case 2:\r\n                        _b.trys.push([2, , 7, 8]);\r\n                        if (StateBuilder.is(tree)) {\r\n                            if (tree.editInfo.applied)\r\n                                throw new Error('This builder has already been applied. Create a new builder for further state updates');\r\n                            tree.editInfo.applied = true;\r\n                        }\r\n                        this.reverted = false;\r\n                        if (!(options && (options.revertIfAborted || options.revertOnError))) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, this._revertibleTreeUpdate(taskCtx, params, options)];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 6];\r\n                    case 4: return [4 /*yield*/, this._updateTree(taskCtx, params)];\r\n                    case 5:\r\n                        _a = _b.sent();\r\n                        _b.label = 6;\r\n                    case 6:\r\n                        ret = _a;\r\n                        reverted = this.reverted;\r\n                        if (ret.ctx.hadError)\r\n                            this.inTransactionError = true;\r\n                        if (!ret.cell)\r\n                            return [2 /*return*/];\r\n                        return [2 /*return*/, new StateObjectSelector(ret.cell.transform.ref, this)];\r\n                    case 7:\r\n                        this._inUpdate = false;\r\n                        this.updateQueue.handled(params);\r\n                        if (!this.inTransaction) {\r\n                            this.behaviors.isUpdating.next(false);\r\n                            if (!(options === null || options === void 0 ? void 0 : options.canUndo)) {\r\n                                if (!this.undoingHistory)\r\n                                    this.clearHistory();\r\n                            }\r\n                            else if (!reverted) {\r\n                                this.addHistory(snapshot, typeof options.canUndo === 'string' ? options.canUndo : void 0);\r\n                            }\r\n                        }\r\n                        return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); }, function () {\r\n            _this.updateQueue.remove(params);\r\n        });\r\n    };\r\n    State.prototype._revertibleTreeUpdate = function (taskCtx, params, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var old, ret, revert;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        old = this.tree;\r\n                        return [4 /*yield*/, this._updateTree(taskCtx, params)];\r\n                    case 1:\r\n                        ret = _a.sent();\r\n                        revert = ((ret.ctx.hadError || ret.ctx.wasAborted) && options.revertOnError) || (ret.ctx.wasAborted && options.revertIfAborted);\r\n                        if (!revert) return [3 /*break*/, 3];\r\n                        this.reverted = true;\r\n                        return [4 /*yield*/, this._updateTree(taskCtx, { tree: old, options: params.options })];\r\n                    case 2: return [2 /*return*/, _a.sent()];\r\n                    case 3: return [2 /*return*/, ret];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    State.prototype._updateTree = function (taskCtx, params) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var updated, ctx, cell;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        updated = false;\r\n                        ctx = this.updateTreeAndCreateCtx(params.tree, taskCtx, params.options);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, , 3, 4]);\r\n                        return [4 /*yield*/, update(ctx)];\r\n                    case 2:\r\n                        updated = _a.sent();\r\n                        if (StateBuilder.isTo(params.tree)) {\r\n                            cell = this.select(params.tree.ref)[0];\r\n                            return [2 /*return*/, { ctx: ctx, cell: cell }];\r\n                        }\r\n                        return [2 /*return*/, { ctx: ctx }];\r\n                    case 3:\r\n                        this.spine.current = undefined;\r\n                        if (updated)\r\n                            this.events.changed.next({ state: this, inTransaction: this.inTransaction });\r\n                        return [7 /*endfinally*/];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    State.prototype.updateTreeAndCreateCtx = function (tree, taskCtx, options) {\r\n        var _tree = (StateBuilder.is(tree) ? tree.getTree() : tree).asTransient();\r\n        var oldTree = this._tree;\r\n        this._tree = _tree;\r\n        var cells = this.cells;\r\n        var ctx = {\r\n            parent: this,\r\n            editInfo: StateBuilder.is(tree) ? tree.editInfo : void 0,\r\n            errorFree: this.errorFree,\r\n            taskCtx: taskCtx,\r\n            oldTree: oldTree,\r\n            tree: _tree,\r\n            cells: this.cells,\r\n            spine: this.spine,\r\n            results: [],\r\n            options: __assign(__assign({}, StateUpdateDefaultOptions), options),\r\n            changed: false,\r\n            hadError: false,\r\n            wasAborted: false,\r\n            newCurrent: void 0,\r\n            getCellData: function (ref) { var _a; return (_a = cells.get(ref).obj) === null || _a === void 0 ? void 0 : _a.data; }\r\n        };\r\n        this.errorFree = true;\r\n        return ctx;\r\n    };\r\n    return State;\r\n}());\r\n(function (State) {\r\n    function create(rootObject, params) {\r\n        return new State(rootObject, params);\r\n    }\r\n    State.create = create;\r\n    var ObjectEvent;\r\n    (function (ObjectEvent) {\r\n        function isCell(e, cell) {\r\n            return !!cell && e.ref === cell.transform.ref && e.state === cell.parent;\r\n        }\r\n        ObjectEvent.isCell = isCell;\r\n    })(ObjectEvent = State.ObjectEvent || (State.ObjectEvent = {}));\r\n})(State || (State = {}));\r\nvar StateUpdateDefaultOptions = {\r\n    doNotLogTiming: false,\r\n    doNotUpdateCurrent: true,\r\n    revertIfAborted: false,\r\n    revertOnError: false,\r\n    canUndo: false\r\n};\r\nfunction update(ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var fastTrack, deletes, deletedObjects, roots, current, hasCurrent, _i, deletes_1, d, newCurrent_1, i, cell, _a, deletes_2, d, cell, obj, init, _b, _c, cell, i, d, parent_1, _d, _e, cell, _f, roots_1, root, newCurrent, _g, _h, update_1, transform, current, currentCell;\r\n        return __generator(this, function (_j) {\r\n            switch (_j.label) {\r\n                case 0:\r\n                    fastTrack = !!(ctx.editInfo && ctx.editInfo.count === 1 && ctx.editInfo.lastUpdate && ctx.editInfo.sourceTree === ctx.oldTree);\r\n                    deletedObjects = [];\r\n                    if (fastTrack) {\r\n                        deletes = [];\r\n                        roots = [ctx.editInfo.lastUpdate];\r\n                    }\r\n                    else {\r\n                        // find all nodes that will definitely be deleted.\r\n                        // this is done in \"post order\", meaning that leaves will be deleted first.\r\n                        deletes = findDeletes(ctx);\r\n                        current = ctx.parent.current;\r\n                        hasCurrent = false;\r\n                        for (_i = 0, deletes_1 = deletes; _i < deletes_1.length; _i++) {\r\n                            d = deletes_1[_i];\r\n                            if (d === current) {\r\n                                hasCurrent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (hasCurrent) {\r\n                            newCurrent_1 = findNewCurrent(ctx.oldTree, current, deletes, ctx.cells);\r\n                            ctx.parent.setCurrent(newCurrent_1);\r\n                        }\r\n                        for (i = deletes.length - 1; i >= 0; i--) {\r\n                            cell = ctx.cells.get(deletes[i]);\r\n                            if (cell) {\r\n                                dispose(cell.transform, cell.obj, cell === null || cell === void 0 ? void 0 : cell.transform.params, cell.cache, ctx.parent.globalContext);\r\n                            }\r\n                        }\r\n                        for (_a = 0, deletes_2 = deletes; _a < deletes_2.length; _a++) {\r\n                            d = deletes_2[_a];\r\n                            cell = ctx.cells.get(d);\r\n                            if (cell) {\r\n                                cell.parent = void 0;\r\n                                unlinkCell(cell);\r\n                            }\r\n                            obj = cell && cell.obj;\r\n                            ctx.cells.delete(d);\r\n                            deletedObjects.push(obj);\r\n                        }\r\n                        // Find roots where transform version changed or where nodes will be added.\r\n                        roots = findUpdateRoots(ctx.cells, ctx.tree);\r\n                    }\r\n                    init = initCells(ctx, roots);\r\n                    // Notify additions of new cells.\r\n                    for (_b = 0, _c = init.added; _b < _c.length; _b++) {\r\n                        cell = _c[_b];\r\n                        ctx.parent.events.cell.created.next({ state: ctx.parent, ref: cell.transform.ref, cell: cell });\r\n                    }\r\n                    for (i = 0; i < deletes.length; i++) {\r\n                        d = deletes[i];\r\n                        parent_1 = ctx.oldTree.transforms.get(d).parent;\r\n                        ctx.parent.events.object.removed.next({ state: ctx.parent, ref: d, obj: deletedObjects[i] });\r\n                        ctx.parent.events.cell.removed.next({ state: ctx.parent, ref: d, parent: parent_1 });\r\n                    }\r\n                    if (deletedObjects.length)\r\n                        deletedObjects = [];\r\n                    if (init.dependent) {\r\n                        for (_d = 0, _e = init.dependent; _d < _e.length; _d++) {\r\n                            cell = _e[_d];\r\n                            roots.push(cell.transform.ref);\r\n                        }\r\n                    }\r\n                    // Set status of cells that will be updated to 'pending'.\r\n                    initCellStatus(ctx, roots);\r\n                    _f = 0, roots_1 = roots;\r\n                    _j.label = 1;\r\n                case 1:\r\n                    if (!(_f < roots_1.length)) return [3 /*break*/, 4];\r\n                    root = roots_1[_f];\r\n                    return [4 /*yield*/, updateSubtree(ctx, root)];\r\n                case 2:\r\n                    _j.sent();\r\n                    _j.label = 3;\r\n                case 3:\r\n                    _f++;\r\n                    return [3 /*break*/, 1];\r\n                case 4:\r\n                    // Sync cell states\r\n                    if (!ctx.editInfo) {\r\n                        syncNewStates(ctx);\r\n                    }\r\n                    newCurrent = ctx.newCurrent;\r\n                    // Raise object updated events\r\n                    for (_g = 0, _h = ctx.results; _g < _h.length; _g++) {\r\n                        update_1 = _h[_g];\r\n                        if (update_1.action === 'created') {\r\n                            ctx.parent.events.object.created.next({ state: ctx.parent, ref: update_1.ref, obj: update_1.obj });\r\n                            if (!ctx.newCurrent) {\r\n                                transform = ctx.tree.transforms.get(update_1.ref);\r\n                                if (!transform.state.isGhost && update_1.obj !== StateObject.Null)\r\n                                    newCurrent = update_1.ref;\r\n                            }\r\n                        }\r\n                        else if (update_1.action === 'updated') {\r\n                            ctx.parent.events.object.updated.next({ state: ctx.parent, ref: update_1.ref, action: 'in-place', obj: update_1.obj, oldData: update_1.oldData });\r\n                        }\r\n                        else if (update_1.action === 'replaced') {\r\n                            ctx.parent.events.object.updated.next({ state: ctx.parent, ref: update_1.ref, action: 'recreate', obj: update_1.obj, oldObj: update_1.oldObj });\r\n                        }\r\n                    }\r\n                    if (newCurrent) {\r\n                        if (!ctx.options.doNotUpdateCurrent)\r\n                            ctx.parent.setCurrent(newCurrent);\r\n                    }\r\n                    else {\r\n                        current = ctx.parent.current;\r\n                        currentCell = ctx.cells.get(current);\r\n                        if (currentCell && (currentCell.obj === StateObject.Null\r\n                            || (currentCell.status === 'error' && currentCell.errorText === ParentNullErrorText))) {\r\n                            newCurrent = findNewCurrent(ctx.oldTree, current, [], ctx.cells);\r\n                            ctx.parent.setCurrent(newCurrent);\r\n                        }\r\n                    }\r\n                    return [2 /*return*/, deletes.length > 0 || roots.length > 0 || ctx.changed];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction findUpdateRoots(cells, tree) {\r\n    var findState = { roots: [], cells: cells };\r\n    StateTree.doPreOrder(tree, tree.root, findState, findUpdateRootsVisitor);\r\n    return findState.roots;\r\n}\r\nfunction findUpdateRootsVisitor(n, _, s) {\r\n    var cell = s.cells.get(n.ref);\r\n    if (!cell || cell.transform.version !== n.version) {\r\n        s.roots.push(n.ref);\r\n        return false;\r\n    }\r\n    if (cell.status === 'error')\r\n        return false;\r\n    // nothing below a Null object can be an update root\r\n    if (cell && cell.obj === StateObject.Null)\r\n        return false;\r\n    return true;\r\n}\r\nfunction checkDeleteVisitor(n, _, ctx) {\r\n    if (!ctx.newTree.transforms.has(n.ref) && ctx.cells.has(n.ref))\r\n        ctx.deletes.push(n.ref);\r\n}\r\nfunction findDeletes(ctx) {\r\n    var deleteCtx = { newTree: ctx.tree, cells: ctx.cells, deletes: [] };\r\n    StateTree.doPostOrder(ctx.oldTree, ctx.oldTree.root, deleteCtx, checkDeleteVisitor);\r\n    return deleteCtx.deletes;\r\n}\r\nfunction syncNewStatesVisitor(n, tree, ctx) {\r\n    var cell = ctx.cells.get(n.ref);\r\n    if (!cell || !StateTransform.syncState(cell.state, n.state))\r\n        return;\r\n    ctx.parent.events.cell.stateUpdated.next({ state: ctx.parent, ref: n.ref, cell: cell });\r\n}\r\nfunction syncNewStates(ctx) {\r\n    StateTree.doPreOrder(ctx.tree, ctx.tree.root, ctx, syncNewStatesVisitor);\r\n}\r\nfunction setCellStatus(ctx, ref, status, errorText) {\r\n    var cell = ctx.cells.get(ref);\r\n    var changed = cell.status !== status;\r\n    cell.status = status;\r\n    cell.errorText = errorText;\r\n    if (changed)\r\n        ctx.parent.events.cell.stateUpdated.next({ state: ctx.parent, ref: ref, cell: cell });\r\n}\r\nfunction initCellStatusVisitor(t, _, ctx) {\r\n    ctx.cells.get(t.ref).transform = t;\r\n    setCellStatus(ctx, t.ref, 'pending');\r\n}\r\nfunction initCellStatus(ctx, roots) {\r\n    for (var _i = 0, roots_2 = roots; _i < roots_2.length; _i++) {\r\n        var root = roots_2[_i];\r\n        StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), ctx, initCellStatusVisitor);\r\n    }\r\n}\r\nfunction unlinkCell(cell) {\r\n    for (var _i = 0, _a = cell.dependencies.dependsOn; _i < _a.length; _i++) {\r\n        var other = _a[_i];\r\n        arraySetRemove(other.dependencies.dependentBy, cell);\r\n    }\r\n}\r\nfunction addCellsVisitor(transform, _, _a) {\r\n    var ctx = _a.ctx, added = _a.added, visited = _a.visited;\r\n    visited.add(transform.ref);\r\n    if (ctx.cells.has(transform.ref)) {\r\n        return;\r\n    }\r\n    var cell = {\r\n        parent: ctx.parent,\r\n        transform: transform,\r\n        sourceRef: void 0,\r\n        status: 'pending',\r\n        state: __assign({}, transform.state),\r\n        errorText: void 0,\r\n        params: void 0,\r\n        paramsNormalizedVersion: '',\r\n        dependencies: { dependentBy: [], dependsOn: [] },\r\n        cache: void 0\r\n    };\r\n    ctx.cells.set(transform.ref, cell);\r\n    added.push(cell);\r\n}\r\n// type LinkCellsCtx = { ctx: UpdateContext, visited: Set<Ref>, dependent: UniqueArray<Ref, StateObjectCell> }\r\nfunction linkCells(target, ctx) {\r\n    if (!target.transform.dependsOn)\r\n        return;\r\n    for (var _i = 0, _a = target.transform.dependsOn; _i < _a.length; _i++) {\r\n        var ref = _a[_i];\r\n        var t = ctx.tree.transforms.get(ref);\r\n        if (!t) {\r\n            throw new Error(\"Cannot depend on a non-existent transform.\");\r\n        }\r\n        var cell = ctx.cells.get(ref);\r\n        arraySetAdd(target.dependencies.dependsOn, cell);\r\n        arraySetAdd(cell.dependencies.dependentBy, target);\r\n    }\r\n}\r\nfunction initCells(ctx, roots) {\r\n    var initCtx = { ctx: ctx, visited: new Set(), added: [] };\r\n    // Add new cells\r\n    for (var _i = 0, roots_3 = roots; _i < roots_3.length; _i++) {\r\n        var root = roots_3[_i];\r\n        StateTree.doPreOrder(ctx.tree, ctx.tree.transforms.get(root), initCtx, addCellsVisitor);\r\n    }\r\n    // Update links for newly added cells\r\n    for (var _a = 0, _b = initCtx.added; _a < _b.length; _a++) {\r\n        var cell = _b[_a];\r\n        linkCells(cell, ctx);\r\n    }\r\n    var dependent;\r\n    // Find dependent cells\r\n    initCtx.visited.forEach(function (ref) {\r\n        var cell = ctx.cells.get(ref);\r\n        for (var _i = 0, _a = cell.dependencies.dependentBy; _i < _a.length; _i++) {\r\n            var by = _a[_i];\r\n            if (initCtx.visited.has(by.transform.ref))\r\n                continue;\r\n            if (!dependent)\r\n                dependent = UniqueArray.create();\r\n            UniqueArray.add(dependent, by.transform.ref, by);\r\n        }\r\n    });\r\n    // TODO: check if dependent cells are all \"proper roots\"\r\n    return { added: initCtx.added, dependent: dependent ? dependent.array : void 0 };\r\n}\r\nfunction findNewCurrent(tree, start, deletes, cells) {\r\n    var deleteSet = new Set(deletes);\r\n    return _findNewCurrent(tree, start, deleteSet, cells);\r\n}\r\nfunction _findNewCurrent(tree, ref, deletes, cells) {\r\n    if (ref === StateTransform.RootRef)\r\n        return ref;\r\n    var node = tree.transforms.get(ref);\r\n    var siblings = tree.children.get(node.parent).values();\r\n    var prevCandidate = void 0, seenRef = false;\r\n    while (true) {\r\n        var s = siblings.next();\r\n        if (s.done)\r\n            break;\r\n        if (deletes.has(s.value))\r\n            continue;\r\n        var cell = cells.get(s.value);\r\n        if (!cell || cell.status === 'error' || cell.obj === StateObject.Null) {\r\n            continue;\r\n        }\r\n        var t = tree.transforms.get(s.value);\r\n        if (t.state.isGhost)\r\n            continue;\r\n        if (s.value === ref) {\r\n            seenRef = true;\r\n            if (!deletes.has(ref))\r\n                prevCandidate = ref;\r\n            continue;\r\n        }\r\n        if (seenRef)\r\n            return t.ref;\r\n        prevCandidate = t.ref;\r\n    }\r\n    if (prevCandidate)\r\n        return prevCandidate;\r\n    return _findNewCurrent(tree, node.parent, deletes, cells);\r\n}\r\n/** Set status and error text of the cell. Remove all existing objects in the subtree. */\r\nfunction doError(ctx, ref, errorObject, silent) {\r\n    if (!silent) {\r\n        ctx.hadError = true;\r\n        ctx.parent.errorFree = false;\r\n    }\r\n    var cell = ctx.cells.get(ref);\r\n    if (errorObject) {\r\n        ctx.wasAborted = ctx.wasAborted || Task.isAbort(errorObject);\r\n        var message = '' + errorObject;\r\n        setCellStatus(ctx, ref, 'error', message);\r\n        if (!silent)\r\n            ctx.parent.events.log.next({ type: 'error', timestamp: new Date(), message: message });\r\n    }\r\n    else {\r\n        cell.params = void 0;\r\n    }\r\n    if (cell.obj) {\r\n        var obj = cell.obj;\r\n        cell.obj = void 0;\r\n        cell.cache = void 0;\r\n        ctx.parent.events.object.removed.next({ state: ctx.parent, ref: ref, obj: obj });\r\n    }\r\n    // remove the objects in the child nodes if they exist\r\n    var children = ctx.tree.children.get(ref).values();\r\n    while (true) {\r\n        var next = children.next();\r\n        if (next.done)\r\n            return;\r\n        doError(ctx, next.value, void 0, silent);\r\n    }\r\n}\r\nvar ParentNullErrorText = 'Parent is null';\r\nfunction updateSubtree(ctx, root) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var isNull, start, update_2, time, e_2, children, next;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    setCellStatus(ctx, root, 'processing');\r\n                    isNull = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 4]);\r\n                    start = now();\r\n                    return [4 /*yield*/, updateNode(ctx, root)];\r\n                case 2:\r\n                    update_2 = _a.sent();\r\n                    time = now() - start;\r\n                    if (update_2.action !== 'none')\r\n                        ctx.changed = true;\r\n                    setCellStatus(ctx, root, 'ok');\r\n                    ctx.results.push(update_2);\r\n                    if (update_2.action === 'created') {\r\n                        isNull = update_2.obj === StateObject.Null;\r\n                        if (!isNull && !ctx.options.doNotLogTiming)\r\n                            ctx.parent.events.log.next(LogEntry.info(\"Created \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\r\n                    }\r\n                    else if (update_2.action === 'updated') {\r\n                        isNull = update_2.obj === StateObject.Null;\r\n                        if (!isNull && !ctx.options.doNotLogTiming)\r\n                            ctx.parent.events.log.next(LogEntry.info(\"Updated \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\r\n                    }\r\n                    else if (update_2.action === 'replaced') {\r\n                        isNull = update_2.obj === StateObject.Null;\r\n                        if (!isNull && !ctx.options.doNotLogTiming)\r\n                            ctx.parent.events.log.next(LogEntry.info(\"Updated \" + update_2.obj.label + \" in \" + formatTimespan(time) + \".\"));\r\n                    }\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    e_2 = _a.sent();\r\n                    ctx.changed = true;\r\n                    if (!ctx.hadError)\r\n                        ctx.newCurrent = root;\r\n                    doError(ctx, root, e_2, false);\r\n                    if (!isProductionMode)\r\n                        console.error(e_2);\r\n                    return [2 /*return*/];\r\n                case 4:\r\n                    children = ctx.tree.children.get(root).values();\r\n                    _a.label = 5;\r\n                case 5:\r\n                    if (!true) return [3 /*break*/, 9];\r\n                    next = children.next();\r\n                    if (next.done)\r\n                        return [2 /*return*/];\r\n                    if (!isNull) return [3 /*break*/, 6];\r\n                    doError(ctx, next.value, void 0, true);\r\n                    return [3 /*break*/, 8];\r\n                case 6: return [4 /*yield*/, updateSubtree(ctx, next.value)];\r\n                case 7:\r\n                    _a.sent();\r\n                    _a.label = 8;\r\n                case 8: return [3 /*break*/, 5];\r\n                case 9: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction resolveParams(ctx, transform, src, cell) {\r\n    var prms = transform.transformer.definition.params;\r\n    var definition = prms ? prms(src, ctx.parent.globalContext) : {};\r\n    if (cell.paramsNormalizedVersion !== transform.version) {\r\n        transform.params = ParamDefinition.normalizeParams(definition, transform.params, 'all');\r\n        cell.paramsNormalizedVersion = transform.version;\r\n    }\r\n    else {\r\n        var defaultValues = ParamDefinition.getDefaultValues(definition);\r\n        transform.params = transform.params\r\n            ? assignIfUndefined(transform.params, defaultValues)\r\n            : defaultValues;\r\n    }\r\n    ParamDefinition.resolveRefs(definition, transform.params, ctx.getCellData);\r\n    return { definition: definition, values: transform.params };\r\n}\r\nfunction updateNode(ctx, currentRef) {\r\n    var _a;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var oldTree, tree, current, transform, parentCell, parent, params, obj, oldParams, oldCache, oldData, newParams, updateKind, _b, _c, oldObj, newObj;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    oldTree = ctx.oldTree, tree = ctx.tree;\r\n                    current = ctx.cells.get(currentRef);\r\n                    transform = current.transform;\r\n                    // special case for Root\r\n                    if (current.transform.ref === StateTransform.RootRef) {\r\n                        return [2 /*return*/, { action: 'none' }];\r\n                    }\r\n                    parentCell = transform.transformer.definition.from.length === 0\r\n                        ? ctx.cells.get(current.transform.parent)\r\n                        : StateSelection.findAncestorOfType(tree, ctx.cells, currentRef, transform.transformer.definition.from);\r\n                    if (!parentCell) {\r\n                        throw new Error(\"No suitable parent found for '\" + currentRef + \"'\");\r\n                    }\r\n                    ctx.spine.current = current;\r\n                    parent = parentCell.obj;\r\n                    current.sourceRef = parentCell.transform.ref;\r\n                    params = resolveParams(ctx, transform, parent, current);\r\n                    if (!(!oldTree.transforms.has(currentRef) || !current.params)) return [3 /*break*/, 2];\r\n                    current.params = params;\r\n                    return [4 /*yield*/, createObject(ctx, current, transform.transformer, parent, params.values)];\r\n                case 1:\r\n                    obj = _d.sent();\r\n                    updateTag(obj, transform);\r\n                    current.obj = obj;\r\n                    return [2 /*return*/, { ref: currentRef, action: 'created', obj: obj }];\r\n                case 2:\r\n                    oldParams = current.params.values;\r\n                    oldCache = current.cache;\r\n                    oldData = (_a = current.obj) === null || _a === void 0 ? void 0 : _a.data;\r\n                    newParams = params.values;\r\n                    current.params = params;\r\n                    if (!(!!current.obj && current.obj !== StateObject.Null)) return [3 /*break*/, 4];\r\n                    return [4 /*yield*/, updateObject(ctx, current, transform.transformer, parent, current.obj, oldParams, newParams)];\r\n                case 3:\r\n                    _b = _d.sent();\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    _b = StateTransformer.UpdateResult.Recreate;\r\n                    _d.label = 5;\r\n                case 5:\r\n                    updateKind = _b;\r\n                    _c = updateKind;\r\n                    switch (_c) {\r\n                        case StateTransformer.UpdateResult.Recreate: return [3 /*break*/, 6];\r\n                        case StateTransformer.UpdateResult.Updated: return [3 /*break*/, 8];\r\n                        case StateTransformer.UpdateResult.Null: return [3 /*break*/, 9];\r\n                    }\r\n                    return [3 /*break*/, 10];\r\n                case 6:\r\n                    oldObj = current.obj;\r\n                    dispose(transform, oldObj, oldParams, oldCache, ctx.parent.globalContext);\r\n                    return [4 /*yield*/, createObject(ctx, current, transform.transformer, parent, newParams)];\r\n                case 7:\r\n                    newObj = _d.sent();\r\n                    updateTag(newObj, transform);\r\n                    current.obj = newObj;\r\n                    return [2 /*return*/, { ref: currentRef, action: 'replaced', oldObj: oldObj, obj: newObj }];\r\n                case 8:\r\n                    updateTag(current.obj, transform);\r\n                    return [2 /*return*/, { ref: currentRef, action: 'updated', oldData: oldData, obj: current.obj }];\r\n                case 9:\r\n                    {\r\n                        dispose(transform, current.obj, oldParams, oldCache, ctx.parent.globalContext);\r\n                        current.obj = StateObject.Null;\r\n                        return [2 /*return*/, { ref: currentRef, action: 'updated', obj: current.obj }];\r\n                    }\r\n                    _d.label = 10;\r\n                case 10: return [2 /*return*/, { action: 'none' }];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction dispose(transform, b, params, cache, globalContext) {\r\n    var _a, _b;\r\n    (_b = (_a = transform.transformer.definition).dispose) === null || _b === void 0 ? void 0 : _b.call(_a, {\r\n        b: b !== StateObject.Null ? b : void 0,\r\n        params: params,\r\n        cache: cache\r\n    }, globalContext);\r\n}\r\nfunction updateTag(obj, transform) {\r\n    if (!obj || obj === StateObject.Null)\r\n        return;\r\n    obj.tags = transform.tags;\r\n}\r\nfunction runTask(t, ctx) {\r\n    if (typeof t.runInContext === 'function')\r\n        return t.runInContext(ctx);\r\n    return t;\r\n}\r\nfunction resolveDependencies(cell) {\r\n    if (cell.dependencies.dependsOn.length === 0)\r\n        return void 0;\r\n    var deps = Object.create(null);\r\n    for (var _i = 0, _a = cell.dependencies.dependsOn; _i < _a.length; _i++) {\r\n        var dep = _a[_i];\r\n        if (!dep.obj) {\r\n            throw new Error('Unresolved dependency.');\r\n        }\r\n        deps[dep.transform.ref] = dep.obj;\r\n    }\r\n    return deps;\r\n}\r\nfunction createObject(ctx, cell, transformer, a, params) {\r\n    if (!cell.cache)\r\n        cell.cache = Object.create(null);\r\n    return runTask(transformer.definition.apply({ a: a, params: params, cache: cell.cache, spine: ctx.spine, dependencies: resolveDependencies(cell) }, ctx.parent.globalContext), ctx.taskCtx);\r\n}\r\nfunction updateObject(ctx, cell, transformer, a, b, oldParams, newParams) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            if (!transformer.definition.update) {\r\n                return [2 /*return*/, StateTransformer.UpdateResult.Recreate];\r\n            }\r\n            if (!cell.cache)\r\n                cell.cache = Object.create(null);\r\n            return [2 /*return*/, runTask(transformer.definition.update({ a: a, oldParams: oldParams, b: b, newParams: newParams, cache: cell.cache, spine: ctx.spine, dependencies: resolveDependencies(cell) }, ctx.parent.globalContext), ctx.taskCtx)];\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=state.js.map"]},"metadata":{},"sourceType":"module"}