{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { mmCIF_Schema } from '../../../mol-io/reader/cif/schema/mmcif';\nimport { Spacegroup, SpacegroupCell, SymmetryOperator } from '../../../mol-math/geometry';\nimport { Tensor, Vec3, Mat3 } from '../../../mol-math/linear-algebra';\nimport { createAssemblies } from './assembly';\nimport { FormatPropertyProvider } from '../common/property';\nexport { ModelSymmetry };\nvar ModelSymmetry;\n\n(function (ModelSymmetry) {\n  ModelSymmetry.Descriptor = {\n    name: 'model_symmetry'\n  };\n  ModelSymmetry.Provider = FormatPropertyProvider.create(ModelSymmetry.Descriptor);\n\n  function fromData(data) {\n    var assemblies = createAssemblies(data.pdbx_struct_assembly, data.pdbx_struct_assembly_gen, data.pdbx_struct_oper_list);\n    var spacegroup = getSpacegroup(data.symmetry, data.cell);\n    var isNonStandardCrystalFrame = checkNonStandardCrystalFrame(data.atom_sites, spacegroup);\n    return {\n      assemblies: assemblies,\n      spacegroup: spacegroup,\n      isNonStandardCrystalFrame: isNonStandardCrystalFrame,\n      ncsOperators: getNcsOperators(data.struct_ncs_oper)\n    };\n  }\n\n  ModelSymmetry.fromData = fromData;\n\n  function fromCell(size, anglesInRadians) {\n    var spaceCell = SpacegroupCell.create('P 1', size, anglesInRadians);\n    var spacegroup = Spacegroup.create(spaceCell);\n    return {\n      assemblies: [],\n      spacegroup: spacegroup,\n      isNonStandardCrystalFrame: false\n    };\n  }\n\n  ModelSymmetry.fromCell = fromCell;\n})(ModelSymmetry || (ModelSymmetry = {}));\n\nfunction checkNonStandardCrystalFrame(atom_sites, spacegroup) {\n  if (atom_sites._rowCount === 0) return false; // TODO: parse atom_sites transform and check if it corresponds to the toFractional matrix\n\n  return false;\n}\n\nfunction getSpacegroupNameOrNumber(symmetry) {\n  var groupNumber = symmetry['Int_Tables_number'].value(0);\n  var groupName = symmetry['space_group_name_H-M'].value(0);\n  if (!symmetry['Int_Tables_number'].isDefined) return groupName;\n  if (!symmetry['space_group_name_H-M'].isDefined) return groupNumber;\n  return groupName;\n}\n\nfunction getSpacegroup(symmetry, cell) {\n  if (symmetry._rowCount === 0 || cell._rowCount === 0) return Spacegroup.ZeroP1;\n  var nameOrNumber = getSpacegroupNameOrNumber(symmetry);\n  var spaceCell = SpacegroupCell.create(nameOrNumber, Vec3.create(cell.length_a.value(0), cell.length_b.value(0), cell.length_c.value(0)), Vec3.scale(Vec3.zero(), Vec3.create(cell.angle_alpha.value(0), cell.angle_beta.value(0), cell.angle_gamma.value(0)), Math.PI / 180));\n  return Spacegroup.create(spaceCell);\n}\n\nfunction getNcsOperators(struct_ncs_oper) {\n  if (struct_ncs_oper._rowCount === 0) return void 0;\n  var id = struct_ncs_oper.id,\n      matrix = struct_ncs_oper.matrix,\n      vector = struct_ncs_oper.vector;\n  var matrixSpace = mmCIF_Schema.struct_ncs_oper.matrix.space,\n      vectorSpace = mmCIF_Schema.struct_ncs_oper.vector.space;\n  var opers = [];\n\n  for (var i = 0; i < struct_ncs_oper._rowCount; i++) {\n    var m = Tensor.toMat3(Mat3(), matrixSpace, matrix.value(i));\n    var v = Tensor.toVec3(Vec3(), vectorSpace, vector.value(i));\n    if (!SymmetryOperator.checkIfRotationAndTranslation(m, v)) continue; // ignore non-identity 'given' NCS operators\n\n    if (struct_ncs_oper.code.value(i) === 'given' && !Mat3.isIdentity(m) && !Vec3.isZero(v)) continue;\n    var ncsId = id.value(i);\n    opers[opers.length] = SymmetryOperator.ofRotationAndOffset(\"ncs_\" + ncsId, m, v, ncsId);\n  }\n\n  return opers;\n}","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/property/symmetry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { mmCIF_Schema } from '../../../mol-io/reader/cif/schema/mmcif';\r\nimport { Spacegroup, SpacegroupCell, SymmetryOperator } from '../../../mol-math/geometry';\r\nimport { Tensor, Vec3, Mat3 } from '../../../mol-math/linear-algebra';\r\nimport { createAssemblies } from './assembly';\r\nimport { FormatPropertyProvider } from '../common/property';\r\nexport { ModelSymmetry };\r\nvar ModelSymmetry;\r\n(function (ModelSymmetry) {\r\n    ModelSymmetry.Descriptor = {\r\n        name: 'model_symmetry',\r\n    };\r\n    ModelSymmetry.Provider = FormatPropertyProvider.create(ModelSymmetry.Descriptor);\r\n    function fromData(data) {\r\n        var assemblies = createAssemblies(data.pdbx_struct_assembly, data.pdbx_struct_assembly_gen, data.pdbx_struct_oper_list);\r\n        var spacegroup = getSpacegroup(data.symmetry, data.cell);\r\n        var isNonStandardCrystalFrame = checkNonStandardCrystalFrame(data.atom_sites, spacegroup);\r\n        return { assemblies: assemblies, spacegroup: spacegroup, isNonStandardCrystalFrame: isNonStandardCrystalFrame, ncsOperators: getNcsOperators(data.struct_ncs_oper) };\r\n    }\r\n    ModelSymmetry.fromData = fromData;\r\n    function fromCell(size, anglesInRadians) {\r\n        var spaceCell = SpacegroupCell.create('P 1', size, anglesInRadians);\r\n        var spacegroup = Spacegroup.create(spaceCell);\r\n        return { assemblies: [], spacegroup: spacegroup, isNonStandardCrystalFrame: false };\r\n    }\r\n    ModelSymmetry.fromCell = fromCell;\r\n})(ModelSymmetry || (ModelSymmetry = {}));\r\nfunction checkNonStandardCrystalFrame(atom_sites, spacegroup) {\r\n    if (atom_sites._rowCount === 0)\r\n        return false;\r\n    // TODO: parse atom_sites transform and check if it corresponds to the toFractional matrix\r\n    return false;\r\n}\r\nfunction getSpacegroupNameOrNumber(symmetry) {\r\n    var groupNumber = symmetry['Int_Tables_number'].value(0);\r\n    var groupName = symmetry['space_group_name_H-M'].value(0);\r\n    if (!symmetry['Int_Tables_number'].isDefined)\r\n        return groupName;\r\n    if (!symmetry['space_group_name_H-M'].isDefined)\r\n        return groupNumber;\r\n    return groupName;\r\n}\r\nfunction getSpacegroup(symmetry, cell) {\r\n    if (symmetry._rowCount === 0 || cell._rowCount === 0)\r\n        return Spacegroup.ZeroP1;\r\n    var nameOrNumber = getSpacegroupNameOrNumber(symmetry);\r\n    var spaceCell = SpacegroupCell.create(nameOrNumber, Vec3.create(cell.length_a.value(0), cell.length_b.value(0), cell.length_c.value(0)), Vec3.scale(Vec3.zero(), Vec3.create(cell.angle_alpha.value(0), cell.angle_beta.value(0), cell.angle_gamma.value(0)), Math.PI / 180));\r\n    return Spacegroup.create(spaceCell);\r\n}\r\nfunction getNcsOperators(struct_ncs_oper) {\r\n    if (struct_ncs_oper._rowCount === 0)\r\n        return void 0;\r\n    var id = struct_ncs_oper.id, matrix = struct_ncs_oper.matrix, vector = struct_ncs_oper.vector;\r\n    var matrixSpace = mmCIF_Schema.struct_ncs_oper.matrix.space, vectorSpace = mmCIF_Schema.struct_ncs_oper.vector.space;\r\n    var opers = [];\r\n    for (var i = 0; i < struct_ncs_oper._rowCount; i++) {\r\n        var m = Tensor.toMat3(Mat3(), matrixSpace, matrix.value(i));\r\n        var v = Tensor.toVec3(Vec3(), vectorSpace, vector.value(i));\r\n        if (!SymmetryOperator.checkIfRotationAndTranslation(m, v))\r\n            continue;\r\n        // ignore non-identity 'given' NCS operators\r\n        if (struct_ncs_oper.code.value(i) === 'given' && !Mat3.isIdentity(m) && !Vec3.isZero(v))\r\n            continue;\r\n        var ncsId = id.value(i);\r\n        opers[opers.length] = SymmetryOperator.ofRotationAndOffset(\"ncs_\" + ncsId, m, v, ncsId);\r\n    }\r\n    return opers;\r\n}\r\n//# sourceMappingURL=symmetry.js.map"]},"metadata":{},"sourceType":"module"}