{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport * as Data from '../data-model';\nimport { Field } from './field';\nimport { ReaderResult as Result } from '../../result';\nimport { decodeMsgPack } from '../../../common/msgpack/decode';\nimport { Task } from '../../../../mol-task';\n\nfunction checkVersions(min, current) {\n  for (var i = 0; i < 2; i++) {\n    if (min[i] > current[i]) return false;\n  }\n\n  return true;\n}\n\nfunction Category(data) {\n  var map = Object.create(null);\n  var cache = Object.create(null);\n\n  for (var _i = 0, _a = data.columns; _i < _a.length; _i++) {\n    var col = _a[_i];\n    map[col.name] = col;\n  }\n\n  return {\n    rowCount: data.rowCount,\n    name: data.name.substr(1),\n    fieldNames: data.columns.map(function (c) {\n      return c.name;\n    }),\n    getField: function (name) {\n      var col = map[name];\n      if (!col) return void 0;\n      if (!!cache[name]) return cache[name];\n      cache[name] = Field(col);\n      return cache[name];\n    }\n  };\n}\n\nexport function parseCifBinary(data) {\n  var _this = this;\n\n  return Task.create('Parse BinaryCIF', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var minVersion, unpacked, file;\n      return __generator(this, function (_a) {\n        minVersion = [0, 3];\n\n        try {\n          unpacked = decodeMsgPack(data);\n\n          if (!checkVersions(minVersion, unpacked.version.match(/(\\d)\\.(\\d)\\.\\d/).slice(1).map(function (v) {\n            return +v;\n          }))) {\n            return [2\n            /*return*/\n            , Result.error(\"Unsupported format version. Current \" + unpacked.version + \", required \" + minVersion.join('.') + \".\")];\n          }\n\n          file = Data.CifFile(unpacked.dataBlocks.map(function (block) {\n            var cats = Object.create(null);\n\n            for (var _i = 0, _a = block.categories; _i < _a.length; _i++) {\n              var cat = _a[_i];\n              cats[cat.name.substr(1)] = Category(cat);\n            }\n\n            return Data.CifBlock(block.categories.map(function (c) {\n              return c.name.substr(1);\n            }), cats, block.header);\n          }));\n          return [2\n          /*return*/\n          , Result.success(file)];\n        } catch (e) {\n          return [2\n          /*return*/\n          , Result.error('' + e)];\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-io/reader/cif/binary/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport * as Data from '../data-model';\r\nimport { Field } from './field';\r\nimport { ReaderResult as Result } from '../../result';\r\nimport { decodeMsgPack } from '../../../common/msgpack/decode';\r\nimport { Task } from '../../../../mol-task';\r\nfunction checkVersions(min, current) {\r\n    for (var i = 0; i < 2; i++) {\r\n        if (min[i] > current[i])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction Category(data) {\r\n    var map = Object.create(null);\r\n    var cache = Object.create(null);\r\n    for (var _i = 0, _a = data.columns; _i < _a.length; _i++) {\r\n        var col = _a[_i];\r\n        map[col.name] = col;\r\n    }\r\n    return {\r\n        rowCount: data.rowCount,\r\n        name: data.name.substr(1),\r\n        fieldNames: data.columns.map(function (c) { return c.name; }),\r\n        getField: function (name) {\r\n            var col = map[name];\r\n            if (!col)\r\n                return void 0;\r\n            if (!!cache[name])\r\n                return cache[name];\r\n            cache[name] = Field(col);\r\n            return cache[name];\r\n        }\r\n    };\r\n}\r\nexport function parseCifBinary(data) {\r\n    var _this = this;\r\n    return Task.create('Parse BinaryCIF', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var minVersion, unpacked, file;\r\n        return __generator(this, function (_a) {\r\n            minVersion = [0, 3];\r\n            try {\r\n                unpacked = decodeMsgPack(data);\r\n                if (!checkVersions(minVersion, unpacked.version.match(/(\\d)\\.(\\d)\\.\\d/).slice(1).map(function (v) { return +v; }))) {\r\n                    return [2 /*return*/, Result.error(\"Unsupported format version. Current \" + unpacked.version + \", required \" + minVersion.join('.') + \".\")];\r\n                }\r\n                file = Data.CifFile(unpacked.dataBlocks.map(function (block) {\r\n                    var cats = Object.create(null);\r\n                    for (var _i = 0, _a = block.categories; _i < _a.length; _i++) {\r\n                        var cat = _a[_i];\r\n                        cats[cat.name.substr(1)] = Category(cat);\r\n                    }\r\n                    return Data.CifBlock(block.categories.map(function (c) { return c.name.substr(1); }), cats, block.header);\r\n                }));\r\n                return [2 /*return*/, Result.success(file)];\r\n            }\r\n            catch (e) {\r\n                return [2 /*return*/, Result.error('' + e)];\r\n            }\r\n            return [2 /*return*/];\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}