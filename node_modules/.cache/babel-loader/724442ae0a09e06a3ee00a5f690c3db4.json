{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from NGL.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { chunkedSubtask, Task } from '../../../mol-task';\nimport { parseFloat as fastParseFloat } from '../common/text/number-parser';\nimport { Tokenizer } from '../common/text/tokenizer';\nimport { ReaderResult as Result } from '../result';\nimport { utf8Read } from '../../common/utf8';\n\nfunction readHeader(tokenizer) {\n  var header = {\n    h: Vec3()\n  };\n  var headerByteCount = 0;\n  var deltaLineCount = 0;\n  var reWhitespace = /\\s+/g;\n\n  while (true) {\n    var line = Tokenizer.readLine(tokenizer);\n    var ls = void 0;\n\n    if (line.startsWith('object 1')) {\n      ls = line.split(reWhitespace);\n      header.dim = Vec3.create(parseInt(ls[5]), parseInt(ls[6]), parseInt(ls[7]));\n    } else if (line.startsWith('origin')) {\n      ls = line.split(reWhitespace);\n      header.min = Vec3.create(parseFloat(ls[1]), parseFloat(ls[2]), parseFloat(ls[3]));\n    } else if (line.startsWith('delta')) {\n      ls = line.split(reWhitespace);\n\n      if (deltaLineCount === 0) {\n        header.h[0] = parseFloat(ls[1]);\n      } else if (deltaLineCount === 1) {\n        header.h[1] = parseFloat(ls[2]);\n      } else if (deltaLineCount === 2) {\n        header.h[2] = parseFloat(ls[3]);\n      }\n\n      deltaLineCount += 1;\n    } else if (line.startsWith('object 3')) {\n      headerByteCount += line.length + 1;\n      break;\n    }\n\n    headerByteCount += line.length + 1;\n  }\n\n  return {\n    header: header,\n    headerByteCount: headerByteCount\n  };\n}\n\nfunction readValuesText(ctx, tokenizer, header) {\n  var N = header.dim[0] * header.dim[1] * header.dim[2];\n  var chunkSize = 100 * 100 * 100;\n  var data = new Float64Array(N);\n  var offset = 0;\n  return chunkedSubtask(ctx, chunkSize, data, function (count, data) {\n    var max = Math.min(N, offset + count);\n\n    for (var i = offset; i < max; i++) {\n      Tokenizer.skipWhitespace(tokenizer);\n      tokenizer.tokenStart = tokenizer.position;\n      Tokenizer.eatValue(tokenizer);\n      data[i] = fastParseFloat(tokenizer.data, tokenizer.tokenStart, tokenizer.tokenEnd);\n    }\n\n    offset = max;\n    return max === N ? 0 : chunkSize;\n  }, function (ctx, _, i) {\n    return ctx.update({\n      current: Math.min(i, N),\n      max: N\n    });\n  });\n}\n\nfunction parseText(taskCtx, data, name) {\n  return __awaiter(this, void 0, void 0, function () {\n    var tokenizer, header, values;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , taskCtx.update('Reading header...')];\n\n        case 1:\n          _a.sent();\n\n          tokenizer = Tokenizer(data);\n          header = readHeader(tokenizer).header;\n          return [4\n          /*yield*/\n          , taskCtx.update('Reading values...')];\n\n        case 2:\n          _a.sent();\n\n          return [4\n          /*yield*/\n          , readValuesText(taskCtx, tokenizer, header)];\n\n        case 3:\n          values = _a.sent();\n          return [2\n          /*return*/\n          , Result.success({\n            header: header,\n            values: values,\n            name: name\n          })];\n      }\n    });\n  });\n}\n\nfunction parseBinary(taskCtx, data, name) {\n  return __awaiter(this, void 0, void 0, function () {\n    var headerString, tokenizer, _a, header, headerByteCount, size, dv, values, i;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , taskCtx.update('Reading header...')];\n\n        case 1:\n          _b.sent();\n\n          headerString = utf8Read(data, 0, 1000);\n          tokenizer = Tokenizer(headerString);\n          _a = readHeader(tokenizer), header = _a.header, headerByteCount = _a.headerByteCount;\n          return [4\n          /*yield*/\n          , taskCtx.update('Reading values...')];\n\n        case 2:\n          _b.sent();\n\n          size = header.dim[0] * header.dim[1] * header.dim[2];\n          dv = new DataView(data.buffer, data.byteOffset + headerByteCount);\n          values = new Float64Array(size);\n\n          for (i = 0; i < size; i++) {\n            values[i] = dv.getFloat64(i * 8, true);\n          } // TODO: why doesnt this work? throw \"attempting to construct out-of-bounds TypedArray\"\n          // const values = new Float64Array(data.buffer, data.byteOffset + headerByteCount, header.dim[0] * header.dim[1] * header.dim[2]);\n\n\n          return [2\n          /*return*/\n          , Result.success({\n            header: header,\n            values: values,\n            name: name\n          })];\n      }\n    });\n  });\n}\n\nexport function parseDx(data, name) {\n  return Task.create('Parse Cube', function (taskCtx) {\n    if (typeof data === 'string') return parseText(taskCtx, data, name);\n    return parseBinary(taskCtx, data, name);\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-io/reader/dx/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from NGL.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { chunkedSubtask, Task } from '../../../mol-task';\r\nimport { parseFloat as fastParseFloat } from '../common/text/number-parser';\r\nimport { Tokenizer } from '../common/text/tokenizer';\r\nimport { ReaderResult as Result } from '../result';\r\nimport { utf8Read } from '../../common/utf8';\r\nfunction readHeader(tokenizer) {\r\n    var header = { h: Vec3() };\r\n    var headerByteCount = 0;\r\n    var deltaLineCount = 0;\r\n    var reWhitespace = /\\s+/g;\r\n    while (true) {\r\n        var line = Tokenizer.readLine(tokenizer);\r\n        var ls = void 0;\r\n        if (line.startsWith('object 1')) {\r\n            ls = line.split(reWhitespace);\r\n            header.dim = Vec3.create(parseInt(ls[5]), parseInt(ls[6]), parseInt(ls[7]));\r\n        }\r\n        else if (line.startsWith('origin')) {\r\n            ls = line.split(reWhitespace);\r\n            header.min = Vec3.create(parseFloat(ls[1]), parseFloat(ls[2]), parseFloat(ls[3]));\r\n        }\r\n        else if (line.startsWith('delta')) {\r\n            ls = line.split(reWhitespace);\r\n            if (deltaLineCount === 0) {\r\n                header.h[0] = parseFloat(ls[1]);\r\n            }\r\n            else if (deltaLineCount === 1) {\r\n                header.h[1] = parseFloat(ls[2]);\r\n            }\r\n            else if (deltaLineCount === 2) {\r\n                header.h[2] = parseFloat(ls[3]);\r\n            }\r\n            deltaLineCount += 1;\r\n        }\r\n        else if (line.startsWith('object 3')) {\r\n            headerByteCount += line.length + 1;\r\n            break;\r\n        }\r\n        headerByteCount += line.length + 1;\r\n    }\r\n    return { header: header, headerByteCount: headerByteCount };\r\n}\r\nfunction readValuesText(ctx, tokenizer, header) {\r\n    var N = header.dim[0] * header.dim[1] * header.dim[2];\r\n    var chunkSize = 100 * 100 * 100;\r\n    var data = new Float64Array(N);\r\n    var offset = 0;\r\n    return chunkedSubtask(ctx, chunkSize, data, function (count, data) {\r\n        var max = Math.min(N, offset + count);\r\n        for (var i = offset; i < max; i++) {\r\n            Tokenizer.skipWhitespace(tokenizer);\r\n            tokenizer.tokenStart = tokenizer.position;\r\n            Tokenizer.eatValue(tokenizer);\r\n            data[i] = fastParseFloat(tokenizer.data, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n        }\r\n        offset = max;\r\n        return max === N ? 0 : chunkSize;\r\n    }, function (ctx, _, i) { return ctx.update({ current: Math.min(i, N), max: N }); });\r\n}\r\nfunction parseText(taskCtx, data, name) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tokenizer, header, values;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, taskCtx.update('Reading header...')];\r\n                case 1:\r\n                    _a.sent();\r\n                    tokenizer = Tokenizer(data);\r\n                    header = readHeader(tokenizer).header;\r\n                    return [4 /*yield*/, taskCtx.update('Reading values...')];\r\n                case 2:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, readValuesText(taskCtx, tokenizer, header)];\r\n                case 3:\r\n                    values = _a.sent();\r\n                    return [2 /*return*/, Result.success({ header: header, values: values, name: name })];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction parseBinary(taskCtx, data, name) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var headerString, tokenizer, _a, header, headerByteCount, size, dv, values, i;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, taskCtx.update('Reading header...')];\r\n                case 1:\r\n                    _b.sent();\r\n                    headerString = utf8Read(data, 0, 1000);\r\n                    tokenizer = Tokenizer(headerString);\r\n                    _a = readHeader(tokenizer), header = _a.header, headerByteCount = _a.headerByteCount;\r\n                    return [4 /*yield*/, taskCtx.update('Reading values...')];\r\n                case 2:\r\n                    _b.sent();\r\n                    size = header.dim[0] * header.dim[1] * header.dim[2];\r\n                    dv = new DataView(data.buffer, data.byteOffset + headerByteCount);\r\n                    values = new Float64Array(size);\r\n                    for (i = 0; i < size; i++) {\r\n                        values[i] = dv.getFloat64(i * 8, true);\r\n                    }\r\n                    // TODO: why doesnt this work? throw \"attempting to construct out-of-bounds TypedArray\"\r\n                    // const values = new Float64Array(data.buffer, data.byteOffset + headerByteCount, header.dim[0] * header.dim[1] * header.dim[2]);\r\n                    return [2 /*return*/, Result.success({ header: header, values: values, name: name })];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function parseDx(data, name) {\r\n    return Task.create('Parse Cube', function (taskCtx) {\r\n        if (typeof data === 'string')\r\n            return parseText(taskCtx, data, name);\r\n        return parseBinary(taskCtx, data, name);\r\n    });\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}