{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { LocationIterator, PositionLocation } from '../../../mol-geo/util/location-iterator';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { createSizes, getMaxSize } from '../size-data';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { hashFnv32a } from '../../../mol-data/util';\nimport { createGroupMapping } from '../../util';\nimport { createEmptyClipping } from '../clipping-data';\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\nexport var Spheres;\n\n(function (Spheres) {\n  function create(centers, mappings, indices, groups, sphereCount, spheres) {\n    return spheres ? update(centers, mappings, indices, groups, sphereCount, spheres) : fromArrays(centers, mappings, indices, groups, sphereCount);\n  }\n\n  Spheres.create = create;\n\n  function createEmpty(spheres) {\n    var cb = spheres ? spheres.centerBuffer.ref.value : new Float32Array(0);\n    var mb = spheres ? spheres.mappingBuffer.ref.value : new Float32Array(0);\n    var ib = spheres ? spheres.indexBuffer.ref.value : new Uint32Array(0);\n    var gb = spheres ? spheres.groupBuffer.ref.value : new Float32Array(0);\n    return create(cb, mb, ib, gb, 0, spheres);\n  }\n\n  Spheres.createEmpty = createEmpty;\n\n  function hashCode(spheres) {\n    return hashFnv32a([spheres.sphereCount, spheres.centerBuffer.ref.version, spheres.mappingBuffer.ref.version, spheres.indexBuffer.ref.version, spheres.groupBuffer.ref.version]);\n  }\n\n  function fromArrays(centers, mappings, indices, groups, sphereCount) {\n    var boundingSphere = Sphere3D();\n    var groupMapping;\n    var currentHash = -1;\n    var currentGroup = -1;\n    var spheres = {\n      kind: 'spheres',\n      sphereCount: sphereCount,\n      centerBuffer: ValueCell.create(centers),\n      mappingBuffer: ValueCell.create(mappings),\n      indexBuffer: ValueCell.create(indices),\n      groupBuffer: ValueCell.create(groups),\n\n      get boundingSphere() {\n        var newHash = hashCode(spheres);\n\n        if (newHash !== currentHash) {\n          var b = calculateInvariantBoundingSphere(spheres.centerBuffer.ref.value, spheres.sphereCount * 4, 4);\n          Sphere3D.copy(boundingSphere, b);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      },\n\n      get groupMapping() {\n        if (spheres.groupBuffer.ref.version !== currentGroup) {\n          groupMapping = createGroupMapping(spheres.groupBuffer.ref.value, spheres.sphereCount, 4);\n          currentGroup = spheres.groupBuffer.ref.version;\n        }\n\n        return groupMapping;\n      },\n\n      setBoundingSphere: function (sphere) {\n        Sphere3D.copy(boundingSphere, sphere);\n        currentHash = hashCode(spheres);\n      }\n    };\n    return spheres;\n  }\n\n  function update(centers, mappings, indices, groups, sphereCount, spheres) {\n    if (sphereCount > spheres.sphereCount) {\n      ValueCell.update(spheres.mappingBuffer, mappings);\n      ValueCell.update(spheres.indexBuffer, indices);\n    }\n\n    spheres.sphereCount = sphereCount;\n    ValueCell.update(spheres.centerBuffer, centers);\n    ValueCell.update(spheres.groupBuffer, groups);\n    return spheres;\n  }\n\n  Spheres.Params = __assign(__assign({}, BaseGeometry.Params), {\n    sizeFactor: PD.Numeric(1, {\n      min: 0,\n      max: 10,\n      step: 0.1\n    }),\n    doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo),\n    ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory)\n  });\n  Spheres.Utils = {\n    Params: Spheres.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: createRenderableState,\n    updateRenderableState: updateRenderableState,\n    createPositionIterator: createPositionIterator\n  };\n\n  function createPositionIterator(spheres, transform) {\n    var groupCount = spheres.sphereCount * 4;\n    var instanceCount = transform.instanceCount.ref.value;\n    var location = PositionLocation();\n    var p = location.position;\n    var v = spheres.centerBuffer.ref.value;\n    var m = transform.aTransform.ref.value;\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      if (instanceIndex < 0) {\n        Vec3.fromArray(p, v, groupIndex * 3);\n      } else {\n        Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\n      }\n\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 4, getLocation);\n  }\n\n  function createValues(spheres, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = createPositionIterator(spheres, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var size = createSizes(locationIt, theme.size);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: spheres.sphereCount * 2 * 3,\n      vertexCount: spheres.sphereCount * 4,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var padding = spheres.boundingSphere.radius ? getMaxSize(size) * props.sizeFactor : 0;\n    var invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      aPosition: spheres.centerBuffer,\n      aMapping: spheres.mappingBuffer,\n      aGroup: spheres.groupBuffer,\n      elements: spheres.indexBuffer,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), size), marker), overpaint), transparency), clipping), transform), {\n      padding: ValueCell.create(padding)\n    }), BaseGeometry.createValues(props, counts)), {\n      uSizeFactor: ValueCell.create(props.sizeFactor),\n      dDoubleSided: ValueCell.create(props.doubleSided),\n      dIgnoreLight: ValueCell.create(props.ignoreLight),\n      dXrayShaded: ValueCell.create(props.xrayShaded)\n    });\n  }\n\n  function createValuesSimple(spheres, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Spheres.Params)), props);\n\n    return createValues(spheres, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\n    ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\n    ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\n    ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\n  }\n\n  function updateBoundingSphere(values, spheres) {\n    var padding = spheres.boundingSphere.radius ? getMaxSize(values) * values.uSizeFactor.ref.value : 0;\n    var invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n\n    ValueCell.update(values.padding, padding);\n  }\n\n  function createRenderableState(props) {\n    var state = BaseGeometry.createRenderableState(props);\n    updateRenderableState(state, props);\n    return state;\n  }\n\n  function updateRenderableState(state, props) {\n    BaseGeometry.updateRenderableState(state, props);\n    state.opaque = state.opaque && !props.xrayShaded;\n    state.writeDepth = state.opaque;\n  }\n})(Spheres || (Spheres = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/spheres/spheres.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { LocationIterator, PositionLocation } from '../../../mol-geo/util/location-iterator';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { createSizes, getMaxSize } from '../size-data';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { hashFnv32a } from '../../../mol-data/util';\r\nimport { createGroupMapping } from '../../util';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nimport { Vec3, Vec4 } from '../../../mol-math/linear-algebra';\r\nexport var Spheres;\r\n(function (Spheres) {\r\n    function create(centers, mappings, indices, groups, sphereCount, spheres) {\r\n        return spheres ?\r\n            update(centers, mappings, indices, groups, sphereCount, spheres) :\r\n            fromArrays(centers, mappings, indices, groups, sphereCount);\r\n    }\r\n    Spheres.create = create;\r\n    function createEmpty(spheres) {\r\n        var cb = spheres ? spheres.centerBuffer.ref.value : new Float32Array(0);\r\n        var mb = spheres ? spheres.mappingBuffer.ref.value : new Float32Array(0);\r\n        var ib = spheres ? spheres.indexBuffer.ref.value : new Uint32Array(0);\r\n        var gb = spheres ? spheres.groupBuffer.ref.value : new Float32Array(0);\r\n        return create(cb, mb, ib, gb, 0, spheres);\r\n    }\r\n    Spheres.createEmpty = createEmpty;\r\n    function hashCode(spheres) {\r\n        return hashFnv32a([\r\n            spheres.sphereCount,\r\n            spheres.centerBuffer.ref.version, spheres.mappingBuffer.ref.version,\r\n            spheres.indexBuffer.ref.version, spheres.groupBuffer.ref.version\r\n        ]);\r\n    }\r\n    function fromArrays(centers, mappings, indices, groups, sphereCount) {\r\n        var boundingSphere = Sphere3D();\r\n        var groupMapping;\r\n        var currentHash = -1;\r\n        var currentGroup = -1;\r\n        var spheres = {\r\n            kind: 'spheres',\r\n            sphereCount: sphereCount,\r\n            centerBuffer: ValueCell.create(centers),\r\n            mappingBuffer: ValueCell.create(mappings),\r\n            indexBuffer: ValueCell.create(indices),\r\n            groupBuffer: ValueCell.create(groups),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(spheres);\r\n                if (newHash !== currentHash) {\r\n                    var b = calculateInvariantBoundingSphere(spheres.centerBuffer.ref.value, spheres.sphereCount * 4, 4);\r\n                    Sphere3D.copy(boundingSphere, b);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n            get groupMapping() {\r\n                if (spheres.groupBuffer.ref.version !== currentGroup) {\r\n                    groupMapping = createGroupMapping(spheres.groupBuffer.ref.value, spheres.sphereCount, 4);\r\n                    currentGroup = spheres.groupBuffer.ref.version;\r\n                }\r\n                return groupMapping;\r\n            },\r\n            setBoundingSphere: function (sphere) {\r\n                Sphere3D.copy(boundingSphere, sphere);\r\n                currentHash = hashCode(spheres);\r\n            }\r\n        };\r\n        return spheres;\r\n    }\r\n    function update(centers, mappings, indices, groups, sphereCount, spheres) {\r\n        if (sphereCount > spheres.sphereCount) {\r\n            ValueCell.update(spheres.mappingBuffer, mappings);\r\n            ValueCell.update(spheres.indexBuffer, indices);\r\n        }\r\n        spheres.sphereCount = sphereCount;\r\n        ValueCell.update(spheres.centerBuffer, centers);\r\n        ValueCell.update(spheres.groupBuffer, groups);\r\n        return spheres;\r\n    }\r\n    Spheres.Params = __assign(__assign({}, BaseGeometry.Params), { sizeFactor: PD.Numeric(1, { min: 0, max: 10, step: 0.1 }), doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo), ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory), xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory) });\r\n    Spheres.Utils = {\r\n        Params: Spheres.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: createRenderableState,\r\n        updateRenderableState: updateRenderableState,\r\n        createPositionIterator: createPositionIterator\r\n    };\r\n    function createPositionIterator(spheres, transform) {\r\n        var groupCount = spheres.sphereCount * 4;\r\n        var instanceCount = transform.instanceCount.ref.value;\r\n        var location = PositionLocation();\r\n        var p = location.position;\r\n        var v = spheres.centerBuffer.ref.value;\r\n        var m = transform.aTransform.ref.value;\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            if (instanceIndex < 0) {\r\n                Vec3.fromArray(p, v, groupIndex * 3);\r\n            }\r\n            else {\r\n                Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\r\n            }\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 4, getLocation);\r\n    }\r\n    function createValues(spheres, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = createPositionIterator(spheres, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var size = createSizes(locationIt, theme.size);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: spheres.sphereCount * 2 * 3, vertexCount: spheres.sphereCount * 4, groupCount: groupCount, instanceCount: instanceCount };\r\n        var padding = spheres.boundingSphere.radius ? getMaxSize(size) * props.sizeFactor : 0;\r\n        var invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ aPosition: spheres.centerBuffer, aMapping: spheres.mappingBuffer, aGroup: spheres.groupBuffer, elements: spheres.indexBuffer, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), size), marker), overpaint), transparency), clipping), transform), { padding: ValueCell.create(padding) }), BaseGeometry.createValues(props, counts)), { uSizeFactor: ValueCell.create(props.sizeFactor), dDoubleSided: ValueCell.create(props.doubleSided), dIgnoreLight: ValueCell.create(props.ignoreLight), dXrayShaded: ValueCell.create(props.xrayShaded) });\r\n    }\r\n    function createValuesSimple(spheres, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Spheres.Params)), props);\r\n        return createValues(spheres, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.uSizeFactor, props.sizeFactor);\r\n        ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\r\n        ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\r\n        ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\r\n    }\r\n    function updateBoundingSphere(values, spheres) {\r\n        var padding = spheres.boundingSphere.radius\r\n            ? getMaxSize(values) * values.uSizeFactor.ref.value\r\n            : 0;\r\n        var invariantBoundingSphere = Sphere3D.expand(Sphere3D(), spheres.boundingSphere, padding);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n        ValueCell.update(values.padding, padding);\r\n    }\r\n    function createRenderableState(props) {\r\n        var state = BaseGeometry.createRenderableState(props);\r\n        updateRenderableState(state, props);\r\n        return state;\r\n    }\r\n    function updateRenderableState(state, props) {\r\n        BaseGeometry.updateRenderableState(state, props);\r\n        state.opaque = state.opaque && !props.xrayShaded;\r\n        state.writeDepth = state.opaque;\r\n    }\r\n})(Spheres || (Spheres = {}));\r\n//# sourceMappingURL=spheres.js.map"]},"metadata":{},"sourceType":"module"}