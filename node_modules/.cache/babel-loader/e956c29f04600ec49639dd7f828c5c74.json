{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { calcAngles } from '../chemistry/geometry';\nimport { Features } from './features';\nimport { typeSymbol, eachBondedAtom } from '../chemistry/util';\nimport { degToRad } from '../../../mol-math/misc';\nvar HalogenBondsParams = {\n  distanceMax: PD.Numeric(4.0, {\n    min: 1,\n    max: 5,\n    step: 0.1\n  }),\n  angleMax: PD.Numeric(30, {\n    min: 0,\n    max: 60,\n    step: 1\n  })\n};\nvar halBondElements = [\"CL\"\n/* CL */\n, \"BR\"\n/* BR */\n, \"I\"\n/* I */\n, \"AT\"\n/* AT */\n];\n/**\r\n * Halogen bond donors (X-C, with X one of Cl, Br, I or At) not F!\r\n */\n\nfunction addUnitHalogenDonors(structure, unit, builder) {\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n\n  for (var i = 0, il = elements.length; i < il; ++i) {\n    var element = typeSymbol(unit, i);\n\n    if (halBondElements.includes(element)) {\n      builder.add(6\n      /* HalogenDonor */\n      , 0\n      /* None */\n      , x[elements[i]], y[elements[i]], z[elements[i]], i);\n    }\n  }\n}\n\nvar X = [\"N\"\n/* N */\n, \"O\"\n/* O */\n, \"S\"\n/* S */\n];\nvar Y = [\"C\"\n/* C */\n, \"N\"\n/* N */\n, \"P\"\n/* P */\n, \"S\"\n/* S */\n];\n/**\r\n * Halogen bond acceptors (Y-{O|N|S}, with Y=C,P,N,S)\r\n */\n\nfunction addUnitHalogenAcceptors(structure, unit, builder) {\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n\n  var _loop_1 = function (i, il) {\n    var element = typeSymbol(unit, i);\n\n    if (X.includes(element)) {\n      var flag_1 = false;\n      eachBondedAtom(structure, unit, i, function (unitB, indexB) {\n        if (Y.includes(typeSymbol(unitB, indexB))) {\n          flag_1 = true;\n        }\n      });\n\n      if (flag_1) {\n        builder.add(7\n        /* HalogenAcceptor */\n        , 0\n        /* None */\n        , x[elements[i]], y[elements[i]], z[elements[i]], i);\n      }\n    }\n  };\n\n  for (var i = 0, il = elements.length; i < il; ++i) {\n    _loop_1(i, il);\n  }\n}\n\nfunction isHalogenBond(ti, tj) {\n  return ti === 7\n  /* HalogenAcceptor */\n  && tj === 6\n  /* HalogenDonor */\n  || ti === 6\n  /* HalogenDonor */\n  && tj === 7\n  /* HalogenAcceptor */\n  ;\n} // http://www.pnas.org/content/101/48/16789.full\n\n\nvar OptimalHalogenAngle = degToRad(180); // adjusted from 165 to account for spherical statistics\n\nvar OptimalAcceptorAngle = degToRad(120);\n\nfunction getOptions(props) {\n  return {\n    angleMax: degToRad(props.angleMax)\n  };\n}\n\nfunction testHalogenBond(structure, infoA, infoB, opts) {\n  var typeA = infoA.types[infoA.feature];\n  var typeB = infoB.types[infoB.feature];\n  if (!isHalogenBond(typeA, typeB)) return;\n\n  var _a = typeA === 6\n  /* HalogenDonor */\n  ? [infoA, infoB] : [infoB, infoA],\n      don = _a[0],\n      acc = _a[1];\n\n  var donIndex = don.members[don.offsets[don.feature]];\n  var accIndex = acc.members[acc.offsets[acc.feature]];\n  var halogenAngles = calcAngles(structure, don.unit, donIndex, acc.unit, accIndex); // Singly bonded halogen only (not bromide ion for example)\n\n  if (halogenAngles.length !== 1) return;\n  if (OptimalHalogenAngle - halogenAngles[0] > opts.angleMax) return;\n  var acceptorAngles = calcAngles(structure, acc.unit, accIndex, don.unit, donIndex); // Angle must be defined. Excludes water as acceptor. Debatable\n\n  if (acceptorAngles.length === 0) return;\n  if (acceptorAngles.some(function (acceptorAngle) {\n    return OptimalAcceptorAngle - acceptorAngle > opts.angleMax;\n  })) return;\n  return 5\n  /* HalogenBond */\n  ;\n} //\n\n\nexport var HalogenDonorProvider = Features.Provider([6\n/* HalogenDonor */\n], addUnitHalogenDonors);\nexport var HalogenAcceptorProvider = Features.Provider([7\n/* HalogenAcceptor */\n], addUnitHalogenAcceptors);\nexport var HalogenBondsProvider = {\n  name: 'halogen-bonds',\n  params: HalogenBondsParams,\n  createTester: function (props) {\n    var opts = getOptions(props);\n    return {\n      maxDistance: props.distanceMax,\n      requiredFeatures: new Set([6\n      /* HalogenDonor */\n      , 7\n      /* HalogenAcceptor */\n      ]),\n      getType: function (structure, infoA, infoB) {\n        return testHalogenBond(structure, infoA, infoB, opts);\n      }\n    };\n  }\n};","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/interactions/halogen-bonds.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { calcAngles } from '../chemistry/geometry';\r\nimport { Features } from './features';\r\nimport { typeSymbol, eachBondedAtom } from '../chemistry/util';\r\nimport { degToRad } from '../../../mol-math/misc';\r\nvar HalogenBondsParams = {\r\n    distanceMax: PD.Numeric(4.0, { min: 1, max: 5, step: 0.1 }),\r\n    angleMax: PD.Numeric(30, { min: 0, max: 60, step: 1 }),\r\n};\r\nvar halBondElements = [\"CL\" /* CL */, \"BR\" /* BR */, \"I\" /* I */, \"AT\" /* AT */];\r\n/**\r\n * Halogen bond donors (X-C, with X one of Cl, Br, I or At) not F!\r\n */\r\nfunction addUnitHalogenDonors(structure, unit, builder) {\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    for (var i = 0, il = elements.length; i < il; ++i) {\r\n        var element = typeSymbol(unit, i);\r\n        if (halBondElements.includes(element)) {\r\n            builder.add(6 /* HalogenDonor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);\r\n        }\r\n    }\r\n}\r\nvar X = [\"N\" /* N */, \"O\" /* O */, \"S\" /* S */];\r\nvar Y = [\"C\" /* C */, \"N\" /* N */, \"P\" /* P */, \"S\" /* S */];\r\n/**\r\n * Halogen bond acceptors (Y-{O|N|S}, with Y=C,P,N,S)\r\n */\r\nfunction addUnitHalogenAcceptors(structure, unit, builder) {\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    var _loop_1 = function (i, il) {\r\n        var element = typeSymbol(unit, i);\r\n        if (X.includes(element)) {\r\n            var flag_1 = false;\r\n            eachBondedAtom(structure, unit, i, function (unitB, indexB) {\r\n                if (Y.includes(typeSymbol(unitB, indexB))) {\r\n                    flag_1 = true;\r\n                }\r\n            });\r\n            if (flag_1) {\r\n                builder.add(7 /* HalogenAcceptor */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);\r\n            }\r\n        }\r\n    };\r\n    for (var i = 0, il = elements.length; i < il; ++i) {\r\n        _loop_1(i, il);\r\n    }\r\n}\r\nfunction isHalogenBond(ti, tj) {\r\n    return ((ti === 7 /* HalogenAcceptor */ && tj === 6 /* HalogenDonor */) ||\r\n        (ti === 6 /* HalogenDonor */ && tj === 7 /* HalogenAcceptor */));\r\n}\r\n// http://www.pnas.org/content/101/48/16789.full\r\nvar OptimalHalogenAngle = degToRad(180); // adjusted from 165 to account for spherical statistics\r\nvar OptimalAcceptorAngle = degToRad(120);\r\nfunction getOptions(props) {\r\n    return {\r\n        angleMax: degToRad(props.angleMax),\r\n    };\r\n}\r\nfunction testHalogenBond(structure, infoA, infoB, opts) {\r\n    var typeA = infoA.types[infoA.feature];\r\n    var typeB = infoB.types[infoB.feature];\r\n    if (!isHalogenBond(typeA, typeB))\r\n        return;\r\n    var _a = typeA === 6 /* HalogenDonor */ ? [infoA, infoB] : [infoB, infoA], don = _a[0], acc = _a[1];\r\n    var donIndex = don.members[don.offsets[don.feature]];\r\n    var accIndex = acc.members[acc.offsets[acc.feature]];\r\n    var halogenAngles = calcAngles(structure, don.unit, donIndex, acc.unit, accIndex);\r\n    // Singly bonded halogen only (not bromide ion for example)\r\n    if (halogenAngles.length !== 1)\r\n        return;\r\n    if (OptimalHalogenAngle - halogenAngles[0] > opts.angleMax)\r\n        return;\r\n    var acceptorAngles = calcAngles(structure, acc.unit, accIndex, don.unit, donIndex);\r\n    // Angle must be defined. Excludes water as acceptor. Debatable\r\n    if (acceptorAngles.length === 0)\r\n        return;\r\n    if (acceptorAngles.some(function (acceptorAngle) { return OptimalAcceptorAngle - acceptorAngle > opts.angleMax; }))\r\n        return;\r\n    return 5 /* HalogenBond */;\r\n}\r\n//\r\nexport var HalogenDonorProvider = Features.Provider([6 /* HalogenDonor */], addUnitHalogenDonors);\r\nexport var HalogenAcceptorProvider = Features.Provider([7 /* HalogenAcceptor */], addUnitHalogenAcceptors);\r\nexport var HalogenBondsProvider = {\r\n    name: 'halogen-bonds',\r\n    params: HalogenBondsParams,\r\n    createTester: function (props) {\r\n        var opts = getOptions(props);\r\n        return {\r\n            maxDistance: props.distanceMax,\r\n            requiredFeatures: new Set([6 /* HalogenDonor */, 7 /* HalogenAcceptor */]),\r\n            getType: function (structure, infoA, infoB) { return testHalogenBond(structure, infoA, infoB, opts); }\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=halogen-bonds.js.map"]},"metadata":{},"sourceType":"module"}