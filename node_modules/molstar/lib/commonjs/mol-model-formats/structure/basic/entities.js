"use strict";
/**
 * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEntities = void 0;
var db_1 = require("../../../mol-data/db");
var common_1 = require("../../../mol-model/structure/model/properties/common");
var types_1 = require("../../../mol-model/structure/model/types");
var schema_1 = require("./schema");
function getEntities(data, properties) {
    var _a;
    var entityData;
    if (!data.entity.id.isDefined) {
        var entityIds_1 = new Set();
        var ids = [];
        var types = [];
        var _b = data.atom_site, label_entity_id = _b.label_entity_id, label_comp_id = _b.label_comp_id;
        for (var i = 0, il = data.atom_site._rowCount; i < il; i++) {
            var entityId = label_entity_id.value(i);
            if (!entityIds_1.has(entityId)) {
                ids.push(entityId);
                types.push((0, types_1.getEntityType)(label_comp_id.value(i)));
                entityIds_1.add(entityId);
            }
        }
        var sphere_entity_id = data.ihm_sphere_obj_site.entity_id;
        for (var i = 0, il = data.ihm_sphere_obj_site._rowCount; i < il; i++) {
            var entityId = sphere_entity_id.value(i);
            if (!entityIds_1.has(entityId)) {
                ids.push(entityId);
                types.push('polymer');
                entityIds_1.add(entityId);
            }
        }
        var gaussian_entity_id = data.ihm_gaussian_obj_site.entity_id;
        for (var i = 0, il = data.ihm_gaussian_obj_site._rowCount; i < il; i++) {
            var entityId = gaussian_entity_id.value(i);
            if (!entityIds_1.has(entityId)) {
                ids.push(entityId);
                types.push('polymer');
                entityIds_1.add(entityId);
            }
        }
        entityData = db_1.Table.ofPartialColumns(schema_1.BasicSchema.entity, {
            id: db_1.Column.ofArray({ array: ids, schema: schema_1.BasicSchema.entity.id }),
            type: db_1.Column.ofArray({ array: types, schema: schema_1.BasicSchema.entity.type }),
        }, ids.length);
    }
    else {
        entityData = data.entity;
    }
    var getEntityIndex = db_1.Column.createIndexer(entityData.id);
    //
    var subtypes = new Array(entityData._rowCount);
    subtypes.fill('other');
    var entityIds = new Set();
    var assignSubtype = false;
    if (data.entity_poly && data.entity_poly.type.isDefined) {
        var _c = data.entity_poly, entity_id = _c.entity_id, type = _c.type, _rowCount = _c._rowCount;
        for (var i = 0; i < _rowCount; ++i) {
            var entityId = entity_id.value(i);
            subtypes[getEntityIndex(entityId)] = type.value(i);
            entityIds.add(entityId);
        }
    }
    else {
        assignSubtype = true;
    }
    if (data.pdbx_entity_branch && data.pdbx_entity_branch.entity_id.isDefined) {
        var _d = data.pdbx_entity_branch, entity_id = _d.entity_id, type = _d.type, _rowCount = _d._rowCount;
        for (var i = 0; i < _rowCount; ++i) {
            var entityId = entity_id.value(i);
            subtypes[getEntityIndex(entityId)] = type.value(i);
            entityIds.add(entityId);
        }
    }
    else {
        assignSubtype = true;
    }
    if (entityIds.size < subtypes.length) {
        // still unassigned subtypes, need to derive from component id/type
        assignSubtype = true;
    }
    if (assignSubtype) {
        var chemCompType = new Map();
        if (data.chem_comp) {
            var _e = data.chem_comp, id = _e.id, type = _e.type;
            for (var i = 0, il = data.chem_comp._rowCount; i < il; i++) {
                chemCompType.set(id.value(i), type.value(i));
            }
        }
        if (data.atom_site) {
            var _f = data.atom_site, label_entity_id = _f.label_entity_id, label_comp_id = _f.label_comp_id;
            for (var i = 0, il = data.atom_site._rowCount; i < il; i++) {
                var entityId = label_entity_id.value(i);
                if (!entityIds.has(entityId)) {
                    var compId = label_comp_id.value(i);
                    var compType = chemCompType.get(compId) || '';
                    subtypes[getEntityIndex(entityId)] = (0, types_1.getEntitySubtype)(compId, compType);
                    entityIds.add(entityId);
                }
            }
        }
        // TODO how to handle coarse?
    }
    var subtypeColumn = db_1.Column.ofArray({ array: subtypes, schema: common_1.EntitySubtype });
    //
    var prdIds = new Array(entityData._rowCount);
    prdIds.fill('');
    if (data.pdbx_molecule && data.pdbx_molecule.prd_id.isDefined) {
        var _g = data.pdbx_molecule, asym_id = _g.asym_id, prd_id = _g.prd_id, _rowCount = _g._rowCount;
        for (var i = 0; i < _rowCount; ++i) {
            var asymId = asym_id.value(i);
            var entityId = (_a = properties.structAsymMap.get(asymId)) === null || _a === void 0 ? void 0 : _a.entity_id;
            if (entityId !== undefined) {
                prdIds[getEntityIndex(entityId)] = prd_id.value(i);
            }
        }
    }
    var prdIdColumn = db_1.Column.ofArray({ array: prdIds, schema: db_1.Column.Schema.str });
    return {
        data: entityData,
        subtype: subtypeColumn,
        prd_id: prdIdColumn,
        getEntityIndex: getEntityIndex
    };
}
exports.getEntities = getEntities;
//# sourceMappingURL=entities.js.map