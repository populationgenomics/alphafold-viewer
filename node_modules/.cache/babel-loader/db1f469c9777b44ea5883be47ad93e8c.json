{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { OrderedSet } from '../../../../mol-data/int';\nimport { Unit } from '../unit';\nimport { Loci } from './loci';\nimport { Location } from './location';\nexport var Stats;\n\n(function (Stats) {\n  function create() {\n    return {\n      elementCount: 0,\n      conformationCount: 0,\n      residueCount: 0,\n      chainCount: 0,\n      unitCount: 0,\n      structureCount: 0,\n      firstElementLoc: Location.create(void 0),\n      firstConformationLoc: Location.create(void 0),\n      firstResidueLoc: Location.create(void 0),\n      firstChainLoc: Location.create(void 0),\n      firstUnitLoc: Location.create(void 0),\n      firstStructureLoc: Location.create(void 0)\n    };\n  }\n\n  Stats.create = create;\n\n  function addCountHelper(map, key, inc) {\n    var count = map.get(key) || 0;\n    map.set(key, count + inc);\n  }\n\n  function handleElement(stats, structure, element) {\n    var indices = element.indices,\n        unit = element.unit;\n    var elements = unit.elements;\n    var size = OrderedSet.size(indices);\n    var lociResidueAltIdCounts = new Map();\n    var residueAltIdCounts = new Map();\n\n    if (size > 0) {\n      Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\n    } // count single element unit as unit not element\n\n\n    if (size === elements.length) {\n      stats.unitCount += 1;\n\n      if (stats.unitCount === 1) {\n        Location.set(stats.firstUnitLoc, structure, unit, elements[OrderedSet.start(indices)]);\n      }\n    } else if (size === 1) {\n      if (Unit.Traits.is(unit.traits, 1\n      /* MultiChain */\n      )) {\n        return;\n      } else {\n        stats.elementCount += 1;\n\n        if (stats.elementCount === 1) {\n          Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\n        }\n      }\n    } else {\n      if (Unit.isAtomic(unit)) {\n        var _a = unit.model.atomicHierarchy.residueAtomSegments,\n            index = _a.index,\n            offsets_1 = _a.offsets;\n        var label_alt_id_1 = unit.model.atomicHierarchy.atoms.label_alt_id;\n        var i = 0;\n\n        var _loop_1 = function () {\n          lociResidueAltIdCounts.clear();\n          var j = 0;\n          var eI = elements[OrderedSet.getAt(indices, i)];\n          var rI = index[eI];\n          addCountHelper(lociResidueAltIdCounts, label_alt_id_1.value(eI), 1);\n          ++i;\n          ++j;\n\n          while (i < size) {\n            var eI_1 = elements[OrderedSet.getAt(indices, i)];\n            if (index[eI_1] !== rI) break;\n            addCountHelper(lociResidueAltIdCounts, label_alt_id_1.value(eI_1), 1);\n            ++i;\n            ++j;\n          }\n\n          if (offsets_1[rI + 1] - offsets_1[rI] === j) {\n            // full residue\n            stats.residueCount += 1;\n\n            if (stats.residueCount === 1) {\n              Location.set(stats.firstResidueLoc, structure, unit, offsets_1[rI]);\n            }\n          } else {\n            // partial residue\n            residueAltIdCounts.clear();\n\n            for (var l = offsets_1[rI], _l = offsets_1[rI + 1]; l < _l; ++l) {\n              addCountHelper(residueAltIdCounts, label_alt_id_1.value(l), 1);\n            } // check if shared atom count match\n\n\n            if (residueAltIdCounts.get('') === lociResidueAltIdCounts.get('')) {\n              lociResidueAltIdCounts.forEach(function (v, k) {\n                if (residueAltIdCounts.get(k) !== v) return;\n\n                if (k !== '') {\n                  stats.conformationCount += 1;\n\n                  if (stats.conformationCount === 1) {\n                    for (var l = offsets_1[rI], _l = offsets_1[rI + 1]; l < _l; ++l) {\n                      if (k === label_alt_id_1.value(l)) {\n                        Location.set(stats.firstConformationLoc, structure, unit, l);\n                        break;\n                      }\n                    }\n                  }\n                }\n\n                j -= v;\n              });\n            }\n\n            stats.elementCount += j;\n          }\n        };\n\n        while (i < size) {\n          _loop_1();\n        }\n      } else {\n        stats.elementCount += size;\n\n        if (stats.elementCount === 1) {\n          Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\n        }\n      }\n    }\n  }\n\n  function handleUnitChainsSimple(stats, structure, element) {\n    var indices = element.indices,\n        unit = element.unit;\n    var size = OrderedSet.size(indices);\n    if (size === 0) return;\n    var elements = unit.elements;\n\n    if (!Unit.Traits.is(unit.traits, 1\n    /* MultiChain */\n    )) {\n      if (size === elements.length) {\n        stats.chainCount += 1;\n\n        if (stats.chainCount === 1) {\n          Location.set(stats.firstChainLoc, structure, unit, elements[OrderedSet.start(indices)]);\n        }\n      }\n\n      return;\n    }\n\n    var segments = Unit.isAtomic(unit) ? unit.model.atomicHierarchy.chainAtomSegments : Unit.isSpheres(unit) ? unit.model.coarseHierarchy.spheres.chainElementSegments : Unit.isGaussians(unit) ? unit.model.coarseHierarchy.gaussians.chainElementSegments : void 0;\n\n    if (!segments) {\n      console.warn('StructureElement loci stats: unknown unit type');\n      return;\n    }\n\n    var index = segments.index,\n        offsets = segments.offsets;\n    var i = 0;\n\n    while (i < size) {\n      var j = 0;\n      var eI = elements[OrderedSet.getAt(indices, i)];\n      var cI = index[eI];\n      ++i;\n      ++j;\n\n      while (i < size) {\n        var eI_2 = elements[OrderedSet.getAt(indices, i)];\n        if (index[eI_2] !== cI) break;\n        ++i;\n        ++j;\n      }\n\n      if (offsets[cI + 1] - offsets[cI] === j) {\n        // full chain\n        stats.chainCount += 1;\n\n        if (stats.chainCount === 1) {\n          Location.set(stats.firstChainLoc, structure, unit, offsets[cI]);\n        }\n      }\n    }\n  }\n\n  function handleUnitChainsPartitioned(stats, structure, lociElements, start, end) {\n    var element = lociElements[start]; // all the elements have the same model since they are part of the same group so this is ok.\n\n    var segments = Unit.isAtomic(element.unit) ? element.unit.model.atomicHierarchy.chainAtomSegments : Unit.isSpheres(element.unit) ? element.unit.model.coarseHierarchy.spheres.chainElementSegments : Unit.isGaussians(element.unit) ? element.unit.model.coarseHierarchy.gaussians.chainElementSegments : void 0;\n\n    if (!segments) {\n      console.warn('StructureElement loci stats: unknown unit type');\n      return;\n    }\n\n    var index = segments.index,\n        offsets = segments.offsets;\n    var chainCounts = new Map();\n\n    for (var elIndex = start; elIndex < end; elIndex++) {\n      element = lociElements[elIndex];\n      var indices = element.indices,\n          unit = element.unit;\n      var size = OrderedSet.size(indices);\n      if (size === 0) continue;\n      var elements = unit.elements;\n\n      if (!Unit.Traits.is(unit.traits, 1\n      /* MultiChain */\n      )) {\n        var eI = elements[OrderedSet.start(indices)];\n        addCountHelper(chainCounts, index[eI], elements.length);\n        continue;\n      }\n\n      var i = 0;\n\n      while (i < size) {\n        var j = 0;\n        var eI = elements[OrderedSet.getAt(indices, i)];\n        var cI = index[eI];\n        ++i;\n        ++j;\n\n        while (i < size) {\n          var eI_3 = elements[OrderedSet.getAt(indices, i)];\n          if (index[eI_3] !== cI) break;\n          ++i;\n          ++j;\n        }\n\n        addCountHelper(chainCounts, cI, j);\n      }\n    }\n\n    var firstCI = -1;\n    chainCounts.forEach(function (count, cI) {\n      if (offsets[cI + 1] - offsets[cI] === count) {\n        // full chain\n        stats.chainCount += 1;\n\n        if (stats.chainCount === 1) {\n          firstCI = cI;\n        }\n      }\n    });\n    if (firstCI < 0) return;\n\n    for (var elIndex = start; elIndex < end; elIndex++) {\n      element = lociElements[elIndex];\n      var indices = element.indices,\n          unit = element.unit;\n      var size = OrderedSet.size(indices);\n      if (size === 0) continue;\n      var elements = unit.elements;\n      var i = 0;\n\n      while (i < size) {\n        var eI = elements[OrderedSet.getAt(indices, i)];\n        var cI = index[eI];\n\n        if (cI === firstCI) {\n          Location.set(stats.firstChainLoc, structure, unit, eI);\n          return;\n        }\n      }\n    }\n  }\n\n  function ofLoci(loci) {\n    var stats = create();\n    if (Loci.isEmpty(loci)) return stats;\n    var hasPartitions = false;\n\n    if (Loci.isWholeStructure(loci)) {\n      stats.structureCount += 1;\n\n      if (stats.structureCount === 1) {\n        var _a = loci.elements[0],\n            unit = _a.unit,\n            indices = _a.indices;\n        Location.set(stats.firstStructureLoc, loci.structure, unit, unit.elements[OrderedSet.min(indices)]);\n      }\n    } else {\n      for (var _i = 0, _b = loci.elements; _i < _b.length; _i++) {\n        var e = _b[_i];\n        handleElement(stats, loci.structure, e);\n\n        if (!Unit.Traits.is(e.unit.traits, 2\n        /* Partitioned */\n        )) {\n          handleUnitChainsSimple(stats, loci.structure, e);\n        } else {\n          hasPartitions = true;\n        }\n      }\n    }\n\n    if (hasPartitions) {\n      for (var i = 0, len = loci.elements.length; i < len; i++) {\n        var e = loci.elements[i];\n        if (!Unit.Traits.is(e.unit.traits, 2\n        /* Partitioned */\n        )) continue;\n        var start = i;\n\n        while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {\n          i++;\n        }\n\n        var end = i;\n        i--;\n\n        if (end - start === 1) {\n          handleUnitChainsSimple(stats, loci.structure, e);\n        } else {\n          handleUnitChainsPartitioned(stats, loci.structure, loci.elements, start, end);\n        }\n      }\n    }\n\n    return stats;\n  }\n\n  Stats.ofLoci = ofLoci;\n  /** Adds counts of two Stats objects together, assumes they describe different structures */\n\n  function add(out, a, b) {\n    if (a.elementCount === 1 && b.elementCount === 0) {\n      Location.copy(out.firstElementLoc, a.firstElementLoc);\n    } else if (a.elementCount === 0 && b.elementCount === 1) {\n      Location.copy(out.firstElementLoc, b.firstElementLoc);\n    }\n\n    if (a.conformationCount === 1 && b.conformationCount === 0) {\n      Location.copy(out.firstConformationLoc, a.firstConformationLoc);\n    } else if (a.conformationCount === 0 && b.conformationCount === 1) {\n      Location.copy(out.firstConformationLoc, b.firstConformationLoc);\n    }\n\n    if (a.residueCount === 1 && b.residueCount === 0) {\n      Location.copy(out.firstResidueLoc, a.firstResidueLoc);\n    } else if (a.residueCount === 0 && b.residueCount === 1) {\n      Location.copy(out.firstResidueLoc, b.firstResidueLoc);\n    }\n\n    if (a.chainCount === 1 && b.chainCount === 0) {\n      Location.copy(out.firstChainLoc, a.firstChainLoc);\n    } else if (a.chainCount === 0 && b.chainCount === 1) {\n      Location.copy(out.firstChainLoc, b.firstChainLoc);\n    }\n\n    if (a.unitCount === 1 && b.unitCount === 0) {\n      Location.copy(out.firstUnitLoc, a.firstUnitLoc);\n    } else if (a.unitCount === 0 && b.unitCount === 1) {\n      Location.copy(out.firstUnitLoc, b.firstUnitLoc);\n    }\n\n    if (a.structureCount === 1 && b.structureCount === 0) {\n      Location.copy(out.firstStructureLoc, a.firstStructureLoc);\n    } else if (a.structureCount === 0 && b.structureCount === 1) {\n      Location.copy(out.firstStructureLoc, b.firstStructureLoc);\n    }\n\n    out.elementCount = a.elementCount + b.elementCount;\n    out.conformationCount = a.conformationCount + b.conformationCount;\n    out.residueCount = a.residueCount + b.residueCount;\n    out.chainCount = a.chainCount + b.chainCount;\n    out.unitCount = a.unitCount + b.unitCount;\n    out.structureCount = a.structureCount + b.structureCount;\n    return out;\n  }\n\n  Stats.add = add;\n})(Stats || (Stats = {}));","map":{"version":3,"sources":["../../../../../src/mol-model/structure/structure/element/stats.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAAS,UAAT,QAA2B,0BAA3B;AACA,SAAS,IAAT,QAAqB,SAArB;AACA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,QAAT,QAAyB,YAAzB;AAoBA,OAAM,IAAW,KAAX;;AAAN,CAAA,UAAiB,KAAjB,EAAsB;AAClB,WAAgB,MAAhB,GAAsB;AAClB,WAAO;AACH,MAAA,YAAY,EAAE,CADX;AAEH,MAAA,iBAAiB,EAAE,CAFhB;AAGH,MAAA,YAAY,EAAE,CAHX;AAIH,MAAA,UAAU,EAAE,CAJT;AAKH,MAAA,SAAS,EAAE,CALR;AAMH,MAAA,cAAc,EAAE,CANb;AAQH,MAAA,eAAe,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB,CARd;AASH,MAAA,oBAAoB,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB,CATnB;AAUH,MAAA,eAAe,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB,CAVd;AAWH,MAAA,aAAa,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB,CAXZ;AAYH,MAAA,YAAY,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB,CAZX;AAaH,MAAA,iBAAiB,EAAE,QAAQ,CAAC,MAAT,CAAgB,KAAK,CAArB;AAbhB,KAAP;AAeH;;AAhBe,EAAA,KAAA,CAAA,MAAA,GAAM,MAAN;;AAkBhB,WAAS,cAAT,CAA2B,GAA3B,EAAgD,GAAhD,EAAwD,GAAxD,EAAmE;AAC/D,QAAM,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,GAAR,KAAgB,CAA9B;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAa,KAAK,GAAG,GAArB;AACH;;AAED,WAAS,aAAT,CAAuB,KAAvB,EAAqC,SAArC,EAA2D,OAA3D,EAAuF;AAC3E,QAAA,OAAO,GAAW,OAAO,CAAlB,OAAP;AAAA,QAAS,IAAI,GAAK,OAAO,CAAZ,IAAb;AACA,QAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;AACR,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,OAAhB,CAAb;AAEA,QAAM,sBAAsB,GAAG,IAAI,GAAJ,EAA/B;AACA,QAAM,kBAAkB,GAAG,IAAI,GAAJ,EAA3B;;AAEA,QAAI,IAAI,GAAG,CAAX,EAAc;AACV,MAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,eAAnB,EAAoC,SAApC,EAA+C,IAA/C,EAAqD,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAA7D;AACH,KAVkF,CAYnF;;;AACA,QAAI,IAAI,KAAK,QAAQ,CAAC,MAAtB,EAA8B;AAC1B,MAAA,KAAK,CAAC,SAAN,IAAmB,CAAnB;;AACA,UAAI,KAAK,CAAC,SAAN,KAAoB,CAAxB,EAA2B;AACvB,QAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,YAAnB,EAAiC,SAAjC,EAA4C,IAA5C,EAAkD,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAA1D;AACH;AACJ,KALD,MAKO,IAAI,IAAI,KAAK,CAAb,EAAgB;AACnB,UAAI,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,IAAI,CAAC,MAApB,EAA0B;AAAA;AAA1B,OAAJ,EAAwD;AACpD;AACH,OAFD,MAEO;AACH,QAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;;AACA,YAAI,KAAK,CAAC,YAAN,KAAuB,CAA3B,EAA8B;AAC1B,UAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,eAAnB,EAAoC,SAApC,EAA+C,IAA/C,EAAqD,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAA7D;AACH;AACJ;AACJ,KATM,MASA;AACH,UAAI,IAAI,CAAC,QAAL,CAAc,IAAd,CAAJ,EAAyB;AACf,YAAA,EAAA,GAAqB,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,mBAAhD;AAAA,YAAE,KAAK,GAAA,EAAA,CAAA,KAAP;AAAA,YAAS,SAAO,GAAA,EAAA,CAAA,OAAhB;AACE,YAAA,cAAY,GAAK,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,KAA3B,CAAL,YAAZ;AACR,YAAI,CAAC,GAAG,CAAR;;;AAEI,UAAA,sBAAsB,CAAC,KAAvB;AACA,cAAI,CAAC,GAAG,CAAR;AACA,cAAM,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,cAAM,EAAE,GAAG,KAAK,CAAC,EAAD,CAAhB;AACA,UAAA,cAAc,CAAC,sBAAD,EAAyB,cAAY,CAAC,KAAb,CAAmB,EAAnB,CAAzB,EAAiD,CAAjD,CAAd;AACA,YAAE,CAAF;AACA,YAAE,CAAF;;AACA,iBAAO,CAAC,GAAG,IAAX,EAAiB;AACb,gBAAM,IAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,gBAAI,KAAK,CAAC,IAAD,CAAL,KAAc,EAAlB,EAAsB;AACtB,YAAA,cAAc,CAAC,sBAAD,EAAyB,cAAY,CAAC,KAAb,CAAmB,IAAnB,CAAzB,EAAiD,CAAjD,CAAd;AACA,cAAE,CAAF;AACA,cAAE,CAAF;AACH;;AAED,cAAI,SAAO,CAAC,EAAE,GAAG,CAAN,CAAP,GAAkB,SAAO,CAAC,EAAD,CAAzB,KAAkC,CAAtC,EAAyC;AACrC;AACA,YAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;;AACA,gBAAI,KAAK,CAAC,YAAN,KAAuB,CAA3B,EAA8B;AAC1B,cAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,eAAnB,EAAoC,SAApC,EAA+C,IAA/C,EAAqD,SAAO,CAAC,EAAD,CAA5D;AACH;AACJ,WAND,MAMO;AACH;AACA,YAAA,kBAAkB,CAAC,KAAnB;;AACA,iBAAK,IAAI,CAAC,GAAG,SAAO,CAAC,EAAD,CAAf,EAAqB,EAAE,GAAG,SAAO,CAAC,EAAE,GAAG,CAAN,CAAtC,EAAgD,CAAC,GAAG,EAApD,EAAwD,EAAE,CAA1D,EAA6D;AACzD,cAAA,cAAc,CAAC,kBAAD,EAAqB,cAAY,CAAC,KAAb,CAAmB,CAAnB,CAArB,EAA4C,CAA5C,CAAd;AACH,aALE,CAMH;;;AACA,gBAAI,kBAAkB,CAAC,GAAnB,CAAuB,EAAvB,MAA+B,sBAAsB,CAAC,GAAvB,CAA2B,EAA3B,CAAnC,EAAmE;AAC/D,cAAA,sBAAsB,CAAC,OAAvB,CAA+B,UAAC,CAAD,EAAI,CAAJ,EAAK;AAChC,oBAAI,kBAAkB,CAAC,GAAnB,CAAuB,CAAvB,MAA8B,CAAlC,EAAqC;;AACrC,oBAAI,CAAC,KAAK,EAAV,EAAc;AACV,kBAAA,KAAK,CAAC,iBAAN,IAA2B,CAA3B;;AACA,sBAAI,KAAK,CAAC,iBAAN,KAA4B,CAAhC,EAAmC;AAC/B,yBAAK,IAAI,CAAC,GAAG,SAAO,CAAC,EAAD,CAAf,EAAqB,EAAE,GAAG,SAAO,CAAC,EAAE,GAAG,CAAN,CAAtC,EAAgD,CAAC,GAAG,EAApD,EAAwD,EAAE,CAA1D,EAA6D;AACzD,0BAAI,CAAC,KAAK,cAAY,CAAC,KAAb,CAAmB,CAAnB,CAAV,EAAiC;AAC7B,wBAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,oBAAnB,EAAyC,SAAzC,EAAoD,IAApD,EAA0D,CAA1D;AACA;AACH;AACJ;AACJ;AACJ;;AACD,gBAAA,CAAC,IAAI,CAAL;AACH,eAdD;AAeH;;AACD,YAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;AACH;;;AA/CL,eAAO,CAAC,GAAG,IAAX,EAAe;;AAgDd;AACJ,OArDD,MAqDO;AACH,QAAA,KAAK,CAAC,YAAN,IAAsB,IAAtB;;AACA,YAAI,KAAK,CAAC,YAAN,KAAuB,CAA3B,EAA8B;AAC1B,UAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,eAAnB,EAAoC,SAApC,EAA+C,IAA/C,EAAqD,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAA7D;AACH;AACJ;AACJ;AACJ;;AAED,WAAS,sBAAT,CAAgC,KAAhC,EAA8C,SAA9C,EAAoE,OAApE,EAAgG;AACpF,QAAA,OAAO,GAAW,OAAO,CAAlB,OAAP;AAAA,QAAS,IAAI,GAAK,OAAO,CAAZ,IAAb;AACR,QAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,OAAhB,CAAb;AACA,QAAI,IAAI,KAAK,CAAb,EAAgB;AAER,QAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;;AAER,QAAI,CAAC,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,IAAI,CAAC,MAApB,EAA0B;AAAA;AAA1B,KAAL,EAAyD;AACrD,UAAI,IAAI,KAAK,QAAQ,CAAC,MAAtB,EAA8B;AAC1B,QAAA,KAAK,CAAC,UAAN,IAAoB,CAApB;;AACA,YAAI,KAAK,CAAC,UAAN,KAAqB,CAAzB,EAA4B;AACxB,UAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,aAAnB,EAAkC,SAAlC,EAA6C,IAA7C,EAAmD,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAA3D;AACH;AACJ;;AACD;AACH;;AAED,QAAM,QAAQ,GAAG,IAAI,CAAC,QAAL,CAAc,IAAd,IACX,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,iBADhB,GAEX,IAAI,CAAC,SAAL,CAAe,IAAf,IACI,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,OAA3B,CAAmC,oBADvC,GAEI,IAAI,CAAC,WAAL,CAAiB,IAAjB,IACI,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,SAA3B,CAAqC,oBADzC,GAEI,KAAK,CANnB;;AAQA,QAAI,CAAC,QAAL,EAAe;AACX,MAAA,OAAO,CAAC,IAAR,CAAa,gDAAb;AACA;AACH;;AAEO,QAAA,KAAK,GAAc,QAAQ,CAAtB,KAAL;AAAA,QAAO,OAAO,GAAK,QAAQ,CAAb,OAAd;AACR,QAAI,CAAC,GAAG,CAAR;;AACA,WAAO,CAAC,GAAG,IAAX,EAAiB;AACb,UAAI,CAAC,GAAG,CAAR;AACA,UAAM,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,UAAM,EAAE,GAAG,KAAK,CAAC,EAAD,CAAhB;AACA,QAAE,CAAF;AACA,QAAE,CAAF;;AACA,aAAO,CAAC,GAAG,IAAX,EAAiB;AACb,YAAM,IAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,YAAI,KAAK,CAAC,IAAD,CAAL,KAAc,EAAlB,EAAsB;AACtB,UAAE,CAAF;AACA,UAAE,CAAF;AACH;;AAED,UAAI,OAAO,CAAC,EAAE,GAAG,CAAN,CAAP,GAAkB,OAAO,CAAC,EAAD,CAAzB,KAAkC,CAAtC,EAAyC;AACrC;AACA,QAAA,KAAK,CAAC,UAAN,IAAoB,CAApB;;AACA,YAAI,KAAK,CAAC,UAAN,KAAqB,CAAzB,EAA4B;AACxB,UAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,aAAnB,EAAkC,SAAlC,EAA6C,IAA7C,EAAmD,OAAO,CAAC,EAAD,CAA1D;AACH;AACJ;AACJ;AACJ;;AAED,WAAS,2BAAT,CAAqC,KAArC,EAAmD,SAAnD,EAAyE,YAAzE,EAAyG,KAAzG,EAAwH,GAAxH,EAAmI;AAC/H,QAAI,OAAO,GAAG,YAAY,CAAC,KAAD,CAA1B,CAD+H,CAG/H;;AACA,QAAM,QAAQ,GAAG,IAAI,CAAC,QAAL,CAAc,OAAO,CAAC,IAAtB,IACX,OAAO,CAAC,IAAR,CAAa,KAAb,CAAmB,eAAnB,CAAmC,iBADxB,GAEX,IAAI,CAAC,SAAL,CAAe,OAAO,CAAC,IAAvB,IACI,OAAO,CAAC,IAAR,CAAa,KAAb,CAAmB,eAAnB,CAAmC,OAAnC,CAA2C,oBAD/C,GAEI,IAAI,CAAC,WAAL,CAAiB,OAAO,CAAC,IAAzB,IACI,OAAO,CAAC,IAAR,CAAa,KAAb,CAAmB,eAAnB,CAAmC,SAAnC,CAA6C,oBADjD,GAEI,KAAK,CANnB;;AAQA,QAAI,CAAC,QAAL,EAAe;AACX,MAAA,OAAO,CAAC,IAAR,CAAa,gDAAb;AACA;AACH;;AAEO,QAAA,KAAK,GAAc,QAAQ,CAAtB,KAAL;AAAA,QAAO,OAAO,GAAK,QAAQ,CAAb,OAAd;AAER,QAAM,WAAW,GAAG,IAAI,GAAJ,EAApB;;AAEA,SAAK,IAAI,OAAO,GAAG,KAAnB,EAA0B,OAAO,GAAG,GAApC,EAAyC,OAAO,EAAhD,EAAoD;AAChD,MAAA,OAAO,GAAG,YAAY,CAAC,OAAD,CAAtB;AAEQ,UAAA,OAAO,GAAW,OAAO,CAAlB,OAAP;AAAA,UAAS,IAAI,GAAK,OAAO,CAAZ,IAAb;AACR,UAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,OAAhB,CAAb;AACA,UAAI,IAAI,KAAK,CAAb,EAAgB;AAER,UAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;;AAER,UAAI,CAAC,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,IAAI,CAAC,MAApB,EAA0B;AAAA;AAA1B,OAAL,EAAyD;AACrD,YAAM,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,CAAD,CAAnB;AACA,QAAA,cAAc,CAAC,WAAD,EAAc,KAAK,CAAC,EAAD,CAAnB,EAAyB,QAAQ,CAAC,MAAlC,CAAd;AACA;AACH;;AAED,UAAI,CAAC,GAAG,CAAR;;AACA,aAAO,CAAC,GAAG,IAAX,EAAiB;AACb,YAAI,CAAC,GAAG,CAAR;AACA,YAAM,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,YAAM,EAAE,GAAG,KAAK,CAAC,EAAD,CAAhB;AACA,UAAE,CAAF;AACA,UAAE,CAAF;;AACA,eAAO,CAAC,GAAG,IAAX,EAAiB;AACb,cAAM,IAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,cAAI,KAAK,CAAC,IAAD,CAAL,KAAc,EAAlB,EAAsB;AACtB,YAAE,CAAF;AACA,YAAE,CAAF;AACH;;AAED,QAAA,cAAc,CAAC,WAAD,EAAc,EAAd,EAAkB,CAAlB,CAAd;AACH;AACJ;;AAED,QAAI,OAAO,GAAG,CAAC,CAAf;AACA,IAAA,WAAW,CAAC,OAAZ,CAAoB,UAAC,KAAD,EAAQ,EAAR,EAAU;AAC1B,UAAI,OAAO,CAAC,EAAE,GAAG,CAAN,CAAP,GAAkB,OAAO,CAAC,EAAD,CAAzB,KAAkC,KAAtC,EAA6C;AACzC;AACA,QAAA,KAAK,CAAC,UAAN,IAAoB,CAApB;;AACA,YAAI,KAAK,CAAC,UAAN,KAAqB,CAAzB,EAA4B;AACxB,UAAA,OAAO,GAAG,EAAV;AACH;AACJ;AACJ,KARD;AAUA,QAAI,OAAO,GAAG,CAAd,EAAiB;;AAEjB,SAAK,IAAI,OAAO,GAAG,KAAnB,EAA0B,OAAO,GAAG,GAApC,EAAyC,OAAO,EAAhD,EAAoD;AAChD,MAAA,OAAO,GAAG,YAAY,CAAC,OAAD,CAAtB;AAEQ,UAAA,OAAO,GAAW,OAAO,CAAlB,OAAP;AAAA,UAAS,IAAI,GAAK,OAAO,CAAZ,IAAb;AACR,UAAM,IAAI,GAAG,UAAU,CAAC,IAAX,CAAgB,OAAhB,CAAb;AACA,UAAI,IAAI,KAAK,CAAb,EAAgB;AAER,UAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;AAER,UAAM,CAAC,GAAG,CAAV;;AACA,aAAO,CAAC,GAAG,IAAX,EAAiB;AACb,YAAM,EAAE,GAAG,QAAQ,CAAC,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAD,CAAnB;AACA,YAAM,EAAE,GAAG,KAAK,CAAC,EAAD,CAAhB;;AACA,YAAI,EAAE,KAAK,OAAX,EAAoB;AAChB,UAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,aAAnB,EAAkC,SAAlC,EAA6C,IAA7C,EAAmD,EAAnD;AACA;AACH;AACJ;AACJ;AACJ;;AAED,WAAgB,MAAhB,CAAuB,IAAvB,EAAiC;AAC7B,QAAM,KAAK,GAAG,MAAM,EAApB;AACA,QAAI,IAAI,CAAC,OAAL,CAAa,IAAb,CAAJ,EAAwB,OAAO,KAAP;AAExB,QAAI,aAAa,GAAG,KAApB;;AACA,QAAI,IAAI,CAAC,gBAAL,CAAsB,IAAtB,CAAJ,EAAiC;AAC7B,MAAA,KAAK,CAAC,cAAN,IAAwB,CAAxB;;AACA,UAAI,KAAK,CAAC,cAAN,KAAyB,CAA7B,EAAgC;AACtB,YAAA,EAAA,GAAoB,IAAI,CAAC,QAAL,CAAc,CAAd,CAApB;AAAA,YAAE,IAAI,GAAA,EAAA,CAAA,IAAN;AAAA,YAAQ,OAAO,GAAA,EAAA,CAAA,OAAf;AACN,QAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,iBAAnB,EAAsC,IAAI,CAAC,SAA3C,EAAsD,IAAtD,EAA4D,IAAI,CAAC,QAAL,CAAc,UAAU,CAAC,GAAX,CAAe,OAAf,CAAd,CAA5D;AACH;AACJ,KAND,MAMO;AACH,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,IAAI,CAAC,QAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA+B;AAA1B,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AACD,QAAA,aAAa,CAAC,KAAD,EAAQ,IAAI,CAAC,SAAb,EAAwB,CAAxB,CAAb;;AACA,YAAI,CAAC,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,CAAC,CAAC,IAAF,CAAO,MAAtB,EAA4B;AAAA;AAA5B,SAAL,EAA4D;AACxD,UAAA,sBAAsB,CAAC,KAAD,EAAQ,IAAI,CAAC,SAAb,EAAwB,CAAxB,CAAtB;AACH,SAFD,MAEO;AACH,UAAA,aAAa,GAAG,IAAhB;AACH;AACJ;AACJ;;AAED,QAAI,aAAJ,EAAmB;AACf,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,IAAI,CAAC,QAAL,CAAc,MAApC,EAA4C,CAAC,GAAG,GAAhD,EAAqD,CAAC,EAAtD,EAA0D;AACtD,YAAM,CAAC,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAV;AACA,YAAI,CAAC,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAe,CAAC,CAAC,IAAF,CAAO,MAAtB,EAA4B;AAAA;AAA5B,SAAL,EAA4D;AAE5D,YAAM,KAAK,GAAG,CAAd;;AACA,eAAO,CAAC,GAAG,GAAJ,IAAW,IAAI,CAAC,yBAAL,CAA+B,IAAI,CAAC,QAAL,CAAc,CAAd,EAAiB,IAAhD,EAAsD,CAAC,CAAC,IAAxD,CAAlB,EAAiF;AAC7E,UAAA,CAAC;AACJ;;AACD,YAAM,GAAG,GAAG,CAAZ;AACA,QAAA,CAAC;;AACD,YAAI,GAAG,GAAG,KAAN,KAAgB,CAApB,EAAuB;AACnB,UAAA,sBAAsB,CAAC,KAAD,EAAQ,IAAI,CAAC,SAAb,EAAwB,CAAxB,CAAtB;AACH,SAFD,MAEO;AACH,UAAA,2BAA2B,CAAC,KAAD,EAAQ,IAAI,CAAC,SAAb,EAAwB,IAAI,CAAC,QAA7B,EAAuC,KAAvC,EAA8C,GAA9C,CAA3B;AACH;AACJ;AACJ;;AAED,WAAO,KAAP;AACH;;AA1Ce,EAAA,KAAA,CAAA,MAAA,GAAM,MAAN;AA4ChB;;AACA,WAAgB,GAAhB,CAAoB,GAApB,EAAgC,CAAhC,EAA0C,CAA1C,EAAkD;AAC9C,QAAI,CAAC,CAAC,YAAF,KAAmB,CAAnB,IAAwB,CAAC,CAAC,YAAF,KAAmB,CAA/C,EAAkD;AAC9C,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,eAAlB,EAAmC,CAAC,CAAC,eAArC;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,YAAF,KAAmB,CAAnB,IAAwB,CAAC,CAAC,YAAF,KAAmB,CAA/C,EAAkD;AACrD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,eAAlB,EAAmC,CAAC,CAAC,eAArC;AACH;;AAED,QAAI,CAAC,CAAC,iBAAF,KAAwB,CAAxB,IAA6B,CAAC,CAAC,iBAAF,KAAwB,CAAzD,EAA4D;AACxD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,oBAAlB,EAAwC,CAAC,CAAC,oBAA1C;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,iBAAF,KAAwB,CAAxB,IAA6B,CAAC,CAAC,iBAAF,KAAwB,CAAzD,EAA4D;AAC/D,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,oBAAlB,EAAwC,CAAC,CAAC,oBAA1C;AACH;;AAED,QAAI,CAAC,CAAC,YAAF,KAAmB,CAAnB,IAAwB,CAAC,CAAC,YAAF,KAAmB,CAA/C,EAAkD;AAC9C,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,eAAlB,EAAmC,CAAC,CAAC,eAArC;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,YAAF,KAAmB,CAAnB,IAAwB,CAAC,CAAC,YAAF,KAAmB,CAA/C,EAAkD;AACrD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,eAAlB,EAAmC,CAAC,CAAC,eAArC;AACH;;AAED,QAAI,CAAC,CAAC,UAAF,KAAiB,CAAjB,IAAsB,CAAC,CAAC,UAAF,KAAiB,CAA3C,EAA8C;AAC1C,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,aAAlB,EAAiC,CAAC,CAAC,aAAnC;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,UAAF,KAAiB,CAAjB,IAAsB,CAAC,CAAC,UAAF,KAAiB,CAA3C,EAA8C;AACjD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,aAAlB,EAAiC,CAAC,CAAC,aAAnC;AACH;;AAED,QAAI,CAAC,CAAC,SAAF,KAAgB,CAAhB,IAAqB,CAAC,CAAC,SAAF,KAAgB,CAAzC,EAA4C;AACxC,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,YAAlB,EAAgC,CAAC,CAAC,YAAlC;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,SAAF,KAAgB,CAAhB,IAAqB,CAAC,CAAC,SAAF,KAAgB,CAAzC,EAA4C;AAC/C,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,YAAlB,EAAgC,CAAC,CAAC,YAAlC;AACH;;AAED,QAAI,CAAC,CAAC,cAAF,KAAqB,CAArB,IAA0B,CAAC,CAAC,cAAF,KAAqB,CAAnD,EAAsD;AAClD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,iBAAlB,EAAqC,CAAC,CAAC,iBAAvC;AACH,KAFD,MAEO,IAAI,CAAC,CAAC,cAAF,KAAqB,CAArB,IAA0B,CAAC,CAAC,cAAF,KAAqB,CAAnD,EAAsD;AACzD,MAAA,QAAQ,CAAC,IAAT,CAAc,GAAG,CAAC,iBAAlB,EAAqC,CAAC,CAAC,iBAAvC;AACH;;AAED,IAAA,GAAG,CAAC,YAAJ,GAAmB,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,YAAtC;AACA,IAAA,GAAG,CAAC,iBAAJ,GAAwB,CAAC,CAAC,iBAAF,GAAsB,CAAC,CAAC,iBAAhD;AACA,IAAA,GAAG,CAAC,YAAJ,GAAmB,CAAC,CAAC,YAAF,GAAiB,CAAC,CAAC,YAAtC;AACA,IAAA,GAAG,CAAC,UAAJ,GAAiB,CAAC,CAAC,UAAF,GAAe,CAAC,CAAC,UAAlC;AACA,IAAA,GAAG,CAAC,SAAJ,GAAgB,CAAC,CAAC,SAAF,GAAc,CAAC,CAAC,SAAhC;AACA,IAAA,GAAG,CAAC,cAAJ,GAAqB,CAAC,CAAC,cAAF,GAAmB,CAAC,CAAC,cAA1C;AACA,WAAO,GAAP;AACH;;AA5Ce,EAAA,KAAA,CAAA,GAAA,GAAG,GAAH;AA6CnB,CA3VD,EAAiB,KAAK,KAAL,KAAK,GAAA,EAAA,CAAtB","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { OrderedSet } from '../../../../mol-data/int';\r\nimport { Unit } from '../unit';\r\nimport { Loci } from './loci';\r\nimport { Location } from './location';\r\nexport var Stats;\r\n(function (Stats) {\r\n    function create() {\r\n        return {\r\n            elementCount: 0,\r\n            conformationCount: 0,\r\n            residueCount: 0,\r\n            chainCount: 0,\r\n            unitCount: 0,\r\n            structureCount: 0,\r\n            firstElementLoc: Location.create(void 0),\r\n            firstConformationLoc: Location.create(void 0),\r\n            firstResidueLoc: Location.create(void 0),\r\n            firstChainLoc: Location.create(void 0),\r\n            firstUnitLoc: Location.create(void 0),\r\n            firstStructureLoc: Location.create(void 0),\r\n        };\r\n    }\r\n    Stats.create = create;\r\n    function addCountHelper(map, key, inc) {\r\n        var count = map.get(key) || 0;\r\n        map.set(key, count + inc);\r\n    }\r\n    function handleElement(stats, structure, element) {\r\n        var indices = element.indices, unit = element.unit;\r\n        var elements = unit.elements;\r\n        var size = OrderedSet.size(indices);\r\n        var lociResidueAltIdCounts = new Map();\r\n        var residueAltIdCounts = new Map();\r\n        if (size > 0) {\r\n            Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\r\n        }\r\n        // count single element unit as unit not element\r\n        if (size === elements.length) {\r\n            stats.unitCount += 1;\r\n            if (stats.unitCount === 1) {\r\n                Location.set(stats.firstUnitLoc, structure, unit, elements[OrderedSet.start(indices)]);\r\n            }\r\n        }\r\n        else if (size === 1) {\r\n            if (Unit.Traits.is(unit.traits, 1 /* MultiChain */)) {\r\n                return;\r\n            }\r\n            else {\r\n                stats.elementCount += 1;\r\n                if (stats.elementCount === 1) {\r\n                    Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            if (Unit.isAtomic(unit)) {\r\n                var _a = unit.model.atomicHierarchy.residueAtomSegments, index = _a.index, offsets_1 = _a.offsets;\r\n                var label_alt_id_1 = unit.model.atomicHierarchy.atoms.label_alt_id;\r\n                var i = 0;\r\n                var _loop_1 = function () {\r\n                    lociResidueAltIdCounts.clear();\r\n                    var j = 0;\r\n                    var eI = elements[OrderedSet.getAt(indices, i)];\r\n                    var rI = index[eI];\r\n                    addCountHelper(lociResidueAltIdCounts, label_alt_id_1.value(eI), 1);\r\n                    ++i;\r\n                    ++j;\r\n                    while (i < size) {\r\n                        var eI_1 = elements[OrderedSet.getAt(indices, i)];\r\n                        if (index[eI_1] !== rI)\r\n                            break;\r\n                        addCountHelper(lociResidueAltIdCounts, label_alt_id_1.value(eI_1), 1);\r\n                        ++i;\r\n                        ++j;\r\n                    }\r\n                    if (offsets_1[rI + 1] - offsets_1[rI] === j) {\r\n                        // full residue\r\n                        stats.residueCount += 1;\r\n                        if (stats.residueCount === 1) {\r\n                            Location.set(stats.firstResidueLoc, structure, unit, offsets_1[rI]);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // partial residue\r\n                        residueAltIdCounts.clear();\r\n                        for (var l = offsets_1[rI], _l = offsets_1[rI + 1]; l < _l; ++l) {\r\n                            addCountHelper(residueAltIdCounts, label_alt_id_1.value(l), 1);\r\n                        }\r\n                        // check if shared atom count match\r\n                        if (residueAltIdCounts.get('') === lociResidueAltIdCounts.get('')) {\r\n                            lociResidueAltIdCounts.forEach(function (v, k) {\r\n                                if (residueAltIdCounts.get(k) !== v)\r\n                                    return;\r\n                                if (k !== '') {\r\n                                    stats.conformationCount += 1;\r\n                                    if (stats.conformationCount === 1) {\r\n                                        for (var l = offsets_1[rI], _l = offsets_1[rI + 1]; l < _l; ++l) {\r\n                                            if (k === label_alt_id_1.value(l)) {\r\n                                                Location.set(stats.firstConformationLoc, structure, unit, l);\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                j -= v;\r\n                            });\r\n                        }\r\n                        stats.elementCount += j;\r\n                    }\r\n                };\r\n                while (i < size) {\r\n                    _loop_1();\r\n                }\r\n            }\r\n            else {\r\n                stats.elementCount += size;\r\n                if (stats.elementCount === 1) {\r\n                    Location.set(stats.firstElementLoc, structure, unit, elements[OrderedSet.start(indices)]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleUnitChainsSimple(stats, structure, element) {\r\n        var indices = element.indices, unit = element.unit;\r\n        var size = OrderedSet.size(indices);\r\n        if (size === 0)\r\n            return;\r\n        var elements = unit.elements;\r\n        if (!Unit.Traits.is(unit.traits, 1 /* MultiChain */)) {\r\n            if (size === elements.length) {\r\n                stats.chainCount += 1;\r\n                if (stats.chainCount === 1) {\r\n                    Location.set(stats.firstChainLoc, structure, unit, elements[OrderedSet.start(indices)]);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        var segments = Unit.isAtomic(unit)\r\n            ? unit.model.atomicHierarchy.chainAtomSegments\r\n            : Unit.isSpheres(unit)\r\n                ? unit.model.coarseHierarchy.spheres.chainElementSegments\r\n                : Unit.isGaussians(unit)\r\n                    ? unit.model.coarseHierarchy.gaussians.chainElementSegments\r\n                    : void 0;\r\n        if (!segments) {\r\n            console.warn('StructureElement loci stats: unknown unit type');\r\n            return;\r\n        }\r\n        var index = segments.index, offsets = segments.offsets;\r\n        var i = 0;\r\n        while (i < size) {\r\n            var j = 0;\r\n            var eI = elements[OrderedSet.getAt(indices, i)];\r\n            var cI = index[eI];\r\n            ++i;\r\n            ++j;\r\n            while (i < size) {\r\n                var eI_2 = elements[OrderedSet.getAt(indices, i)];\r\n                if (index[eI_2] !== cI)\r\n                    break;\r\n                ++i;\r\n                ++j;\r\n            }\r\n            if (offsets[cI + 1] - offsets[cI] === j) {\r\n                // full chain\r\n                stats.chainCount += 1;\r\n                if (stats.chainCount === 1) {\r\n                    Location.set(stats.firstChainLoc, structure, unit, offsets[cI]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleUnitChainsPartitioned(stats, structure, lociElements, start, end) {\r\n        var element = lociElements[start];\r\n        // all the elements have the same model since they are part of the same group so this is ok.\r\n        var segments = Unit.isAtomic(element.unit)\r\n            ? element.unit.model.atomicHierarchy.chainAtomSegments\r\n            : Unit.isSpheres(element.unit)\r\n                ? element.unit.model.coarseHierarchy.spheres.chainElementSegments\r\n                : Unit.isGaussians(element.unit)\r\n                    ? element.unit.model.coarseHierarchy.gaussians.chainElementSegments\r\n                    : void 0;\r\n        if (!segments) {\r\n            console.warn('StructureElement loci stats: unknown unit type');\r\n            return;\r\n        }\r\n        var index = segments.index, offsets = segments.offsets;\r\n        var chainCounts = new Map();\r\n        for (var elIndex = start; elIndex < end; elIndex++) {\r\n            element = lociElements[elIndex];\r\n            var indices = element.indices, unit = element.unit;\r\n            var size = OrderedSet.size(indices);\r\n            if (size === 0)\r\n                continue;\r\n            var elements = unit.elements;\r\n            if (!Unit.Traits.is(unit.traits, 1 /* MultiChain */)) {\r\n                var eI = elements[OrderedSet.start(indices)];\r\n                addCountHelper(chainCounts, index[eI], elements.length);\r\n                continue;\r\n            }\r\n            var i = 0;\r\n            while (i < size) {\r\n                var j = 0;\r\n                var eI = elements[OrderedSet.getAt(indices, i)];\r\n                var cI = index[eI];\r\n                ++i;\r\n                ++j;\r\n                while (i < size) {\r\n                    var eI_3 = elements[OrderedSet.getAt(indices, i)];\r\n                    if (index[eI_3] !== cI)\r\n                        break;\r\n                    ++i;\r\n                    ++j;\r\n                }\r\n                addCountHelper(chainCounts, cI, j);\r\n            }\r\n        }\r\n        var firstCI = -1;\r\n        chainCounts.forEach(function (count, cI) {\r\n            if (offsets[cI + 1] - offsets[cI] === count) {\r\n                // full chain\r\n                stats.chainCount += 1;\r\n                if (stats.chainCount === 1) {\r\n                    firstCI = cI;\r\n                }\r\n            }\r\n        });\r\n        if (firstCI < 0)\r\n            return;\r\n        for (var elIndex = start; elIndex < end; elIndex++) {\r\n            element = lociElements[elIndex];\r\n            var indices = element.indices, unit = element.unit;\r\n            var size = OrderedSet.size(indices);\r\n            if (size === 0)\r\n                continue;\r\n            var elements = unit.elements;\r\n            var i = 0;\r\n            while (i < size) {\r\n                var eI = elements[OrderedSet.getAt(indices, i)];\r\n                var cI = index[eI];\r\n                if (cI === firstCI) {\r\n                    Location.set(stats.firstChainLoc, structure, unit, eI);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function ofLoci(loci) {\r\n        var stats = create();\r\n        if (Loci.isEmpty(loci))\r\n            return stats;\r\n        var hasPartitions = false;\r\n        if (Loci.isWholeStructure(loci)) {\r\n            stats.structureCount += 1;\r\n            if (stats.structureCount === 1) {\r\n                var _a = loci.elements[0], unit = _a.unit, indices = _a.indices;\r\n                Location.set(stats.firstStructureLoc, loci.structure, unit, unit.elements[OrderedSet.min(indices)]);\r\n            }\r\n        }\r\n        else {\r\n            for (var _i = 0, _b = loci.elements; _i < _b.length; _i++) {\r\n                var e = _b[_i];\r\n                handleElement(stats, loci.structure, e);\r\n                if (!Unit.Traits.is(e.unit.traits, 2 /* Partitioned */)) {\r\n                    handleUnitChainsSimple(stats, loci.structure, e);\r\n                }\r\n                else {\r\n                    hasPartitions = true;\r\n                }\r\n            }\r\n        }\r\n        if (hasPartitions) {\r\n            for (var i = 0, len = loci.elements.length; i < len; i++) {\r\n                var e = loci.elements[i];\r\n                if (!Unit.Traits.is(e.unit.traits, 2 /* Partitioned */))\r\n                    continue;\r\n                var start = i;\r\n                while (i < len && Unit.areSameChainOperatorGroup(loci.elements[i].unit, e.unit)) {\r\n                    i++;\r\n                }\r\n                var end = i;\r\n                i--;\r\n                if (end - start === 1) {\r\n                    handleUnitChainsSimple(stats, loci.structure, e);\r\n                }\r\n                else {\r\n                    handleUnitChainsPartitioned(stats, loci.structure, loci.elements, start, end);\r\n                }\r\n            }\r\n        }\r\n        return stats;\r\n    }\r\n    Stats.ofLoci = ofLoci;\r\n    /** Adds counts of two Stats objects together, assumes they describe different structures */\r\n    function add(out, a, b) {\r\n        if (a.elementCount === 1 && b.elementCount === 0) {\r\n            Location.copy(out.firstElementLoc, a.firstElementLoc);\r\n        }\r\n        else if (a.elementCount === 0 && b.elementCount === 1) {\r\n            Location.copy(out.firstElementLoc, b.firstElementLoc);\r\n        }\r\n        if (a.conformationCount === 1 && b.conformationCount === 0) {\r\n            Location.copy(out.firstConformationLoc, a.firstConformationLoc);\r\n        }\r\n        else if (a.conformationCount === 0 && b.conformationCount === 1) {\r\n            Location.copy(out.firstConformationLoc, b.firstConformationLoc);\r\n        }\r\n        if (a.residueCount === 1 && b.residueCount === 0) {\r\n            Location.copy(out.firstResidueLoc, a.firstResidueLoc);\r\n        }\r\n        else if (a.residueCount === 0 && b.residueCount === 1) {\r\n            Location.copy(out.firstResidueLoc, b.firstResidueLoc);\r\n        }\r\n        if (a.chainCount === 1 && b.chainCount === 0) {\r\n            Location.copy(out.firstChainLoc, a.firstChainLoc);\r\n        }\r\n        else if (a.chainCount === 0 && b.chainCount === 1) {\r\n            Location.copy(out.firstChainLoc, b.firstChainLoc);\r\n        }\r\n        if (a.unitCount === 1 && b.unitCount === 0) {\r\n            Location.copy(out.firstUnitLoc, a.firstUnitLoc);\r\n        }\r\n        else if (a.unitCount === 0 && b.unitCount === 1) {\r\n            Location.copy(out.firstUnitLoc, b.firstUnitLoc);\r\n        }\r\n        if (a.structureCount === 1 && b.structureCount === 0) {\r\n            Location.copy(out.firstStructureLoc, a.firstStructureLoc);\r\n        }\r\n        else if (a.structureCount === 0 && b.structureCount === 1) {\r\n            Location.copy(out.firstStructureLoc, b.firstStructureLoc);\r\n        }\r\n        out.elementCount = a.elementCount + b.elementCount;\r\n        out.conformationCount = a.conformationCount + b.conformationCount;\r\n        out.residueCount = a.residueCount + b.residueCount;\r\n        out.chainCount = a.chainCount + b.chainCount;\r\n        out.unitCount = a.unitCount + b.unitCount;\r\n        out.structureCount = a.structureCount + b.structureCount;\r\n        return out;\r\n    }\r\n    Stats.add = add;\r\n})(Stats || (Stats = {}));\r\n//# sourceMappingURL=stats.js.map"]},"metadata":{},"sourceType":"module"}