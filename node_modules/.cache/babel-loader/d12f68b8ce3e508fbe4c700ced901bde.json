{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { TextEncoder } from './cif/encoder/text';\nimport { BinaryEncoder } from './cif/encoder/binary';\nimport * as _Encoder from './cif/encoder';\nimport { ArrayEncoding, ArrayEncoder } from '../common/binary-cif';\nexport var CifWriter;\n\n(function (CifWriter) {\n  CifWriter.Encoder = _Encoder.Encoder;\n  CifWriter.Category = _Encoder.Category;\n  CifWriter.Field = _Encoder.Field;\n  CifWriter.Encoding = ArrayEncoding;\n\n  function createEncoder(params) {\n    var _a = params || {},\n        _b = _a.binary,\n        binary = _b === void 0 ? false : _b,\n        _c = _a.encoderName,\n        encoderName = _c === void 0 ? 'mol*' : _c;\n\n    return binary ? new BinaryEncoder(encoderName, params ? params.binaryEncodingPovider : void 0, params ? !!params.binaryAutoClassifyEncoding : false) : new TextEncoder();\n  }\n\n  CifWriter.createEncoder = createEncoder;\n\n  function fields() {\n    return CifWriter.Field.build();\n  }\n\n  CifWriter.fields = fields;\n  var E = CifWriter.Encoding;\n  CifWriter.Encodings = {\n    deltaRLE: E.by(E.delta).and(E.runLength).and(E.integerPacking),\n    fixedPoint2: E.by(E.fixedPoint(100)).and(E.delta).and(E.integerPacking),\n    fixedPoint3: E.by(E.fixedPoint(1000)).and(E.delta).and(E.integerPacking)\n  };\n\n  function categoryInstance(fields, source) {\n    return {\n      fields: fields,\n      source: [source]\n    };\n  }\n\n  CifWriter.categoryInstance = categoryInstance;\n\n  function createEncodingProviderFromCifFrame(frame) {\n    return {\n      get: function (c, f) {\n        var cat = frame.categories[c];\n        if (!cat) return void 0;\n        var ff = cat.getField(f);\n        return ff && ff.binaryEncoding ? ArrayEncoder.fromEncoding(ff.binaryEncoding) : void 0;\n      }\n    };\n  }\n\n  CifWriter.createEncodingProviderFromCifFrame = createEncodingProviderFromCifFrame;\n  ;\n\n  function createEncodingProviderFromJsonConfig(hints) {\n    return {\n      get: function (c, f) {\n        for (var i = 0; i < hints.length; i++) {\n          var hint = hints[i];\n\n          if (hint.categoryName === c && hint.columnName === f) {\n            return resolveEncoding(hint);\n          }\n        }\n      }\n    };\n  }\n\n  CifWriter.createEncodingProviderFromJsonConfig = createEncodingProviderFromJsonConfig;\n\n  function resolveEncoding(hint) {\n    var precision = hint.precision;\n\n    if (precision !== void 0) {\n      var multiplier = Math.pow(10, precision);\n      var fixedPoint = E.by(E.fixedPoint(multiplier));\n\n      switch (hint.encoding) {\n        case 'pack':\n          return fixedPoint.and(E.integerPacking);\n\n        case 'rle':\n          return fixedPoint.and(E.runLength).and(E.integerPacking);\n\n        case 'delta':\n          return fixedPoint.and(E.delta).and(E.integerPacking);\n\n        case 'delta-rle':\n          return fixedPoint.and(E.delta).and(E.runLength).and(E.integerPacking);\n      }\n\n      ;\n    } else {\n      switch (hint.encoding) {\n        case 'pack':\n          return E.by(E.integerPacking);\n\n        case 'rle':\n          return E.by(E.runLength).and(E.integerPacking);\n\n        case 'delta':\n          return E.by(E.delta).and(E.integerPacking);\n\n        case 'delta-rle':\n          return E.by(E.delta).and(E.runLength).and(E.integerPacking);\n      }\n    }\n\n    throw new Error('cannot be reached');\n  }\n})(CifWriter || (CifWriter = {}));","map":{"version":3,"sources":["../../../src/mol-io/writer/cif.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAAS,WAAT,QAA4B,oBAA5B;AACA,SAAS,aAAT,QAAsD,sBAAtD;AACA,OAAO,KAAK,QAAZ,MAA0B,eAA1B;AACA,SAAS,aAAT,EAAwB,YAAxB,QAA4C,sBAA5C;AAGA,OAAM,IAAW,SAAX;;AAAN,CAAA,UAAiB,SAAjB,EAA0B;AACR,EAAA,SAAA,CAAA,OAAA,GAAU,QAAQ,CAAC,OAAnB;AACA,EAAA,SAAA,CAAA,QAAA,GAAW,QAAQ,CAAC,QAApB;AACA,EAAA,SAAA,CAAA,KAAA,GAAQ,QAAQ,CAAC,KAAjB;AACA,EAAA,SAAA,CAAA,QAAA,GAAW,aAAX;;AASd,WAAgB,aAAhB,CAA8B,MAA9B,EAAoD;AAC1C,QAAA,EAAA,GAA2C,MAAM,IAAI,EAArD;AAAA,QAAE,EAAA,GAAA,EAAA,CAAA,MAAF;AAAA,QAAE,MAAM,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAAhB;AAAA,QAAkB,EAAA,GAAA,EAAA,CAAA,WAAlB;AAAA,QAAkB,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,MAAH,GAAS,EAAtC;;AACN,WAAO,MAAM,GAAG,IAAI,aAAJ,CAAkB,WAAlB,EAA+B,MAAM,GAAG,MAAM,CAAC,qBAAV,GAAkC,KAAK,CAA5E,EAA+E,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,0BAAZ,GAAyC,KAA9H,CAAH,GAA0I,IAAI,WAAJ,EAAvJ;AACH;;AAHe,EAAA,SAAA,CAAA,aAAA,GAAa,aAAb;;AAKhB,WAAgB,MAAhB,GAAsB;AAClB,WAAO,SAAA,CAAA,KAAA,CAAM,KAAN,EAAP;AACH;;AAFe,EAAA,SAAA,CAAA,MAAA,GAAM,MAAN;AAIhB,MAAO,CAAC,GAAG,SAAA,CAAA,QAAX;AACa,EAAA,SAAA,CAAA,SAAA,GAAY;AACrB,IAAA,QAAQ,EAAE,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,KAAP,EAAc,GAAd,CAAkB,CAAC,CAAC,SAApB,EAA+B,GAA/B,CAAmC,CAAC,CAAC,cAArC,CADW;AAErB,IAAA,WAAW,EAAE,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,UAAF,CAAa,GAAb,CAAL,EAAwB,GAAxB,CAA4B,CAAC,CAAC,KAA9B,EAAqC,GAArC,CAAyC,CAAC,CAAC,cAA3C,CAFQ;AAGrB,IAAA,WAAW,EAAE,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,UAAF,CAAa,IAAb,CAAL,EAAyB,GAAzB,CAA6B,CAAC,CAAC,KAA/B,EAAsC,GAAtC,CAA0C,CAAC,CAAC,cAA5C;AAHQ,GAAZ;;AAMb,WAAgB,gBAAhB,CAA4C,MAA5C,EAAwE,MAAxE,EAAmG;AAC/F,WAAO;AAAE,MAAA,MAAM,EAAA,MAAR;AAAU,MAAA,MAAM,EAAE,CAAC,MAAD;AAAlB,KAAP;AACH;;AAFe,EAAA,SAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AAIhB,WAAgB,kCAAhB,CAAmD,KAAnD,EAAkE;AAC9D,WAAO;AACH,MAAA,GAAG,EAAA,UAAC,CAAD,EAAI,CAAJ,EAAK;AACJ,YAAM,GAAG,GAAG,KAAK,CAAC,UAAN,CAAiB,CAAjB,CAAZ;AACA,YAAI,CAAC,GAAL,EAAU,OAAO,KAAK,CAAZ;AACV,YAAM,EAAE,GAAG,GAAG,CAAC,QAAJ,CAAa,CAAb,CAAX;AACA,eAAO,EAAE,IAAI,EAAE,CAAC,cAAT,GAA0B,YAAY,CAAC,YAAb,CAA0B,EAAE,CAAC,cAA7B,CAA1B,GAAyE,KAAK,CAArF;AACH;AANE,KAAP;AAQH;;AATe,EAAA,SAAA,CAAA,kCAAA,GAAkC,kCAAlC;AASf;;AAED,WAAgB,oCAAhB,CAAqD,KAArD,EAAkF;AAC9E,WAAO;AACH,MAAA,GAAG,EAAA,UAAC,CAAD,EAAI,CAAJ,EAAK;AACJ,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,cAAM,IAAI,GAAG,KAAK,CAAC,CAAD,CAAlB;;AACA,cAAI,IAAI,CAAC,YAAL,KAAsB,CAAtB,IAA2B,IAAI,CAAC,UAAL,KAAoB,CAAnD,EAAsD;AAClD,mBAAO,eAAe,CAAC,IAAD,CAAtB;AACH;AACJ;AACJ;AARE,KAAP;AAUH;;AAXe,EAAA,SAAA,CAAA,oCAAA,GAAoC,oCAApC;;AAahB,WAAS,eAAT,CAAyB,IAAzB,EAAmD;AAC/C,QAAM,SAAS,GAAuB,IAAI,CAAC,SAA3C;;AACA,QAAI,SAAS,KAAK,KAAK,CAAvB,EAA0B;AACtB,UAAM,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,SAAb,CAAnB;AACA,UAAM,UAAU,GAAG,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,UAAF,CAAa,UAAb,CAAL,CAAnB;;AACA,cAAQ,IAAI,CAAC,QAAb;AACI,aAAK,MAAL;AACI,iBAAO,UAAU,CAAC,GAAX,CAAe,CAAC,CAAC,cAAjB,CAAP;;AACJ,aAAK,KAAL;AACI,iBAAO,UAAU,CAAC,GAAX,CAAe,CAAC,CAAC,SAAjB,EAA4B,GAA5B,CAAgC,CAAC,CAAC,cAAlC,CAAP;;AACJ,aAAK,OAAL;AACI,iBAAO,UAAU,CAAC,GAAX,CAAe,CAAC,CAAC,KAAjB,EAAwB,GAAxB,CAA4B,CAAC,CAAC,cAA9B,CAAP;;AACJ,aAAK,WAAL;AACI,iBAAO,UAAU,CAAC,GAAX,CAAe,CAAC,CAAC,KAAjB,EAAwB,GAAxB,CAA4B,CAAC,CAAC,SAA9B,EAAyC,GAAzC,CAA6C,CAAC,CAAC,cAA/C,CAAP;AARR;;AASC;AACJ,KAbD,MAaO;AACH,cAAQ,IAAI,CAAC,QAAb;AACI,aAAK,MAAL;AACI,iBAAO,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,cAAP,CAAP;;AACJ,aAAK,KAAL;AACI,iBAAO,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,SAAP,EAAkB,GAAlB,CAAsB,CAAC,CAAC,cAAxB,CAAP;;AACJ,aAAK,OAAL;AACI,iBAAO,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,KAAP,EAAc,GAAd,CAAkB,CAAC,CAAC,cAApB,CAAP;;AACJ,aAAK,WAAL;AACI,iBAAO,CAAC,CAAC,EAAF,CAAK,CAAC,CAAC,KAAP,EAAc,GAAd,CAAkB,CAAC,CAAC,SAApB,EAA+B,GAA/B,CAAmC,CAAC,CAAC,cAArC,CAAP;AARR;AAUH;;AACD,UAAM,IAAI,KAAJ,CAAU,mBAAV,CAAN;AACH;AACJ,CAtFD,EAAiB,SAAS,KAAT,SAAS,GAAA,EAAA,CAA1B","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { TextEncoder } from './cif/encoder/text';\r\nimport { BinaryEncoder } from './cif/encoder/binary';\r\nimport * as _Encoder from './cif/encoder';\r\nimport { ArrayEncoding, ArrayEncoder } from '../common/binary-cif';\r\nexport var CifWriter;\r\n(function (CifWriter) {\r\n    CifWriter.Encoder = _Encoder.Encoder;\r\n    CifWriter.Category = _Encoder.Category;\r\n    CifWriter.Field = _Encoder.Field;\r\n    CifWriter.Encoding = ArrayEncoding;\r\n    function createEncoder(params) {\r\n        var _a = params || {}, _b = _a.binary, binary = _b === void 0 ? false : _b, _c = _a.encoderName, encoderName = _c === void 0 ? 'mol*' : _c;\r\n        return binary ? new BinaryEncoder(encoderName, params ? params.binaryEncodingPovider : void 0, params ? !!params.binaryAutoClassifyEncoding : false) : new TextEncoder();\r\n    }\r\n    CifWriter.createEncoder = createEncoder;\r\n    function fields() {\r\n        return CifWriter.Field.build();\r\n    }\r\n    CifWriter.fields = fields;\r\n    var E = CifWriter.Encoding;\r\n    CifWriter.Encodings = {\r\n        deltaRLE: E.by(E.delta).and(E.runLength).and(E.integerPacking),\r\n        fixedPoint2: E.by(E.fixedPoint(100)).and(E.delta).and(E.integerPacking),\r\n        fixedPoint3: E.by(E.fixedPoint(1000)).and(E.delta).and(E.integerPacking),\r\n    };\r\n    function categoryInstance(fields, source) {\r\n        return { fields: fields, source: [source] };\r\n    }\r\n    CifWriter.categoryInstance = categoryInstance;\r\n    function createEncodingProviderFromCifFrame(frame) {\r\n        return {\r\n            get: function (c, f) {\r\n                var cat = frame.categories[c];\r\n                if (!cat)\r\n                    return void 0;\r\n                var ff = cat.getField(f);\r\n                return ff && ff.binaryEncoding ? ArrayEncoder.fromEncoding(ff.binaryEncoding) : void 0;\r\n            }\r\n        };\r\n    }\r\n    CifWriter.createEncodingProviderFromCifFrame = createEncodingProviderFromCifFrame;\r\n    ;\r\n    function createEncodingProviderFromJsonConfig(hints) {\r\n        return {\r\n            get: function (c, f) {\r\n                for (var i = 0; i < hints.length; i++) {\r\n                    var hint = hints[i];\r\n                    if (hint.categoryName === c && hint.columnName === f) {\r\n                        return resolveEncoding(hint);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    CifWriter.createEncodingProviderFromJsonConfig = createEncodingProviderFromJsonConfig;\r\n    function resolveEncoding(hint) {\r\n        var precision = hint.precision;\r\n        if (precision !== void 0) {\r\n            var multiplier = Math.pow(10, precision);\r\n            var fixedPoint = E.by(E.fixedPoint(multiplier));\r\n            switch (hint.encoding) {\r\n                case 'pack':\r\n                    return fixedPoint.and(E.integerPacking);\r\n                case 'rle':\r\n                    return fixedPoint.and(E.runLength).and(E.integerPacking);\r\n                case 'delta':\r\n                    return fixedPoint.and(E.delta).and(E.integerPacking);\r\n                case 'delta-rle':\r\n                    return fixedPoint.and(E.delta).and(E.runLength).and(E.integerPacking);\r\n            }\r\n            ;\r\n        }\r\n        else {\r\n            switch (hint.encoding) {\r\n                case 'pack':\r\n                    return E.by(E.integerPacking);\r\n                case 'rle':\r\n                    return E.by(E.runLength).and(E.integerPacking);\r\n                case 'delta':\r\n                    return E.by(E.delta).and(E.integerPacking);\r\n                case 'delta-rle':\r\n                    return E.by(E.delta).and(E.runLength).and(E.integerPacking);\r\n            }\r\n        }\r\n        throw new Error('cannot be reached');\r\n    }\r\n})(CifWriter || (CifWriter = {}));\r\n//# sourceMappingURL=cif.js.map"]},"metadata":{},"sourceType":"module"}