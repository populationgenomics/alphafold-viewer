{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { Vec3, Mat4, Mat3, Vec4 } from '../../../mol-math/linear-algebra';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { transformPositionArray, transformDirectionArray, computeIndexedVertexNormals, createGroupMapping } from '../../util';\nimport { createMarkers } from '../marker-data';\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\nimport { createColors } from '../color-data';\nimport { ChunkedArray, hashFnv32a, invertCantorPairing, sortedCantorPairing } from '../../../mol-data/util';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { createEmptyClipping } from '../clipping-data';\nimport { arraySetAdd } from '../../../mol-util/array';\nimport { degToRad } from '../../../mol-math/misc';\nexport var Mesh;\n\n(function (Mesh) {\n  function create(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) {\n    return mesh ? update(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) : fromArrays(vertices, indices, normals, groups, vertexCount, triangleCount);\n  }\n\n  Mesh.create = create;\n\n  function createEmpty(mesh) {\n    var vb = mesh ? mesh.vertexBuffer.ref.value : new Float32Array(0);\n    var ib = mesh ? mesh.indexBuffer.ref.value : new Uint32Array(0);\n    var nb = mesh ? mesh.normalBuffer.ref.value : new Float32Array(0);\n    var gb = mesh ? mesh.groupBuffer.ref.value : new Float32Array(0);\n    return create(vb, ib, nb, gb, 0, 0, mesh);\n  }\n\n  Mesh.createEmpty = createEmpty;\n\n  function hashCode(mesh) {\n    return hashFnv32a([mesh.vertexCount, mesh.triangleCount, mesh.vertexBuffer.ref.version, mesh.indexBuffer.ref.version, mesh.normalBuffer.ref.version, mesh.groupBuffer.ref.version]);\n  }\n\n  function fromArrays(vertices, indices, normals, groups, vertexCount, triangleCount) {\n    var boundingSphere = Sphere3D();\n    var groupMapping;\n    var currentHash = -1;\n    var currentGroup = -1;\n    var mesh = {\n      kind: 'mesh',\n      vertexCount: vertexCount,\n      triangleCount: triangleCount,\n      vertexBuffer: ValueCell.create(vertices),\n      indexBuffer: ValueCell.create(indices),\n      normalBuffer: ValueCell.create(normals),\n      groupBuffer: ValueCell.create(groups),\n\n      get boundingSphere() {\n        var newHash = hashCode(mesh);\n\n        if (newHash !== currentHash) {\n          var b = calculateInvariantBoundingSphere(mesh.vertexBuffer.ref.value, mesh.vertexCount, 1);\n          Sphere3D.copy(boundingSphere, b);\n          currentHash = newHash;\n        }\n\n        return boundingSphere;\n      },\n\n      get groupMapping() {\n        if (mesh.groupBuffer.ref.version !== currentGroup) {\n          groupMapping = createGroupMapping(mesh.groupBuffer.ref.value, mesh.vertexCount);\n          currentGroup = mesh.groupBuffer.ref.version;\n        }\n\n        return groupMapping;\n      },\n\n      setBoundingSphere: function (sphere) {\n        Sphere3D.copy(boundingSphere, sphere);\n        currentHash = hashCode(mesh);\n      },\n      meta: {}\n    };\n    return mesh;\n  }\n\n  function update(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) {\n    mesh.vertexCount = vertexCount;\n    mesh.triangleCount = triangleCount;\n    ValueCell.update(mesh.vertexBuffer, vertices);\n    ValueCell.update(mesh.indexBuffer, indices);\n    ValueCell.update(mesh.normalBuffer, normals);\n    ValueCell.update(mesh.groupBuffer, groups);\n    return mesh;\n  }\n\n  function computeNormals(mesh) {\n    var vertexCount = mesh.vertexCount,\n        triangleCount = mesh.triangleCount;\n    var vertices = mesh.vertexBuffer.ref.value;\n    var indices = mesh.indexBuffer.ref.value;\n    var normals = mesh.normalBuffer.ref.value.length >= vertexCount * 3 ? mesh.normalBuffer.ref.value : new Float32Array(vertexCount * 3);\n\n    if (normals === mesh.normalBuffer.ref.value) {\n      normals.fill(0, 0, vertexCount * 3);\n    }\n\n    computeIndexedVertexNormals(vertices, indices, normals, vertexCount, triangleCount);\n    ValueCell.update(mesh.normalBuffer, normals);\n  }\n\n  Mesh.computeNormals = computeNormals;\n\n  function checkForDuplicateVertices(mesh, fractionDigits) {\n    if (fractionDigits === void 0) {\n      fractionDigits = 3;\n    }\n\n    var v = mesh.vertexBuffer.ref.value;\n    var map = new Map();\n\n    var hash = function (v, d) {\n      return v[0].toFixed(d) + \"|\" + v[1].toFixed(d) + \"|\" + v[2].toFixed(d);\n    };\n\n    var duplicates = 0;\n    var a = Vec3();\n\n    for (var i = 0, il = mesh.vertexCount; i < il; ++i) {\n      Vec3.fromArray(a, v, i * 3);\n      var k = hash(a, fractionDigits);\n      var count = map.get(k);\n\n      if (count !== undefined) {\n        duplicates += 1;\n        map.set(k, count + 1);\n      } else {\n        map.set(k, 1);\n      }\n    }\n\n    return duplicates;\n  }\n\n  Mesh.checkForDuplicateVertices = checkForDuplicateVertices;\n  var tmpMat3 = Mat3();\n\n  function transform(mesh, t) {\n    var v = mesh.vertexBuffer.ref.value;\n    transformPositionArray(t, v, 0, mesh.vertexCount);\n\n    if (!Mat4.isTranslationAndUniformScaling(t)) {\n      var n = Mat3.directionTransform(tmpMat3, t);\n      transformDirectionArray(n, mesh.normalBuffer.ref.value, 0, mesh.vertexCount);\n    }\n\n    ValueCell.update(mesh.vertexBuffer, v);\n  }\n\n  Mesh.transform = transform;\n  /** Meshes may contain some original data in case any processing was done. */\n\n  function getOriginalData(x) {\n    var originalData = ('kind' in x ? x.meta : x.meta.ref.value).originalData;\n    return originalData;\n  }\n\n  Mesh.getOriginalData = getOriginalData;\n  /**\r\n   * Ensure that each vertices of each triangle have the same group id.\r\n   * Note that normals are copied over and can't be re-created from the new mesh.\r\n   */\n\n  function uniformTriangleGroup(mesh, splitTriangles) {\n    if (splitTriangles === void 0) {\n      splitTriangles = true;\n    }\n\n    var indexBuffer = mesh.indexBuffer,\n        vertexBuffer = mesh.vertexBuffer,\n        groupBuffer = mesh.groupBuffer,\n        normalBuffer = mesh.normalBuffer,\n        triangleCount = mesh.triangleCount,\n        vertexCount = mesh.vertexCount;\n    var ib = indexBuffer.ref.value;\n    var vb = vertexBuffer.ref.value;\n    var gb = groupBuffer.ref.value;\n    var nb = normalBuffer.ref.value; // new\n\n    var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount); // re-use\n\n    var vertex = ChunkedArray.create(Float32Array, 3, 1024, vb);\n    vertex.currentIndex = vertexCount * 3;\n    vertex.elementCount = vertexCount;\n    var normal = ChunkedArray.create(Float32Array, 3, 1024, nb);\n    normal.currentIndex = vertexCount * 3;\n    normal.elementCount = vertexCount;\n    var group = ChunkedArray.create(Float32Array, 1, 1024, gb);\n    group.currentIndex = vertexCount;\n    group.elementCount = vertexCount;\n    var vi = Vec3();\n    var vj = Vec3();\n    var vk = Vec3();\n    var ni = Vec3();\n    var nj = Vec3();\n    var nk = Vec3();\n\n    function add(i) {\n      Vec3.fromArray(vi, vb, i * 3);\n      Vec3.fromArray(ni, nb, i * 3);\n      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\n      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\n    }\n\n    function addMid(i, j) {\n      Vec3.fromArray(vi, vb, i * 3);\n      Vec3.fromArray(vj, vb, j * 3);\n      Vec3.scale(vi, Vec3.add(vi, vi, vj), 0.5);\n      Vec3.fromArray(ni, nb, i * 3);\n      Vec3.fromArray(nj, nb, j * 3);\n      Vec3.scale(ni, Vec3.add(ni, ni, nj), 0.5);\n      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\n      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\n    }\n\n    function addCenter(i, j, k) {\n      Vec3.fromArray(vi, vb, i * 3);\n      Vec3.fromArray(vj, vb, j * 3);\n      Vec3.fromArray(vk, vb, k * 3);\n      Vec3.scale(vi, Vec3.add(vi, Vec3.add(vi, vi, vj), vk), 1 / 3);\n      Vec3.fromArray(ni, nb, i * 3);\n      Vec3.fromArray(nj, nb, j * 3);\n      Vec3.fromArray(nk, nb, k * 3);\n      Vec3.scale(ni, Vec3.add(ni, Vec3.add(ni, ni, nj), nk), 1 / 3);\n      ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\n      ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\n    }\n\n    function split2(i0, i1, i2, g0, g1) {\n      ++newTriangleCount;\n      add(i0);\n      addMid(i0, i1);\n      addMid(i0, i2);\n      ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);\n\n      for (var j = 0; j < 3; ++j) ChunkedArray.add(group, g0);\n\n      newVertexCount += 3;\n      newTriangleCount += 2;\n      add(i1);\n      add(i2);\n      addMid(i0, i1);\n      addMid(i0, i2);\n      ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\n      ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\n\n      for (var j = 0; j < 4; ++j) ChunkedArray.add(group, g1);\n\n      newVertexCount += 4;\n    }\n\n    var newVertexCount = vertexCount;\n    var newTriangleCount = 0;\n\n    if (splitTriangles) {\n      for (var i = 0, il = triangleCount; i < il; ++i) {\n        var i0 = ib[i * 3],\n            i1 = ib[i * 3 + 1],\n            i2 = ib[i * 3 + 2];\n        var g0 = gb[i0],\n            g1 = gb[i1],\n            g2 = gb[i2];\n\n        if (g0 === g1 && g0 === g2) {\n          ++newTriangleCount;\n          ChunkedArray.add3(index, i0, i1, i2);\n        } else if (g0 === g1) {\n          split2(i2, i0, i1, g2, g0);\n        } else if (g0 === g2) {\n          split2(i1, i2, i0, g1, g2);\n        } else if (g1 === g2) {\n          split2(i0, i1, i2, g0, g1);\n        } else {\n          newTriangleCount += 2;\n          add(i0);\n          addMid(i0, i1);\n          addMid(i0, i2);\n          addCenter(i0, i1, i2);\n          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\n          ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\n\n          for (var j = 0; j < 4; ++j) ChunkedArray.add(group, g0);\n\n          newVertexCount += 4;\n          newTriangleCount += 2;\n          add(i1);\n          addMid(i1, i2);\n          addMid(i1, i0);\n          addCenter(i0, i1, i2);\n          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\n          ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\n\n          for (var j = 0; j < 4; ++j) ChunkedArray.add(group, g1);\n\n          newVertexCount += 4;\n          newTriangleCount += 2;\n          add(i2);\n          addMid(i2, i1);\n          addMid(i2, i0);\n          addCenter(i0, i1, i2);\n          ChunkedArray.add3(index, newVertexCount + 3, newVertexCount + 1, newVertexCount);\n          ChunkedArray.add3(index, newVertexCount + 2, newVertexCount + 3, newVertexCount);\n\n          for (var j = 0; j < 4; ++j) ChunkedArray.add(group, g2);\n\n          newVertexCount += 4;\n        }\n      }\n    } else {\n      for (var i = 0, il = triangleCount; i < il; ++i) {\n        var i0 = ib[i * 3],\n            i1 = ib[i * 3 + 1],\n            i2 = ib[i * 3 + 2];\n        var g0 = gb[i0],\n            g1 = gb[i1],\n            g2 = gb[i2];\n\n        if (g0 !== g1 || g0 !== g2) {\n          ++newTriangleCount;\n          add(i0);\n          add(i1);\n          add(i2);\n          ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);\n          var g = g1 === g2 ? g1 : g0;\n\n          for (var j = 0; j < 3; ++j) ChunkedArray.add(group, g);\n\n          newVertexCount += 3;\n        } else {\n          ++newTriangleCount;\n          ChunkedArray.add3(index, i0, i1, i2);\n        }\n      }\n    }\n\n    var newIb = ChunkedArray.compact(index);\n    var newVb = ChunkedArray.compact(vertex);\n    var newNb = ChunkedArray.compact(normal);\n    var newGb = ChunkedArray.compact(group);\n    mesh.vertexCount = newVertexCount;\n    mesh.triangleCount = newTriangleCount;\n    ValueCell.update(vertexBuffer, newVb);\n    ValueCell.update(groupBuffer, newGb);\n    ValueCell.update(indexBuffer, newIb);\n    ValueCell.update(normalBuffer, newNb); // keep some original data, e.g., for geometry export\n\n    mesh.meta.originalData = {\n      indexBuffer: ib,\n      vertexCount: vertexCount,\n      triangleCount: triangleCount\n    };\n    return mesh;\n  }\n\n  Mesh.uniformTriangleGroup = uniformTriangleGroup; //\n\n  function getNeighboursMap(mesh) {\n    var vertexCount = mesh.vertexCount,\n        triangleCount = mesh.triangleCount;\n    var elements = mesh.indexBuffer.ref.value;\n    var neighboursMap = [];\n\n    for (var i = 0; i < vertexCount; ++i) {\n      neighboursMap[i] = [];\n    }\n\n    for (var i = 0; i < triangleCount; ++i) {\n      var v1 = elements[i * 3];\n      var v2 = elements[i * 3 + 1];\n      var v3 = elements[i * 3 + 2];\n      arraySetAdd(neighboursMap[v1], v2);\n      arraySetAdd(neighboursMap[v1], v3);\n      arraySetAdd(neighboursMap[v2], v1);\n      arraySetAdd(neighboursMap[v2], v3);\n      arraySetAdd(neighboursMap[v3], v1);\n      arraySetAdd(neighboursMap[v3], v2);\n    }\n\n    return neighboursMap;\n  }\n\n  function getEdgeCounts(mesh) {\n    var triangleCount = mesh.triangleCount;\n    var elements = mesh.indexBuffer.ref.value;\n    var edgeCounts = new Map();\n\n    var add = function (a, b) {\n      var z = sortedCantorPairing(a, b);\n      var c = edgeCounts.get(z) || 0;\n      edgeCounts.set(z, c + 1);\n    };\n\n    for (var i = 0; i < triangleCount; ++i) {\n      var a = elements[i * 3];\n      var b = elements[i * 3 + 1];\n      var c = elements[i * 3 + 2];\n      add(a, b);\n      add(a, c);\n      add(b, c);\n    }\n\n    return edgeCounts;\n  }\n\n  function getBorderVertices(edgeCounts) {\n    var borderVertices = new Set();\n    var pair = [0, 0];\n    edgeCounts.forEach(function (c, z) {\n      if (c === 1) {\n        invertCantorPairing(pair, z);\n        borderVertices.add(pair[0]);\n        borderVertices.add(pair[1]);\n      }\n    });\n    return borderVertices;\n  }\n\n  function getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts) {\n    var borderNeighboursMap = new Map();\n\n    var add = function (v, nb) {\n      if (borderNeighboursMap.has(v)) arraySetAdd(borderNeighboursMap.get(v), nb);else borderNeighboursMap.set(v, [nb]);\n    };\n\n    borderVertices.forEach(function (v) {\n      var neighbours = neighboursMap[v];\n\n      for (var _i = 0, neighbours_1 = neighbours; _i < neighbours_1.length; _i++) {\n        var nb = neighbours_1[_i];\n\n        if (borderVertices.has(nb) && edgeCounts.get(sortedCantorPairing(v, nb)) === 1) {\n          add(v, nb);\n        }\n      }\n    });\n    return borderNeighboursMap;\n  }\n\n  function trimEdges(mesh, neighboursMap) {\n    var indexBuffer = mesh.indexBuffer,\n        triangleCount = mesh.triangleCount;\n    var ib = indexBuffer.ref.value; // new\n\n    var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);\n    var newTriangleCount = 0;\n\n    for (var i = 0; i < triangleCount; ++i) {\n      var a = ib[i * 3];\n      var b = ib[i * 3 + 1];\n      var c = ib[i * 3 + 2];\n      if (neighboursMap[a].length === 2 || neighboursMap[b].length === 2 || neighboursMap[c].length === 2) continue;\n      ChunkedArray.add3(index, a, b, c);\n      newTriangleCount += 1;\n    }\n\n    var newIb = ChunkedArray.compact(index);\n    mesh.triangleCount = newTriangleCount;\n    ValueCell.update(indexBuffer, newIb);\n    return mesh;\n  }\n\n  function fillEdges(mesh, neighboursMap, borderNeighboursMap, maxLengthSquared) {\n    var _a;\n\n    var vertexBuffer = mesh.vertexBuffer,\n        indexBuffer = mesh.indexBuffer,\n        normalBuffer = mesh.normalBuffer,\n        triangleCount = mesh.triangleCount;\n    var vb = vertexBuffer.ref.value;\n    var ib = indexBuffer.ref.value;\n    var nb = normalBuffer.ref.value; // new\n\n    var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);\n    var newTriangleCount = 0;\n\n    for (var i = 0; i < triangleCount; ++i) {\n      ChunkedArray.add3(index, ib[i * 3], ib[i * 3 + 1], ib[i * 3 + 2]);\n      newTriangleCount += 1;\n    }\n\n    var vA = Vec3();\n    var vB = Vec3();\n    var vC = Vec3();\n    var vD = Vec3();\n    var vAB = Vec3();\n    var vAC = Vec3();\n    var vAD = Vec3();\n    var vABC = Vec3();\n    var vAN = Vec3();\n    var vN = Vec3();\n    var AngleThreshold = degToRad(120);\n    var added = new Set();\n    var indices = Array.from(borderNeighboursMap.keys()).filter(function (v) {\n      return borderNeighboursMap.get(v).length < 2;\n    }).map(function (v) {\n      var bnd = borderNeighboursMap.get(v);\n      Vec3.fromArray(vA, vb, v * 3);\n      Vec3.fromArray(vB, vb, bnd[0] * 3);\n      Vec3.fromArray(vC, vb, bnd[1] * 3);\n      Vec3.sub(vAB, vB, vA);\n      Vec3.sub(vAC, vC, vA);\n      return [v, Vec3.angle(vAB, vAC)];\n    }); // start with the smallest angle\n\n    indices.sort(function (_a, _b) {\n      var a = _a[1];\n      var b = _b[1];\n      return a - b;\n    });\n\n    for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {\n      var _b = indices_1[_i],\n          v = _b[0],\n          angle = _b[1];\n      if (added.has(v) || angle > AngleThreshold) continue;\n      var nbs = borderNeighboursMap.get(v);\n      if (neighboursMap[nbs[0]].includes(nbs[1]) && !((_a = borderNeighboursMap.get(nbs[0])) === null || _a === void 0 ? void 0 : _a.includes(nbs[1]))) continue;\n      Vec3.fromArray(vA, vb, v * 3);\n      Vec3.fromArray(vB, vb, nbs[0] * 3);\n      Vec3.fromArray(vC, vb, nbs[1] * 3);\n      Vec3.sub(vAB, vB, vA);\n      Vec3.sub(vAC, vC, vA);\n      Vec3.add(vABC, vAB, vAC);\n      if (Vec3.squaredDistance(vA, vB) >= maxLengthSquared) continue;\n      var add = false;\n\n      for (var _c = 0, _d = neighboursMap[v]; _c < _d.length; _c++) {\n        var nb_1 = _d[_c];\n        if (nbs.includes(nb_1)) continue;\n        Vec3.fromArray(vD, vb, nb_1 * 3);\n        Vec3.sub(vAD, vD, vA);\n\n        if (Vec3.dot(vABC, vAD) < 0) {\n          add = true;\n          break;\n        }\n      }\n\n      if (!add) continue;\n      Vec3.fromArray(vAN, nb, v * 3);\n      Vec3.triangleNormal(vN, vA, vB, vC);\n\n      if (Vec3.dot(vN, vAN) > 0) {\n        ChunkedArray.add3(index, v, nbs[0], nbs[1]);\n      } else {\n        ChunkedArray.add3(index, nbs[1], nbs[0], v);\n      }\n\n      added.add(v);\n      added.add(nbs[0]);\n      added.add(nbs[1]);\n      newTriangleCount += 1;\n    }\n\n    var newIb = ChunkedArray.compact(index);\n    mesh.triangleCount = newTriangleCount;\n    ValueCell.update(indexBuffer, newIb);\n    return mesh;\n  }\n\n  function laplacianEdgeSmoothing(mesh, borderNeighboursMap, options) {\n    var iterations = options.iterations,\n        lambda = options.lambda;\n    var a = Vec3();\n    var b = Vec3();\n    var c = Vec3();\n    var t = Vec3();\n    var mu = -lambda;\n    var dst = new Float32Array(mesh.vertexBuffer.ref.value.length);\n\n    var step = function (f) {\n      var pos = mesh.vertexBuffer.ref.value;\n      dst.set(pos);\n      borderNeighboursMap.forEach(function (nbs, v) {\n        if (nbs.length !== 2) return;\n        Vec3.fromArray(a, pos, v * 3);\n        Vec3.fromArray(b, pos, nbs[0] * 3);\n        Vec3.fromArray(c, pos, nbs[1] * 3);\n        var wab = 1 / Vec3.distance(a, b);\n        var wac = 1 / Vec3.distance(a, c);\n        Vec3.scale(b, b, wab);\n        Vec3.scale(c, c, wac);\n        Vec3.add(t, b, c);\n        Vec3.scale(t, t, 1 / (wab + wac));\n        Vec3.sub(t, t, a);\n        Vec3.scale(t, t, f);\n        Vec3.add(t, a, t);\n        Vec3.toArray(t, dst, v * 3);\n      });\n      var tmp = mesh.vertexBuffer.ref.value;\n      ValueCell.update(mesh.vertexBuffer, dst);\n      dst = tmp;\n    };\n\n    for (var k = 0; k < iterations; ++k) {\n      step(lambda);\n      step(mu);\n    }\n  }\n\n  function smoothEdges(mesh, options) {\n    trimEdges(mesh, getNeighboursMap(mesh));\n\n    for (var k = 0; k < 10; ++k) {\n      var oldTriangleCount = mesh.triangleCount;\n      var edgeCounts_1 = getEdgeCounts(mesh);\n      var neighboursMap_1 = getNeighboursMap(mesh);\n      var borderVertices_1 = getBorderVertices(edgeCounts_1);\n      var borderNeighboursMap_1 = getBorderNeighboursMap(neighboursMap_1, borderVertices_1, edgeCounts_1);\n      fillEdges(mesh, neighboursMap_1, borderNeighboursMap_1, options.maxNewEdgeLength * options.maxNewEdgeLength);\n      if (mesh.triangleCount === oldTriangleCount) break;\n    }\n\n    var edgeCounts = getEdgeCounts(mesh);\n    var neighboursMap = getNeighboursMap(mesh);\n    var borderVertices = getBorderVertices(edgeCounts);\n    var borderNeighboursMap = getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts);\n    laplacianEdgeSmoothing(mesh, borderNeighboursMap, {\n      iterations: options.iterations,\n      lambda: 0.5\n    });\n    return mesh;\n  }\n\n  Mesh.smoothEdges = smoothEdges; //\n\n  Mesh.Params = __assign(__assign({}, BaseGeometry.Params), {\n    doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo),\n    flipSided: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    flatShaded: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory)\n  });\n  Mesh.Utils = {\n    Params: Mesh.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: createRenderableState,\n    updateRenderableState: updateRenderableState,\n    createPositionIterator: createPositionIterator\n  };\n\n  function createPositionIterator(mesh, transform) {\n    var groupCount = mesh.vertexCount;\n    var instanceCount = transform.instanceCount.ref.value;\n    var location = PositionLocation();\n    var p = location.position;\n    var v = mesh.vertexBuffer.ref.value;\n    var m = transform.aTransform.ref.value;\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      if (instanceIndex < 0) {\n        Vec3.fromArray(p, v, groupIndex * 3);\n      } else {\n        Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\n      }\n\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  function createValues(mesh, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = createPositionIterator(mesh, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: mesh.triangleCount * 3,\n      vertexCount: mesh.vertexCount,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      aPosition: mesh.vertexBuffer,\n      aNormal: mesh.normalBuffer,\n      aGroup: mesh.groupBuffer,\n      elements: mesh.indexBuffer,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), {\n      dDoubleSided: ValueCell.create(props.doubleSided),\n      dFlatShaded: ValueCell.create(props.flatShaded),\n      dFlipSided: ValueCell.create(props.flipSided),\n      dIgnoreLight: ValueCell.create(props.ignoreLight),\n      dXrayShaded: ValueCell.create(props.xrayShaded),\n      meta: ValueCell.create(mesh.meta)\n    });\n  }\n\n  function createValuesSimple(mesh, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(Mesh.Params)), props);\n\n    return createValues(mesh, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\n    ValueCell.updateIfChanged(values.dFlatShaded, props.flatShaded);\n    ValueCell.updateIfChanged(values.dFlipSided, props.flipSided);\n    ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\n    ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\n  }\n\n  function updateBoundingSphere(values, mesh) {\n    var invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n\n  function createRenderableState(props) {\n    var state = BaseGeometry.createRenderableState(props);\n    updateRenderableState(state, props);\n    return state;\n  }\n\n  function updateRenderableState(state, props) {\n    BaseGeometry.updateRenderableState(state, props);\n    state.opaque = state.opaque && !props.xrayShaded;\n    state.writeDepth = state.opaque;\n  }\n})(Mesh || (Mesh = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/mesh/mesh.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { Vec3, Mat4, Mat3, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { transformPositionArray, transformDirectionArray, computeIndexedVertexNormals, createGroupMapping } from '../../util';\r\nimport { createMarkers } from '../marker-data';\r\nimport { LocationIterator, PositionLocation } from '../../util/location-iterator';\r\nimport { createColors } from '../color-data';\r\nimport { ChunkedArray, hashFnv32a, invertCantorPairing, sortedCantorPairing } from '../../../mol-data/util';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { calculateInvariantBoundingSphere, calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nimport { arraySetAdd } from '../../../mol-util/array';\r\nimport { degToRad } from '../../../mol-math/misc';\r\nexport var Mesh;\r\n(function (Mesh) {\r\n    function create(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) {\r\n        return mesh ?\r\n            update(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) :\r\n            fromArrays(vertices, indices, normals, groups, vertexCount, triangleCount);\r\n    }\r\n    Mesh.create = create;\r\n    function createEmpty(mesh) {\r\n        var vb = mesh ? mesh.vertexBuffer.ref.value : new Float32Array(0);\r\n        var ib = mesh ? mesh.indexBuffer.ref.value : new Uint32Array(0);\r\n        var nb = mesh ? mesh.normalBuffer.ref.value : new Float32Array(0);\r\n        var gb = mesh ? mesh.groupBuffer.ref.value : new Float32Array(0);\r\n        return create(vb, ib, nb, gb, 0, 0, mesh);\r\n    }\r\n    Mesh.createEmpty = createEmpty;\r\n    function hashCode(mesh) {\r\n        return hashFnv32a([\r\n            mesh.vertexCount, mesh.triangleCount,\r\n            mesh.vertexBuffer.ref.version, mesh.indexBuffer.ref.version,\r\n            mesh.normalBuffer.ref.version, mesh.groupBuffer.ref.version\r\n        ]);\r\n    }\r\n    function fromArrays(vertices, indices, normals, groups, vertexCount, triangleCount) {\r\n        var boundingSphere = Sphere3D();\r\n        var groupMapping;\r\n        var currentHash = -1;\r\n        var currentGroup = -1;\r\n        var mesh = {\r\n            kind: 'mesh',\r\n            vertexCount: vertexCount,\r\n            triangleCount: triangleCount,\r\n            vertexBuffer: ValueCell.create(vertices),\r\n            indexBuffer: ValueCell.create(indices),\r\n            normalBuffer: ValueCell.create(normals),\r\n            groupBuffer: ValueCell.create(groups),\r\n            get boundingSphere() {\r\n                var newHash = hashCode(mesh);\r\n                if (newHash !== currentHash) {\r\n                    var b = calculateInvariantBoundingSphere(mesh.vertexBuffer.ref.value, mesh.vertexCount, 1);\r\n                    Sphere3D.copy(boundingSphere, b);\r\n                    currentHash = newHash;\r\n                }\r\n                return boundingSphere;\r\n            },\r\n            get groupMapping() {\r\n                if (mesh.groupBuffer.ref.version !== currentGroup) {\r\n                    groupMapping = createGroupMapping(mesh.groupBuffer.ref.value, mesh.vertexCount);\r\n                    currentGroup = mesh.groupBuffer.ref.version;\r\n                }\r\n                return groupMapping;\r\n            },\r\n            setBoundingSphere: function (sphere) {\r\n                Sphere3D.copy(boundingSphere, sphere);\r\n                currentHash = hashCode(mesh);\r\n            },\r\n            meta: {}\r\n        };\r\n        return mesh;\r\n    }\r\n    function update(vertices, indices, normals, groups, vertexCount, triangleCount, mesh) {\r\n        mesh.vertexCount = vertexCount;\r\n        mesh.triangleCount = triangleCount;\r\n        ValueCell.update(mesh.vertexBuffer, vertices);\r\n        ValueCell.update(mesh.indexBuffer, indices);\r\n        ValueCell.update(mesh.normalBuffer, normals);\r\n        ValueCell.update(mesh.groupBuffer, groups);\r\n        return mesh;\r\n    }\r\n    function computeNormals(mesh) {\r\n        var vertexCount = mesh.vertexCount, triangleCount = mesh.triangleCount;\r\n        var vertices = mesh.vertexBuffer.ref.value;\r\n        var indices = mesh.indexBuffer.ref.value;\r\n        var normals = mesh.normalBuffer.ref.value.length >= vertexCount * 3\r\n            ? mesh.normalBuffer.ref.value\r\n            : new Float32Array(vertexCount * 3);\r\n        if (normals === mesh.normalBuffer.ref.value) {\r\n            normals.fill(0, 0, vertexCount * 3);\r\n        }\r\n        computeIndexedVertexNormals(vertices, indices, normals, vertexCount, triangleCount);\r\n        ValueCell.update(mesh.normalBuffer, normals);\r\n    }\r\n    Mesh.computeNormals = computeNormals;\r\n    function checkForDuplicateVertices(mesh, fractionDigits) {\r\n        if (fractionDigits === void 0) { fractionDigits = 3; }\r\n        var v = mesh.vertexBuffer.ref.value;\r\n        var map = new Map();\r\n        var hash = function (v, d) { return v[0].toFixed(d) + \"|\" + v[1].toFixed(d) + \"|\" + v[2].toFixed(d); };\r\n        var duplicates = 0;\r\n        var a = Vec3();\r\n        for (var i = 0, il = mesh.vertexCount; i < il; ++i) {\r\n            Vec3.fromArray(a, v, i * 3);\r\n            var k = hash(a, fractionDigits);\r\n            var count = map.get(k);\r\n            if (count !== undefined) {\r\n                duplicates += 1;\r\n                map.set(k, count + 1);\r\n            }\r\n            else {\r\n                map.set(k, 1);\r\n            }\r\n        }\r\n        return duplicates;\r\n    }\r\n    Mesh.checkForDuplicateVertices = checkForDuplicateVertices;\r\n    var tmpMat3 = Mat3();\r\n    function transform(mesh, t) {\r\n        var v = mesh.vertexBuffer.ref.value;\r\n        transformPositionArray(t, v, 0, mesh.vertexCount);\r\n        if (!Mat4.isTranslationAndUniformScaling(t)) {\r\n            var n = Mat3.directionTransform(tmpMat3, t);\r\n            transformDirectionArray(n, mesh.normalBuffer.ref.value, 0, mesh.vertexCount);\r\n        }\r\n        ValueCell.update(mesh.vertexBuffer, v);\r\n    }\r\n    Mesh.transform = transform;\r\n    /** Meshes may contain some original data in case any processing was done. */\r\n    function getOriginalData(x) {\r\n        var originalData = ('kind' in x ? x.meta : x.meta.ref.value).originalData;\r\n        return originalData;\r\n    }\r\n    Mesh.getOriginalData = getOriginalData;\r\n    /**\r\n     * Ensure that each vertices of each triangle have the same group id.\r\n     * Note that normals are copied over and can't be re-created from the new mesh.\r\n     */\r\n    function uniformTriangleGroup(mesh, splitTriangles) {\r\n        if (splitTriangles === void 0) { splitTriangles = true; }\r\n        var indexBuffer = mesh.indexBuffer, vertexBuffer = mesh.vertexBuffer, groupBuffer = mesh.groupBuffer, normalBuffer = mesh.normalBuffer, triangleCount = mesh.triangleCount, vertexCount = mesh.vertexCount;\r\n        var ib = indexBuffer.ref.value;\r\n        var vb = vertexBuffer.ref.value;\r\n        var gb = groupBuffer.ref.value;\r\n        var nb = normalBuffer.ref.value;\r\n        // new\r\n        var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);\r\n        // re-use\r\n        var vertex = ChunkedArray.create(Float32Array, 3, 1024, vb);\r\n        vertex.currentIndex = vertexCount * 3;\r\n        vertex.elementCount = vertexCount;\r\n        var normal = ChunkedArray.create(Float32Array, 3, 1024, nb);\r\n        normal.currentIndex = vertexCount * 3;\r\n        normal.elementCount = vertexCount;\r\n        var group = ChunkedArray.create(Float32Array, 1, 1024, gb);\r\n        group.currentIndex = vertexCount;\r\n        group.elementCount = vertexCount;\r\n        var vi = Vec3();\r\n        var vj = Vec3();\r\n        var vk = Vec3();\r\n        var ni = Vec3();\r\n        var nj = Vec3();\r\n        var nk = Vec3();\r\n        function add(i) {\r\n            Vec3.fromArray(vi, vb, i * 3);\r\n            Vec3.fromArray(ni, nb, i * 3);\r\n            ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\r\n            ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\r\n        }\r\n        function addMid(i, j) {\r\n            Vec3.fromArray(vi, vb, i * 3);\r\n            Vec3.fromArray(vj, vb, j * 3);\r\n            Vec3.scale(vi, Vec3.add(vi, vi, vj), 0.5);\r\n            Vec3.fromArray(ni, nb, i * 3);\r\n            Vec3.fromArray(nj, nb, j * 3);\r\n            Vec3.scale(ni, Vec3.add(ni, ni, nj), 0.5);\r\n            ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\r\n            ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\r\n        }\r\n        function addCenter(i, j, k) {\r\n            Vec3.fromArray(vi, vb, i * 3);\r\n            Vec3.fromArray(vj, vb, j * 3);\r\n            Vec3.fromArray(vk, vb, k * 3);\r\n            Vec3.scale(vi, Vec3.add(vi, Vec3.add(vi, vi, vj), vk), 1 / 3);\r\n            Vec3.fromArray(ni, nb, i * 3);\r\n            Vec3.fromArray(nj, nb, j * 3);\r\n            Vec3.fromArray(nk, nb, k * 3);\r\n            Vec3.scale(ni, Vec3.add(ni, Vec3.add(ni, ni, nj), nk), 1 / 3);\r\n            ChunkedArray.add3(vertex, vi[0], vi[1], vi[2]);\r\n            ChunkedArray.add3(normal, ni[0], ni[1], ni[2]);\r\n        }\r\n        function split2(i0, i1, i2, g0, g1) {\r\n            ++newTriangleCount;\r\n            add(i0);\r\n            addMid(i0, i1);\r\n            addMid(i0, i2);\r\n            ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);\r\n            for (var j = 0; j < 3; ++j)\r\n                ChunkedArray.add(group, g0);\r\n            newVertexCount += 3;\r\n            newTriangleCount += 2;\r\n            add(i1);\r\n            add(i2);\r\n            addMid(i0, i1);\r\n            addMid(i0, i2);\r\n            ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\r\n            ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\r\n            for (var j = 0; j < 4; ++j)\r\n                ChunkedArray.add(group, g1);\r\n            newVertexCount += 4;\r\n        }\r\n        var newVertexCount = vertexCount;\r\n        var newTriangleCount = 0;\r\n        if (splitTriangles) {\r\n            for (var i = 0, il = triangleCount; i < il; ++i) {\r\n                var i0 = ib[i * 3], i1 = ib[i * 3 + 1], i2 = ib[i * 3 + 2];\r\n                var g0 = gb[i0], g1 = gb[i1], g2 = gb[i2];\r\n                if (g0 === g1 && g0 === g2) {\r\n                    ++newTriangleCount;\r\n                    ChunkedArray.add3(index, i0, i1, i2);\r\n                }\r\n                else if (g0 === g1) {\r\n                    split2(i2, i0, i1, g2, g0);\r\n                }\r\n                else if (g0 === g2) {\r\n                    split2(i1, i2, i0, g1, g2);\r\n                }\r\n                else if (g1 === g2) {\r\n                    split2(i0, i1, i2, g0, g1);\r\n                }\r\n                else {\r\n                    newTriangleCount += 2;\r\n                    add(i0);\r\n                    addMid(i0, i1);\r\n                    addMid(i0, i2);\r\n                    addCenter(i0, i1, i2);\r\n                    ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\r\n                    ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\r\n                    for (var j = 0; j < 4; ++j)\r\n                        ChunkedArray.add(group, g0);\r\n                    newVertexCount += 4;\r\n                    newTriangleCount += 2;\r\n                    add(i1);\r\n                    addMid(i1, i2);\r\n                    addMid(i1, i0);\r\n                    addCenter(i0, i1, i2);\r\n                    ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 3);\r\n                    ChunkedArray.add3(index, newVertexCount, newVertexCount + 3, newVertexCount + 2);\r\n                    for (var j = 0; j < 4; ++j)\r\n                        ChunkedArray.add(group, g1);\r\n                    newVertexCount += 4;\r\n                    newTriangleCount += 2;\r\n                    add(i2);\r\n                    addMid(i2, i1);\r\n                    addMid(i2, i0);\r\n                    addCenter(i0, i1, i2);\r\n                    ChunkedArray.add3(index, newVertexCount + 3, newVertexCount + 1, newVertexCount);\r\n                    ChunkedArray.add3(index, newVertexCount + 2, newVertexCount + 3, newVertexCount);\r\n                    for (var j = 0; j < 4; ++j)\r\n                        ChunkedArray.add(group, g2);\r\n                    newVertexCount += 4;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0, il = triangleCount; i < il; ++i) {\r\n                var i0 = ib[i * 3], i1 = ib[i * 3 + 1], i2 = ib[i * 3 + 2];\r\n                var g0 = gb[i0], g1 = gb[i1], g2 = gb[i2];\r\n                if (g0 !== g1 || g0 !== g2) {\r\n                    ++newTriangleCount;\r\n                    add(i0);\r\n                    add(i1);\r\n                    add(i2);\r\n                    ChunkedArray.add3(index, newVertexCount, newVertexCount + 1, newVertexCount + 2);\r\n                    var g = g1 === g2 ? g1 : g0;\r\n                    for (var j = 0; j < 3; ++j)\r\n                        ChunkedArray.add(group, g);\r\n                    newVertexCount += 3;\r\n                }\r\n                else {\r\n                    ++newTriangleCount;\r\n                    ChunkedArray.add3(index, i0, i1, i2);\r\n                }\r\n            }\r\n        }\r\n        var newIb = ChunkedArray.compact(index);\r\n        var newVb = ChunkedArray.compact(vertex);\r\n        var newNb = ChunkedArray.compact(normal);\r\n        var newGb = ChunkedArray.compact(group);\r\n        mesh.vertexCount = newVertexCount;\r\n        mesh.triangleCount = newTriangleCount;\r\n        ValueCell.update(vertexBuffer, newVb);\r\n        ValueCell.update(groupBuffer, newGb);\r\n        ValueCell.update(indexBuffer, newIb);\r\n        ValueCell.update(normalBuffer, newNb);\r\n        // keep some original data, e.g., for geometry export\r\n        mesh.meta.originalData = { indexBuffer: ib, vertexCount: vertexCount, triangleCount: triangleCount };\r\n        return mesh;\r\n    }\r\n    Mesh.uniformTriangleGroup = uniformTriangleGroup;\r\n    //\r\n    function getNeighboursMap(mesh) {\r\n        var vertexCount = mesh.vertexCount, triangleCount = mesh.triangleCount;\r\n        var elements = mesh.indexBuffer.ref.value;\r\n        var neighboursMap = [];\r\n        for (var i = 0; i < vertexCount; ++i) {\r\n            neighboursMap[i] = [];\r\n        }\r\n        for (var i = 0; i < triangleCount; ++i) {\r\n            var v1 = elements[i * 3];\r\n            var v2 = elements[i * 3 + 1];\r\n            var v3 = elements[i * 3 + 2];\r\n            arraySetAdd(neighboursMap[v1], v2);\r\n            arraySetAdd(neighboursMap[v1], v3);\r\n            arraySetAdd(neighboursMap[v2], v1);\r\n            arraySetAdd(neighboursMap[v2], v3);\r\n            arraySetAdd(neighboursMap[v3], v1);\r\n            arraySetAdd(neighboursMap[v3], v2);\r\n        }\r\n        return neighboursMap;\r\n    }\r\n    function getEdgeCounts(mesh) {\r\n        var triangleCount = mesh.triangleCount;\r\n        var elements = mesh.indexBuffer.ref.value;\r\n        var edgeCounts = new Map();\r\n        var add = function (a, b) {\r\n            var z = sortedCantorPairing(a, b);\r\n            var c = edgeCounts.get(z) || 0;\r\n            edgeCounts.set(z, c + 1);\r\n        };\r\n        for (var i = 0; i < triangleCount; ++i) {\r\n            var a = elements[i * 3];\r\n            var b = elements[i * 3 + 1];\r\n            var c = elements[i * 3 + 2];\r\n            add(a, b);\r\n            add(a, c);\r\n            add(b, c);\r\n        }\r\n        return edgeCounts;\r\n    }\r\n    function getBorderVertices(edgeCounts) {\r\n        var borderVertices = new Set();\r\n        var pair = [0, 0];\r\n        edgeCounts.forEach(function (c, z) {\r\n            if (c === 1) {\r\n                invertCantorPairing(pair, z);\r\n                borderVertices.add(pair[0]);\r\n                borderVertices.add(pair[1]);\r\n            }\r\n        });\r\n        return borderVertices;\r\n    }\r\n    function getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts) {\r\n        var borderNeighboursMap = new Map();\r\n        var add = function (v, nb) {\r\n            if (borderNeighboursMap.has(v))\r\n                arraySetAdd(borderNeighboursMap.get(v), nb);\r\n            else\r\n                borderNeighboursMap.set(v, [nb]);\r\n        };\r\n        borderVertices.forEach(function (v) {\r\n            var neighbours = neighboursMap[v];\r\n            for (var _i = 0, neighbours_1 = neighbours; _i < neighbours_1.length; _i++) {\r\n                var nb = neighbours_1[_i];\r\n                if (borderVertices.has(nb) && edgeCounts.get(sortedCantorPairing(v, nb)) === 1) {\r\n                    add(v, nb);\r\n                }\r\n            }\r\n        });\r\n        return borderNeighboursMap;\r\n    }\r\n    function trimEdges(mesh, neighboursMap) {\r\n        var indexBuffer = mesh.indexBuffer, triangleCount = mesh.triangleCount;\r\n        var ib = indexBuffer.ref.value;\r\n        // new\r\n        var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);\r\n        var newTriangleCount = 0;\r\n        for (var i = 0; i < triangleCount; ++i) {\r\n            var a = ib[i * 3];\r\n            var b = ib[i * 3 + 1];\r\n            var c = ib[i * 3 + 2];\r\n            if (neighboursMap[a].length === 2 ||\r\n                neighboursMap[b].length === 2 ||\r\n                neighboursMap[c].length === 2)\r\n                continue;\r\n            ChunkedArray.add3(index, a, b, c);\r\n            newTriangleCount += 1;\r\n        }\r\n        var newIb = ChunkedArray.compact(index);\r\n        mesh.triangleCount = newTriangleCount;\r\n        ValueCell.update(indexBuffer, newIb);\r\n        return mesh;\r\n    }\r\n    function fillEdges(mesh, neighboursMap, borderNeighboursMap, maxLengthSquared) {\r\n        var _a;\r\n        var vertexBuffer = mesh.vertexBuffer, indexBuffer = mesh.indexBuffer, normalBuffer = mesh.normalBuffer, triangleCount = mesh.triangleCount;\r\n        var vb = vertexBuffer.ref.value;\r\n        var ib = indexBuffer.ref.value;\r\n        var nb = normalBuffer.ref.value;\r\n        // new\r\n        var index = ChunkedArray.create(Uint32Array, 3, 1024, triangleCount);\r\n        var newTriangleCount = 0;\r\n        for (var i = 0; i < triangleCount; ++i) {\r\n            ChunkedArray.add3(index, ib[i * 3], ib[i * 3 + 1], ib[i * 3 + 2]);\r\n            newTriangleCount += 1;\r\n        }\r\n        var vA = Vec3();\r\n        var vB = Vec3();\r\n        var vC = Vec3();\r\n        var vD = Vec3();\r\n        var vAB = Vec3();\r\n        var vAC = Vec3();\r\n        var vAD = Vec3();\r\n        var vABC = Vec3();\r\n        var vAN = Vec3();\r\n        var vN = Vec3();\r\n        var AngleThreshold = degToRad(120);\r\n        var added = new Set();\r\n        var indices = Array.from(borderNeighboursMap.keys())\r\n            .filter(function (v) { return borderNeighboursMap.get(v).length < 2; })\r\n            .map(function (v) {\r\n            var bnd = borderNeighboursMap.get(v);\r\n            Vec3.fromArray(vA, vb, v * 3);\r\n            Vec3.fromArray(vB, vb, bnd[0] * 3);\r\n            Vec3.fromArray(vC, vb, bnd[1] * 3);\r\n            Vec3.sub(vAB, vB, vA);\r\n            Vec3.sub(vAC, vC, vA);\r\n            return [v, Vec3.angle(vAB, vAC)];\r\n        });\r\n        // start with the smallest angle\r\n        indices.sort(function (_a, _b) {\r\n            var a = _a[1];\r\n            var b = _b[1];\r\n            return a - b;\r\n        });\r\n        for (var _i = 0, indices_1 = indices; _i < indices_1.length; _i++) {\r\n            var _b = indices_1[_i], v = _b[0], angle = _b[1];\r\n            if (added.has(v) || angle > AngleThreshold)\r\n                continue;\r\n            var nbs = borderNeighboursMap.get(v);\r\n            if (neighboursMap[nbs[0]].includes(nbs[1]) &&\r\n                !((_a = borderNeighboursMap.get(nbs[0])) === null || _a === void 0 ? void 0 : _a.includes(nbs[1])))\r\n                continue;\r\n            Vec3.fromArray(vA, vb, v * 3);\r\n            Vec3.fromArray(vB, vb, nbs[0] * 3);\r\n            Vec3.fromArray(vC, vb, nbs[1] * 3);\r\n            Vec3.sub(vAB, vB, vA);\r\n            Vec3.sub(vAC, vC, vA);\r\n            Vec3.add(vABC, vAB, vAC);\r\n            if (Vec3.squaredDistance(vA, vB) >= maxLengthSquared)\r\n                continue;\r\n            var add = false;\r\n            for (var _c = 0, _d = neighboursMap[v]; _c < _d.length; _c++) {\r\n                var nb_1 = _d[_c];\r\n                if (nbs.includes(nb_1))\r\n                    continue;\r\n                Vec3.fromArray(vD, vb, nb_1 * 3);\r\n                Vec3.sub(vAD, vD, vA);\r\n                if (Vec3.dot(vABC, vAD) < 0) {\r\n                    add = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!add)\r\n                continue;\r\n            Vec3.fromArray(vAN, nb, v * 3);\r\n            Vec3.triangleNormal(vN, vA, vB, vC);\r\n            if (Vec3.dot(vN, vAN) > 0) {\r\n                ChunkedArray.add3(index, v, nbs[0], nbs[1]);\r\n            }\r\n            else {\r\n                ChunkedArray.add3(index, nbs[1], nbs[0], v);\r\n            }\r\n            added.add(v);\r\n            added.add(nbs[0]);\r\n            added.add(nbs[1]);\r\n            newTriangleCount += 1;\r\n        }\r\n        var newIb = ChunkedArray.compact(index);\r\n        mesh.triangleCount = newTriangleCount;\r\n        ValueCell.update(indexBuffer, newIb);\r\n        return mesh;\r\n    }\r\n    function laplacianEdgeSmoothing(mesh, borderNeighboursMap, options) {\r\n        var iterations = options.iterations, lambda = options.lambda;\r\n        var a = Vec3();\r\n        var b = Vec3();\r\n        var c = Vec3();\r\n        var t = Vec3();\r\n        var mu = -lambda;\r\n        var dst = new Float32Array(mesh.vertexBuffer.ref.value.length);\r\n        var step = function (f) {\r\n            var pos = mesh.vertexBuffer.ref.value;\r\n            dst.set(pos);\r\n            borderNeighboursMap.forEach(function (nbs, v) {\r\n                if (nbs.length !== 2)\r\n                    return;\r\n                Vec3.fromArray(a, pos, v * 3);\r\n                Vec3.fromArray(b, pos, nbs[0] * 3);\r\n                Vec3.fromArray(c, pos, nbs[1] * 3);\r\n                var wab = 1 / Vec3.distance(a, b);\r\n                var wac = 1 / Vec3.distance(a, c);\r\n                Vec3.scale(b, b, wab);\r\n                Vec3.scale(c, c, wac);\r\n                Vec3.add(t, b, c);\r\n                Vec3.scale(t, t, 1 / (wab + wac));\r\n                Vec3.sub(t, t, a);\r\n                Vec3.scale(t, t, f);\r\n                Vec3.add(t, a, t);\r\n                Vec3.toArray(t, dst, v * 3);\r\n            });\r\n            var tmp = mesh.vertexBuffer.ref.value;\r\n            ValueCell.update(mesh.vertexBuffer, dst);\r\n            dst = tmp;\r\n        };\r\n        for (var k = 0; k < iterations; ++k) {\r\n            step(lambda);\r\n            step(mu);\r\n        }\r\n    }\r\n    function smoothEdges(mesh, options) {\r\n        trimEdges(mesh, getNeighboursMap(mesh));\r\n        for (var k = 0; k < 10; ++k) {\r\n            var oldTriangleCount = mesh.triangleCount;\r\n            var edgeCounts_1 = getEdgeCounts(mesh);\r\n            var neighboursMap_1 = getNeighboursMap(mesh);\r\n            var borderVertices_1 = getBorderVertices(edgeCounts_1);\r\n            var borderNeighboursMap_1 = getBorderNeighboursMap(neighboursMap_1, borderVertices_1, edgeCounts_1);\r\n            fillEdges(mesh, neighboursMap_1, borderNeighboursMap_1, options.maxNewEdgeLength * options.maxNewEdgeLength);\r\n            if (mesh.triangleCount === oldTriangleCount)\r\n                break;\r\n        }\r\n        var edgeCounts = getEdgeCounts(mesh);\r\n        var neighboursMap = getNeighboursMap(mesh);\r\n        var borderVertices = getBorderVertices(edgeCounts);\r\n        var borderNeighboursMap = getBorderNeighboursMap(neighboursMap, borderVertices, edgeCounts);\r\n        laplacianEdgeSmoothing(mesh, borderNeighboursMap, { iterations: options.iterations, lambda: 0.5 });\r\n        return mesh;\r\n    }\r\n    Mesh.smoothEdges = smoothEdges;\r\n    //\r\n    Mesh.Params = __assign(__assign({}, BaseGeometry.Params), { doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo), flipSided: PD.Boolean(false, BaseGeometry.ShadingCategory), flatShaded: PD.Boolean(false, BaseGeometry.ShadingCategory), ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory), xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory) });\r\n    Mesh.Utils = {\r\n        Params: Mesh.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: createRenderableState,\r\n        updateRenderableState: updateRenderableState,\r\n        createPositionIterator: createPositionIterator\r\n    };\r\n    function createPositionIterator(mesh, transform) {\r\n        var groupCount = mesh.vertexCount;\r\n        var instanceCount = transform.instanceCount.ref.value;\r\n        var location = PositionLocation();\r\n        var p = location.position;\r\n        var v = mesh.vertexBuffer.ref.value;\r\n        var m = transform.aTransform.ref.value;\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            if (instanceIndex < 0) {\r\n                Vec3.fromArray(p, v, groupIndex * 3);\r\n            }\r\n            else {\r\n                Vec3.transformMat4Offset(p, v, m, 0, groupIndex * 3, instanceIndex * 16);\r\n            }\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    function createValues(mesh, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = createPositionIterator(mesh, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: mesh.triangleCount * 3, vertexCount: mesh.vertexCount, groupCount: groupCount, instanceCount: instanceCount };\r\n        var invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ aPosition: mesh.vertexBuffer, aNormal: mesh.normalBuffer, aGroup: mesh.groupBuffer, elements: mesh.indexBuffer, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), { dDoubleSided: ValueCell.create(props.doubleSided), dFlatShaded: ValueCell.create(props.flatShaded), dFlipSided: ValueCell.create(props.flipSided), dIgnoreLight: ValueCell.create(props.ignoreLight), dXrayShaded: ValueCell.create(props.xrayShaded), meta: ValueCell.create(mesh.meta) });\r\n    }\r\n    function createValuesSimple(mesh, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(Mesh.Params)), props);\r\n        return createValues(mesh, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\r\n        ValueCell.updateIfChanged(values.dFlatShaded, props.flatShaded);\r\n        ValueCell.updateIfChanged(values.dFlipSided, props.flipSided);\r\n        ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\r\n        ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\r\n    }\r\n    function updateBoundingSphere(values, mesh) {\r\n        var invariantBoundingSphere = Sphere3D.clone(mesh.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n    function createRenderableState(props) {\r\n        var state = BaseGeometry.createRenderableState(props);\r\n        updateRenderableState(state, props);\r\n        return state;\r\n    }\r\n    function updateRenderableState(state, props) {\r\n        BaseGeometry.updateRenderableState(state, props);\r\n        state.opaque = state.opaque && !props.xrayShaded;\r\n        state.writeDepth = state.opaque;\r\n    }\r\n})(Mesh || (Mesh = {}));\r\n//# sourceMappingURL=mesh.js.map"]},"metadata":{},"sourceType":"module"}