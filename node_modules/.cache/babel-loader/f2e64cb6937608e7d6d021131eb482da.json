{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Camera } from '../camera';\nimport { Quat, Vec3 } from '../../mol-math/linear-algebra';\nimport { lerp } from '../../mol-math/interpolate';\nexport { CameraTransitionManager };\n\nvar CameraTransitionManager =\n/** @class */\nfunction () {\n  function CameraTransitionManager(camera) {\n    this.camera = camera;\n    this.t = 0;\n    this.func = CameraTransitionManager.defaultTransition;\n    this.start = 0;\n    this.inTransition = false;\n    this.durationMs = 0;\n    this._source = Camera.createDefaultSnapshot();\n    this._target = Camera.createDefaultSnapshot();\n    this._current = Camera.createDefaultSnapshot();\n  }\n\n  Object.defineProperty(CameraTransitionManager.prototype, \"source\", {\n    get: function () {\n      return this._source;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CameraTransitionManager.prototype, \"target\", {\n    get: function () {\n      return this._target;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  CameraTransitionManager.prototype.apply = function (to, durationMs, transition) {\n    if (durationMs === void 0) {\n      durationMs = 0;\n    }\n\n    if (!this.inTransition || durationMs > 0) {\n      Camera.copySnapshot(this._source, this.camera.state);\n    }\n\n    if (!this.inTransition) {\n      Camera.copySnapshot(this._target, this.camera.state);\n    }\n\n    Camera.copySnapshot(this._target, to);\n\n    if (this._target.radius > this._target.radiusMax) {\n      this._target.radius = this._target.radiusMax;\n    }\n\n    if (this._target.radius < 0.01) this._target.radius = 0.01;\n    if (this._target.radiusMax < 0.01) this._target.radiusMax = 0.01;\n\n    if (!this.inTransition && durationMs <= 0 || typeof to.mode !== 'undefined' && to.mode !== this.camera.state.mode) {\n      this.finish(this._target);\n      return;\n    }\n\n    this.inTransition = true;\n    this.func = transition || CameraTransitionManager.defaultTransition;\n\n    if (!this.inTransition || durationMs > 0) {\n      this.start = this.t;\n      this.durationMs = durationMs;\n    }\n  };\n\n  CameraTransitionManager.prototype.tick = function (t) {\n    this.t = t;\n    this.update();\n  };\n\n  CameraTransitionManager.prototype.finish = function (to) {\n    Camera.copySnapshot(this.camera.state, to);\n    this.inTransition = false;\n  };\n\n  CameraTransitionManager.prototype.update = function () {\n    if (!this.inTransition) return;\n    var normalized = Math.min((this.t - this.start) / this.durationMs, 1);\n\n    if (normalized === 1) {\n      this.finish(this._target);\n      return;\n    }\n\n    this.func(this._current, normalized, this._source, this._target);\n    Camera.copySnapshot(this.camera.state, this._current);\n  };\n\n  return CameraTransitionManager;\n}();\n\n(function (CameraTransitionManager) {\n  var _rot = Quat.identity();\n\n  function defaultTransition(out, t, source, target) {\n    Camera.copySnapshot(out, target); // Rotate up\n\n    Quat.slerp(_rot, Quat.Identity, Quat.rotationTo(_rot, source.up, target.up), t);\n    Vec3.transformQuat(out.up, source.up, _rot); // Lerp target, position & radius\n\n    Vec3.lerp(out.target, source.target, target.target, t);\n    Vec3.lerp(out.position, source.position, target.position, t);\n    out.radius = lerp(source.radius, target.radius, t); // TODO take change of `clipFar` into account\n\n    out.radiusMax = lerp(source.radiusMax, target.radiusMax, t); // Lerp fov & fog\n\n    out.fov = lerp(source.fov, target.fov, t);\n    out.fog = lerp(source.fog, target.fog, t);\n  }\n\n  CameraTransitionManager.defaultTransition = defaultTransition;\n})(CameraTransitionManager || (CameraTransitionManager = {}));","map":{"version":3,"sources":["../../../src/mol-canvas3d/camera/transition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Camera } from '../camera';\r\nimport { Quat, Vec3 } from '../../mol-math/linear-algebra';\r\nimport { lerp } from '../../mol-math/interpolate';\r\nexport { CameraTransitionManager };\r\nvar CameraTransitionManager = /** @class */ (function () {\r\n    function CameraTransitionManager(camera) {\r\n        this.camera = camera;\r\n        this.t = 0;\r\n        this.func = CameraTransitionManager.defaultTransition;\r\n        this.start = 0;\r\n        this.inTransition = false;\r\n        this.durationMs = 0;\r\n        this._source = Camera.createDefaultSnapshot();\r\n        this._target = Camera.createDefaultSnapshot();\r\n        this._current = Camera.createDefaultSnapshot();\r\n    }\r\n    Object.defineProperty(CameraTransitionManager.prototype, \"source\", {\r\n        get: function () { return this._source; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(CameraTransitionManager.prototype, \"target\", {\r\n        get: function () { return this._target; },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    CameraTransitionManager.prototype.apply = function (to, durationMs, transition) {\r\n        if (durationMs === void 0) { durationMs = 0; }\r\n        if (!this.inTransition || durationMs > 0) {\r\n            Camera.copySnapshot(this._source, this.camera.state);\r\n        }\r\n        if (!this.inTransition) {\r\n            Camera.copySnapshot(this._target, this.camera.state);\r\n        }\r\n        Camera.copySnapshot(this._target, to);\r\n        if (this._target.radius > this._target.radiusMax) {\r\n            this._target.radius = this._target.radiusMax;\r\n        }\r\n        if (this._target.radius < 0.01)\r\n            this._target.radius = 0.01;\r\n        if (this._target.radiusMax < 0.01)\r\n            this._target.radiusMax = 0.01;\r\n        if (!this.inTransition && durationMs <= 0 || (typeof to.mode !== 'undefined' && to.mode !== this.camera.state.mode)) {\r\n            this.finish(this._target);\r\n            return;\r\n        }\r\n        this.inTransition = true;\r\n        this.func = transition || CameraTransitionManager.defaultTransition;\r\n        if (!this.inTransition || durationMs > 0) {\r\n            this.start = this.t;\r\n            this.durationMs = durationMs;\r\n        }\r\n    };\r\n    CameraTransitionManager.prototype.tick = function (t) {\r\n        this.t = t;\r\n        this.update();\r\n    };\r\n    CameraTransitionManager.prototype.finish = function (to) {\r\n        Camera.copySnapshot(this.camera.state, to);\r\n        this.inTransition = false;\r\n    };\r\n    CameraTransitionManager.prototype.update = function () {\r\n        if (!this.inTransition)\r\n            return;\r\n        var normalized = Math.min((this.t - this.start) / this.durationMs, 1);\r\n        if (normalized === 1) {\r\n            this.finish(this._target);\r\n            return;\r\n        }\r\n        this.func(this._current, normalized, this._source, this._target);\r\n        Camera.copySnapshot(this.camera.state, this._current);\r\n    };\r\n    return CameraTransitionManager;\r\n}());\r\n(function (CameraTransitionManager) {\r\n    var _rot = Quat.identity();\r\n    function defaultTransition(out, t, source, target) {\r\n        Camera.copySnapshot(out, target);\r\n        // Rotate up\r\n        Quat.slerp(_rot, Quat.Identity, Quat.rotationTo(_rot, source.up, target.up), t);\r\n        Vec3.transformQuat(out.up, source.up, _rot);\r\n        // Lerp target, position & radius\r\n        Vec3.lerp(out.target, source.target, target.target, t);\r\n        Vec3.lerp(out.position, source.position, target.position, t);\r\n        out.radius = lerp(source.radius, target.radius, t);\r\n        // TODO take change of `clipFar` into account\r\n        out.radiusMax = lerp(source.radiusMax, target.radiusMax, t);\r\n        // Lerp fov & fog\r\n        out.fov = lerp(source.fov, target.fov, t);\r\n        out.fog = lerp(source.fog, target.fog, t);\r\n    }\r\n    CameraTransitionManager.defaultTransition = defaultTransition;\r\n})(CameraTransitionManager || (CameraTransitionManager = {}));\r\n//# sourceMappingURL=transition.js.map"]},"metadata":{},"sourceType":"module"}