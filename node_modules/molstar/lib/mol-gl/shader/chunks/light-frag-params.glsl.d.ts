/**
 * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 *
 * adapted from three.js (https://github.com/mrdoob/three.js/)
 * which under the MIT License, Copyright Â© 2010-2019 three.js authors
 */
export declare const light_frag_params = "\nuniform float uLightIntensity;\nuniform float uAmbientIntensity;\nuniform float uReflectivity;\nuniform float uMetalness;\nuniform float uRoughness;\n\nstruct PhysicalMaterial {\n    vec3 diffuseColor;\n    float specularRoughness;\n    vec3 specularColor;\n};\n\nstruct IncidentLight {\n    vec3 color;\n    vec3 direction;\n};\n\nstruct ReflectedLight {\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n};\n\nstruct GeometricContext {\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n};\n\nvec3 F_Schlick(const in vec3 specularColor, const in float dotLH) {\n    // Original approximation by Christophe Schlick '94\n    // float fresnel = pow( 1.0 - dotLH, 5.0 );\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\n    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n    float fresnel = exp2((-5.55473 * dotLH - 6.98316) * dotLH);\n    return (1.0 - specularColor) * fresnel + specularColor;\n}\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated(const in float alpha, const in float dotNL, const in float dotNV) {\n    float a2 = pow2(alpha);\n    // dotNL and dotNV are explicitly swapped. This is not a mistake.\n    float gv = dotNL * sqrt(a2 + (1.0 - a2) * pow2(dotNV));\n    float gl = dotNV * sqrt(a2 + (1.0 - a2) * pow2(dotNL));\n    return 0.5 / max(gv + gl, EPSILON);\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney\u2019s reparameterization\nfloat D_GGX(const in float alpha, const in float dotNH) {\n    float a2 = pow2(alpha);\n    float denom = pow2(dotNH) * (a2 - 1.0) + 1.0; // avoid alpha = 0 with dotNH = 1\n    return RECIPROCAL_PI * a2 / pow2(denom);\n}\n\nvec3 BRDF_Diffuse_Lambert(const in vec3 diffuseColor) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX(const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness) {\n    float alpha = pow2(roughness); // UE4's roughness\n    vec3 halfDir = normalize(incidentLight.direction + geometry.viewDir);\n\n    float dotNL = saturate(dot(geometry.normal, incidentLight.direction));\n    float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n    float dotNH = saturate(dot(geometry.normal, halfDir));\n    float dotLH = saturate(dot(incidentLight.direction, halfDir));\n\n    vec3 F = F_Schlick(specularColor, dotLH);\n    float G = G_GGX_SmithCorrelated(alpha, dotNL, dotNV);\n    float D = D_GGX(alpha, dotNH);\n    return F * (G * D);\n}\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment(const in GeometricContext geometry, const in vec3 specularColor, const in float roughness) {\n    float dotNV = saturate(dot(geometry.normal, geometry.viewDir));\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * dotNV)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;\n}\n\nvoid RE_Direct_Physical(const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n    float dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n    irradiance *= PI; // punctual light\n\n    reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX(directLight, geometry, material.specularColor, material.specularRoughness);\n    reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n\nvoid RE_IndirectDiffuse_Physical(const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert(material.diffuseColor);\n}\n";
