{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { Features } from './features';\nimport { typeSymbol, eachBondedAtom } from '../chemistry/util';\nvar HydrophobicParams = {\n  distanceMax: PD.Numeric(4.0, {\n    min: 1,\n    max: 5,\n    step: 0.1\n  })\n};\n/**\r\n * Hydropbobic atoms\r\n * - Carbon only bonded to carbon or hydrogen\r\n * - Fluorine\r\n */\n\nfunction addHydrophobicAtom(structure, unit, builder) {\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n\n  var _loop_1 = function (i, il) {\n    var element = typeSymbol(unit, i);\n    var flag = false;\n\n    if (element === \"C\"\n    /* C */\n    ) {\n      flag = true;\n      eachBondedAtom(structure, unit, i, function (unitB, indexB) {\n        var elementB = typeSymbol(unitB, indexB);\n        if (elementB !== \"C\"\n        /* C */\n        && elementB !== \"H\"\n        /* H */\n        ) flag = false;\n      });\n    } else if (element === \"F\"\n    /* F */\n    ) {\n      flag = true;\n    }\n\n    if (flag) {\n      builder.add(8\n      /* HydrophobicAtom */\n      , 0\n      /* None */\n      , x[elements[i]], y[elements[i]], z[elements[i]], i);\n    }\n  };\n\n  for (var i = 0, il = elements.length; i < il; ++i) {\n    _loop_1(i, il);\n  }\n}\n\nfunction isHydrophobicContact(ti, tj) {\n  return ti === 8\n  /* HydrophobicAtom */\n  && tj === 8\n  /* HydrophobicAtom */\n  ;\n}\n\nfunction testHydrophobic(structure, infoA, infoB, distanceSq) {\n  var typeA = infoA.types[infoA.feature];\n  var typeB = infoB.types[infoB.feature];\n  if (!isHydrophobicContact(typeA, typeB)) return;\n  var indexA = infoA.members[infoA.offsets[infoA.feature]];\n  var indexB = infoB.members[infoB.offsets[infoB.feature]];\n  if (typeSymbol(infoA.unit, indexA) === \"F\"\n  /* F */\n  && typeSymbol(infoB.unit, indexB) === \"F\"\n  /* F */\n  ) return;\n  return 6\n  /* Hydrophobic */\n  ;\n} //\n\n\nexport var HydrophobicAtomProvider = Features.Provider([8\n/* HydrophobicAtom */\n], addHydrophobicAtom);\nexport var HydrophobicProvider = {\n  name: 'hydrophobic',\n  params: HydrophobicParams,\n  createTester: function (props) {\n    return {\n      maxDistance: props.distanceMax,\n      requiredFeatures: new Set([8\n      /* HydrophobicAtom */\n      ]),\n      getType: function (structure, infoA, infoB, distanceSq) {\n        return testHydrophobic(structure, infoA, infoB, distanceSq);\n      }\n    };\n  }\n};","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/interactions/hydrophobic.ts"],"names":[],"mappings":"AAAA;;;;;;;AAOG;AAEH,SAAS,eAAe,IAAI,EAA5B,QAAsC,oCAAtC;AAEA,SAA0B,QAA1B,QAA0C,YAA1C;AACA,SAAS,UAAT,EAAqB,cAArB,QAA2C,mBAA3C;AAKA,IAAM,iBAAiB,GAAG;AACtB,EAAA,WAAW,EAAE,EAAE,CAAC,OAAH,CAAW,GAAX,EAAgB;AAAE,IAAA,GAAG,EAAE,CAAP;AAAU,IAAA,GAAG,EAAE,CAAf;AAAkB,IAAA,IAAI,EAAE;AAAxB,GAAhB;AADS,CAA1B;AAMA;;;;AAIG;;AACH,SAAS,kBAAT,CAA4B,SAA5B,EAAkD,IAAlD,EAAqE,OAArE,EAA6F;AACjF,MAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;AACF,MAAA,EAAA,GAAc,IAAI,CAAC,KAAL,CAAW,kBAAzB;AAAA,MAAE,CAAC,GAAA,EAAA,CAAA,CAAH;AAAA,MAAK,CAAC,GAAA,EAAA,CAAA,CAAN;AAAA,MAAQ,CAAC,GAAA,EAAA,CAAA,CAAT;;0BAEG,C,EAAqC,E,EAAE;AAC5C,QAAM,OAAO,GAAG,UAAU,CAAC,IAAD,EAAO,CAAP,CAA1B;AACA,QAAI,IAAI,GAAG,KAAX;;AACA,QAAI,OAAO,KAAA;AAAA;AAAX,MAA4B;AACxB,MAAA,IAAI,GAAG,IAAP;AACA,MAAA,cAAc,CAAC,SAAD,EAAY,IAAZ,EAAkB,CAAlB,EAAqB,UAAC,KAAD,EAAQ,MAAR,EAAc;AAC7C,YAAM,QAAQ,GAAG,UAAU,CAAC,KAAD,EAAQ,MAAR,CAA3B;AACA,YAAI,QAAQ,KAAA;AAAA;AAAR,WAA2B,QAAQ,KAAA;AAAA;AAAvC,UAAwD,IAAI,GAAG,KAAP;AAC3D,OAHa,CAAd;AAIH,KAND,MAMO,IAAI,OAAO,KAAA;AAAA;AAAX,MAA4B;AAC/B,MAAA,IAAI,GAAG,IAAP;AACH;;AAED,QAAI,IAAJ,EAAU;AACN,MAAA,OAAO,CAAC,GAAR,CAAW;AAAA;AAAX,QAAW;AAAA;AAAX,QAA4D,CAAC,CAAC,QAAQ,CAAC,CAAD,CAAT,CAA7D,EAA4E,CAAC,CAAC,QAAQ,CAAC,CAAD,CAAT,CAA7E,EAA4F,CAAC,CAAC,QAAQ,CAAC,CAAD,CAAT,CAA7F,EAA4G,CAA5G;AACH;;;AAfL,OAAK,IAAI,CAAC,GAAG,CAAR,EAAyC,EAAE,GAAG,QAAQ,CAAC,MAA5D,EAAoE,CAAC,GAAG,EAAxE,EAA4E,EAAE,CAA9E,EAA+E;YAAtE,C,EAAqC,E;AAgB7C;AACJ;;AAED,SAAS,oBAAT,CAA8B,EAA9B,EAA+C,EAA/C,EAA8D;AAC1D,SAAO,EAAE,KAAA;AAAA;AAAF,KAAsC,EAAE,KAAA;AAAA;AAA/C;AACH;;AAED,SAAS,eAAT,CAAyB,SAAzB,EAA+C,KAA/C,EAAqE,KAArE,EAA2F,UAA3F,EAA6G;AACzG,MAAM,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,OAAlB,CAAd;AACA,MAAM,KAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,CAAC,OAAlB,CAAd;AAEA,MAAI,CAAC,oBAAoB,CAAC,KAAD,EAAQ,KAAR,CAAzB,EAAyC;AAEzC,MAAM,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,OAApB,CAAd,CAAf;AACA,MAAM,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,OAAN,CAAc,KAAK,CAAC,OAApB,CAAd,CAAf;AACA,MAAI,UAAU,CAAC,KAAK,CAAC,IAAP,EAAa,MAAb,CAAV,KAA8B;AAAA;AAA9B,KAAiD,UAAU,CAAC,KAAK,CAAC,IAAP,EAAa,MAAb,CAAV,KAA8B;AAAA;AAAnF,IAAoG;AAEpG,SAAA;AAAA;AAAA;AACH,C,CAED;;;AAEA,OAAO,IAAM,uBAAuB,GAAG,QAAQ,CAAC,QAAT,CAAkB,CAAA;AAAA;AAAA,CAAlB,EAAiD,kBAAjD,CAAhC;AAEP,OAAO,IAAM,mBAAmB,GAAuC;AACnE,EAAA,IAAI,EAAE,aAD6D;AAEnE,EAAA,MAAM,EAAE,iBAF2D;AAGnE,EAAA,YAAY,EAAE,UAAC,KAAD,EAAwB;AAClC,WAAO;AACH,MAAA,WAAW,EAAE,KAAK,CAAC,WADhB;AAEH,MAAA,gBAAgB,EAAE,IAAI,GAAJ,CAAQ,CAAA;AAAA;AAAA,OAAR,CAFf;AAGH,MAAA,OAAO,EAAE,UAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,EAA0B,UAA1B,EAAoC;AAAK,eAAA,eAAe,CAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,EAAf,UAAe,CAAf;AAAoD;AAHnG,KAAP;AAKH;AATkE,CAAhE","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { Features } from './features';\r\nimport { typeSymbol, eachBondedAtom } from '../chemistry/util';\r\nvar HydrophobicParams = {\r\n    distanceMax: PD.Numeric(4.0, { min: 1, max: 5, step: 0.1 }),\r\n};\r\n/**\r\n * Hydropbobic atoms\r\n * - Carbon only bonded to carbon or hydrogen\r\n * - Fluorine\r\n */\r\nfunction addHydrophobicAtom(structure, unit, builder) {\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    var _loop_1 = function (i, il) {\r\n        var element = typeSymbol(unit, i);\r\n        var flag = false;\r\n        if (element === \"C\" /* C */) {\r\n            flag = true;\r\n            eachBondedAtom(structure, unit, i, function (unitB, indexB) {\r\n                var elementB = typeSymbol(unitB, indexB);\r\n                if (elementB !== \"C\" /* C */ && elementB !== \"H\" /* H */)\r\n                    flag = false;\r\n            });\r\n        }\r\n        else if (element === \"F\" /* F */) {\r\n            flag = true;\r\n        }\r\n        if (flag) {\r\n            builder.add(8 /* HydrophobicAtom */, 0 /* None */, x[elements[i]], y[elements[i]], z[elements[i]], i);\r\n        }\r\n    };\r\n    for (var i = 0, il = elements.length; i < il; ++i) {\r\n        _loop_1(i, il);\r\n    }\r\n}\r\nfunction isHydrophobicContact(ti, tj) {\r\n    return ti === 8 /* HydrophobicAtom */ && tj === 8 /* HydrophobicAtom */;\r\n}\r\nfunction testHydrophobic(structure, infoA, infoB, distanceSq) {\r\n    var typeA = infoA.types[infoA.feature];\r\n    var typeB = infoB.types[infoB.feature];\r\n    if (!isHydrophobicContact(typeA, typeB))\r\n        return;\r\n    var indexA = infoA.members[infoA.offsets[infoA.feature]];\r\n    var indexB = infoB.members[infoB.offsets[infoB.feature]];\r\n    if (typeSymbol(infoA.unit, indexA) === \"F\" /* F */ && typeSymbol(infoB.unit, indexB) === \"F\" /* F */)\r\n        return;\r\n    return 6 /* Hydrophobic */;\r\n}\r\n//\r\nexport var HydrophobicAtomProvider = Features.Provider([8 /* HydrophobicAtom */], addHydrophobicAtom);\r\nexport var HydrophobicProvider = {\r\n    name: 'hydrophobic',\r\n    params: HydrophobicParams,\r\n    createTester: function (props) {\r\n        return {\r\n            maxDistance: props.distanceMax,\r\n            requiredFeatures: new Set([8 /* HydrophobicAtom */]),\r\n            getType: function (structure, infoA, infoB, distanceSq) { return testHydrophobic(structure, infoA, infoB, distanceSq); }\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=hydrophobic.js.map"]},"metadata":{},"sourceType":"module"}