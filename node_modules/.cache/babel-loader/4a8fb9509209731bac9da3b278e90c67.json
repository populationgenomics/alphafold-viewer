{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __extends } from \"tslib\";\nimport { Structure, StructureElement } from '../../mol-model/structure';\nimport { SequenceWrapper } from './wrapper';\nimport { OrderedSet, Interval } from '../../mol-data/int';\nimport { ColorNames } from '../../mol-util/color/names';\nimport { applyMarkerAction } from '../../mol-util/marker-action';\n\nvar ElementSequenceWrapper =\n/** @class */\nfunction (_super) {\n  __extends(ElementSequenceWrapper, _super);\n\n  function ElementSequenceWrapper(data) {\n    var _this = this;\n\n    var length = 0;\n    var unitIndices = new Map();\n    var lociElements = [];\n\n    for (var i = 0, il = data.units.length; i < il; ++i) {\n      var unit = data.units[i];\n      length += unit.elements.length;\n      var indices = Interval.ofBounds(0, unit.elements.length);\n      unitIndices.set(unit.id, indices);\n      lociElements.push({\n        unit: unit,\n        indices: indices\n      });\n    }\n\n    var markerArray = new Uint8Array(length);\n    _this = _super.call(this, data, markerArray, length) || this;\n    _this.unitIndices = unitIndices;\n    return _this;\n  }\n\n  ElementSequenceWrapper.prototype.residueLabel = function (seqIdx) {\n    return 'X';\n  };\n\n  ElementSequenceWrapper.prototype.residueColor = function (seqIdx) {\n    return ColorNames.black;\n  };\n\n  ElementSequenceWrapper.prototype.residueClass = function (seqIdx) {\n    return 'msp-sequence-present';\n  };\n\n  ElementSequenceWrapper.prototype.mark = function (loci, action) {\n    var changed = false;\n    var _a = this.data,\n        structure = _a.structure,\n        units = _a.units;\n\n    if (StructureElement.Loci.is(loci)) {\n      if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n      loci = StructureElement.Loci.remap(loci, structure);\n\n      for (var _i = 0, _b = loci.elements; _i < _b.length; _i++) {\n        var e = _b[_i];\n        var indices = this.unitIndices.get(e.unit.id);\n\n        if (indices) {\n          if (OrderedSet.isSubset(indices, e.indices)) {\n            if (applyMarkerAction(this.markerArray, e.indices, action)) changed = true;\n          }\n        }\n      }\n    } else if (Structure.isLoci(loci)) {\n      if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n\n      for (var i = 0, il = units.length; i < il; ++i) {\n        var indices = this.unitIndices.get(units[i].id);\n        if (applyMarkerAction(this.markerArray, indices, action)) changed = true;\n      }\n    }\n\n    return changed;\n  };\n\n  ElementSequenceWrapper.prototype.getLoci = function (seqIdx) {\n    var units = this.data.units;\n    var lociElements = [];\n    var offset = 0;\n\n    for (var i = 0, il = units.length; i < il; ++i) {\n      var unit = units[i];\n\n      if (seqIdx < offset + unit.elements.length) {\n        lociElements.push({\n          unit: unit,\n          indices: Interval.ofSingleton(seqIdx - offset)\n        });\n        break;\n      }\n\n      offset += unit.elements.length;\n    }\n\n    return StructureElement.Loci(this.data.structure, lociElements);\n  };\n\n  return ElementSequenceWrapper;\n}(SequenceWrapper);\n\nexport { ElementSequenceWrapper };","map":{"version":3,"sources":["../../../src/mol-plugin-ui/sequence/element.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __extends } from \"tslib\";\r\nimport { Structure, StructureElement } from '../../mol-model/structure';\r\nimport { SequenceWrapper } from './wrapper';\r\nimport { OrderedSet, Interval } from '../../mol-data/int';\r\nimport { ColorNames } from '../../mol-util/color/names';\r\nimport { applyMarkerAction } from '../../mol-util/marker-action';\r\nvar ElementSequenceWrapper = /** @class */ (function (_super) {\r\n    __extends(ElementSequenceWrapper, _super);\r\n    function ElementSequenceWrapper(data) {\r\n        var _this = this;\r\n        var length = 0;\r\n        var unitIndices = new Map();\r\n        var lociElements = [];\r\n        for (var i = 0, il = data.units.length; i < il; ++i) {\r\n            var unit = data.units[i];\r\n            length += unit.elements.length;\r\n            var indices = Interval.ofBounds(0, unit.elements.length);\r\n            unitIndices.set(unit.id, indices);\r\n            lociElements.push({ unit: unit, indices: indices });\r\n        }\r\n        var markerArray = new Uint8Array(length);\r\n        _this = _super.call(this, data, markerArray, length) || this;\r\n        _this.unitIndices = unitIndices;\r\n        return _this;\r\n    }\r\n    ElementSequenceWrapper.prototype.residueLabel = function (seqIdx) {\r\n        return 'X';\r\n    };\r\n    ElementSequenceWrapper.prototype.residueColor = function (seqIdx) {\r\n        return ColorNames.black;\r\n    };\r\n    ElementSequenceWrapper.prototype.residueClass = function (seqIdx) {\r\n        return 'msp-sequence-present';\r\n    };\r\n    ElementSequenceWrapper.prototype.mark = function (loci, action) {\r\n        var changed = false;\r\n        var _a = this.data, structure = _a.structure, units = _a.units;\r\n        if (StructureElement.Loci.is(loci)) {\r\n            if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n                return false;\r\n            loci = StructureElement.Loci.remap(loci, structure);\r\n            for (var _i = 0, _b = loci.elements; _i < _b.length; _i++) {\r\n                var e = _b[_i];\r\n                var indices = this.unitIndices.get(e.unit.id);\r\n                if (indices) {\r\n                    if (OrderedSet.isSubset(indices, e.indices)) {\r\n                        if (applyMarkerAction(this.markerArray, e.indices, action))\r\n                            changed = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else if (Structure.isLoci(loci)) {\r\n            if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n                return false;\r\n            for (var i = 0, il = units.length; i < il; ++i) {\r\n                var indices = this.unitIndices.get(units[i].id);\r\n                if (applyMarkerAction(this.markerArray, indices, action))\r\n                    changed = true;\r\n            }\r\n        }\r\n        return changed;\r\n    };\r\n    ElementSequenceWrapper.prototype.getLoci = function (seqIdx) {\r\n        var units = this.data.units;\r\n        var lociElements = [];\r\n        var offset = 0;\r\n        for (var i = 0, il = units.length; i < il; ++i) {\r\n            var unit = units[i];\r\n            if (seqIdx < offset + unit.elements.length) {\r\n                lociElements.push({ unit: unit, indices: Interval.ofSingleton(seqIdx - offset) });\r\n                break;\r\n            }\r\n            offset += unit.elements.length;\r\n        }\r\n        return StructureElement.Loci(this.data.structure, lociElements);\r\n    };\r\n    return ElementSequenceWrapper;\r\n}(SequenceWrapper));\r\nexport { ElementSequenceWrapper };\r\n//# sourceMappingURL=element.js.map"]},"metadata":{},"sourceType":"module"}