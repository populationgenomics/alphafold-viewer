"use strict";
/**
 * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Michal Malý <michal.maly@ibt.cas.cz>
 * @author Jiří Černý <jiri.cerny@ibt.cas.cz>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DnatcoConfalPyramids = exports.DnatcoConfalPyramidsPreset = void 0;
var tslib_1 = require("tslib");
var color_1 = require("./color");
var property_1 = require("./property");
var representation_1 = require("./representation");
var behavior_1 = require("../../../mol-plugin/behavior/behavior");
var representation_preset_1 = require("../../../mol-plugin-state/builder/structure/representation-preset");
var mol_state_1 = require("../../../mol-state");
var mol_task_1 = require("../../../mol-task");
var param_definition_1 = require("../../../mol-util/param-definition");
exports.DnatcoConfalPyramidsPreset = (0, representation_preset_1.StructureRepresentationPresetProvider)({
    id: 'preset-structure-representation-confal-pyramids',
    display: {
        name: 'Confal Pyramids', group: 'Annotation',
        description: 'Schematic depiction of conformer class and confal value.',
    },
    isApplicable: function (a) {
        return a.data.models.length >= 1 && a.data.models.some(function (m) { return property_1.ConfalPyramids.isApplicable(m); });
    },
    params: function () { return representation_preset_1.StructureRepresentationPresetProvider.CommonParams; },
    apply: function (ref, params, plugin) {
        var _a;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var structureCell, model, _b, components, representations, pyramids, _c, update, builder, typeParams, pyramidsRepr;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        structureCell = mol_state_1.StateObjectRef.resolveAndCheck(plugin.state.data, ref);
                        model = (_a = structureCell === null || structureCell === void 0 ? void 0 : structureCell.obj) === null || _a === void 0 ? void 0 : _a.data.model;
                        if (!structureCell || !model)
                            return [2 /*return*/, {}];
                        return [4 /*yield*/, plugin.runTask(mol_task_1.Task.create('Confal Pyramids', function (runtime) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
                                return (0, tslib_1.__generator)(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, property_1.ConfalPyramidsProvider.attach({ runtime: runtime, assetManager: plugin.managers.asset }, model)];
                                        case 1:
                                            _a.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 1:
                        _d.sent();
                        return [4 /*yield*/, representation_preset_1.PresetStructureRepresentations.auto.apply(ref, (0, tslib_1.__assign)({}, params), plugin)];
                    case 2:
                        _b = _d.sent(), components = _b.components, representations = _b.representations;
                        return [4 /*yield*/, plugin.builders.structure.tryCreateComponentStatic(structureCell, 'nucleic', { label: 'Confal Pyramids' })];
                    case 3:
                        pyramids = _d.sent();
                        _c = representation_preset_1.StructureRepresentationPresetProvider.reprBuilder(plugin, params), update = _c.update, builder = _c.builder, typeParams = _c.typeParams;
                        if (representations)
                            pyramidsRepr = builder.buildRepresentation(update, pyramids, { type: representation_1.ConfalPyramidsRepresentationProvider, typeParams: typeParams, color: color_1.ConfalPyramidsColorThemeProvider }, { tag: 'confal-pyramdis' });
                        return [4 /*yield*/, update.commit({ revertOnError: true })];
                    case 4:
                        _d.sent();
                        return [2 /*return*/, { components: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, components), { pyramids: pyramids }), representations: (0, tslib_1.__assign)((0, tslib_1.__assign)({}, representations), { pyramidsRepr: pyramidsRepr }) }];
                }
            });
        });
    }
});
exports.DnatcoConfalPyramids = behavior_1.PluginBehavior.create({
    name: 'dnatco-confal-pyramids-prop',
    category: 'custom-props',
    display: {
        name: 'Confal Pyramids',
        description: 'Schematic depiction of conformer class and confal value.',
    },
    ctor: /** @class */ (function (_super) {
        (0, tslib_1.__extends)(class_1, _super);
        function class_1() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.provider = property_1.ConfalPyramidsProvider;
            _this.labelConfalPyramids = {
                label: function (loci) {
                    if (!_this.params.showToolTip)
                        return void 0;
                    /* TODO: Implement this */
                    return void 0;
                }
            };
            return _this;
        }
        class_1.prototype.register = function () {
            this.ctx.customModelProperties.register(this.provider, this.params.autoAttach);
            this.ctx.managers.lociLabels.addProvider(this.labelConfalPyramids);
            this.ctx.representation.structure.themes.colorThemeRegistry.add(color_1.ConfalPyramidsColorThemeProvider);
            this.ctx.representation.structure.registry.add(representation_1.ConfalPyramidsRepresentationProvider);
            this.ctx.builders.structure.representation.registerPreset(exports.DnatcoConfalPyramidsPreset);
        };
        class_1.prototype.update = function (p) {
            var updated = this.params.autoAttach !== p.autoAttach;
            this.params.autoAttach = p.autoAttach;
            this.params.showToolTip = p.showToolTip;
            this.ctx.customModelProperties.setDefaultAutoAttach(this.provider.descriptor.name, this.params.autoAttach);
            return updated;
        };
        class_1.prototype.unregister = function () {
            this.ctx.customModelProperties.unregister(property_1.ConfalPyramidsProvider.descriptor.name);
            this.ctx.managers.lociLabels.removeProvider(this.labelConfalPyramids);
            this.ctx.representation.structure.registry.remove(representation_1.ConfalPyramidsRepresentationProvider);
            this.ctx.representation.structure.themes.colorThemeRegistry.remove(color_1.ConfalPyramidsColorThemeProvider);
            this.ctx.builders.structure.representation.unregisterPreset(exports.DnatcoConfalPyramidsPreset);
        };
        return class_1;
    }(behavior_1.PluginBehavior.Handler)),
    params: function () { return ({
        autoAttach: param_definition_1.ParamDefinition.Boolean(true),
        showToolTip: param_definition_1.ParamDefinition.Boolean(true)
    }); }
});
//# sourceMappingURL=behavior.js.map