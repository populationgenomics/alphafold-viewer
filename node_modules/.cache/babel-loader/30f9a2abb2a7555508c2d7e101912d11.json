{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\nimport { Grid, Volume } from '../../mol-model/volume';\nimport { Mesh } from '../../mol-geo/geometry/mesh/mesh';\nimport { computeMarchingCubesMesh, computeMarchingCubesLines } from '../../mol-geo/util/marching-cubes/algorithm';\nimport { VolumeVisual, VolumeRepresentation, VolumeRepresentationProvider } from './representation';\nimport { LocationIterator } from '../../mol-geo/util/location-iterator';\nimport { NullLocation } from '../../mol-model/location';\nimport { Lines } from '../../mol-geo/geometry/lines/lines';\nimport { Representation } from '../representation';\nimport { EmptyLoci } from '../../mol-model/loci';\nimport { Interval } from '../../mol-data/int';\nimport { Tensor, Vec2, Vec3 } from '../../mol-math/linear-algebra';\nimport { fillSerial } from '../../mol-util/array';\nimport { createVolumeTexture2d, eachVolumeLoci, getVolumeTexture2dLayout } from './util';\nimport { TextureMesh } from '../../mol-geo/geometry/texture-mesh/texture-mesh';\nimport { extractIsosurface } from '../../mol-gl/compute/marching-cubes/isosurface';\nimport { CustomPropertyDescriptor } from '../../mol-model/custom-property';\nexport var VolumeIsosurfaceParams = {\n  isoValue: Volume.IsoValueParam\n};\n\nfunction gpuSupport(webgl) {\n  return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.drawBuffers;\n}\n\nvar Padding = 1;\n\nfunction suitableForGpu(volume, webgl) {\n  var gridDim = volume.grid.cells.space.dimensions;\n  var powerOfTwoSize = getVolumeTexture2dLayout(gridDim, Padding).powerOfTwoSize;\n  return powerOfTwoSize <= webgl.maxTextureSize / 2;\n}\n\nexport function IsosurfaceVisual(materialId, volume, props, webgl) {\n  if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(volume, webgl)) {\n    return IsosurfaceTextureMeshVisual(materialId);\n  }\n\n  return IsosurfaceMeshVisual(materialId);\n}\n\nfunction getLoci(volume, props) {\n  return Volume.Isosurface.Loci(volume, props.isoValue);\n}\n\nfunction getIsosurfaceLoci(pickingId, volume, props, id) {\n  var objectId = pickingId.objectId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    return Volume.Cell.Loci(volume, Interval.ofSingleton(groupId));\n  }\n\n  return EmptyLoci;\n}\n\nexport function eachIsosurface(loci, volume, props, apply) {\n  return eachVolumeLoci(loci, volume, props.isoValue, apply);\n} //\n\nexport function createVolumeIsosurfaceMesh(ctx, volume, theme, props, mesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var ids, surface, transform;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ctx.runtime.update({\n            message: 'Marching cubes...'\n          });\n          ids = fillSerial(new Int32Array(volume.grid.cells.data.length));\n          return [4\n          /*yield*/\n          , computeMarchingCubesMesh({\n            isoLevel: Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue,\n            scalarField: volume.grid.cells,\n            idField: Tensor.create(volume.grid.cells.space, Tensor.Data1(ids))\n          }, mesh).runAsChild(ctx.runtime)];\n\n        case 1:\n          surface = _a.sent();\n          transform = Grid.getGridToCartesianTransform(volume.grid);\n          Mesh.transform(surface, transform);\n\n          if (ctx.webgl && !ctx.webgl.isWebGL2) {\n            // 2nd arg means not to split triangles based on group id. Splitting triangles\n            // is too expensive if each cell has its own group id as is the case here.\n            Mesh.uniformTriangleGroup(surface, false);\n          }\n\n          surface.setBoundingSphere(Volume.getBoundingSphere(volume));\n          return [2\n          /*return*/\n          , surface];\n      }\n    });\n  });\n}\nexport var IsosurfaceMeshParams = __assign(__assign(__assign(__assign({}, Mesh.Params), TextureMesh.Params), VolumeIsosurfaceParams), {\n  quality: __assign(__assign({}, Mesh.Params.quality), {\n    isEssential: false\n  }),\n  tryUseGpu: PD.Boolean(true)\n});\nexport function IsosurfaceMeshVisual(materialId) {\n  return VolumeVisual({\n    defaultProps: PD.getDefaultValues(IsosurfaceMeshParams),\n    createGeometry: createVolumeIsosurfaceMesh,\n    createLocationIterator: function (volume) {\n      return LocationIterator(volume.grid.cells.data.length, 1, 1, function () {\n        return NullLocation;\n      });\n    },\n    getLoci: getIsosurfaceLoci,\n    eachLocation: eachIsosurface,\n    setUpdateState: function (state, volume, newProps, currentProps) {\n      if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats)) state.createGeometry = true;\n    },\n    geometryUtils: Mesh.Utils,\n    mustRecreate: function (volume, props, webgl) {\n      return props.tryUseGpu && !!webgl && suitableForGpu(volume, webgl);\n    }\n  }, materialId);\n} //\n\nvar VolumeIsosurfaceTexture;\n\n(function (VolumeIsosurfaceTexture) {\n  var name = 'volume-isosurface-texture';\n  VolumeIsosurfaceTexture.descriptor = CustomPropertyDescriptor({\n    name: name\n  });\n\n  function get(volume, webgl) {\n    var resources = webgl.resources;\n    var transform = Grid.getGridToCartesianTransform(volume.grid);\n    var gridDimension = Vec3.clone(volume.grid.cells.space.dimensions);\n\n    var _a = getVolumeTexture2dLayout(gridDimension, Padding),\n        width = _a.width,\n        height = _a.height,\n        texDim = _a.powerOfTwoSize;\n\n    var gridTexDim = Vec3.create(width, height, 0);\n    var gridTexScale = Vec2.create(width / texDim, height / texDim); // console.log({ texDim, width, height, gridDimension });\n\n    if (texDim > webgl.maxTextureSize / 2) {\n      throw new Error('volume too large for gpu isosurface extraction');\n    }\n\n    if (!volume._propertyData[name]) {\n      volume._propertyData[name] = resources.texture('image-uint8', 'alpha', 'ubyte', 'linear');\n      var texture_1 = volume._propertyData[name];\n      texture_1.define(texDim, texDim); // load volume into sub-section of texture\n\n      texture_1.load(createVolumeTexture2d(volume, 'data', Padding), true);\n      volume.customProperties.add(VolumeIsosurfaceTexture.descriptor);\n      volume.customProperties.assets(VolumeIsosurfaceTexture.descriptor, [{\n        dispose: function () {\n          return texture_1.destroy();\n        }\n      }]);\n    }\n\n    gridDimension[0] += Padding;\n    gridDimension[1] += Padding;\n    return {\n      texture: volume._propertyData[name],\n      transform: transform,\n      gridDimension: gridDimension,\n      gridTexDim: gridTexDim,\n      gridTexScale: gridTexScale\n    };\n  }\n\n  VolumeIsosurfaceTexture.get = get;\n})(VolumeIsosurfaceTexture || (VolumeIsosurfaceTexture = {}));\n\nfunction createVolumeIsosurfaceTextureMesh(ctx, volume, theme, props, textureMesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, max, min, diff, value, isoLevel, _b, texture, gridDimension, gridTexDim, gridTexScale, transform, buffer, gv, surface;\n\n    return __generator(this, function (_c) {\n      if (!ctx.webgl) throw new Error('webgl context required to create volume isosurface texture-mesh');\n      _a = volume.grid.stats, max = _a.max, min = _a.min;\n      diff = max - min;\n      value = Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue;\n      isoLevel = (value - min) / diff;\n      _b = VolumeIsosurfaceTexture.get(volume, ctx.webgl), texture = _b.texture, gridDimension = _b.gridDimension, gridTexDim = _b.gridTexDim, gridTexScale = _b.gridTexScale, transform = _b.transform;\n      buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\n      gv = extractIsosurface(ctx.webgl, texture, gridDimension, gridTexDim, gridTexScale, transform, isoLevel, value < 0, false, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\n      surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, Volume.getBoundingSphere(volume), textureMesh);\n      return [2\n      /*return*/\n      , surface];\n    });\n  });\n}\n\nexport function IsosurfaceTextureMeshVisual(materialId) {\n  return VolumeVisual({\n    defaultProps: PD.getDefaultValues(IsosurfaceMeshParams),\n    createGeometry: createVolumeIsosurfaceTextureMesh,\n    createLocationIterator: function (volume) {\n      return LocationIterator(volume.grid.cells.data.length, 1, 1, function () {\n        return NullLocation;\n      });\n    },\n    getLoci: getIsosurfaceLoci,\n    eachLocation: eachIsosurface,\n    setUpdateState: function (state, volume, newProps, currentProps) {\n      if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats)) state.createGeometry = true;\n    },\n    geometryUtils: TextureMesh.Utils,\n    mustRecreate: function (volume, props, webgl) {\n      return !props.tryUseGpu || !webgl || !suitableForGpu(volume, webgl);\n    },\n    dispose: function (geometry) {\n      geometry.vertexTexture.ref.value.destroy();\n      geometry.groupTexture.ref.value.destroy();\n      geometry.normalTexture.ref.value.destroy();\n      geometry.doubleBuffer.destroy();\n    }\n  }, materialId);\n} //\n\nexport function createVolumeIsosurfaceWireframe(ctx, volume, theme, props, lines) {\n  return __awaiter(this, void 0, void 0, function () {\n    var ids, wireframe, transform;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          ctx.runtime.update({\n            message: 'Marching cubes...'\n          });\n          ids = fillSerial(new Int32Array(volume.grid.cells.data.length));\n          return [4\n          /*yield*/\n          , computeMarchingCubesLines({\n            isoLevel: Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue,\n            scalarField: volume.grid.cells,\n            idField: Tensor.create(volume.grid.cells.space, Tensor.Data1(ids))\n          }, lines).runAsChild(ctx.runtime)];\n\n        case 1:\n          wireframe = _a.sent();\n          transform = Grid.getGridToCartesianTransform(volume.grid);\n          Lines.transform(wireframe, transform);\n          wireframe.setBoundingSphere(Volume.getBoundingSphere(volume));\n          return [2\n          /*return*/\n          , wireframe];\n      }\n    });\n  });\n}\nexport var IsosurfaceWireframeParams = __assign(__assign(__assign({}, Lines.Params), VolumeIsosurfaceParams), {\n  quality: __assign(__assign({}, Lines.Params.quality), {\n    isEssential: false\n  }),\n  sizeFactor: PD.Numeric(3, {\n    min: 0,\n    max: 10,\n    step: 0.1\n  })\n});\nexport function IsosurfaceWireframeVisual(materialId) {\n  return VolumeVisual({\n    defaultProps: PD.getDefaultValues(IsosurfaceWireframeParams),\n    createGeometry: createVolumeIsosurfaceWireframe,\n    createLocationIterator: function (volume) {\n      return LocationIterator(volume.grid.cells.data.length, 1, 1, function () {\n        return NullLocation;\n      });\n    },\n    getLoci: getIsosurfaceLoci,\n    eachLocation: eachIsosurface,\n    setUpdateState: function (state, volume, newProps, currentProps) {\n      if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats)) state.createGeometry = true;\n    },\n    geometryUtils: Lines.Utils\n  }, materialId);\n} //\n\nvar IsosurfaceVisuals = {\n  'solid': function (ctx, getParams) {\n    return VolumeRepresentation('Isosurface mesh', ctx, getParams, IsosurfaceVisual, getLoci);\n  },\n  'wireframe': function (ctx, getParams) {\n    return VolumeRepresentation('Isosurface wireframe', ctx, getParams, IsosurfaceWireframeVisual, getLoci);\n  }\n};\nexport var IsosurfaceParams = __assign(__assign(__assign({}, IsosurfaceMeshParams), IsosurfaceWireframeParams), {\n  visuals: PD.MultiSelect(['solid'], PD.objectToOptions(IsosurfaceVisuals))\n});\nexport function getIsosurfaceParams(ctx, volume) {\n  var p = PD.clone(IsosurfaceParams);\n  p.isoValue = Volume.createIsoValueParam(Volume.IsoValue.relative(2), volume.grid.stats);\n  return p;\n}\nexport function IsosurfaceRepresentation(ctx, getParams) {\n  return Representation.createMulti('Isosurface', ctx, getParams, Representation.StateBuilder, IsosurfaceVisuals);\n}\nexport var IsosurfaceRepresentationProvider = VolumeRepresentationProvider({\n  name: 'isosurface',\n  label: 'Isosurface',\n  description: 'Displays a triangulated isosurface of volumetric data.',\n  factory: IsosurfaceRepresentation,\n  getParams: getIsosurfaceParams,\n  defaultValues: PD.getDefaultValues(IsosurfaceParams),\n  defaultColorTheme: {\n    name: 'uniform'\n  },\n  defaultSizeTheme: {\n    name: 'uniform'\n  },\n  isApplicable: function (volume) {\n    return !Volume.isEmpty(volume);\n  }\n});","map":{"version":3,"sources":["../../../src/mol-repr/volume/isosurface.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\r\nimport { Grid, Volume } from '../../mol-model/volume';\r\nimport { Mesh } from '../../mol-geo/geometry/mesh/mesh';\r\nimport { computeMarchingCubesMesh, computeMarchingCubesLines } from '../../mol-geo/util/marching-cubes/algorithm';\r\nimport { VolumeVisual, VolumeRepresentation, VolumeRepresentationProvider } from './representation';\r\nimport { LocationIterator } from '../../mol-geo/util/location-iterator';\r\nimport { NullLocation } from '../../mol-model/location';\r\nimport { Lines } from '../../mol-geo/geometry/lines/lines';\r\nimport { Representation } from '../representation';\r\nimport { EmptyLoci } from '../../mol-model/loci';\r\nimport { Interval } from '../../mol-data/int';\r\nimport { Tensor, Vec2, Vec3 } from '../../mol-math/linear-algebra';\r\nimport { fillSerial } from '../../mol-util/array';\r\nimport { createVolumeTexture2d, eachVolumeLoci, getVolumeTexture2dLayout } from './util';\r\nimport { TextureMesh } from '../../mol-geo/geometry/texture-mesh/texture-mesh';\r\nimport { extractIsosurface } from '../../mol-gl/compute/marching-cubes/isosurface';\r\nimport { CustomPropertyDescriptor } from '../../mol-model/custom-property';\r\nexport var VolumeIsosurfaceParams = {\r\n    isoValue: Volume.IsoValueParam\r\n};\r\nfunction gpuSupport(webgl) {\r\n    return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.drawBuffers;\r\n}\r\nvar Padding = 1;\r\nfunction suitableForGpu(volume, webgl) {\r\n    var gridDim = volume.grid.cells.space.dimensions;\r\n    var powerOfTwoSize = getVolumeTexture2dLayout(gridDim, Padding).powerOfTwoSize;\r\n    return powerOfTwoSize <= webgl.maxTextureSize / 2;\r\n}\r\nexport function IsosurfaceVisual(materialId, volume, props, webgl) {\r\n    if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(volume, webgl)) {\r\n        return IsosurfaceTextureMeshVisual(materialId);\r\n    }\r\n    return IsosurfaceMeshVisual(materialId);\r\n}\r\nfunction getLoci(volume, props) {\r\n    return Volume.Isosurface.Loci(volume, props.isoValue);\r\n}\r\nfunction getIsosurfaceLoci(pickingId, volume, props, id) {\r\n    var objectId = pickingId.objectId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        return Volume.Cell.Loci(volume, Interval.ofSingleton(groupId));\r\n    }\r\n    return EmptyLoci;\r\n}\r\nexport function eachIsosurface(loci, volume, props, apply) {\r\n    return eachVolumeLoci(loci, volume, props.isoValue, apply);\r\n}\r\n//\r\nexport function createVolumeIsosurfaceMesh(ctx, volume, theme, props, mesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ids, surface, transform;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ctx.runtime.update({ message: 'Marching cubes...' });\r\n                    ids = fillSerial(new Int32Array(volume.grid.cells.data.length));\r\n                    return [4 /*yield*/, computeMarchingCubesMesh({\r\n                            isoLevel: Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue,\r\n                            scalarField: volume.grid.cells,\r\n                            idField: Tensor.create(volume.grid.cells.space, Tensor.Data1(ids))\r\n                        }, mesh).runAsChild(ctx.runtime)];\r\n                case 1:\r\n                    surface = _a.sent();\r\n                    transform = Grid.getGridToCartesianTransform(volume.grid);\r\n                    Mesh.transform(surface, transform);\r\n                    if (ctx.webgl && !ctx.webgl.isWebGL2) {\r\n                        // 2nd arg means not to split triangles based on group id. Splitting triangles\r\n                        // is too expensive if each cell has its own group id as is the case here.\r\n                        Mesh.uniformTriangleGroup(surface, false);\r\n                    }\r\n                    surface.setBoundingSphere(Volume.getBoundingSphere(volume));\r\n                    return [2 /*return*/, surface];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport var IsosurfaceMeshParams = __assign(__assign(__assign(__assign({}, Mesh.Params), TextureMesh.Params), VolumeIsosurfaceParams), { quality: __assign(__assign({}, Mesh.Params.quality), { isEssential: false }), tryUseGpu: PD.Boolean(true) });\r\nexport function IsosurfaceMeshVisual(materialId) {\r\n    return VolumeVisual({\r\n        defaultProps: PD.getDefaultValues(IsosurfaceMeshParams),\r\n        createGeometry: createVolumeIsosurfaceMesh,\r\n        createLocationIterator: function (volume) { return LocationIterator(volume.grid.cells.data.length, 1, 1, function () { return NullLocation; }); },\r\n        getLoci: getIsosurfaceLoci,\r\n        eachLocation: eachIsosurface,\r\n        setUpdateState: function (state, volume, newProps, currentProps) {\r\n            if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats))\r\n                state.createGeometry = true;\r\n        },\r\n        geometryUtils: Mesh.Utils,\r\n        mustRecreate: function (volume, props, webgl) {\r\n            return props.tryUseGpu && !!webgl && suitableForGpu(volume, webgl);\r\n        }\r\n    }, materialId);\r\n}\r\n//\r\nvar VolumeIsosurfaceTexture;\r\n(function (VolumeIsosurfaceTexture) {\r\n    var name = 'volume-isosurface-texture';\r\n    VolumeIsosurfaceTexture.descriptor = CustomPropertyDescriptor({ name: name });\r\n    function get(volume, webgl) {\r\n        var resources = webgl.resources;\r\n        var transform = Grid.getGridToCartesianTransform(volume.grid);\r\n        var gridDimension = Vec3.clone(volume.grid.cells.space.dimensions);\r\n        var _a = getVolumeTexture2dLayout(gridDimension, Padding), width = _a.width, height = _a.height, texDim = _a.powerOfTwoSize;\r\n        var gridTexDim = Vec3.create(width, height, 0);\r\n        var gridTexScale = Vec2.create(width / texDim, height / texDim);\r\n        // console.log({ texDim, width, height, gridDimension });\r\n        if (texDim > webgl.maxTextureSize / 2) {\r\n            throw new Error('volume too large for gpu isosurface extraction');\r\n        }\r\n        if (!volume._propertyData[name]) {\r\n            volume._propertyData[name] = resources.texture('image-uint8', 'alpha', 'ubyte', 'linear');\r\n            var texture_1 = volume._propertyData[name];\r\n            texture_1.define(texDim, texDim);\r\n            // load volume into sub-section of texture\r\n            texture_1.load(createVolumeTexture2d(volume, 'data', Padding), true);\r\n            volume.customProperties.add(VolumeIsosurfaceTexture.descriptor);\r\n            volume.customProperties.assets(VolumeIsosurfaceTexture.descriptor, [{ dispose: function () { return texture_1.destroy(); } }]);\r\n        }\r\n        gridDimension[0] += Padding;\r\n        gridDimension[1] += Padding;\r\n        return {\r\n            texture: volume._propertyData[name],\r\n            transform: transform,\r\n            gridDimension: gridDimension,\r\n            gridTexDim: gridTexDim,\r\n            gridTexScale: gridTexScale\r\n        };\r\n    }\r\n    VolumeIsosurfaceTexture.get = get;\r\n})(VolumeIsosurfaceTexture || (VolumeIsosurfaceTexture = {}));\r\nfunction createVolumeIsosurfaceTextureMesh(ctx, volume, theme, props, textureMesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, max, min, diff, value, isoLevel, _b, texture, gridDimension, gridTexDim, gridTexScale, transform, buffer, gv, surface;\r\n        return __generator(this, function (_c) {\r\n            if (!ctx.webgl)\r\n                throw new Error('webgl context required to create volume isosurface texture-mesh');\r\n            _a = volume.grid.stats, max = _a.max, min = _a.min;\r\n            diff = max - min;\r\n            value = Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue;\r\n            isoLevel = ((value - min) / diff);\r\n            _b = VolumeIsosurfaceTexture.get(volume, ctx.webgl), texture = _b.texture, gridDimension = _b.gridDimension, gridTexDim = _b.gridTexDim, gridTexScale = _b.gridTexScale, transform = _b.transform;\r\n            buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\r\n            gv = extractIsosurface(ctx.webgl, texture, gridDimension, gridTexDim, gridTexScale, transform, isoLevel, value < 0, false, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\r\n            surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, Volume.getBoundingSphere(volume), textureMesh);\r\n            return [2 /*return*/, surface];\r\n        });\r\n    });\r\n}\r\nexport function IsosurfaceTextureMeshVisual(materialId) {\r\n    return VolumeVisual({\r\n        defaultProps: PD.getDefaultValues(IsosurfaceMeshParams),\r\n        createGeometry: createVolumeIsosurfaceTextureMesh,\r\n        createLocationIterator: function (volume) { return LocationIterator(volume.grid.cells.data.length, 1, 1, function () { return NullLocation; }); },\r\n        getLoci: getIsosurfaceLoci,\r\n        eachLocation: eachIsosurface,\r\n        setUpdateState: function (state, volume, newProps, currentProps) {\r\n            if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats))\r\n                state.createGeometry = true;\r\n        },\r\n        geometryUtils: TextureMesh.Utils,\r\n        mustRecreate: function (volume, props, webgl) {\r\n            return !props.tryUseGpu || !webgl || !suitableForGpu(volume, webgl);\r\n        },\r\n        dispose: function (geometry) {\r\n            geometry.vertexTexture.ref.value.destroy();\r\n            geometry.groupTexture.ref.value.destroy();\r\n            geometry.normalTexture.ref.value.destroy();\r\n            geometry.doubleBuffer.destroy();\r\n        }\r\n    }, materialId);\r\n}\r\n//\r\nexport function createVolumeIsosurfaceWireframe(ctx, volume, theme, props, lines) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ids, wireframe, transform;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ctx.runtime.update({ message: 'Marching cubes...' });\r\n                    ids = fillSerial(new Int32Array(volume.grid.cells.data.length));\r\n                    return [4 /*yield*/, computeMarchingCubesLines({\r\n                            isoLevel: Volume.IsoValue.toAbsolute(props.isoValue, volume.grid.stats).absoluteValue,\r\n                            scalarField: volume.grid.cells,\r\n                            idField: Tensor.create(volume.grid.cells.space, Tensor.Data1(ids))\r\n                        }, lines).runAsChild(ctx.runtime)];\r\n                case 1:\r\n                    wireframe = _a.sent();\r\n                    transform = Grid.getGridToCartesianTransform(volume.grid);\r\n                    Lines.transform(wireframe, transform);\r\n                    wireframe.setBoundingSphere(Volume.getBoundingSphere(volume));\r\n                    return [2 /*return*/, wireframe];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport var IsosurfaceWireframeParams = __assign(__assign(__assign({}, Lines.Params), VolumeIsosurfaceParams), { quality: __assign(__assign({}, Lines.Params.quality), { isEssential: false }), sizeFactor: PD.Numeric(3, { min: 0, max: 10, step: 0.1 }) });\r\nexport function IsosurfaceWireframeVisual(materialId) {\r\n    return VolumeVisual({\r\n        defaultProps: PD.getDefaultValues(IsosurfaceWireframeParams),\r\n        createGeometry: createVolumeIsosurfaceWireframe,\r\n        createLocationIterator: function (volume) { return LocationIterator(volume.grid.cells.data.length, 1, 1, function () { return NullLocation; }); },\r\n        getLoci: getIsosurfaceLoci,\r\n        eachLocation: eachIsosurface,\r\n        setUpdateState: function (state, volume, newProps, currentProps) {\r\n            if (!Volume.IsoValue.areSame(newProps.isoValue, currentProps.isoValue, volume.grid.stats))\r\n                state.createGeometry = true;\r\n        },\r\n        geometryUtils: Lines.Utils\r\n    }, materialId);\r\n}\r\n//\r\nvar IsosurfaceVisuals = {\r\n    'solid': function (ctx, getParams) { return VolumeRepresentation('Isosurface mesh', ctx, getParams, IsosurfaceVisual, getLoci); },\r\n    'wireframe': function (ctx, getParams) { return VolumeRepresentation('Isosurface wireframe', ctx, getParams, IsosurfaceWireframeVisual, getLoci); },\r\n};\r\nexport var IsosurfaceParams = __assign(__assign(__assign({}, IsosurfaceMeshParams), IsosurfaceWireframeParams), { visuals: PD.MultiSelect(['solid'], PD.objectToOptions(IsosurfaceVisuals)) });\r\nexport function getIsosurfaceParams(ctx, volume) {\r\n    var p = PD.clone(IsosurfaceParams);\r\n    p.isoValue = Volume.createIsoValueParam(Volume.IsoValue.relative(2), volume.grid.stats);\r\n    return p;\r\n}\r\nexport function IsosurfaceRepresentation(ctx, getParams) {\r\n    return Representation.createMulti('Isosurface', ctx, getParams, Representation.StateBuilder, IsosurfaceVisuals);\r\n}\r\nexport var IsosurfaceRepresentationProvider = VolumeRepresentationProvider({\r\n    name: 'isosurface',\r\n    label: 'Isosurface',\r\n    description: 'Displays a triangulated isosurface of volumetric data.',\r\n    factory: IsosurfaceRepresentation,\r\n    getParams: getIsosurfaceParams,\r\n    defaultValues: PD.getDefaultValues(IsosurfaceParams),\r\n    defaultColorTheme: { name: 'uniform' },\r\n    defaultSizeTheme: { name: 'uniform' },\r\n    isApplicable: function (volume) { return !Volume.isEmpty(volume); }\r\n});\r\n//# sourceMappingURL=isosurface.js.map"]},"metadata":{},"sourceType":"module"}