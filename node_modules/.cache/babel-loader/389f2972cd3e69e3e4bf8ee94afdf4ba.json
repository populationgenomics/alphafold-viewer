{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Vec3, Mat4 } from '../../../../mol-math/linear-algebra';\nimport { MeshBuilder } from '../mesh-builder';\nimport { transformPrimitive } from '../../../primitive/primitive';\nimport { Cylinder, DefaultCylinderProps } from '../../../primitive/cylinder';\nimport { Prism } from '../../../primitive/prism';\nimport { polygon } from '../../../primitive/polygon';\nimport { hashFnv32a } from '../../../../mol-data/util';\nvar cylinderMap = new Map();\nvar up = Vec3.create(0, 1, 0);\nvar tmpCylinderDir = Vec3();\nvar tmpCylinderMatDir = Vec3();\nvar tmpCylinderCenter = Vec3();\nvar tmpCylinderMat = Mat4();\nvar tmpCylinderMatRot = Mat4();\nvar tmpCylinderScale = Vec3();\nvar tmpCylinderStart = Vec3();\nvar tmpUp = Vec3();\n\nfunction setCylinderMat(m, start, dir, length, matchDir) {\n  Vec3.setMagnitude(tmpCylinderMatDir, dir, length / 2);\n  Vec3.add(tmpCylinderCenter, start, tmpCylinderMatDir); // ensure the direction used to create the rotation is always pointing in the same\n  // direction so the triangles of adjacent cylinder will line up\n\n  if (matchDir) Vec3.matchDirection(tmpUp, up, tmpCylinderMatDir);else Vec3.copy(tmpUp, up);\n  Vec3.set(tmpCylinderScale, 1, length, 1);\n  Vec3.makeRotation(tmpCylinderMatRot, tmpUp, tmpCylinderMatDir);\n  Mat4.scale(m, tmpCylinderMatRot, tmpCylinderScale);\n  return Mat4.setTranslation(m, tmpCylinderCenter);\n}\n\nvar tmpPropValues = new Int32Array(9);\n\nfunction getCylinderPropsKey(props) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  tmpPropValues[0] = Math.round(1000 * ((_a = props.radiusTop) !== null && _a !== void 0 ? _a : DefaultCylinderProps.radiusTop));\n  tmpPropValues[1] = Math.round(1000 * ((_b = props.radiusBottom) !== null && _b !== void 0 ? _b : DefaultCylinderProps.radiusBottom));\n  tmpPropValues[2] = Math.round(1000 * ((_c = props.height) !== null && _c !== void 0 ? _c : DefaultCylinderProps.height));\n  tmpPropValues[3] = (_d = props.radialSegments) !== null && _d !== void 0 ? _d : DefaultCylinderProps.radialSegments;\n  tmpPropValues[4] = (_e = props.heightSegments) !== null && _e !== void 0 ? _e : DefaultCylinderProps.heightSegments;\n  tmpPropValues[5] = ((_f = props.topCap) !== null && _f !== void 0 ? _f : DefaultCylinderProps.topCap) ? 1 : 0;\n  tmpPropValues[6] = ((_g = props.bottomCap) !== null && _g !== void 0 ? _g : DefaultCylinderProps.bottomCap) ? 1 : 0;\n  tmpPropValues[7] = Math.round(1000 * ((_h = props.thetaStart) !== null && _h !== void 0 ? _h : DefaultCylinderProps.thetaStart));\n  tmpPropValues[8] = Math.round(1000 * ((_j = props.thetaLength) !== null && _j !== void 0 ? _j : DefaultCylinderProps.thetaLength));\n  return hashFnv32a(tmpPropValues);\n}\n\nfunction getCylinder(props) {\n  var key = getCylinderPropsKey(props);\n  var cylinder = cylinderMap.get(key);\n\n  if (cylinder === undefined) {\n    if (props.radialSegments && props.radialSegments <= 4) {\n      var sideCount = Math.max(3, props.radialSegments);\n      var prism = Prism(polygon(sideCount, true, props.radiusTop), props);\n      cylinder = transformPrimitive(prism, Mat4.rotX90);\n    } else {\n      cylinder = Cylinder(props);\n    }\n\n    cylinderMap.set(key, cylinder);\n  }\n\n  return cylinder;\n}\n\nexport function addSimpleCylinder(state, start, end, props) {\n  var d = Vec3.distance(start, end);\n  Vec3.sub(tmpCylinderDir, end, start);\n  setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d, false);\n  MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));\n}\nexport function addCylinder(state, start, end, lengthScale, props) {\n  var d = Vec3.distance(start, end) * lengthScale;\n  Vec3.sub(tmpCylinderDir, end, start);\n  setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d, true);\n  MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));\n}\nexport function addDoubleCylinder(state, start, end, lengthScale, shift, props) {\n  var d = Vec3.distance(start, end) * lengthScale;\n  var cylinder = getCylinder(props);\n  Vec3.sub(tmpCylinderDir, end, start); // positivly shifted cylinder\n\n  Vec3.add(tmpCylinderStart, start, shift);\n  setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d, true);\n  MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder); // negativly shifted cylinder\n\n  Vec3.sub(tmpCylinderStart, start, shift);\n  setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d, true);\n  MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);\n}\nexport function addFixedCountDashedCylinder(state, start, end, lengthScale, segmentCount, props) {\n  var s = Math.floor(segmentCount / 2);\n  var step = 1 / segmentCount; // automatically adjust length so links/bonds that are rendered as two half cylinders\n  // have evenly spaced dashed cylinders\n\n  if (lengthScale < 1) {\n    var bias = lengthScale / 2 / segmentCount;\n    lengthScale += segmentCount % 2 === 1 ? bias : -bias;\n  }\n\n  var d = Vec3.distance(start, end) * lengthScale;\n  var cylinder = getCylinder(props);\n  Vec3.sub(tmpCylinderDir, end, start);\n\n  for (var j = 0; j < s; ++j) {\n    var f = step * (j * 2 + 1);\n    Vec3.setMagnitude(tmpCylinderDir, tmpCylinderDir, d * f);\n    Vec3.add(tmpCylinderStart, start, tmpCylinderDir);\n    setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d * step, false);\n    MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-geo/geometry/mesh/builder/cylinder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Vec3, Mat4 } from '../../../../mol-math/linear-algebra';\r\nimport { MeshBuilder } from '../mesh-builder';\r\nimport { transformPrimitive } from '../../../primitive/primitive';\r\nimport { Cylinder, DefaultCylinderProps } from '../../../primitive/cylinder';\r\nimport { Prism } from '../../../primitive/prism';\r\nimport { polygon } from '../../../primitive/polygon';\r\nimport { hashFnv32a } from '../../../../mol-data/util';\r\nvar cylinderMap = new Map();\r\nvar up = Vec3.create(0, 1, 0);\r\nvar tmpCylinderDir = Vec3();\r\nvar tmpCylinderMatDir = Vec3();\r\nvar tmpCylinderCenter = Vec3();\r\nvar tmpCylinderMat = Mat4();\r\nvar tmpCylinderMatRot = Mat4();\r\nvar tmpCylinderScale = Vec3();\r\nvar tmpCylinderStart = Vec3();\r\nvar tmpUp = Vec3();\r\nfunction setCylinderMat(m, start, dir, length, matchDir) {\r\n    Vec3.setMagnitude(tmpCylinderMatDir, dir, length / 2);\r\n    Vec3.add(tmpCylinderCenter, start, tmpCylinderMatDir);\r\n    // ensure the direction used to create the rotation is always pointing in the same\r\n    // direction so the triangles of adjacent cylinder will line up\r\n    if (matchDir)\r\n        Vec3.matchDirection(tmpUp, up, tmpCylinderMatDir);\r\n    else\r\n        Vec3.copy(tmpUp, up);\r\n    Vec3.set(tmpCylinderScale, 1, length, 1);\r\n    Vec3.makeRotation(tmpCylinderMatRot, tmpUp, tmpCylinderMatDir);\r\n    Mat4.scale(m, tmpCylinderMatRot, tmpCylinderScale);\r\n    return Mat4.setTranslation(m, tmpCylinderCenter);\r\n}\r\nvar tmpPropValues = new Int32Array(9);\r\nfunction getCylinderPropsKey(props) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\r\n    tmpPropValues[0] = Math.round(1000 * ((_a = props.radiusTop) !== null && _a !== void 0 ? _a : DefaultCylinderProps.radiusTop));\r\n    tmpPropValues[1] = Math.round(1000 * ((_b = props.radiusBottom) !== null && _b !== void 0 ? _b : DefaultCylinderProps.radiusBottom));\r\n    tmpPropValues[2] = Math.round(1000 * ((_c = props.height) !== null && _c !== void 0 ? _c : DefaultCylinderProps.height));\r\n    tmpPropValues[3] = (_d = props.radialSegments) !== null && _d !== void 0 ? _d : DefaultCylinderProps.radialSegments;\r\n    tmpPropValues[4] = (_e = props.heightSegments) !== null && _e !== void 0 ? _e : DefaultCylinderProps.heightSegments;\r\n    tmpPropValues[5] = ((_f = props.topCap) !== null && _f !== void 0 ? _f : DefaultCylinderProps.topCap) ? 1 : 0;\r\n    tmpPropValues[6] = ((_g = props.bottomCap) !== null && _g !== void 0 ? _g : DefaultCylinderProps.bottomCap) ? 1 : 0;\r\n    tmpPropValues[7] = Math.round(1000 * ((_h = props.thetaStart) !== null && _h !== void 0 ? _h : DefaultCylinderProps.thetaStart));\r\n    tmpPropValues[8] = Math.round(1000 * ((_j = props.thetaLength) !== null && _j !== void 0 ? _j : DefaultCylinderProps.thetaLength));\r\n    return hashFnv32a(tmpPropValues);\r\n}\r\nfunction getCylinder(props) {\r\n    var key = getCylinderPropsKey(props);\r\n    var cylinder = cylinderMap.get(key);\r\n    if (cylinder === undefined) {\r\n        if (props.radialSegments && props.radialSegments <= 4) {\r\n            var sideCount = Math.max(3, props.radialSegments);\r\n            var prism = Prism(polygon(sideCount, true, props.radiusTop), props);\r\n            cylinder = transformPrimitive(prism, Mat4.rotX90);\r\n        }\r\n        else {\r\n            cylinder = Cylinder(props);\r\n        }\r\n        cylinderMap.set(key, cylinder);\r\n    }\r\n    return cylinder;\r\n}\r\nexport function addSimpleCylinder(state, start, end, props) {\r\n    var d = Vec3.distance(start, end);\r\n    Vec3.sub(tmpCylinderDir, end, start);\r\n    setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d, false);\r\n    MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));\r\n}\r\nexport function addCylinder(state, start, end, lengthScale, props) {\r\n    var d = Vec3.distance(start, end) * lengthScale;\r\n    Vec3.sub(tmpCylinderDir, end, start);\r\n    setCylinderMat(tmpCylinderMat, start, tmpCylinderDir, d, true);\r\n    MeshBuilder.addPrimitive(state, tmpCylinderMat, getCylinder(props));\r\n}\r\nexport function addDoubleCylinder(state, start, end, lengthScale, shift, props) {\r\n    var d = Vec3.distance(start, end) * lengthScale;\r\n    var cylinder = getCylinder(props);\r\n    Vec3.sub(tmpCylinderDir, end, start);\r\n    // positivly shifted cylinder\r\n    Vec3.add(tmpCylinderStart, start, shift);\r\n    setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d, true);\r\n    MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);\r\n    // negativly shifted cylinder\r\n    Vec3.sub(tmpCylinderStart, start, shift);\r\n    setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d, true);\r\n    MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);\r\n}\r\nexport function addFixedCountDashedCylinder(state, start, end, lengthScale, segmentCount, props) {\r\n    var s = Math.floor(segmentCount / 2);\r\n    var step = 1 / segmentCount;\r\n    // automatically adjust length so links/bonds that are rendered as two half cylinders\r\n    // have evenly spaced dashed cylinders\r\n    if (lengthScale < 1) {\r\n        var bias = lengthScale / 2 / segmentCount;\r\n        lengthScale += segmentCount % 2 === 1 ? bias : -bias;\r\n    }\r\n    var d = Vec3.distance(start, end) * lengthScale;\r\n    var cylinder = getCylinder(props);\r\n    Vec3.sub(tmpCylinderDir, end, start);\r\n    for (var j = 0; j < s; ++j) {\r\n        var f = step * (j * 2 + 1);\r\n        Vec3.setMagnitude(tmpCylinderDir, tmpCylinderDir, d * f);\r\n        Vec3.add(tmpCylinderStart, start, tmpCylinderDir);\r\n        setCylinderMat(tmpCylinderMat, tmpCylinderStart, tmpCylinderDir, d * step, false);\r\n        MeshBuilder.addPrimitive(state, tmpCylinderMat, cylinder);\r\n    }\r\n}\r\n//# sourceMappingURL=cylinder.js.map"]},"metadata":{},"sourceType":"module"}