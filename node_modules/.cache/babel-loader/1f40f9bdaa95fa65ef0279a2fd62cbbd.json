{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task, chunkedSubtask } from '../../../mol-task';\nimport { Tokenizer, TokenBuilder } from '../common/text/tokenizer';\nimport { ReaderResult as Result } from '../result';\nimport { TokenColumnProvider as TokenColumn } from '../common/text/column/token';\nimport { Column } from '../../../mol-data/db';\nvar readLine = Tokenizer.readLine,\n    skipWhitespace = Tokenizer.skipWhitespace,\n    eatValue = Tokenizer.eatValue,\n    eatLine = Tokenizer.eatLine,\n    markStart = Tokenizer.markStart;\nvar reWhitespace = /\\s+/;\nvar reTitle = /(^\\*|REMARK)*/;\n\nfunction State(tokenizer, runtimeCtx) {\n  return {\n    tokenizer: tokenizer,\n    runtimeCtx: runtimeCtx\n  };\n}\n\nfunction handleAtoms(state, count) {\n  return __awaiter(this, void 0, void 0, function () {\n    var tokenizer, atomId, segmentName, residueId, residueName, atomName, atomType, charge, mass, position, line, isLammpsFull, n, length, linesAlreadyRead;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          tokenizer = state.tokenizer;\n          atomId = TokenBuilder.create(tokenizer.data, count * 2);\n          segmentName = TokenBuilder.create(tokenizer.data, count * 2);\n          residueId = TokenBuilder.create(tokenizer.data, count * 2);\n          residueName = TokenBuilder.create(tokenizer.data, count * 2);\n          atomName = TokenBuilder.create(tokenizer.data, count * 2);\n          atomType = TokenBuilder.create(tokenizer.data, count * 2);\n          charge = TokenBuilder.create(tokenizer.data, count * 2);\n          mass = TokenBuilder.create(tokenizer.data, count * 2);\n          position = tokenizer.position;\n          line = readLine(tokenizer).trim();\n          tokenizer.position = position;\n          isLammpsFull = line.split(reWhitespace).length === 7;\n          n = isLammpsFull ? 6 : 8;\n          length = tokenizer.length;\n          linesAlreadyRead = 0;\n          return [4\n          /*yield*/\n          , chunkedSubtask(state.runtimeCtx, 100000, void 0, function (chunkSize) {\n            var linesToRead = Math.min(count - linesAlreadyRead, chunkSize);\n\n            for (var i = 0; i < linesToRead; ++i) {\n              for (var j = 0; j < n; ++j) {\n                skipWhitespace(tokenizer);\n                markStart(tokenizer);\n                eatValue(tokenizer);\n\n                if (isLammpsFull) {\n                  switch (j) {\n                    case 0:\n                      TokenBuilder.addUnchecked(atomId, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 1:\n                      TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 2:\n                      TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 3:\n                      TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 4:\n                      TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 5:\n                      TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n                  }\n                } else {\n                  switch (j) {\n                    case 0:\n                      TokenBuilder.addUnchecked(atomId, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 1:\n                      TokenBuilder.addUnchecked(segmentName, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 2:\n                      TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 3:\n                      TokenBuilder.addUnchecked(residueName, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 4:\n                      TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 5:\n                      TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 6:\n                      TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n\n                    case 7:\n                      TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);\n                      break;\n                  }\n                }\n              } // ignore any extra columns\n\n\n              eatLine(tokenizer);\n              markStart(tokenizer);\n            }\n\n            linesAlreadyRead += linesToRead;\n            return linesToRead;\n          }, function (ctx) {\n            return ctx.update({\n              message: 'Parsing...',\n              current: tokenizer.position,\n              max: length\n            });\n          })];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          , {\n            count: count,\n            atomId: TokenColumn(atomId)(Column.Schema.int),\n            segmentName: isLammpsFull ? TokenColumn(residueId)(Column.Schema.str) : TokenColumn(segmentName)(Column.Schema.str),\n            residueId: TokenColumn(residueId)(Column.Schema.int),\n            residueName: isLammpsFull ? TokenColumn(residueId)(Column.Schema.str) : TokenColumn(residueName)(Column.Schema.str),\n            atomName: TokenColumn(atomName)(Column.Schema.str),\n            atomType: TokenColumn(atomType)(Column.Schema.str),\n            charge: TokenColumn(charge)(Column.Schema.float),\n            mass: TokenColumn(mass)(Column.Schema.float)\n          }];\n      }\n    });\n  });\n}\n\nfunction handleBonds(state, count) {\n  return __awaiter(this, void 0, void 0, function () {\n    var tokenizer, atomIdA, atomIdB, length, bondsAlreadyRead;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          tokenizer = state.tokenizer;\n          atomIdA = TokenBuilder.create(tokenizer.data, count * 2);\n          atomIdB = TokenBuilder.create(tokenizer.data, count * 2);\n          length = tokenizer.length;\n          bondsAlreadyRead = 0;\n          return [4\n          /*yield*/\n          , chunkedSubtask(state.runtimeCtx, 10, void 0, function (chunkSize) {\n            var bondsToRead = Math.min(count - bondsAlreadyRead, chunkSize);\n\n            for (var i = 0; i < bondsToRead; ++i) {\n              for (var j = 0; j < 2; ++j) {\n                skipWhitespace(tokenizer);\n                markStart(tokenizer);\n                eatValue(tokenizer);\n\n                switch (j) {\n                  case 0:\n                    TokenBuilder.addUnchecked(atomIdA, tokenizer.tokenStart, tokenizer.tokenEnd);\n                    break;\n\n                  case 1:\n                    TokenBuilder.addUnchecked(atomIdB, tokenizer.tokenStart, tokenizer.tokenEnd);\n                    break;\n                }\n              }\n            }\n\n            bondsAlreadyRead += bondsToRead;\n            return bondsToRead;\n          }, function (ctx) {\n            return ctx.update({\n              message: 'Parsing...',\n              current: tokenizer.position,\n              max: length\n            });\n          })];\n\n        case 1:\n          _a.sent();\n\n          return [2\n          /*return*/\n          , {\n            count: count,\n            atomIdA: TokenColumn(atomIdA)(Column.Schema.int),\n            atomIdB: TokenColumn(atomIdB)(Column.Schema.int)\n          }];\n      }\n    });\n  });\n}\n\nfunction parseTitle(state, count) {\n  var title = [];\n\n  for (var i = 0; i < count; ++i) {\n    var line = readLine(state.tokenizer);\n    title.push(line.replace(reTitle, '').trim());\n  }\n\n  return title;\n}\n\nfunction parseInternal(data, ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var tokenizer, state, title, atoms, bonds, id, line, numTitle, numAtoms, numBonds, result;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          tokenizer = Tokenizer(data);\n          state = State(tokenizer, ctx);\n          title = undefined;\n          atoms = undefined;\n          bonds = undefined;\n          id = readLine(state.tokenizer).trim();\n          _a.label = 1;\n\n        case 1:\n          if (!(tokenizer.tokenEnd < tokenizer.length)) return [3\n          /*break*/\n          , 8];\n          line = readLine(state.tokenizer).trim();\n          if (!line.includes('!NTITLE')) return [3\n          /*break*/\n          , 2];\n          numTitle = parseInt(line.split(reWhitespace)[0]);\n          title = parseTitle(state, numTitle);\n          return [3\n          /*break*/\n          , 7];\n\n        case 2:\n          if (!line.includes('!NATOM')) return [3\n          /*break*/\n          , 4];\n          numAtoms = parseInt(line.split(reWhitespace)[0]);\n          return [4\n          /*yield*/\n          , handleAtoms(state, numAtoms)];\n\n        case 3:\n          atoms = _a.sent();\n          return [3\n          /*break*/\n          , 7];\n\n        case 4:\n          if (!line.includes('!NBOND')) return [3\n          /*break*/\n          , 6];\n          numBonds = parseInt(line.split(reWhitespace)[0]);\n          return [4\n          /*yield*/\n          , handleBonds(state, numBonds)];\n\n        case 5:\n          bonds = _a.sent();\n          return [3\n          /*break*/\n          , 8];\n        // TODO: don't break when the below are implemented\n\n        case 6:\n          if (line.includes('!NTHETA')) {// TODO\n          } else if (line.includes('!NPHI')) {// TODO\n          } else if (line.includes('!NIMPHI')) {// TODO\n          } else if (line.includes('!NDON')) {// TODO\n          } else if (line.includes('!NACC')) {// TODO\n          } else if (line.includes('!NNB')) {// TODO\n          } else if (line.includes('!NGRP NST2')) {// TODO\n          } else if (line.includes('!MOLNT')) {// TODO\n          } else if (line.includes('!NUMLP NUMLPH')) {// TODO\n          } else if (line.includes('!NCRTERM')) {// TODO\n          }\n\n          _a.label = 7;\n\n        case 7:\n          return [3\n          /*break*/\n          , 1];\n\n        case 8:\n          if (title === undefined) {\n            title = [];\n          }\n\n          if (atoms === undefined) {\n            return [2\n            /*return*/\n            , Result.error('no atoms data')];\n          }\n\n          if (bonds === undefined) {\n            return [2\n            /*return*/\n            , Result.error('no bonds data')];\n          }\n\n          result = {\n            id: id,\n            title: title,\n            atoms: atoms,\n            bonds: bonds\n          };\n          return [2\n          /*return*/\n          , Result.success(result)];\n      }\n    });\n  });\n}\n\nexport function parsePsf(data) {\n  var _this = this;\n\n  return Task.create('Parse PSF', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , parseInternal(data, ctx)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../src/mol-io/reader/psf/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task, chunkedSubtask } from '../../../mol-task';\r\nimport { Tokenizer, TokenBuilder } from '../common/text/tokenizer';\r\nimport { ReaderResult as Result } from '../result';\r\nimport { TokenColumnProvider as TokenColumn } from '../common/text/column/token';\r\nimport { Column } from '../../../mol-data/db';\r\nvar readLine = Tokenizer.readLine, skipWhitespace = Tokenizer.skipWhitespace, eatValue = Tokenizer.eatValue, eatLine = Tokenizer.eatLine, markStart = Tokenizer.markStart;\r\nvar reWhitespace = /\\s+/;\r\nvar reTitle = /(^\\*|REMARK)*/;\r\nfunction State(tokenizer, runtimeCtx) {\r\n    return {\r\n        tokenizer: tokenizer,\r\n        runtimeCtx: runtimeCtx,\r\n    };\r\n}\r\nfunction handleAtoms(state, count) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tokenizer, atomId, segmentName, residueId, residueName, atomName, atomType, charge, mass, position, line, isLammpsFull, n, length, linesAlreadyRead;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    tokenizer = state.tokenizer;\r\n                    atomId = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    segmentName = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    residueId = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    residueName = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    atomName = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    atomType = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    charge = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    mass = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    position = tokenizer.position;\r\n                    line = readLine(tokenizer).trim();\r\n                    tokenizer.position = position;\r\n                    isLammpsFull = line.split(reWhitespace).length === 7;\r\n                    n = isLammpsFull ? 6 : 8;\r\n                    length = tokenizer.length;\r\n                    linesAlreadyRead = 0;\r\n                    return [4 /*yield*/, chunkedSubtask(state.runtimeCtx, 100000, void 0, function (chunkSize) {\r\n                            var linesToRead = Math.min(count - linesAlreadyRead, chunkSize);\r\n                            for (var i = 0; i < linesToRead; ++i) {\r\n                                for (var j = 0; j < n; ++j) {\r\n                                    skipWhitespace(tokenizer);\r\n                                    markStart(tokenizer);\r\n                                    eatValue(tokenizer);\r\n                                    if (isLammpsFull) {\r\n                                        switch (j) {\r\n                                            case 0:\r\n                                                TokenBuilder.addUnchecked(atomId, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 1:\r\n                                                TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 2:\r\n                                                TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 3:\r\n                                                TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 4:\r\n                                                TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 5:\r\n                                                TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                        }\r\n                                    }\r\n                                    else {\r\n                                        switch (j) {\r\n                                            case 0:\r\n                                                TokenBuilder.addUnchecked(atomId, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 1:\r\n                                                TokenBuilder.addUnchecked(segmentName, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 2:\r\n                                                TokenBuilder.addUnchecked(residueId, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 3:\r\n                                                TokenBuilder.addUnchecked(residueName, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 4:\r\n                                                TokenBuilder.addUnchecked(atomName, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 5:\r\n                                                TokenBuilder.addUnchecked(atomType, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 6:\r\n                                                TokenBuilder.addUnchecked(charge, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                            case 7:\r\n                                                TokenBuilder.addUnchecked(mass, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                                break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                // ignore any extra columns\r\n                                eatLine(tokenizer);\r\n                                markStart(tokenizer);\r\n                            }\r\n                            linesAlreadyRead += linesToRead;\r\n                            return linesToRead;\r\n                        }, function (ctx) { return ctx.update({ message: 'Parsing...', current: tokenizer.position, max: length }); })];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/, {\r\n                            count: count,\r\n                            atomId: TokenColumn(atomId)(Column.Schema.int),\r\n                            segmentName: isLammpsFull\r\n                                ? TokenColumn(residueId)(Column.Schema.str)\r\n                                : TokenColumn(segmentName)(Column.Schema.str),\r\n                            residueId: TokenColumn(residueId)(Column.Schema.int),\r\n                            residueName: isLammpsFull\r\n                                ? TokenColumn(residueId)(Column.Schema.str)\r\n                                : TokenColumn(residueName)(Column.Schema.str),\r\n                            atomName: TokenColumn(atomName)(Column.Schema.str),\r\n                            atomType: TokenColumn(atomType)(Column.Schema.str),\r\n                            charge: TokenColumn(charge)(Column.Schema.float),\r\n                            mass: TokenColumn(mass)(Column.Schema.float)\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction handleBonds(state, count) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tokenizer, atomIdA, atomIdB, length, bondsAlreadyRead;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    tokenizer = state.tokenizer;\r\n                    atomIdA = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    atomIdB = TokenBuilder.create(tokenizer.data, count * 2);\r\n                    length = tokenizer.length;\r\n                    bondsAlreadyRead = 0;\r\n                    return [4 /*yield*/, chunkedSubtask(state.runtimeCtx, 10, void 0, function (chunkSize) {\r\n                            var bondsToRead = Math.min(count - bondsAlreadyRead, chunkSize);\r\n                            for (var i = 0; i < bondsToRead; ++i) {\r\n                                for (var j = 0; j < 2; ++j) {\r\n                                    skipWhitespace(tokenizer);\r\n                                    markStart(tokenizer);\r\n                                    eatValue(tokenizer);\r\n                                    switch (j) {\r\n                                        case 0:\r\n                                            TokenBuilder.addUnchecked(atomIdA, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                            break;\r\n                                        case 1:\r\n                                            TokenBuilder.addUnchecked(atomIdB, tokenizer.tokenStart, tokenizer.tokenEnd);\r\n                                            break;\r\n                                    }\r\n                                }\r\n                            }\r\n                            bondsAlreadyRead += bondsToRead;\r\n                            return bondsToRead;\r\n                        }, function (ctx) { return ctx.update({ message: 'Parsing...', current: tokenizer.position, max: length }); })];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [2 /*return*/, {\r\n                            count: count,\r\n                            atomIdA: TokenColumn(atomIdA)(Column.Schema.int),\r\n                            atomIdB: TokenColumn(atomIdB)(Column.Schema.int),\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction parseTitle(state, count) {\r\n    var title = [];\r\n    for (var i = 0; i < count; ++i) {\r\n        var line = readLine(state.tokenizer);\r\n        title.push(line.replace(reTitle, '').trim());\r\n    }\r\n    return title;\r\n}\r\nfunction parseInternal(data, ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var tokenizer, state, title, atoms, bonds, id, line, numTitle, numAtoms, numBonds, result;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    tokenizer = Tokenizer(data);\r\n                    state = State(tokenizer, ctx);\r\n                    title = undefined;\r\n                    atoms = undefined;\r\n                    bonds = undefined;\r\n                    id = readLine(state.tokenizer).trim();\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(tokenizer.tokenEnd < tokenizer.length)) return [3 /*break*/, 8];\r\n                    line = readLine(state.tokenizer).trim();\r\n                    if (!line.includes('!NTITLE')) return [3 /*break*/, 2];\r\n                    numTitle = parseInt(line.split(reWhitespace)[0]);\r\n                    title = parseTitle(state, numTitle);\r\n                    return [3 /*break*/, 7];\r\n                case 2:\r\n                    if (!line.includes('!NATOM')) return [3 /*break*/, 4];\r\n                    numAtoms = parseInt(line.split(reWhitespace)[0]);\r\n                    return [4 /*yield*/, handleAtoms(state, numAtoms)];\r\n                case 3:\r\n                    atoms = _a.sent();\r\n                    return [3 /*break*/, 7];\r\n                case 4:\r\n                    if (!line.includes('!NBOND')) return [3 /*break*/, 6];\r\n                    numBonds = parseInt(line.split(reWhitespace)[0]);\r\n                    return [4 /*yield*/, handleBonds(state, numBonds)];\r\n                case 5:\r\n                    bonds = _a.sent();\r\n                    return [3 /*break*/, 8]; // TODO: don't break when the below are implemented\r\n                case 6:\r\n                    if (line.includes('!NTHETA')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NPHI')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NIMPHI')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NDON')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NACC')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NNB')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NGRP NST2')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!MOLNT')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NUMLP NUMLPH')) {\r\n                        // TODO\r\n                    }\r\n                    else if (line.includes('!NCRTERM')) {\r\n                        // TODO\r\n                    }\r\n                    _a.label = 7;\r\n                case 7: return [3 /*break*/, 1];\r\n                case 8:\r\n                    if (title === undefined) {\r\n                        title = [];\r\n                    }\r\n                    if (atoms === undefined) {\r\n                        return [2 /*return*/, Result.error('no atoms data')];\r\n                    }\r\n                    if (bonds === undefined) {\r\n                        return [2 /*return*/, Result.error('no bonds data')];\r\n                    }\r\n                    result = {\r\n                        id: id,\r\n                        title: title,\r\n                        atoms: atoms,\r\n                        bonds: bonds\r\n                    };\r\n                    return [2 /*return*/, Result.success(result)];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function parsePsf(data) {\r\n    var _this = this;\r\n    return Task.create('Parse PSF', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, parseInternal(data, ctx)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}