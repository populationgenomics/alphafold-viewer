{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Type } from '../type';\nimport * as Core from './core';\nimport { Arguments, Argument } from '../symbol';\nimport { symbol } from '../helpers';\nexport var Types;\n\n(function (Types) {\n  Types.ElementSymbol = Type.Value('Structure', 'ElementSymbol');\n  Types.AtomName = Type.Value('Structure', 'AtomName');\n  Types.BondFlag = Type.OneOf('Structure', 'BondFlag', Type.Str, ['covalent', 'metallic', 'ion', 'hydrogen', 'sulfide', 'computed', 'aromatic']);\n  Types.BondFlags = Core.Types.Flags(Types.BondFlag, 'BondFlags');\n  Types.SecondaryStructureFlag = Type.OneOf('Structure', 'SecondaryStructureFlag', Type.Str, ['alpha', 'beta', '3-10', 'pi', 'sheet', 'strand', 'helix', 'turn', 'none']);\n  Types.SecondaryStructureFlags = Core.Types.Flags(Types.SecondaryStructureFlag, 'SecondaryStructureFlag');\n  Types.RingFingerprint = Type.Value('Structure', 'RingFingerprint');\n  Types.EntityType = Type.OneOf('Structure', 'EntityType', Type.Str, ['polymer', 'non-polymer', 'water', 'branched']);\n  Types.EntitySubtype = Type.OneOf('Structure', 'EntitySubtype', Type.Str, ['other', 'polypeptide(D)', 'polypeptide(L)', 'polydeoxyribonucleotide', 'polyribonucleotide', 'polydeoxyribonucleotide/polyribonucleotide hybrid', 'cyclic-pseudo-peptide', 'peptide nucleic acid', 'oligosaccharide']);\n  Types.ObjectPrimitive = Type.OneOf('Structure', 'ObjectPrimitive', Type.Str, ['atomistic', 'sphere', 'gaussian', 'other']);\n  Types.ResidueId = Type.Value('Structure', 'ResidueId');\n  Types.ElementSet = Type.Value('Structure', 'ElementSet');\n  Types.ElementSelection = Type.Value('Structure', 'ElementSelection');\n  Types.ElementReference = Type.Value('Structure', 'ElementReference');\n  Types.ElementSelectionQuery = Core.Types.Fn(Types.ElementSelection, 'ElementSelectionQuery');\n})(Types || (Types = {}));\n\nvar type = {\n  '@header': 'Types',\n  elementSymbol: symbol(Arguments.Dictionary({\n    0: Argument(Type.Str)\n  }), Types.ElementSymbol, 'Create element symbol representation from a string value.'),\n  atomName: symbol(Arguments.Dictionary({\n    0: Argument(Type.AnyValue)\n  }), Types.AtomName, 'Convert a value to an atom name.'),\n  entityType: symbol(Arguments.Dictionary({\n    0: Argument(Types.EntityType)\n  }), Types.EntityType, \"Create normalized representation of entity type: \" + Type.oneOfValues(Types.EntityType).join(', ') + \".\"),\n  bondFlags: symbol(Arguments.List(Types.BondFlag), Types.BondFlags, \"Create bond flags representation from a list of strings. Allowed flags: \" + Type.oneOfValues(Types.BondFlag).join(', ') + \".\"),\n  ringFingerprint: symbol(Arguments.List(Types.ElementSymbol, {\n    nonEmpty: true\n  }), Types.RingFingerprint, 'Create ring fingerprint from the supplied atom element list.'),\n  secondaryStructureFlags: symbol(Arguments.List(Types.SecondaryStructureFlag), Types.SecondaryStructureFlags, \"Create secondary structure flags representation from a list of strings. Allowed flags: \" + Type.oneOfValues(Types.SecondaryStructureFlag).join(', ') + \".\"),\n  authResidueId: symbol(Arguments.Dictionary({\n    0: Argument(Type.Str, {\n      description: 'auth_asym_id'\n    }),\n    1: Argument(Type.Num, {\n      description: 'auth_seq_id'\n    }),\n    2: Argument(Type.Str, {\n      description: 'pdbx_PDB_ins_code',\n      isOptional: true\n    })\n  }), Types.ResidueId, \"Residue identifier based on \\\"auth_\\\" annotation.\"),\n  labelResidueId: symbol(Arguments.Dictionary({\n    0: Argument(Type.Str, {\n      description: 'label_entity_id'\n    }),\n    1: Argument(Type.Str, {\n      description: 'label_asym_id'\n    }),\n    2: Argument(Type.Num, {\n      description: 'label_seq_id'\n    }),\n    3: Argument(Type.Str, {\n      description: 'pdbx_PDB_ins_code',\n      isOptional: true\n    })\n  }), Types.ResidueId, \"Residue identifier based on mmCIF's \\\"label_\\\" annotation.\")\n};\nvar slot = {\n  '@header': 'Iteration Slots',\n  element: symbol(Arguments.None, Types.ElementReference, 'A reference to the current element.'),\n  elementSetReduce: symbol(Arguments.None, Type.Variable('a', Type.AnyValue, true), 'Current value of the element set reducer.')\n};\nvar generator = {\n  '@header': 'Generators',\n  all: symbol(Arguments.None, Types.ElementSelectionQuery, 'The entire structure.'),\n  atomGroups: symbol(Arguments.Dictionary({\n    'entity-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true,\n      description: 'Test for the 1st atom of every entity'\n    }),\n    'chain-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true,\n      description: 'Test for the 1st atom of every chain'\n    }),\n    'residue-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true,\n      description: 'Test for the 1st atom every residue'\n    }),\n    'atom-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true\n    }),\n    'group-by': Argument(Type.Any, {\n      isOptional: true,\n      defaultValue: \"atom-key\",\n      description: 'Group atoms to sets based on this property. Default: each atom has its own set'\n    })\n  }), Types.ElementSelectionQuery, 'Return all atoms for which the tests are satisfied, grouped into sets.'),\n  bondedAtomicPairs: symbol(Arguments.Dictionary({\n    0: Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: 'true for covalent bonds',\n      description: 'Test each bond with this predicate. Each bond is visited twice with swapped atom order.'\n    }) // TODO: shoud we support this or just use queryEach to get similar behavior\n    // 'group-by': Argument(Type.Any, { isOptional: true, defaultValue: ``, description: 'Group the bonds using the privided value' }),\n\n  }), Types.ElementSelectionQuery, 'Return all pairs of atoms for which the test is satisfied.'),\n  rings: symbol(Arguments.Dictionary({\n    'fingerprint': Argument(Types.RingFingerprint, {\n      isOptional: true\n    }),\n    'only-aromatic': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: false\n    })\n  }), Types.ElementSelectionQuery, 'Return all rings or those with the specified fingerprint and/or only aromatic rings.'),\n  queryInSelection: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    query: Argument(Types.ElementSelectionQuery),\n    'in-complement': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: false\n    })\n  }), Types.ElementSelectionQuery, 'Executes query only on atoms that are in the source selection.'),\n  empty: symbol(Arguments.None, Types.ElementSelectionQuery, 'Nada.')\n};\nvar modifier = {\n  '@header': 'Selection Modifications',\n  queryEach: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    query: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Query every atom set in the input selection separately.'),\n  intersectBy: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    by: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Intersect each atom set from the first sequence from atoms in the second one.'),\n  exceptBy: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    by: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, \"Remove all atoms from 'selection' that occur in 'by'.\"),\n  unionBy: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    by: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'For each atom set A in the orginal sequence, combine all atoms sets in the target selection that intersect with A.'),\n  union: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Collects all atom sets in the sequence into a single atom set.'),\n  cluster: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    'min-distance': Argument(Type.Num, {\n      isOptional: true,\n      defaultValue: 0\n    }),\n    'max-distance': Argument(Type.Num),\n    'min-size': Argument(Type.Num, {\n      description: 'Minimal number of sets to merge, must be at least 2',\n      isOptional: true,\n      defaultValue: 2\n    }),\n    'max-size': Argument(Type.Num, {\n      description: 'Maximal number of sets to merge, if not set, no limit',\n      isOptional: true\n    })\n  }), Types.ElementSelectionQuery, 'Combines atom sets that have mutual distance in the interval [min-radius, max-radius]. Minimum/maximum size determines how many atom sets can be combined.'),\n  includeSurroundings: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    radius: Argument(Type.Num),\n    'atom-radius': Argument(Type.Num, {\n      isOptional: true,\n      defaultValue: 0,\n      description: 'Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding.'\n    }),\n    'as-whole-residues': Argument(Type.Bool, {\n      isOptional: true\n    })\n  }), Types.ElementSelectionQuery, 'For each atom set in the selection, include all surrouding atoms/residues that are within the specified radius.'),\n  surroundingLigands: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    radius: Argument(Type.Num),\n    'include-water': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true\n    })\n  }), Types.ElementSelectionQuery, 'Find all ligands components around the source query.'),\n  includeConnected: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    'bond-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: 'true for covalent bonds'\n    }),\n    'layer-count': Argument(Type.Num, {\n      isOptional: true,\n      defaultValue: 1,\n      description: 'Number of bonded layers to include.'\n    }),\n    'fixed-point': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: false,\n      description: 'Continue adding layers as long as new connections exist.'\n    }),\n    'as-whole-residues': Argument(Type.Bool, {\n      isOptional: true\n    })\n  }), Types.ElementSelectionQuery, 'Pick all atom sets that are connected to the target.'),\n  wholeResidues: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Expand the selection to whole residues.'),\n  expandProperty: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    property: Argument(Type.AnyValue)\n  }), Types.ElementSelectionQuery, 'To each atom set in the selection, add all atoms that have the same property value that was already present in the set.')\n};\nvar filter = {\n  '@header': 'Selection Filters',\n  pick: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    test: Argument(Type.Bool)\n  }), Types.ElementSelectionQuery, 'Pick all atom sets that satisfy the test.'),\n  first: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Take the 1st atom set in the sequence.'),\n  withSameAtomProperties: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    source: Argument(Types.ElementSelectionQuery),\n    property: Argument(Type.Any)\n  }), Types.ElementSelectionQuery, 'Pick all atom sets for which the set of given atom properties is a subset of the source properties.'),\n  intersectedBy: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    by: Argument(Types.ElementSelectionQuery)\n  }), Types.ElementSelectionQuery, 'Pick all atom sets that have non-zero intersection with the target.'),\n  within: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    target: Argument(Types.ElementSelectionQuery),\n    'min-radius': Argument(Type.Num, {\n      isOptional: true,\n      defaultValue: 0\n    }),\n    'max-radius': Argument(Type.Num),\n    'atom-radius': Argument(Type.Num, {\n      isOptional: true,\n      defaultValue: 0,\n      description: 'Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding.'\n    }),\n    invert: Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: false,\n      description: 'If true, pick only atom sets that are further than the specified radius.'\n    })\n  }), Types.ElementSelectionQuery, 'Pick all atom sets from selection that have any atom within the radius of any atom from target.'),\n  isConnectedTo: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery),\n    target: Argument(Types.ElementSelectionQuery),\n    'bond-test': Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: 'true for covalent bonds'\n    }),\n    disjunct: Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: true,\n      description: 'If true, there must exist a bond to an atom that lies outside the given atom set to pass test.'\n    }),\n    invert: Argument(Type.Bool, {\n      isOptional: true,\n      defaultValue: false,\n      description: 'If true, return atom sets that are not connected.'\n    })\n  }), Types.ElementSelectionQuery, 'Pick all atom sets that are connected to the target.')\n};\nvar combinator = {\n  '@header': 'Selection Combinators',\n  intersect: symbol(Arguments.List(Types.ElementSelectionQuery), Types.ElementSelectionQuery, 'Return all unique atom sets that appear in all of the source selections.'),\n  merge: symbol(Arguments.List(Types.ElementSelectionQuery), Types.ElementSelectionQuery, 'Merges multiple selections into a single one. Only unique atom sets are kept.'),\n  distanceCluster: symbol(Arguments.Dictionary({\n    matrix: Argument(Core.Types.List(Core.Types.List(Type.Num)), {\n      description: 'Distance matrix, represented as list of rows (num[][])). Lower triangle is min distance, upper triangle is max distance.'\n    }),\n    selections: Argument(Core.Types.List(Types.ElementSelectionQuery), {\n      description: 'A list of held selections.'\n    })\n  }), Types.ElementSelectionQuery, 'Pick combinations of atom sets from the source sequences that are mutually within distances specified by a matrix.')\n};\nvar atomSet = {\n  '@header': 'Atom Sets',\n  atomCount: symbol(Arguments.None, Type.Num),\n  countQuery: symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementSelectionQuery)\n  }), Type.Num, 'Counts the number of occurences of a specific query inside the current atom set.'),\n  reduce: symbol(Arguments.Dictionary({\n    initial: Argument(Type.Variable('a', Type.AnyValue, true), {\n      description: 'Initial value assigned to slot.atom-set-reduce. Current atom is set to the 1st atom of the current set for this.'\n    }),\n    value: Argument(Type.Variable('a', Type.AnyValue, true), {\n      description: 'Expression executed for each atom in the set'\n    })\n  }), Type.Variable('a', Type.AnyValue, true), 'Execute the value expression for each atom in the current atom set and return the result. Works the same way as Array.reduce in JavaScript (``result = value(value(...value(initial)))``)'),\n  propertySet: symbol(Arguments.Dictionary({\n    0: Argument(Core.Types.ConstrainedVar)\n  }), Core.Types.Set(Core.Types.ConstrainedVar), 'Returns a set with all values of the given property in the current atom set.')\n};\nvar atomProperty = {\n  '@header': 'Atom Properties',\n  core: {\n    '@header': 'Core Properties',\n    elementSymbol: atomProp(Types.ElementSymbol),\n    vdw: atomProp(Type.Num, 'Van der Waals radius'),\n    mass: atomProp(Type.Num, 'Atomic weight'),\n    atomicNumber: atomProp(Type.Num, 'Atomic number'),\n    x: atomProp(Type.Num, 'Cartesian X coordinate'),\n    y: atomProp(Type.Num, 'Cartesian Y coordinate'),\n    z: atomProp(Type.Num, 'Cartesian Z coordinate'),\n    atomKey: atomProp(Type.AnyValue, 'Unique value for each atom. Main use case is grouping of atoms.'),\n    bondCount: symbol(Arguments.Dictionary({\n      0: Argument(Types.ElementReference, {\n        isOptional: true,\n        defaultValue: 'slot.current-atom'\n      }),\n      flags: Argument(Types.BondFlags, {\n        isOptional: true,\n        defaultValue: 'covalent'\n      })\n    }), Type.Num, 'Number of bonds (by default only covalent bonds are counted).'),\n    sourceIndex: atomProp(Type.Num, 'Index of the atom/element in the input file.'),\n    operatorName: atomProp(Type.Str, 'Name of the symmetry operator applied to this element.'),\n    modelIndex: atomProp(Type.Num, 'Index of the model in the input file.'),\n    modelLabel: atomProp(Type.Str, 'Label/header of the model in the input file.')\n  },\n  topology: {\n    connectedComponentKey: atomProp(Type.AnyValue, 'Unique value for each connected component.')\n  },\n  macromolecular: {\n    '@header': 'Macromolecular Properties (derived from the mmCIF format)',\n    authResidueId: atomProp(Types.ResidueId, \"type.auth-residue-id symbol executed on current atom's residue\"),\n    labelResidueId: atomProp(Types.ResidueId, \"type.label-residue-id symbol executed on current atom's residue\"),\n    residueKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``(label_entity_id,auth_asym_id, auth_seq_id, pdbx_PDB_ins_code)``, main use case is grouping of atoms'),\n    chainKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``(label_entity_id, auth_asym_id)``, main use case is grouping of atoms'),\n    entityKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``label_entity_id``, main use case is grouping of atoms'),\n    isHet: atomProp(Type.Bool, 'Equivalent to atom_site.group_PDB !== ATOM'),\n    id: atomProp(Type.Num, '_atom_site.id'),\n    label_atom_id: atomProp(Types.AtomName),\n    label_alt_id: atomProp(Type.Str),\n    label_comp_id: atomProp(Type.Str),\n    label_asym_id: atomProp(Type.Str),\n    label_entity_id: atomProp(Type.Str),\n    label_seq_id: atomProp(Type.Num),\n    auth_atom_id: atomProp(Types.AtomName),\n    auth_comp_id: atomProp(Type.Str),\n    auth_asym_id: atomProp(Type.Str),\n    auth_seq_id: atomProp(Type.Num),\n    pdbx_PDB_ins_code: atomProp(Type.Str),\n    pdbx_formal_charge: atomProp(Type.Num),\n    occupancy: atomProp(Type.Num),\n    B_iso_or_equiv: atomProp(Type.Num),\n    entityType: atomProp(Types.EntityType, 'Type of the entity as defined in mmCIF (polymer, non-polymer, branched, water)'),\n    entitySubtype: atomProp(Types.EntitySubtype, 'Subtype of the entity as defined in mmCIF _entity_poly.type and _pdbx_entity_branch.type (other, polypeptide(D), polypeptide(L), polydeoxyribonucleotide, polyribonucleotide, polydeoxyribonucleotide/polyribonucleotide hybrid, cyclic-pseudo-peptide, peptide nucleic acid, oligosaccharide)'),\n    entityPrdId: atomProp(Type.Str, \"The PRD ID of the entity.\"),\n    entityDescription: atomProp(Core.Types.List(Type.Str)),\n    objectPrimitive: atomProp(Types.ObjectPrimitive, 'Type of the primitive object used to model this segment as defined in mmCIF/IHM (atomistic, sphere, gaussian, other)'),\n    secondaryStructureKey: atomProp(Type.AnyValue, 'Unique value for each secondary structure element.'),\n    secondaryStructureFlags: atomProp(Types.SecondaryStructureFlags),\n    isModified: atomProp(Type.Bool, 'True if the atom belongs to modification of a standard residue.'),\n    modifiedParentName: atomProp(Type.Str, \"'3-letter' code of the modifed parent residue.\"),\n    isNonStandard: atomProp(Type.Bool, 'True if this is a non-standard residue.'),\n    chemCompType: atomProp(Type.Str, \"Type of the chemical component as defined in mmCIF.\")\n  }\n};\nvar bondProperty = {\n  '@header': 'Bond Properties',\n  flags: bondProp(Types.BondFlags),\n  order: bondProp(Type.Num),\n  length: bondProp(Type.Num),\n  atomA: bondProp(Types.ElementReference),\n  atomB: bondProp(Types.ElementReference)\n};\n\nfunction atomProp(type, description) {\n  return symbol(Arguments.Dictionary({\n    0: Argument(Types.ElementReference, {\n      isOptional: true,\n      defaultValue: 'slot.current-atom'\n    })\n  }), type, description);\n}\n\nfunction bondProp(type, description) {\n  return symbol(Arguments.None, type, description);\n}\n\nexport var structureQuery = {\n  '@header': 'Structure Queries',\n  type: type,\n  slot: slot,\n  generator: generator,\n  modifier: modifier,\n  filter: filter,\n  combinator: combinator,\n  atomSet: atomSet,\n  atomProperty: atomProperty,\n  bondProperty: bondProperty\n};","map":{"version":3,"sources":["../../../../src/mol-script/language/symbol-table/structure-query.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAEH,SAAS,IAAT,QAAqB,SAArB;AACA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,SAAS,SAAT,EAAoB,QAApB,QAAoC,WAApC;AACA,SAAS,MAAT,QAAuB,YAAvB;AAEA,OAAM,IAAW,KAAX;;AAAN,CAAA,UAAiB,KAAjB,EAAsB;AACL,EAAA,KAAA,CAAA,aAAA,GAAgB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,eAAxB,CAAhB;AACA,EAAA,KAAA,CAAA,QAAA,GAAW,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,UAAxB,CAAX;AAEA,EAAA,KAAA,CAAA,QAAA,GAAW,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,UAAxB,EAAoC,IAAI,CAAC,GAAzC,EAA8C,CAAC,UAAD,EAAa,UAAb,EAAyB,KAAzB,EAAgC,UAAhC,EAA4C,SAA5C,EAAuD,UAAvD,EAAmE,UAAnE,CAA9C,CAAX;AACA,EAAA,KAAA,CAAA,SAAA,GAAY,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAA,CAAA,QAAjB,EAA2B,WAA3B,CAAZ;AAEA,EAAA,KAAA,CAAA,sBAAA,GAAyB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,wBAAxB,EAAkD,IAAI,CAAC,GAAvD,EAA4D,CAAC,OAAD,EAAU,MAAV,EAAkB,MAAlB,EAA0B,IAA1B,EAAgC,OAAhC,EAAyC,QAAzC,EAAmD,OAAnD,EAA4D,MAA5D,EAAoE,MAApE,CAA5D,CAAzB;AACA,EAAA,KAAA,CAAA,uBAAA,GAA0B,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAA,CAAA,sBAAjB,EAAyC,wBAAzC,CAA1B;AAEA,EAAA,KAAA,CAAA,eAAA,GAAkB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,iBAAxB,CAAlB;AACA,EAAA,KAAA,CAAA,UAAA,GAAa,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,YAAxB,EAAsC,IAAI,CAAC,GAA3C,EAAgD,CAAC,SAAD,EAAY,aAAZ,EAA2B,OAA3B,EAAoC,UAApC,CAAhD,CAAb;AACA,EAAA,KAAA,CAAA,aAAA,GAAgB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,eAAxB,EAAyC,IAAI,CAAC,GAA9C,EAAmD,CAAC,OAAD,EAAU,gBAAV,EAA4B,gBAA5B,EAA8C,yBAA9C,EAAyE,oBAAzE,EAA+F,mDAA/F,EAAoJ,uBAApJ,EAA6K,sBAA7K,EAAqM,iBAArM,CAAnD,CAAhB;AACA,EAAA,KAAA,CAAA,eAAA,GAAkB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,iBAAxB,EAA2C,IAAI,CAAC,GAAhD,EAAqD,CAAC,WAAD,EAAc,QAAd,EAAwB,UAAxB,EAAoC,OAApC,CAArD,CAAlB;AACA,EAAA,KAAA,CAAA,SAAA,GAAY,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,WAAxB,CAAZ;AAEA,EAAA,KAAA,CAAA,UAAA,GAAa,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,YAAxB,CAAb;AACA,EAAA,KAAA,CAAA,gBAAA,GAAmB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,kBAAxB,CAAnB;AACA,EAAA,KAAA,CAAA,gBAAA,GAAmB,IAAI,CAAC,KAAL,CAAW,WAAX,EAAwB,kBAAxB,CAAnB;AAEA,EAAA,KAAA,CAAA,qBAAA,GAAwB,IAAI,CAAC,KAAL,CAAW,EAAX,CAAc,KAAA,CAAA,gBAAd,EAAgC,uBAAhC,CAAxB;AAChB,CArBD,EAAiB,KAAK,KAAL,KAAK,GAAA,EAAA,CAAtB;;AAuBA,IAAM,IAAI,GAAG;AACT,aAAW,OADF;AAET,EAAA,aAAa,EAAE,MAAM,CACjB,SAAS,CAAC,UAAV,CAAqB;AAAE,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN;AAAb,GAArB,CADiB,EAEjB,KAAK,CAAC,aAFW,EAEI,2DAFJ,CAFZ;AAMT,EAAA,QAAQ,EAAE,MAAM,CACZ,SAAS,CAAC,UAAV,CAAqB;AAAE,OAAG,QAAQ,CAAC,IAAI,CAAC,QAAN;AAAb,GAArB,CADY,EAC0C,KAAK,CAAC,QADhD,EAC0D,kCAD1D,CANP;AAST,EAAA,UAAU,EAAE,MAAM,CACd,SAAS,CAAC,UAAV,CAAqB;AAAE,OAAG,QAAQ,CAAC,KAAK,CAAC,UAAP;AAAb,GAArB,CADc,EAEd,KAAK,CAAC,UAFQ,EAGd,sDAAoD,IAAI,CAAC,WAAL,CAAiB,KAAK,CAAC,UAAvB,EAAmC,IAAnC,CAAwC,IAAxC,CAApD,GAAiG,GAHnF,CATT;AAcT,EAAA,SAAS,EAAE,MAAM,CACb,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,QAArB,CADa,EAEb,KAAK,CAAC,SAFO,EAGb,6EAA2E,IAAI,CAAC,WAAL,CAAiB,KAAK,CAAC,QAAvB,EAAiC,IAAjC,CAAsC,IAAtC,CAA3E,GAAsH,GAHzG,CAdR;AAmBT,EAAA,eAAe,EAAE,MAAM,CACnB,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,aAArB,EAAoC;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAApC,CADmB,EAEnB,KAAK,CAAC,eAFa,EAGnB,8DAHmB,CAnBd;AAwBT,EAAA,uBAAuB,EAAE,MAAM,CAC3B,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,sBAArB,CAD2B,EAE3B,KAAK,CAAC,uBAFqB,EAG3B,4FAA0F,IAAI,CAAC,WAAL,CAAiB,KAAK,CAAC,sBAAvB,EAA+C,IAA/C,CAAoD,IAApD,CAA1F,GAAmJ,GAHxH,CAxBtB;AA6BT,EAAA,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACvC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE;AAAf,KAAX,CAD4B;AAEvC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE;AAAf,KAAX,CAF4B;AAGvC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE,mBAAf;AAAoC,MAAA,UAAU,EAAE;AAAhD,KAAX;AAH4B,GAArB,CAAD,EAIjB,KAAK,CAAC,SAJW,EAIA,mDAJA,CA7BZ;AAkCT,EAAA,cAAc,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACxC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE;AAAf,KAAX,CAD6B;AAExC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE;AAAf,KAAX,CAF6B;AAGxC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE;AAAf,KAAX,CAH6B;AAIxC,OAAG,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE,mBAAf;AAAoC,MAAA,UAAU,EAAE;AAAhD,KAAX;AAJ6B,GAArB,CAAD,EAKlB,KAAK,CAAC,SALY,EAKD,4DALC;AAlCb,CAAb;AA0CA,IAAM,IAAI,GAAG;AACT,aAAW,iBADF;AAET,EAAA,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,KAAK,CAAC,gBAAvB,EAAyC,qCAAzC,CAFN;AAGT,EAAA,gBAAgB,EAAE,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,IAAI,CAAC,QAAL,CAAc,GAAd,EAAmB,IAAI,CAAC,QAAxB,EAAkC,IAAlC,CAAjB,EAA0D,2CAA1D;AAHf,CAAb;AAMA,IAAM,SAAS,GAAG;AACd,aAAW,YADG;AAEd,EAAA,GAAG,EAAE,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,KAAK,CAAC,qBAAvB,EAA8C,uBAA9C,CAFG;AAId,EAAA,UAAU,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACpC,mBAAe,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,IAAlC;AAAwC,MAAA,WAAW,EAAE;AAArD,KAAZ,CADa;AAEpC,kBAAc,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,IAAlC;AAAwC,MAAA,WAAW,EAAE;AAArD,KAAZ,CAFc;AAGpC,oBAAgB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,IAAlC;AAAwC,MAAA,WAAW,EAAE;AAArD,KAAZ,CAHY;AAIpC,iBAAa,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ,CAJe;AAKpC,gBAAY,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,UAAlC;AAA8C,MAAA,WAAW,EAAE;AAA3D,KAAX;AALgB,GAArB,CAAD,EAMd,KAAK,CAAC,qBANQ,EAMe,wEANf,CAJJ;AAYd,EAAA,iBAAiB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC3C,OAAG,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,yBAAlC;AAAoE,MAAA,WAAW,EAAE;AAAjF,KAAZ,CADgC,CAE3C;AACA;;AAH2C,GAArB,CAAD,EAIrB,KAAK,CAAC,qBAJe,EAIQ,4DAJR,CAZX;AAkBd,EAAA,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC/B,mBAAe,QAAQ,CAAC,KAAK,CAAC,eAAP,EAAwB;AAAE,MAAA,UAAU,EAAE;AAAd,KAAxB,CADQ;AAE/B,qBAAiB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ;AAFM,GAArB,CAAD,EAGT,KAAK,CAAC,qBAHG,EAGoB,sFAHpB,CAlBC;AAuBd,EAAA,gBAAgB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC1C,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD+B;AAE1C,IAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAF2B;AAG1C,qBAAiB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ;AAHiB,GAArB,CAAD,EAIpB,KAAK,CAAC,qBAJc,EAIS,gEAJT,CAvBV;AA6Bd,EAAA,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,KAAK,CAAC,qBAAvB,EAA8C,OAA9C;AA7BC,CAAlB;AAgCA,IAAM,QAAQ,GAAG;AACb,aAAW,yBADE;AAGb,EAAA,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACnC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADwB;AAEnC,IAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAFoB,GAArB,CAAD,EAGb,KAAK,CAAC,qBAHO,EAGgB,yDAHhB,CAHJ;AAQb,EAAA,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACrC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD0B;AAErC,IAAA,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAFyB,GAArB,CAAD,EAGf,KAAK,CAAC,qBAHS,EAGc,+EAHd,CARN;AAab,EAAA,QAAQ,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAClC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADuB;AAElC,IAAA,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAFsB,GAArB,CAAD,EAGZ,KAAK,CAAC,qBAHM,EAGiB,uDAHjB,CAbH;AAkBb,EAAA,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACjC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADsB;AAEjC,IAAA,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAFqB,GAArB,CAAD,EAGX,KAAK,CAAC,qBAHK,EAGkB,oHAHlB,CAlBF;AAuBb,EAAA,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC/B,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP;AADoB,GAArB,CAAD,EAET,KAAK,CAAC,qBAFG,EAEoB,gEAFpB,CAvBA;AA2Bb,EAAA,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACjC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADsB;AAEjC,oBAAgB,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAX,CAFS;AAGjC,oBAAgB,QAAQ,CAAC,IAAI,CAAC,GAAN,CAHS;AAIjC,gBAAY,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE,qDAAf;AAAsE,MAAA,UAAU,EAAE,IAAlF;AAAwF,MAAA,YAAY,EAAE;AAAtG,KAAX,CAJa;AAKjC,gBAAY,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,WAAW,EAAE,uDAAf;AAAwE,MAAA,UAAU,EAAE;AAApF,KAAX;AALa,GAArB,CAAD,EAMX,KAAK,CAAC,qBANK,EAMkB,4JANlB,CA3BF;AAmCb,EAAA,mBAAmB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC7C,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADkC;AAE7C,IAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAF6B;AAG7C,mBAAe,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,CAAlC;AAAqC,MAAA,WAAW,EAAE;AAAlD,KAAX,CAHsB;AAI7C,yBAAqB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE;AAAd,KAAZ;AAJgB,GAArB,CAAD,EAKvB,KAAK,CAAC,qBALiB,EAKM,iHALN,CAnCd;AA0Cb,EAAA,kBAAkB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC5C,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADiC;AAE5C,IAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAF4B;AAG5C,qBAAiB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ;AAHmB,GAArB,CAAD,EAItB,KAAK,CAAC,qBAJgB,EAIO,sDAJP,CA1Cb;AAgDb,EAAA,gBAAgB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC1C,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD+B;AAE1C,iBAAa,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ,CAFqB;AAG1C,mBAAe,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,CAAlC;AAAqC,MAAA,WAAW,EAAE;AAAlD,KAAX,CAHmB;AAI1C,mBAAe,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,KAAlC;AAAyC,MAAA,WAAW,EAAE;AAAtD,KAAZ,CAJmB;AAK1C,yBAAqB,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE;AAAd,KAAZ;AALa,GAArB,CAAD,EAMpB,KAAK,CAAC,qBANc,EAMS,sDANT,CAhDX;AAwDb,EAAA,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACvC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAD4B,GAArB,CAAD,EAEjB,KAAK,CAAC,qBAFW,EAEY,yCAFZ,CAxDR;AA4Db,EAAA,cAAc,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACxC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD6B;AAExC,IAAA,QAAQ,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN;AAFsB,GAArB,CAAD,EAGlB,KAAK,CAAC,qBAHY,EAGW,yHAHX;AA5DT,CAAjB;AAkEA,IAAM,MAAM,GAAG;AACX,aAAW,mBADA;AAEX,EAAA,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC9B,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADmB;AAE9B,IAAA,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN;AAFgB,GAArB,CAAD,EAGR,KAAK,CAAC,qBAHE,EAGqB,2CAHrB,CAFD;AAOX,EAAA,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAC/B,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP;AADoB,GAArB,CAAD,EAET,KAAK,CAAC,qBAFG,EAEoB,wCAFpB,CAPF;AAWX,EAAA,sBAAsB,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAChD,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADqC;AAEhD,IAAA,MAAM,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAFgC;AAGhD,IAAA,QAAQ,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN;AAH8B,GAArB,CAAD,EAI1B,KAAK,CAAC,qBAJoB,EAIG,qGAJH,CAXnB;AAiBX,EAAA,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACvC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD4B;AAEvC,IAAA,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP;AAF2B,GAArB,CAAD,EAGjB,KAAK,CAAC,qBAHW,EAGY,qEAHZ,CAjBV;AAsBX,EAAA,MAAM,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAChC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CADqB;AAEhC,IAAA,MAAM,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAFgB;AAGhC,kBAAc,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAX,CAHU;AAIhC,kBAAc,QAAQ,CAAC,IAAI,CAAC,GAAN,CAJU;AAKhC,mBAAe,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,CAAlC;AAAqC,MAAA,WAAW,EAAE;AAAlD,KAAX,CALS;AAMhC,IAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,KAAlC;AAAyC,MAAA,WAAW,EAAE;AAAtD,KAAZ;AANgB,GAArB,CAAD,EAOV,KAAK,CAAC,qBAPI,EAOmB,iGAPnB,CAtBH;AA+BX,EAAA,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACvC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAD4B;AAEvC,IAAA,MAAM,EAAE,QAAQ,CAAC,KAAK,CAAC,qBAAP,CAFuB;AAGvC,iBAAa,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAZ,CAHkB;AAIvC,IAAA,QAAQ,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,IAAlC;AAAwC,MAAA,WAAW,EAAE;AAArD,KAAZ,CAJqB;AAKvC,IAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE,KAAlC;AAAyC,MAAA,WAAW,EAAE;AAAtD,KAAZ;AALuB,GAArB,CAAD,EAMjB,KAAK,CAAC,qBANW,EAMY,sDANZ;AA/BV,CAAf;AAwCA,IAAM,UAAU,GAAG;AACf,aAAW,uBADI;AAEf,EAAA,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,qBAArB,CAAD,EAA8C,KAAK,CAAC,qBAApD,EAA2E,0EAA3E,CAFF;AAGf,EAAA,KAAK,EAAE,MAAM,CAAC,SAAS,CAAC,IAAV,CAAe,KAAK,CAAC,qBAArB,CAAD,EAA8C,KAAK,CAAC,qBAApD,EAA2E,+EAA3E,CAHE;AAIf,EAAA,eAAe,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACzC,IAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAI,CAAC,GAArB,CAAhB,CAAD,EAA6C;AAAE,MAAA,WAAW,EAAE;AAAf,KAA7C,CADyB;AAEzC,IAAA,UAAU,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,KAAK,CAAC,qBAAtB,CAAD,EAA+C;AAAE,MAAA,WAAW,EAAE;AAAf,KAA/C;AAFqB,GAArB,CAAD,EAGnB,KAAK,CAAC,qBAHa,EAGU,oHAHV;AAJR,CAAnB;AAUA,IAAM,OAAO,GAAG;AACZ,aAAW,WADC;AAGZ,EAAA,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,IAAI,CAAC,GAAtB,CAHL;AAKZ,EAAA,UAAU,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACpC,OAAG,QAAQ,CAAC,KAAK,CAAC,qBAAP;AADyB,GAArB,CAAD,EAEd,IAAI,CAAC,GAFS,EAEJ,kFAFI,CALN;AASZ,EAAA,MAAM,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAChC,IAAA,OAAO,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAL,CAAc,GAAd,EAAmB,IAAI,CAAC,QAAxB,EAAkC,IAAlC,CAAD,EAA0C;AAAE,MAAA,WAAW,EAAE;AAAf,KAA1C,CADe;AAEhC,IAAA,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAL,CAAc,GAAd,EAAmB,IAAI,CAAC,QAAxB,EAAkC,IAAlC,CAAD,EAA0C;AAAE,MAAA,WAAW,EAAE;AAAf,KAA1C;AAFiB,GAArB,CAAD,EAGV,IAAI,CAAC,QAAL,CAAc,GAAd,EAAmB,IAAI,CAAC,QAAxB,EAAkC,IAAlC,CAHU,EAG+B,2LAH/B,CATF;AAcZ,EAAA,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACrC,OAAG,QAAQ,CAAC,IAAI,CAAC,KAAL,CAAW,cAAZ;AAD0B,GAArB,CAAD,EAEf,IAAI,CAAC,KAAL,CAAW,GAAX,CAAe,IAAI,CAAC,KAAL,CAAW,cAA1B,CAFe,EAE4B,8EAF5B;AAdP,CAAhB;AAmBA,IAAM,YAAY,GAAG;AACjB,aAAW,iBADM;AAGjB,EAAA,IAAI,EAAE;AACF,eAAW,iBADT;AAGF,IAAA,aAAa,EAAE,QAAQ,CAAC,KAAK,CAAC,aAAP,CAHrB;AAKF,IAAA,GAAG,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,sBAAX,CALX;AAMF,IAAA,IAAI,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,eAAX,CANZ;AAOF,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,eAAX,CAPpB;AASF,IAAA,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,wBAAX,CATT;AAUF,IAAA,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,wBAAX,CAVT;AAWF,IAAA,CAAC,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,wBAAX,CAXT;AAaF,IAAA,OAAO,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,iEAAhB,CAbf;AAeF,IAAA,SAAS,EAAE,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AACnC,SAAG,QAAQ,CAAC,KAAK,CAAC,gBAAP,EAAyB;AAAE,QAAA,UAAU,EAAE,IAAd;AAAoB,QAAA,YAAY,EAAE;AAAlC,OAAzB,CADwB;AAEnC,MAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAP,EAAkB;AAAE,QAAA,UAAU,EAAE,IAAd;AAAoB,QAAA,YAAY,EAAE;AAAlC,OAAlB;AAFoB,KAArB,CAAD,EAGb,IAAI,CAAC,GAHQ,EAGH,+DAHG,CAff;AAoBF,IAAA,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,8CAAX,CApBnB;AAqBF,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,wDAAX,CArBpB;AAsBF,IAAA,UAAU,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,uCAAX,CAtBlB;AAuBF,IAAA,UAAU,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,8CAAX;AAvBlB,GAHW;AA6BjB,EAAA,QAAQ,EAAE;AACN,IAAA,qBAAqB,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,4CAAhB;AADzB,GA7BO;AAiCjB,EAAA,cAAc,EAAE;AACZ,eAAW,2DADC;AAGZ,IAAA,aAAa,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAP,EAAkB,gEAAlB,CAHX;AAIZ,IAAA,cAAc,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAP,EAAkB,iEAAlB,CAJZ;AAMZ,IAAA,UAAU,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,oIAAhB,CANR;AAOZ,IAAA,QAAQ,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,qGAAhB,CAPN;AAQZ,IAAA,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,qFAAhB,CARP;AAUZ,IAAA,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY,4CAAZ,CAVH;AAYZ,IAAA,EAAE,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,eAAX,CAZA;AAcZ,IAAA,aAAa,EAAE,QAAQ,CAAC,KAAK,CAAC,QAAP,CAdX;AAeZ,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAfV;AAgBZ,IAAA,aAAa,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAhBX;AAiBZ,IAAA,aAAa,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAjBX;AAkBZ,IAAA,eAAe,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAlBb;AAmBZ,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAnBV;AAqBZ,IAAA,YAAY,EAAE,QAAQ,CAAC,KAAK,CAAC,QAAP,CArBV;AAsBZ,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAtBV;AAuBZ,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAvBV;AAwBZ,IAAA,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAxBT;AA0BZ,IAAA,iBAAiB,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CA1Bf;AA2BZ,IAAA,kBAAkB,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CA3BhB;AA6BZ,IAAA,SAAS,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CA7BP;AA8BZ,IAAA,cAAc,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CA9BZ;AAgCZ,IAAA,UAAU,EAAE,QAAQ,CAAC,KAAK,CAAC,UAAP,EAAmB,gFAAnB,CAhCR;AAiCZ,IAAA,aAAa,EAAE,QAAQ,CAAC,KAAK,CAAC,aAAP,EAAsB,gSAAtB,CAjCX;AAkCZ,IAAA,WAAW,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,2BAAX,CAlCT;AAmCZ,IAAA,iBAAiB,EAAE,QAAQ,CAAC,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAI,CAAC,GAArB,CAAD,CAnCf;AAoCZ,IAAA,eAAe,EAAE,QAAQ,CAAC,KAAK,CAAC,eAAP,EAAwB,sHAAxB,CApCb;AAsCZ,IAAA,qBAAqB,EAAE,QAAQ,CAAC,IAAI,CAAC,QAAN,EAAgB,oDAAhB,CAtCnB;AAuCZ,IAAA,uBAAuB,EAAE,QAAQ,CAAC,KAAK,CAAC,uBAAP,CAvCrB;AAwCZ,IAAA,UAAU,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY,iEAAZ,CAxCR;AAyCZ,IAAA,kBAAkB,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,gDAAX,CAzChB;AA0CZ,IAAA,aAAa,EAAE,QAAQ,CAAC,IAAI,CAAC,IAAN,EAAY,yCAAZ,CA1CX;AA2CZ,IAAA,YAAY,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,EAAW,qDAAX;AA3CV;AAjCC,CAArB;AAgFA,IAAM,YAAY,GAAG;AACjB,aAAW,iBADM;AAGjB,EAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,SAAP,CAHE;AAIjB,EAAA,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CAJE;AAKjB,EAAA,MAAM,EAAE,QAAQ,CAAC,IAAI,CAAC,GAAN,CALC;AAMjB,EAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,gBAAP,CANE;AAOjB,EAAA,KAAK,EAAE,QAAQ,CAAC,KAAK,CAAC,gBAAP;AAPE,CAArB;;AAUA,SAAS,QAAT,CAAkB,IAAlB,EAA8B,WAA9B,EAAkD;AAC9C,SAAO,MAAM,CAAC,SAAS,CAAC,UAAV,CAAqB;AAAE,OAAG,QAAQ,CAAC,KAAK,CAAC,gBAAP,EAAyB;AAAE,MAAA,UAAU,EAAE,IAAd;AAAoB,MAAA,YAAY,EAAE;AAAlC,KAAzB;AAAb,GAArB,CAAD,EAAyH,IAAzH,EAA+H,WAA/H,CAAb;AACH;;AAED,SAAS,QAAT,CAAkB,IAAlB,EAA8B,WAA9B,EAAkD;AAC9C,SAAO,MAAM,CAAC,SAAS,CAAC,IAAX,EAAiB,IAAjB,EAAuB,WAAvB,CAAb;AACH;;AAED,OAAO,IAAM,cAAc,GAAG;AAC1B,aAAW,mBADe;AAE1B,EAAA,IAAI,EAAA,IAFsB;AAG1B,EAAA,IAAI,EAAA,IAHsB;AAI1B,EAAA,SAAS,EAAA,SAJiB;AAK1B,EAAA,QAAQ,EAAA,QALkB;AAM1B,EAAA,MAAM,EAAA,MANoB;AAO1B,EAAA,UAAU,EAAA,UAPgB;AAQ1B,EAAA,OAAO,EAAA,OARmB;AAS1B,EAAA,YAAY,EAAA,YATc;AAU1B,EAAA,YAAY,EAAE;AAVY,CAAvB","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Type } from '../type';\r\nimport * as Core from './core';\r\nimport { Arguments, Argument } from '../symbol';\r\nimport { symbol } from '../helpers';\r\nexport var Types;\r\n(function (Types) {\r\n    Types.ElementSymbol = Type.Value('Structure', 'ElementSymbol');\r\n    Types.AtomName = Type.Value('Structure', 'AtomName');\r\n    Types.BondFlag = Type.OneOf('Structure', 'BondFlag', Type.Str, ['covalent', 'metallic', 'ion', 'hydrogen', 'sulfide', 'computed', 'aromatic']);\r\n    Types.BondFlags = Core.Types.Flags(Types.BondFlag, 'BondFlags');\r\n    Types.SecondaryStructureFlag = Type.OneOf('Structure', 'SecondaryStructureFlag', Type.Str, ['alpha', 'beta', '3-10', 'pi', 'sheet', 'strand', 'helix', 'turn', 'none']);\r\n    Types.SecondaryStructureFlags = Core.Types.Flags(Types.SecondaryStructureFlag, 'SecondaryStructureFlag');\r\n    Types.RingFingerprint = Type.Value('Structure', 'RingFingerprint');\r\n    Types.EntityType = Type.OneOf('Structure', 'EntityType', Type.Str, ['polymer', 'non-polymer', 'water', 'branched']);\r\n    Types.EntitySubtype = Type.OneOf('Structure', 'EntitySubtype', Type.Str, ['other', 'polypeptide(D)', 'polypeptide(L)', 'polydeoxyribonucleotide', 'polyribonucleotide', 'polydeoxyribonucleotide/polyribonucleotide hybrid', 'cyclic-pseudo-peptide', 'peptide nucleic acid', 'oligosaccharide']);\r\n    Types.ObjectPrimitive = Type.OneOf('Structure', 'ObjectPrimitive', Type.Str, ['atomistic', 'sphere', 'gaussian', 'other']);\r\n    Types.ResidueId = Type.Value('Structure', 'ResidueId');\r\n    Types.ElementSet = Type.Value('Structure', 'ElementSet');\r\n    Types.ElementSelection = Type.Value('Structure', 'ElementSelection');\r\n    Types.ElementReference = Type.Value('Structure', 'ElementReference');\r\n    Types.ElementSelectionQuery = Core.Types.Fn(Types.ElementSelection, 'ElementSelectionQuery');\r\n})(Types || (Types = {}));\r\nvar type = {\r\n    '@header': 'Types',\r\n    elementSymbol: symbol(Arguments.Dictionary({ 0: Argument(Type.Str) }), Types.ElementSymbol, 'Create element symbol representation from a string value.'),\r\n    atomName: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Types.AtomName, 'Convert a value to an atom name.'),\r\n    entityType: symbol(Arguments.Dictionary({ 0: Argument(Types.EntityType) }), Types.EntityType, \"Create normalized representation of entity type: \" + Type.oneOfValues(Types.EntityType).join(', ') + \".\"),\r\n    bondFlags: symbol(Arguments.List(Types.BondFlag), Types.BondFlags, \"Create bond flags representation from a list of strings. Allowed flags: \" + Type.oneOfValues(Types.BondFlag).join(', ') + \".\"),\r\n    ringFingerprint: symbol(Arguments.List(Types.ElementSymbol, { nonEmpty: true }), Types.RingFingerprint, 'Create ring fingerprint from the supplied atom element list.'),\r\n    secondaryStructureFlags: symbol(Arguments.List(Types.SecondaryStructureFlag), Types.SecondaryStructureFlags, \"Create secondary structure flags representation from a list of strings. Allowed flags: \" + Type.oneOfValues(Types.SecondaryStructureFlag).join(', ') + \".\"),\r\n    authResidueId: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Str, { description: 'auth_asym_id' }),\r\n        1: Argument(Type.Num, { description: 'auth_seq_id' }),\r\n        2: Argument(Type.Str, { description: 'pdbx_PDB_ins_code', isOptional: true })\r\n    }), Types.ResidueId, \"Residue identifier based on \\\"auth_\\\" annotation.\"),\r\n    labelResidueId: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Str, { description: 'label_entity_id' }),\r\n        1: Argument(Type.Str, { description: 'label_asym_id' }),\r\n        2: Argument(Type.Num, { description: 'label_seq_id' }),\r\n        3: Argument(Type.Str, { description: 'pdbx_PDB_ins_code', isOptional: true })\r\n    }), Types.ResidueId, \"Residue identifier based on mmCIF's \\\"label_\\\" annotation.\")\r\n};\r\nvar slot = {\r\n    '@header': 'Iteration Slots',\r\n    element: symbol(Arguments.None, Types.ElementReference, 'A reference to the current element.'),\r\n    elementSetReduce: symbol(Arguments.None, Type.Variable('a', Type.AnyValue, true), 'Current value of the element set reducer.')\r\n};\r\nvar generator = {\r\n    '@header': 'Generators',\r\n    all: symbol(Arguments.None, Types.ElementSelectionQuery, 'The entire structure.'),\r\n    atomGroups: symbol(Arguments.Dictionary({\r\n        'entity-test': Argument(Type.Bool, { isOptional: true, defaultValue: true, description: 'Test for the 1st atom of every entity' }),\r\n        'chain-test': Argument(Type.Bool, { isOptional: true, defaultValue: true, description: 'Test for the 1st atom of every chain' }),\r\n        'residue-test': Argument(Type.Bool, { isOptional: true, defaultValue: true, description: 'Test for the 1st atom every residue' }),\r\n        'atom-test': Argument(Type.Bool, { isOptional: true, defaultValue: true }),\r\n        'group-by': Argument(Type.Any, { isOptional: true, defaultValue: \"atom-key\", description: 'Group atoms to sets based on this property. Default: each atom has its own set' }),\r\n    }), Types.ElementSelectionQuery, 'Return all atoms for which the tests are satisfied, grouped into sets.'),\r\n    bondedAtomicPairs: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Bool, { isOptional: true, defaultValue: 'true for covalent bonds', description: 'Test each bond with this predicate. Each bond is visited twice with swapped atom order.' }),\r\n        // TODO: shoud we support this or just use queryEach to get similar behavior\r\n        // 'group-by': Argument(Type.Any, { isOptional: true, defaultValue: ``, description: 'Group the bonds using the privided value' }),\r\n    }), Types.ElementSelectionQuery, 'Return all pairs of atoms for which the test is satisfied.'),\r\n    rings: symbol(Arguments.Dictionary({\r\n        'fingerprint': Argument(Types.RingFingerprint, { isOptional: true }),\r\n        'only-aromatic': Argument(Type.Bool, { isOptional: true, defaultValue: false }),\r\n    }), Types.ElementSelectionQuery, 'Return all rings or those with the specified fingerprint and/or only aromatic rings.'),\r\n    queryInSelection: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        query: Argument(Types.ElementSelectionQuery),\r\n        'in-complement': Argument(Type.Bool, { isOptional: true, defaultValue: false })\r\n    }), Types.ElementSelectionQuery, 'Executes query only on atoms that are in the source selection.'),\r\n    empty: symbol(Arguments.None, Types.ElementSelectionQuery, 'Nada.'),\r\n};\r\nvar modifier = {\r\n    '@header': 'Selection Modifications',\r\n    queryEach: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        query: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'Query every atom set in the input selection separately.'),\r\n    intersectBy: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        by: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'Intersect each atom set from the first sequence from atoms in the second one.'),\r\n    exceptBy: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        by: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, \"Remove all atoms from 'selection' that occur in 'by'.\"),\r\n    unionBy: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        by: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'For each atom set A in the orginal sequence, combine all atoms sets in the target selection that intersect with A.'),\r\n    union: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'Collects all atom sets in the sequence into a single atom set.'),\r\n    cluster: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        'min-distance': Argument(Type.Num, { isOptional: true, defaultValue: 0 }),\r\n        'max-distance': Argument(Type.Num),\r\n        'min-size': Argument(Type.Num, { description: 'Minimal number of sets to merge, must be at least 2', isOptional: true, defaultValue: 2 }),\r\n        'max-size': Argument(Type.Num, { description: 'Maximal number of sets to merge, if not set, no limit', isOptional: true }),\r\n    }), Types.ElementSelectionQuery, 'Combines atom sets that have mutual distance in the interval [min-radius, max-radius]. Minimum/maximum size determines how many atom sets can be combined.'),\r\n    includeSurroundings: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        radius: Argument(Type.Num),\r\n        'atom-radius': Argument(Type.Num, { isOptional: true, defaultValue: 0, description: 'Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding.' }),\r\n        'as-whole-residues': Argument(Type.Bool, { isOptional: true })\r\n    }), Types.ElementSelectionQuery, 'For each atom set in the selection, include all surrouding atoms/residues that are within the specified radius.'),\r\n    surroundingLigands: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        radius: Argument(Type.Num),\r\n        'include-water': Argument(Type.Bool, { isOptional: true, defaultValue: true })\r\n    }), Types.ElementSelectionQuery, 'Find all ligands components around the source query.'),\r\n    includeConnected: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        'bond-test': Argument(Type.Bool, { isOptional: true, defaultValue: 'true for covalent bonds' }),\r\n        'layer-count': Argument(Type.Num, { isOptional: true, defaultValue: 1, description: 'Number of bonded layers to include.' }),\r\n        'fixed-point': Argument(Type.Bool, { isOptional: true, defaultValue: false, description: 'Continue adding layers as long as new connections exist.' }),\r\n        'as-whole-residues': Argument(Type.Bool, { isOptional: true })\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets that are connected to the target.'),\r\n    wholeResidues: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n    }), Types.ElementSelectionQuery, 'Expand the selection to whole residues.'),\r\n    expandProperty: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        property: Argument(Type.AnyValue)\r\n    }), Types.ElementSelectionQuery, 'To each atom set in the selection, add all atoms that have the same property value that was already present in the set.')\r\n};\r\nvar filter = {\r\n    '@header': 'Selection Filters',\r\n    pick: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        test: Argument(Type.Bool)\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets that satisfy the test.'),\r\n    first: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'Take the 1st atom set in the sequence.'),\r\n    withSameAtomProperties: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        source: Argument(Types.ElementSelectionQuery),\r\n        property: Argument(Type.Any)\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets for which the set of given atom properties is a subset of the source properties.'),\r\n    intersectedBy: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        by: Argument(Types.ElementSelectionQuery)\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets that have non-zero intersection with the target.'),\r\n    within: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        target: Argument(Types.ElementSelectionQuery),\r\n        'min-radius': Argument(Type.Num, { isOptional: true, defaultValue: 0 }),\r\n        'max-radius': Argument(Type.Num),\r\n        'atom-radius': Argument(Type.Num, { isOptional: true, defaultValue: 0, description: 'Value added to each atom before the distance check, for example VDW radius. Using this argument is computationally demanding.' }),\r\n        invert: Argument(Type.Bool, { isOptional: true, defaultValue: false, description: 'If true, pick only atom sets that are further than the specified radius.' }),\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets from selection that have any atom within the radius of any atom from target.'),\r\n    isConnectedTo: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery),\r\n        target: Argument(Types.ElementSelectionQuery),\r\n        'bond-test': Argument(Type.Bool, { isOptional: true, defaultValue: 'true for covalent bonds' }),\r\n        disjunct: Argument(Type.Bool, { isOptional: true, defaultValue: true, description: 'If true, there must exist a bond to an atom that lies outside the given atom set to pass test.' }),\r\n        invert: Argument(Type.Bool, { isOptional: true, defaultValue: false, description: 'If true, return atom sets that are not connected.' })\r\n    }), Types.ElementSelectionQuery, 'Pick all atom sets that are connected to the target.'),\r\n};\r\nvar combinator = {\r\n    '@header': 'Selection Combinators',\r\n    intersect: symbol(Arguments.List(Types.ElementSelectionQuery), Types.ElementSelectionQuery, 'Return all unique atom sets that appear in all of the source selections.'),\r\n    merge: symbol(Arguments.List(Types.ElementSelectionQuery), Types.ElementSelectionQuery, 'Merges multiple selections into a single one. Only unique atom sets are kept.'),\r\n    distanceCluster: symbol(Arguments.Dictionary({\r\n        matrix: Argument(Core.Types.List(Core.Types.List(Type.Num)), { description: 'Distance matrix, represented as list of rows (num[][])). Lower triangle is min distance, upper triangle is max distance.' }),\r\n        selections: Argument(Core.Types.List(Types.ElementSelectionQuery), { description: 'A list of held selections.' })\r\n    }), Types.ElementSelectionQuery, 'Pick combinations of atom sets from the source sequences that are mutually within distances specified by a matrix.')\r\n};\r\nvar atomSet = {\r\n    '@header': 'Atom Sets',\r\n    atomCount: symbol(Arguments.None, Type.Num),\r\n    countQuery: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.ElementSelectionQuery)\r\n    }), Type.Num, 'Counts the number of occurences of a specific query inside the current atom set.'),\r\n    reduce: symbol(Arguments.Dictionary({\r\n        initial: Argument(Type.Variable('a', Type.AnyValue, true), { description: 'Initial value assigned to slot.atom-set-reduce. Current atom is set to the 1st atom of the current set for this.' }),\r\n        value: Argument(Type.Variable('a', Type.AnyValue, true), { description: 'Expression executed for each atom in the set' })\r\n    }), Type.Variable('a', Type.AnyValue, true), 'Execute the value expression for each atom in the current atom set and return the result. Works the same way as Array.reduce in JavaScript (``result = value(value(...value(initial)))``)'),\r\n    propertySet: symbol(Arguments.Dictionary({\r\n        0: Argument(Core.Types.ConstrainedVar),\r\n    }), Core.Types.Set(Core.Types.ConstrainedVar), 'Returns a set with all values of the given property in the current atom set.'),\r\n};\r\nvar atomProperty = {\r\n    '@header': 'Atom Properties',\r\n    core: {\r\n        '@header': 'Core Properties',\r\n        elementSymbol: atomProp(Types.ElementSymbol),\r\n        vdw: atomProp(Type.Num, 'Van der Waals radius'),\r\n        mass: atomProp(Type.Num, 'Atomic weight'),\r\n        atomicNumber: atomProp(Type.Num, 'Atomic number'),\r\n        x: atomProp(Type.Num, 'Cartesian X coordinate'),\r\n        y: atomProp(Type.Num, 'Cartesian Y coordinate'),\r\n        z: atomProp(Type.Num, 'Cartesian Z coordinate'),\r\n        atomKey: atomProp(Type.AnyValue, 'Unique value for each atom. Main use case is grouping of atoms.'),\r\n        bondCount: symbol(Arguments.Dictionary({\r\n            0: Argument(Types.ElementReference, { isOptional: true, defaultValue: 'slot.current-atom' }),\r\n            flags: Argument(Types.BondFlags, { isOptional: true, defaultValue: 'covalent' }),\r\n        }), Type.Num, 'Number of bonds (by default only covalent bonds are counted).'),\r\n        sourceIndex: atomProp(Type.Num, 'Index of the atom/element in the input file.'),\r\n        operatorName: atomProp(Type.Str, 'Name of the symmetry operator applied to this element.'),\r\n        modelIndex: atomProp(Type.Num, 'Index of the model in the input file.'),\r\n        modelLabel: atomProp(Type.Str, 'Label/header of the model in the input file.')\r\n    },\r\n    topology: {\r\n        connectedComponentKey: atomProp(Type.AnyValue, 'Unique value for each connected component.')\r\n    },\r\n    macromolecular: {\r\n        '@header': 'Macromolecular Properties (derived from the mmCIF format)',\r\n        authResidueId: atomProp(Types.ResidueId, \"type.auth-residue-id symbol executed on current atom's residue\"),\r\n        labelResidueId: atomProp(Types.ResidueId, \"type.label-residue-id symbol executed on current atom's residue\"),\r\n        residueKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``(label_entity_id,auth_asym_id, auth_seq_id, pdbx_PDB_ins_code)``, main use case is grouping of atoms'),\r\n        chainKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``(label_entity_id, auth_asym_id)``, main use case is grouping of atoms'),\r\n        entityKey: atomProp(Type.AnyValue, 'Unique value for each tuple ``label_entity_id``, main use case is grouping of atoms'),\r\n        isHet: atomProp(Type.Bool, 'Equivalent to atom_site.group_PDB !== ATOM'),\r\n        id: atomProp(Type.Num, '_atom_site.id'),\r\n        label_atom_id: atomProp(Types.AtomName),\r\n        label_alt_id: atomProp(Type.Str),\r\n        label_comp_id: atomProp(Type.Str),\r\n        label_asym_id: atomProp(Type.Str),\r\n        label_entity_id: atomProp(Type.Str),\r\n        label_seq_id: atomProp(Type.Num),\r\n        auth_atom_id: atomProp(Types.AtomName),\r\n        auth_comp_id: atomProp(Type.Str),\r\n        auth_asym_id: atomProp(Type.Str),\r\n        auth_seq_id: atomProp(Type.Num),\r\n        pdbx_PDB_ins_code: atomProp(Type.Str),\r\n        pdbx_formal_charge: atomProp(Type.Num),\r\n        occupancy: atomProp(Type.Num),\r\n        B_iso_or_equiv: atomProp(Type.Num),\r\n        entityType: atomProp(Types.EntityType, 'Type of the entity as defined in mmCIF (polymer, non-polymer, branched, water)'),\r\n        entitySubtype: atomProp(Types.EntitySubtype, 'Subtype of the entity as defined in mmCIF _entity_poly.type and _pdbx_entity_branch.type (other, polypeptide(D), polypeptide(L), polydeoxyribonucleotide, polyribonucleotide, polydeoxyribonucleotide/polyribonucleotide hybrid, cyclic-pseudo-peptide, peptide nucleic acid, oligosaccharide)'),\r\n        entityPrdId: atomProp(Type.Str, \"The PRD ID of the entity.\"),\r\n        entityDescription: atomProp(Core.Types.List(Type.Str)),\r\n        objectPrimitive: atomProp(Types.ObjectPrimitive, 'Type of the primitive object used to model this segment as defined in mmCIF/IHM (atomistic, sphere, gaussian, other)'),\r\n        secondaryStructureKey: atomProp(Type.AnyValue, 'Unique value for each secondary structure element.'),\r\n        secondaryStructureFlags: atomProp(Types.SecondaryStructureFlags),\r\n        isModified: atomProp(Type.Bool, 'True if the atom belongs to modification of a standard residue.'),\r\n        modifiedParentName: atomProp(Type.Str, \"'3-letter' code of the modifed parent residue.\"),\r\n        isNonStandard: atomProp(Type.Bool, 'True if this is a non-standard residue.'),\r\n        chemCompType: atomProp(Type.Str, \"Type of the chemical component as defined in mmCIF.\"),\r\n    }\r\n};\r\nvar bondProperty = {\r\n    '@header': 'Bond Properties',\r\n    flags: bondProp(Types.BondFlags),\r\n    order: bondProp(Type.Num),\r\n    length: bondProp(Type.Num),\r\n    atomA: bondProp(Types.ElementReference),\r\n    atomB: bondProp(Types.ElementReference)\r\n};\r\nfunction atomProp(type, description) {\r\n    return symbol(Arguments.Dictionary({ 0: Argument(Types.ElementReference, { isOptional: true, defaultValue: 'slot.current-atom' }) }), type, description);\r\n}\r\nfunction bondProp(type, description) {\r\n    return symbol(Arguments.None, type, description);\r\n}\r\nexport var structureQuery = {\r\n    '@header': 'Structure Queries',\r\n    type: type,\r\n    slot: slot,\r\n    generator: generator,\r\n    modifier: modifier,\r\n    filter: filter,\r\n    combinator: combinator,\r\n    atomSet: atomSet,\r\n    atomProperty: atomProperty,\r\n    bondProperty: bondProperty\r\n};\r\n//# sourceMappingURL=structure-query.js.map"]},"metadata":{},"sourceType":"module"}