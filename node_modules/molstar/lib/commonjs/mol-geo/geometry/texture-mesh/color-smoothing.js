"use strict";
/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcTextureMeshColorSmoothing = exports.ColorNormalizeSchema = exports.ColorAccumulateSchema = void 0;
var tslib_1 = require("tslib");
var mol_util_1 = require("../../../mol-util");
var renderable_1 = require("../../../mol-gl/renderable");
var shader_code_1 = require("../../../mol-gl/shader-code");
var render_item_1 = require("../../../mol-gl/webgl/render-item");
var schema_1 = require("../../../mol-gl/renderable/schema");
var quad_vert_1 = require("../../../mol-gl/shader/quad.vert");
var normalize_frag_1 = require("../../../mol-gl/shader/compute/color-smoothing/normalize.frag");
var util_1 = require("../../../mol-gl/compute/util");
var linear_algebra_1 = require("../../../mol-math/linear-algebra");
var geometry_1 = require("../../../mol-math/geometry");
var accumulate_frag_1 = require("../../../mol-gl/shader/compute/color-smoothing/accumulate.frag");
var accumulate_vert_1 = require("../../../mol-gl/shader/compute/color-smoothing/accumulate.vert");
exports.ColorAccumulateSchema = {
    drawCount: (0, schema_1.ValueSpec)('number'),
    instanceCount: (0, schema_1.ValueSpec)('number'),
    stride: (0, schema_1.ValueSpec)('number'),
    uTotalCount: (0, schema_1.UniformSpec)('i'),
    uInstanceCount: (0, schema_1.UniformSpec)('i'),
    uGroupCount: (0, schema_1.UniformSpec)('i'),
    aTransform: (0, schema_1.AttributeSpec)('float32', 16, 1),
    aInstance: (0, schema_1.AttributeSpec)('float32', 1, 1),
    aSample: (0, schema_1.AttributeSpec)('float32', 1, 0),
    uGeoTexDim: (0, schema_1.UniformSpec)('v2', 'buffered'),
    tPosition: (0, schema_1.TextureSpec)('texture', 'rgba', 'float', 'nearest'),
    tGroup: (0, schema_1.TextureSpec)('texture', 'rgba', 'float', 'nearest'),
    uColorTexDim: (0, schema_1.UniformSpec)('v2'),
    tColor: (0, schema_1.TextureSpec)('image-uint8', 'rgb', 'ubyte', 'nearest'),
    dColorType: (0, schema_1.DefineSpec)('string', ['group', 'groupInstance', 'vertex', 'vertexInstance']),
    uCurrentSlice: (0, schema_1.UniformSpec)('f'),
    uCurrentX: (0, schema_1.UniformSpec)('f'),
    uCurrentY: (0, schema_1.UniformSpec)('f'),
    uBboxMin: (0, schema_1.UniformSpec)('v3', 'material'),
    uBboxSize: (0, schema_1.UniformSpec)('v3', 'material'),
    uResolution: (0, schema_1.UniformSpec)('f', 'material'),
};
var ColorAccumulateName = 'color-accumulate';
function getSampleBuffer(sampleCount, stride) {
    var sampleBuffer = new Float32Array(sampleCount);
    for (var i = 0; i < sampleCount; ++i) {
        sampleBuffer[i] = i * stride;
    }
    return sampleBuffer;
}
function getAccumulateRenderable(ctx, input, box, resolution, stride) {
    if (ctx.namedComputeRenderables[ColorAccumulateName]) {
        var extent = linear_algebra_1.Vec3.sub((0, linear_algebra_1.Vec3)(), box.max, box.min);
        var v = ctx.namedComputeRenderables[ColorAccumulateName].values;
        var sampleCount = Math.round(input.vertexCount / stride);
        if (sampleCount > v.drawCount.ref.value || stride !== v.stride.ref.value) {
            mol_util_1.ValueCell.update(v.aSample, getSampleBuffer(sampleCount, stride));
        }
        mol_util_1.ValueCell.updateIfChanged(v.drawCount, sampleCount);
        mol_util_1.ValueCell.updateIfChanged(v.instanceCount, input.instanceCount);
        mol_util_1.ValueCell.updateIfChanged(v.stride, stride);
        mol_util_1.ValueCell.updateIfChanged(v.uTotalCount, input.vertexCount);
        mol_util_1.ValueCell.updateIfChanged(v.uInstanceCount, input.instanceCount);
        mol_util_1.ValueCell.updateIfChanged(v.uGroupCount, input.groupCount);
        mol_util_1.ValueCell.update(v.aTransform, input.transformBuffer);
        mol_util_1.ValueCell.update(v.aInstance, input.instanceBuffer);
        mol_util_1.ValueCell.update(v.uGeoTexDim, linear_algebra_1.Vec2.set(v.uGeoTexDim.ref.value, input.positionTexture.getWidth(), input.positionTexture.getHeight()));
        mol_util_1.ValueCell.update(v.tPosition, input.positionTexture);
        mol_util_1.ValueCell.update(v.tGroup, input.groupTexture);
        mol_util_1.ValueCell.update(v.uColorTexDim, linear_algebra_1.Vec2.set(v.uColorTexDim.ref.value, input.colorData.width, input.colorData.height));
        mol_util_1.ValueCell.update(v.tColor, input.colorData);
        mol_util_1.ValueCell.updateIfChanged(v.dColorType, input.colorType);
        mol_util_1.ValueCell.updateIfChanged(v.uCurrentSlice, 0);
        mol_util_1.ValueCell.updateIfChanged(v.uCurrentX, 0);
        mol_util_1.ValueCell.updateIfChanged(v.uCurrentY, 0);
        mol_util_1.ValueCell.update(v.uBboxMin, box.min);
        mol_util_1.ValueCell.update(v.uBboxSize, extent);
        mol_util_1.ValueCell.updateIfChanged(v.uResolution, resolution);
        ctx.namedComputeRenderables[ColorAccumulateName].update();
    }
    else {
        ctx.namedComputeRenderables[ColorAccumulateName] = createAccumulateRenderable(ctx, input, box, resolution, stride);
    }
    return ctx.namedComputeRenderables[ColorAccumulateName];
}
function createAccumulateRenderable(ctx, input, box, resolution, stride) {
    var extent = linear_algebra_1.Vec3.sub((0, linear_algebra_1.Vec3)(), box.max, box.min);
    var sampleCount = Math.round(input.vertexCount / stride);
    var values = {
        drawCount: mol_util_1.ValueCell.create(sampleCount),
        instanceCount: mol_util_1.ValueCell.create(input.instanceCount),
        stride: mol_util_1.ValueCell.create(stride),
        uTotalCount: mol_util_1.ValueCell.create(input.vertexCount),
        uInstanceCount: mol_util_1.ValueCell.create(input.instanceCount),
        uGroupCount: mol_util_1.ValueCell.create(input.groupCount),
        aTransform: mol_util_1.ValueCell.create(input.transformBuffer),
        aInstance: mol_util_1.ValueCell.create(input.instanceBuffer),
        aSample: mol_util_1.ValueCell.create(getSampleBuffer(sampleCount, stride)),
        uGeoTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(input.positionTexture.getWidth(), input.positionTexture.getHeight())),
        tPosition: mol_util_1.ValueCell.create(input.positionTexture),
        tGroup: mol_util_1.ValueCell.create(input.groupTexture),
        uColorTexDim: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(input.colorData.width, input.colorData.height)),
        tColor: mol_util_1.ValueCell.create(input.colorData),
        dColorType: mol_util_1.ValueCell.create(input.colorType),
        uCurrentSlice: mol_util_1.ValueCell.create(0),
        uCurrentX: mol_util_1.ValueCell.create(0),
        uCurrentY: mol_util_1.ValueCell.create(0),
        uBboxMin: mol_util_1.ValueCell.create(box.min),
        uBboxSize: mol_util_1.ValueCell.create(extent),
        uResolution: mol_util_1.ValueCell.create(resolution),
    };
    var schema = (0, tslib_1.__assign)({}, exports.ColorAccumulateSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('accumulate', accumulate_vert_1.accumulate_vert, accumulate_frag_1.accumulate_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'points', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
function setAccumulateDefaults(ctx) {
    var gl = ctx.gl, state = ctx.state;
    state.disable(gl.CULL_FACE);
    state.enable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.enable(gl.SCISSOR_TEST);
    state.depthMask(false);
    state.clearColor(0, 0, 0, 0);
    state.blendFunc(gl.ONE, gl.ONE);
    state.blendEquation(gl.FUNC_ADD);
}
//
exports.ColorNormalizeSchema = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, util_1.QuadSchema), { tColor: (0, schema_1.TextureSpec)('texture', 'rgba', 'float', 'nearest'), uTexSize: (0, schema_1.UniformSpec)('v2') });
var ColorNormalizeName = 'color-normalize';
function getNormalizeRenderable(ctx, color) {
    if (ctx.namedComputeRenderables[ColorNormalizeName]) {
        var v = ctx.namedComputeRenderables[ColorNormalizeName].values;
        mol_util_1.ValueCell.update(v.tColor, color);
        mol_util_1.ValueCell.update(v.uTexSize, linear_algebra_1.Vec2.set(v.uTexSize.ref.value, color.getWidth(), color.getHeight()));
        ctx.namedComputeRenderables[ColorNormalizeName].update();
    }
    else {
        ctx.namedComputeRenderables[ColorNormalizeName] = createColorNormalizeRenderable(ctx, color);
    }
    return ctx.namedComputeRenderables[ColorNormalizeName];
}
function createColorNormalizeRenderable(ctx, color) {
    var values = (0, tslib_1.__assign)((0, tslib_1.__assign)({}, util_1.QuadValues), { tColor: mol_util_1.ValueCell.create(color), uTexSize: mol_util_1.ValueCell.create(linear_algebra_1.Vec2.create(color.getWidth(), color.getHeight())) });
    var schema = (0, tslib_1.__assign)({}, exports.ColorNormalizeSchema);
    var shaderCode = (0, shader_code_1.ShaderCode)('normalize', quad_vert_1.quad_vert, normalize_frag_1.normalize_frag);
    var renderItem = (0, render_item_1.createComputeRenderItem)(ctx, 'triangles', shaderCode, schema, values);
    return (0, renderable_1.createComputeRenderable)(renderItem, values);
}
function setNormalizeDefaults(ctx) {
    var gl = ctx.gl, state = ctx.state;
    state.disable(gl.CULL_FACE);
    state.enable(gl.BLEND);
    state.disable(gl.DEPTH_TEST);
    state.enable(gl.SCISSOR_TEST);
    state.depthMask(false);
    state.clearColor(0, 0, 0, 0);
    state.blendFunc(gl.ONE, gl.ONE);
    state.blendEquation(gl.FUNC_ADD);
}
//
function getTexture2dSize(gridDim) {
    var area = gridDim[0] * gridDim[1] * gridDim[2];
    var squareDim = Math.sqrt(area);
    var powerOfTwoSize = Math.pow(2, Math.ceil(Math.log(squareDim) / Math.log(2)));
    var texDimX = 0;
    var texDimY = gridDim[1];
    var texRows = 1;
    var texCols = gridDim[2];
    if (powerOfTwoSize < gridDim[0] * gridDim[2]) {
        texCols = Math.floor(powerOfTwoSize / gridDim[0]);
        texRows = Math.ceil(gridDim[2] / texCols);
        texDimX = texCols * gridDim[0];
        texDimY *= texRows;
    }
    else {
        texDimX = gridDim[0] * gridDim[2];
    }
    // console.log(texDimX, texDimY, texDimY < powerOfTwoSize ? powerOfTwoSize : powerOfTwoSize * 2);
    return { texDimX: texDimX, texDimY: texDimY, texRows: texRows, texCols: texCols, powerOfTwoSize: texDimY < powerOfTwoSize ? powerOfTwoSize : powerOfTwoSize * 2 };
}
function calcTextureMeshColorSmoothing(input, resolution, stride, webgl, texture) {
    var gl = webgl.gl, resources = webgl.resources, state = webgl.state, _a = webgl.extensions, colorBufferHalfFloat = _a.colorBufferHalfFloat, textureHalfFloat = _a.textureHalfFloat;
    var isInstanceType = input.colorType.endsWith('Instance');
    var box = geometry_1.Box3D.fromSphere3D((0, geometry_1.Box3D)(), isInstanceType ? input.boundingSphere : input.invariantBoundingSphere);
    var scaleFactor = 1 / resolution;
    var scaledBox = geometry_1.Box3D.scale((0, geometry_1.Box3D)(), box, scaleFactor);
    var gridDim = geometry_1.Box3D.size((0, linear_algebra_1.Vec3)(), scaledBox);
    linear_algebra_1.Vec3.ceil(gridDim, gridDim);
    linear_algebra_1.Vec3.add(gridDim, gridDim, linear_algebra_1.Vec3.create(2, 2, 2));
    var min = box.min;
    var dx = gridDim[0], dy = gridDim[1], dz = gridDim[2];
    var _b = getTexture2dSize(gridDim), width = _b.texDimX, height = _b.texDimY, texCols = _b.texCols;
    // console.log({ width, height, texCols, dim, resolution });
    if (!webgl.namedTextures[ColorAccumulateName]) {
        webgl.namedTextures[ColorAccumulateName] = colorBufferHalfFloat && textureHalfFloat
            ? resources.texture('image-float16', 'rgba', 'fp16', 'nearest')
            : resources.texture('image-float32', 'rgba', 'float', 'nearest');
    }
    var accumulateTexture = webgl.namedTextures[ColorAccumulateName];
    accumulateTexture.define(width, height);
    var accumulateRenderable = getAccumulateRenderable(webgl, input, box, resolution, stride);
    //
    var _c = accumulateRenderable.values, uCurrentSlice = _c.uCurrentSlice, uCurrentX = _c.uCurrentX, uCurrentY = _c.uCurrentY;
    if (!webgl.namedFramebuffers[ColorAccumulateName]) {
        webgl.namedFramebuffers[ColorAccumulateName] = webgl.resources.framebuffer();
    }
    var framebuffer = webgl.namedFramebuffers[ColorAccumulateName];
    framebuffer.bind();
    setAccumulateDefaults(webgl);
    state.currentRenderItemId = -1;
    accumulateTexture.attachFramebuffer(framebuffer, 0);
    gl.viewport(0, 0, width, height);
    gl.scissor(0, 0, width, height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    mol_util_1.ValueCell.update(uCurrentY, 0);
    var currCol = 0;
    var currY = 0;
    var currX = 0;
    for (var i = 0; i < dz; ++i) {
        if (currCol >= texCols) {
            currCol -= texCols;
            currY += dy;
            currX = 0;
            mol_util_1.ValueCell.update(uCurrentY, currY);
        }
        // console.log({ i, currX, currY });
        mol_util_1.ValueCell.update(uCurrentX, currX);
        mol_util_1.ValueCell.update(uCurrentSlice, i);
        gl.viewport(currX, currY, dx, dy);
        gl.scissor(currX, currY, dx, dy);
        accumulateRenderable.render();
        ++currCol;
        currX += dx;
    }
    // const accImage = new Float32Array(width * height * 4);
    // accumulateTexture.attachFramebuffer(framebuffer, 0);
    // webgl.readPixels(0, 0, width, height, accImage);
    // console.log(accImage);
    // printTextureImage({ array: accImage, width, height }, 1 / 4);
    // normalize
    if (!texture)
        texture = resources.texture('image-uint8', 'rgb', 'ubyte', 'linear');
    texture.define(width, height);
    var normalizeRenderable = getNormalizeRenderable(webgl, accumulateTexture);
    setNormalizeDefaults(webgl);
    state.currentRenderItemId = -1;
    texture.attachFramebuffer(framebuffer, 0);
    gl.viewport(0, 0, width, height);
    gl.scissor(0, 0, width, height);
    gl.clear(gl.COLOR_BUFFER_BIT);
    normalizeRenderable.render();
    // const normImage = new Uint8Array(width * height * 4);
    // texture.attachFramebuffer(framebuffer, 0);
    // webgl.readPixels(0, 0, width, height, normImage);
    // console.log(normImage);
    // printTextureImage({ array: normImage, width, height }, 1 / 4);
    var gridTransform = linear_algebra_1.Vec4.create(min[0], min[1], min[2], scaleFactor);
    var type = isInstanceType ? 'volumeInstance' : 'volume';
    return { texture: texture, gridDim: gridDim, gridTexDim: linear_algebra_1.Vec2.create(width, height), gridTransform: gridTransform, type: type };
}
exports.calcTextureMeshColorSmoothing = calcTextureMeshColorSmoothing;
//# sourceMappingURL=color-smoothing.js.map