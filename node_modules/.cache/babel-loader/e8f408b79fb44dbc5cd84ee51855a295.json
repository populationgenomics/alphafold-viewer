{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../../../mol-task';\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\nimport { GaussianDensityTexture, GaussianDensityTexture2d } from '../../../../mol-math/geometry/gaussian-density/gpu';\nimport { getUnitConformationAndRadius, getStructureConformationAndRadius, CommonSurfaceParams, ensureReasonableResolution } from './common';\nimport { BaseGeometry } from '../../../../mol-geo/geometry/base';\nimport { GaussianDensityCPU } from '../../../../mol-math/geometry/gaussian-density/cpu';\nexport var GaussianDensityParams = __assign({\n  resolution: PD.Numeric(1, {\n    min: 0.1,\n    max: 20,\n    step: 0.1\n  }, __assign({\n    description: 'Grid resolution/cell spacing.'\n  }, BaseGeometry.CustomQualityParamInfo)),\n  radiusOffset: PD.Numeric(0, {\n    min: 0,\n    max: 10,\n    step: 0.1\n  }, {\n    description: 'Extra/offset radius added to the atoms/coarse elements for gaussian calculation. Useful to create coarse, low resolution surfaces.'\n  }),\n  smoothness: PD.Numeric(1.5, {\n    min: 0.5,\n    max: 2.5,\n    step: 0.1\n  }, {\n    description: 'Smoothness of the gausian surface, lower is smoother.'\n  })\n}, CommonSurfaceParams);\nexport var DefaultGaussianDensityProps = PD.getDefaultValues(GaussianDensityParams); //\n\nexport function getTextureMaxCells(webgl, structure) {\n  var d = webgl.maxTextureSize / 3;\n  return d * d / Math.max(1, structure ? structure.units.length / 16 : 1);\n} //\n\nexport function computeUnitGaussianDensity(structure, unit, props) {\n  var _this = this;\n\n  var box = unit.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props);\n\n  var _a = getUnitConformationAndRadius(structure, unit, p),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , GaussianDensityCPU(ctx, position, box, radius, p)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  });\n}\nexport function computeUnitGaussianDensityTexture(structure, unit, props, webgl, texture) {\n  var _this = this;\n\n  var box = unit.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl, structure));\n\n  var _a = getUnitConformationAndRadius(structure, unit, p),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , GaussianDensityTexture(webgl, position, box, radius, p, texture)];\n      });\n    });\n  });\n}\nexport function computeUnitGaussianDensityTexture2d(structure, unit, powerOfTwo, props, webgl, texture) {\n  var _this = this;\n\n  var box = unit.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl, structure));\n\n  var _a = getUnitConformationAndRadius(structure, unit, p),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , GaussianDensityTexture2d(webgl, position, box, radius, powerOfTwo, p, texture)];\n      });\n    });\n  });\n} //\n\nexport function computeStructureGaussianDensity(structure, props) {\n  var _this = this;\n\n  var box = structure.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props);\n\n  var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , GaussianDensityCPU(ctx, position, box, radius, p)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  });\n}\nexport function computeStructureGaussianDensityTexture(structure, props, webgl, texture) {\n  var _this = this;\n\n  var box = structure.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl));\n\n  var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , GaussianDensityTexture(webgl, position, box, radius, p, texture)];\n      });\n    });\n  });\n}\nexport function computeStructureGaussianDensityTexture2d(structure, powerOfTwo, props, webgl, texture) {\n  var _this = this;\n\n  var box = structure.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl));\n\n  var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly),\n      position = _a.position,\n      radius = _a.radius;\n\n  return Task.create('Gaussian Density', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , GaussianDensityTexture2d(webgl, position, box, radius, powerOfTwo, p, texture)];\n      });\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/gaussian.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../../../mol-task';\r\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\r\nimport { GaussianDensityTexture, GaussianDensityTexture2d } from '../../../../mol-math/geometry/gaussian-density/gpu';\r\nimport { getUnitConformationAndRadius, getStructureConformationAndRadius, CommonSurfaceParams, ensureReasonableResolution } from './common';\r\nimport { BaseGeometry } from '../../../../mol-geo/geometry/base';\r\nimport { GaussianDensityCPU } from '../../../../mol-math/geometry/gaussian-density/cpu';\r\nexport var GaussianDensityParams = __assign({ resolution: PD.Numeric(1, { min: 0.1, max: 20, step: 0.1 }, __assign({ description: 'Grid resolution/cell spacing.' }, BaseGeometry.CustomQualityParamInfo)), radiusOffset: PD.Numeric(0, { min: 0, max: 10, step: 0.1 }, { description: 'Extra/offset radius added to the atoms/coarse elements for gaussian calculation. Useful to create coarse, low resolution surfaces.' }), smoothness: PD.Numeric(1.5, { min: 0.5, max: 2.5, step: 0.1 }, { description: 'Smoothness of the gausian surface, lower is smoother.' }) }, CommonSurfaceParams);\r\nexport var DefaultGaussianDensityProps = PD.getDefaultValues(GaussianDensityParams);\r\n//\r\nexport function getTextureMaxCells(webgl, structure) {\r\n    var d = webgl.maxTextureSize / 3;\r\n    return (d * d) / Math.max(1, (structure ? structure.units.length / 16 : 1));\r\n}\r\n//\r\nexport function computeUnitGaussianDensity(structure, unit, props) {\r\n    var _this = this;\r\n    var box = unit.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props);\r\n    var _a = getUnitConformationAndRadius(structure, unit, p), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, GaussianDensityCPU(ctx, position, box, radius, p)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nexport function computeUnitGaussianDensityTexture(structure, unit, props, webgl, texture) {\r\n    var _this = this;\r\n    var box = unit.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl, structure));\r\n    var _a = getUnitConformationAndRadius(structure, unit, p), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, GaussianDensityTexture(webgl, position, box, radius, p, texture)];\r\n        });\r\n    }); });\r\n}\r\nexport function computeUnitGaussianDensityTexture2d(structure, unit, powerOfTwo, props, webgl, texture) {\r\n    var _this = this;\r\n    var box = unit.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl, structure));\r\n    var _a = getUnitConformationAndRadius(structure, unit, p), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, GaussianDensityTexture2d(webgl, position, box, radius, powerOfTwo, p, texture)];\r\n        });\r\n    }); });\r\n}\r\n//\r\nexport function computeStructureGaussianDensity(structure, props) {\r\n    var _this = this;\r\n    var box = structure.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props);\r\n    var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, GaussianDensityCPU(ctx, position, box, radius, p)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nexport function computeStructureGaussianDensityTexture(structure, props, webgl, texture) {\r\n    var _this = this;\r\n    var box = structure.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl));\r\n    var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, GaussianDensityTexture(webgl, position, box, radius, p, texture)];\r\n        });\r\n    }); });\r\n}\r\nexport function computeStructureGaussianDensityTexture2d(structure, powerOfTwo, props, webgl, texture) {\r\n    var _this = this;\r\n    var box = structure.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props, getTextureMaxCells(webgl));\r\n    var _a = getStructureConformationAndRadius(structure, props.ignoreHydrogens, props.traceOnly), position = _a.position, radius = _a.radius;\r\n    return Task.create('Gaussian Density', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, GaussianDensityTexture2d(webgl, position, box, radius, powerOfTwo, p, texture)];\r\n        });\r\n    }); });\r\n}\r\n//# sourceMappingURL=gaussian.js.map"]},"metadata":{},"sourceType":"module"}