{"ast":null,"code":"/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Segmentation } from '../../../../../mol-data/int';\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\nimport { getPolymerRanges } from '../polymer';\nexport function eachPolymerBackboneLink(unit, callback) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return eachAtomicPolymerBackboneLink(unit, callback);\n\n    case 1\n    /* Spheres */\n    :\n    case 2\n    /* Gaussians */\n    :\n      return eachCoarsePolymerBackboneLink(unit, callback);\n  }\n}\n\nfunction eachAtomicPolymerBackboneLink(unit, callback) {\n  var cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;\n  var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\n  var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n  var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\n\n  var moleculeType = unit.model.atomicHierarchy.derived.residue.moleculeType;\n  var indexA = -1;\n  var indexB = -1;\n  var isFirst = true;\n  var firstGroup = -1;\n  var i = 0;\n\n  while (polymerIt.hasNext) {\n    isFirst = true;\n    firstGroup = i;\n    residueIt.setSegment(polymerIt.move());\n\n    while (residueIt.hasNext) {\n      if (isFirst) {\n        var index_1 = residueIt.move().index;\n        ++i;\n        if (!residueIt.hasNext) continue;\n        isFirst = false;\n        indexB = index_1;\n      }\n\n      var index = residueIt.move().index;\n      indexA = indexB;\n      indexB = index;\n      callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, i, moleculeType[indexA]);\n      ++i;\n    }\n\n    if (cyclicPolymerMap.has(indexB)) {\n      indexA = indexB;\n      indexB = cyclicPolymerMap.get(indexA);\n      callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, firstGroup, moleculeType[indexA]);\n    }\n  }\n}\n\nfunction eachCoarsePolymerBackboneLink(unit, callback) {\n  var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\n  var elements = unit.elements;\n  var isFirst = true;\n  var i = 0;\n\n  while (polymerIt.hasNext) {\n    isFirst = true;\n\n    var _a = polymerIt.move(),\n        start = _a.start,\n        end = _a.end;\n\n    for (var j = start, jl = end; j < jl; ++j) {\n      if (isFirst) {\n        ++j;\n        ++i;\n        if (j > jl) continue;\n        isFirst = false;\n      }\n\n      callback(elements[j - 1], elements[j], i - 1, i, 0\n      /* Unknown */\n      );\n      ++i;\n    }\n  }\n}\n\nexport function eachPolymerBackboneElement(unit, callback) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return eachAtomicPolymerBackboneElement(unit, callback);\n\n    case 1\n    /* Spheres */\n    :\n    case 2\n    /* Gaussians */\n    :\n      return eachCoarsePolymerBackboneElement(unit, callback);\n  }\n}\nexport function eachAtomicPolymerBackboneElement(unit, callback) {\n  var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\n  var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n  var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\n\n  var i = 0;\n\n  while (polymerIt.hasNext) {\n    residueIt.setSegment(polymerIt.move());\n\n    while (residueIt.hasNext) {\n      var index = residueIt.move().index;\n      callback(traceElementIndex[index], i);\n      ++i;\n    }\n  }\n}\n\nfunction eachCoarsePolymerBackboneElement(unit, callback) {\n  var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\n  var elements = unit.elements;\n  var i = 0;\n\n  while (polymerIt.hasNext) {\n    var _a = polymerIt.move(),\n        start = _a.start,\n        end = _a.end;\n\n    for (var j = start, jl = end; j < jl; ++j) {\n      callback(elements[j], i);\n      ++i;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../../src/mol-repr/structure/visual/util/polymer/backbone.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Segmentation } from '../../../../../mol-data/int';\r\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\r\nimport { getPolymerRanges } from '../polymer';\r\nexport function eachPolymerBackboneLink(unit, callback) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return eachAtomicPolymerBackboneLink(unit, callback);\r\n        case 1 /* Spheres */:\r\n        case 2 /* Gaussians */:\r\n            return eachCoarsePolymerBackboneLink(unit, callback);\r\n    }\r\n}\r\nfunction eachAtomicPolymerBackboneLink(unit, callback) {\r\n    var cyclicPolymerMap = unit.model.atomicRanges.cyclicPolymerMap;\r\n    var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\r\n    var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\r\n    var moleculeType = unit.model.atomicHierarchy.derived.residue.moleculeType;\r\n    var indexA = -1;\r\n    var indexB = -1;\r\n    var isFirst = true;\r\n    var firstGroup = -1;\r\n    var i = 0;\r\n    while (polymerIt.hasNext) {\r\n        isFirst = true;\r\n        firstGroup = i;\r\n        residueIt.setSegment(polymerIt.move());\r\n        while (residueIt.hasNext) {\r\n            if (isFirst) {\r\n                var index_1 = residueIt.move().index;\r\n                ++i;\r\n                if (!residueIt.hasNext)\r\n                    continue;\r\n                isFirst = false;\r\n                indexB = index_1;\r\n            }\r\n            var index = residueIt.move().index;\r\n            indexA = indexB;\r\n            indexB = index;\r\n            callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, i, moleculeType[indexA]);\r\n            ++i;\r\n        }\r\n        if (cyclicPolymerMap.has(indexB)) {\r\n            indexA = indexB;\r\n            indexB = cyclicPolymerMap.get(indexA);\r\n            callback(traceElementIndex[indexA], traceElementIndex[indexB], i - 1, firstGroup, moleculeType[indexA]);\r\n        }\r\n    }\r\n}\r\nfunction eachCoarsePolymerBackboneLink(unit, callback) {\r\n    var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\r\n    var elements = unit.elements;\r\n    var isFirst = true;\r\n    var i = 0;\r\n    while (polymerIt.hasNext) {\r\n        isFirst = true;\r\n        var _a = polymerIt.move(), start = _a.start, end = _a.end;\r\n        for (var j = start, jl = end; j < jl; ++j) {\r\n            if (isFirst) {\r\n                ++j;\r\n                ++i;\r\n                if (j > jl)\r\n                    continue;\r\n                isFirst = false;\r\n            }\r\n            callback(elements[j - 1], elements[j], i - 1, i, 0 /* Unknown */);\r\n            ++i;\r\n        }\r\n    }\r\n}\r\nexport function eachPolymerBackboneElement(unit, callback) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */: return eachAtomicPolymerBackboneElement(unit, callback);\r\n        case 1 /* Spheres */:\r\n        case 2 /* Gaussians */:\r\n            return eachCoarsePolymerBackboneElement(unit, callback);\r\n    }\r\n}\r\nexport function eachAtomicPolymerBackboneElement(unit, callback) {\r\n    var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\r\n    var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues\r\n    var i = 0;\r\n    while (polymerIt.hasNext) {\r\n        residueIt.setSegment(polymerIt.move());\r\n        while (residueIt.hasNext) {\r\n            var index = residueIt.move().index;\r\n            callback(traceElementIndex[index], i);\r\n            ++i;\r\n        }\r\n    }\r\n}\r\nfunction eachCoarsePolymerBackboneElement(unit, callback) {\r\n    var polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);\r\n    var elements = unit.elements;\r\n    var i = 0;\r\n    while (polymerIt.hasNext) {\r\n        var _a = polymerIt.move(), start = _a.start, end = _a.end;\r\n        for (var j = start, jl = end; j < jl; ++j) {\r\n            callback(elements[j], i);\r\n            ++i;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=backbone.js.map"]},"metadata":{},"sourceType":"module"}