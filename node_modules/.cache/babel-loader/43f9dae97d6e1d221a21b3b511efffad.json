{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\nimport { radToDeg } from '../../../../mol-math/misc';\n/**\r\n * Bend(i) =: [angle ((CW - Ca(i - 2)),(C\"(i + 2) - C\"(i))) > 70\"]\r\n *\r\n * Type: S\r\n */\n\nexport function assignBends(ctx) {\n  var unit = ctx.unit,\n      flags = ctx.flags,\n      proteinInfo = ctx.proteinInfo;\n  var position = unit.conformation.position;\n  var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\n  var residueIndices = proteinInfo.residueIndices,\n      nIndices = proteinInfo.nIndices;\n  var residueCount = residueIndices.length; // const position = (i: number, v: Vec3) => Vec3.set(v, x[i], y[i], z[i])\n\n  var p = function (i, v) {\n    return i === -1 ? Vec3.setNaN(v) : position(i, v);\n  };\n\n  var caPosPrev2 = Vec3();\n  var caPos = Vec3();\n  var caPosNext2 = Vec3();\n  var cPos = Vec3();\n  var nPosNext = Vec3();\n  var caMinus2 = Vec3();\n  var caPlus2 = Vec3();\n\n  f1: for (var i = 2; i < residueCount - 2; i++) {\n    // check for peptide bond\n    for (var k = 0; k < 4; k++) {\n      var index = i + k - 2;\n      p(traceElementIndex[index], cPos);\n      p(nIndices[index + 1], nPosNext);\n\n      if (Vec3.squaredDistance(cPos, nPosNext) > 6.25\n      /* max squared peptide bond distance allowed */\n      ) {\n        continue f1;\n      }\n    }\n\n    var oRIprev2 = residueIndices[i - 2];\n    var oRI = residueIndices[i];\n    var oRInext2 = residueIndices[i + 2];\n    var caAtomPrev2 = traceElementIndex[oRIprev2];\n    var caAtom = traceElementIndex[oRI];\n    var caAtomNext2 = traceElementIndex[oRInext2];\n    p(caAtomPrev2, caPosPrev2);\n    p(caAtom, caPos);\n    p(caAtomNext2, caPosNext2);\n    Vec3.sub(caMinus2, caPosPrev2, caPos);\n    Vec3.sub(caPlus2, caPos, caPosNext2);\n    var angle = radToDeg(Vec3.angle(caMinus2, caPlus2));\n\n    if (angle && angle > 70.00) {\n      flags[i] |= 32\n      /* S */\n      ;\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/bends.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\r\nimport { radToDeg } from '../../../../mol-math/misc';\r\n/**\r\n * Bend(i) =: [angle ((CW - Ca(i - 2)),(C\"(i + 2) - C\"(i))) > 70\"]\r\n *\r\n * Type: S\r\n */\r\nexport function assignBends(ctx) {\r\n    var unit = ctx.unit, flags = ctx.flags, proteinInfo = ctx.proteinInfo;\r\n    var position = unit.conformation.position;\r\n    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var residueIndices = proteinInfo.residueIndices, nIndices = proteinInfo.nIndices;\r\n    var residueCount = residueIndices.length;\r\n    // const position = (i: number, v: Vec3) => Vec3.set(v, x[i], y[i], z[i])\r\n    var p = function (i, v) { return i === -1 ? Vec3.setNaN(v) : position(i, v); };\r\n    var caPosPrev2 = Vec3();\r\n    var caPos = Vec3();\r\n    var caPosNext2 = Vec3();\r\n    var cPos = Vec3();\r\n    var nPosNext = Vec3();\r\n    var caMinus2 = Vec3();\r\n    var caPlus2 = Vec3();\r\n    f1: for (var i = 2; i < residueCount - 2; i++) {\r\n        // check for peptide bond\r\n        for (var k = 0; k < 4; k++) {\r\n            var index = i + k - 2;\r\n            p(traceElementIndex[index], cPos);\r\n            p(nIndices[index + 1], nPosNext);\r\n            if (Vec3.squaredDistance(cPos, nPosNext) > 6.25 /* max squared peptide bond distance allowed */) {\r\n                continue f1;\r\n            }\r\n        }\r\n        var oRIprev2 = residueIndices[i - 2];\r\n        var oRI = residueIndices[i];\r\n        var oRInext2 = residueIndices[i + 2];\r\n        var caAtomPrev2 = traceElementIndex[oRIprev2];\r\n        var caAtom = traceElementIndex[oRI];\r\n        var caAtomNext2 = traceElementIndex[oRInext2];\r\n        p(caAtomPrev2, caPosPrev2);\r\n        p(caAtom, caPos);\r\n        p(caAtomNext2, caPosNext2);\r\n        Vec3.sub(caMinus2, caPosPrev2, caPos);\r\n        Vec3.sub(caPlus2, caPos, caPosNext2);\r\n        var angle = radToDeg(Vec3.angle(caMinus2, caPlus2));\r\n        if (angle && angle > 70.00) {\r\n            flags[i] |= 32 /* S */;\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=bends.js.map"]},"metadata":{},"sourceType":"module"}