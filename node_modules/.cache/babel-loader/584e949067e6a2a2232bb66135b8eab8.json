{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { Features } from './features';\nimport { ProteinBackboneAtoms, PolymerNames, BaseNames } from '../../../mol-model/structure/model/types';\nimport { typeSymbol, atomId, eachBondedAtom } from '../chemistry/util';\nimport { ValenceModelProvider } from '../valence-model';\nimport { degToRad } from '../../../mol-math/misc';\nimport { Segmentation } from '../../../mol-data/int';\nimport { isGuanidine, isAcetamidine, isPhosphate, isSulfonicAcid, isSulfate, isCarboxylate } from '../chemistry/functional-group';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nvar IonicParams = {\n  distanceMax: PD.Numeric(5.0, {\n    min: 0,\n    max: 8,\n    step: 0.1\n  })\n};\nvar PiStackingParams = {\n  distanceMax: PD.Numeric(5.5, {\n    min: 1,\n    max: 8,\n    step: 0.1\n  }),\n  offsetMax: PD.Numeric(2.0, {\n    min: 0,\n    max: 4,\n    step: 0.1\n  }),\n  angleDevMax: PD.Numeric(30, {\n    min: 0,\n    max: 180,\n    step: 1\n  })\n};\nvar CationPiParams = {\n  distanceMax: PD.Numeric(6.0, {\n    min: 1,\n    max: 8,\n    step: 0.1\n  }),\n  offsetMax: PD.Numeric(2.0, {\n    min: 0,\n    max: 4,\n    step: 0.1\n  })\n}; //\n\nvar PositvelyCharged = ['ARG', 'HIS', 'LYS'];\nvar NegativelyCharged = ['GLU', 'ASP'];\n\nfunction getUnitValenceModel(structure, unit) {\n  var valenceModel = ValenceModelProvider.get(structure).value;\n  if (!valenceModel) throw Error('expected valence model to be available');\n  var unitValenceModel = valenceModel.get(unit.id);\n  if (!unitValenceModel) throw Error('expected valence model for unit to be available');\n  return unitValenceModel;\n}\n\nfunction addUnitPositiveCharges(structure, unit, builder) {\n  var charge = getUnitValenceModel(structure, unit).charge;\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n  var addedElements = new Set();\n  var label_comp_id = unit.model.atomicHierarchy.atoms.label_comp_id;\n  var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\n\n  while (residueIt.hasNext) {\n    var _b = residueIt.move(),\n        residueIndex = _b.index,\n        start = _b.start,\n        end = _b.end;\n\n    var compId = label_comp_id.value(unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex]);\n\n    if (PositvelyCharged.includes(compId)) {\n      builder.startState();\n\n      for (var j = start; j < end; ++j) {\n        if (typeSymbol(unit, j) === \"N\"\n        /* N */\n        && !ProteinBackboneAtoms.has(atomId(unit, j))) {\n          builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\n        }\n      }\n\n      builder.finishState(1\n      /* PositiveCharge */\n      , 0\n      /* None */\n      );\n    } else if (!PolymerNames.has(compId)) {\n      addedElements.clear();\n\n      for (var j = start; j < end; ++j) {\n        var group = 0\n        /* None */\n        ;\n\n        if (isGuanidine(structure, unit, j)) {\n          group = 8\n          /* Guanidine */\n          ;\n        } else if (isAcetamidine(structure, unit, j)) {\n          group = 9\n          /* Acetamidine */\n          ;\n        }\n\n        if (group) {\n          builder.startState();\n          eachBondedAtom(structure, unit, j, function (_, k) {\n            if (typeSymbol(unit, k) === \"N\"\n            /* N */\n            ) {\n              addedElements.add(k);\n              builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\n            }\n          });\n          builder.finishState(1\n          /* PositiveCharge */\n          , group);\n        }\n      }\n\n      for (var j = start; j < end; ++j) {\n        if (charge[j] > 0 && !addedElements.has(j)) {\n          builder.add(1\n          /* PositiveCharge */\n          , 0\n          /* None */\n          , x[elements[j]], y[elements[j]], z[elements[j]], j);\n        }\n      }\n    }\n  }\n}\n\nfunction addUnitNegativeCharges(structure, unit, builder) {\n  var charge = getUnitValenceModel(structure, unit).charge;\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n  var addedElements = new Set();\n  var label_comp_id = unit.model.atomicHierarchy.atoms.label_comp_id;\n  var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\n\n  while (residueIt.hasNext) {\n    var _b = residueIt.move(),\n        residueIndex = _b.index,\n        start = _b.start,\n        end = _b.end;\n\n    var compId = label_comp_id.value(unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex]);\n\n    if (NegativelyCharged.includes(compId)) {\n      builder.startState();\n\n      for (var j = start; j < end; ++j) {\n        if (typeSymbol(unit, j) === \"O\"\n        /* O */\n        && !ProteinBackboneAtoms.has(atomId(unit, j))) {\n          builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\n        }\n      }\n\n      builder.finishState(2\n      /* NegativeCharge */\n      , 0\n      /* None */\n      );\n    } else if (BaseNames.has(compId)) {\n      for (var j = start; j < end; ++j) {\n        if (isPhosphate(structure, unit, j)) {\n          builder.startState();\n          eachBondedAtom(structure, unit, j, function (_, k) {\n            if (typeSymbol(unit, k) === \"O\"\n            /* O */\n            ) {\n              builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\n            }\n          });\n          builder.finishState(2\n          /* NegativeCharge */\n          , 6\n          /* Phosphate */\n          );\n        }\n      }\n    } else if (!PolymerNames.has(compId)) {\n      for (var j = start; j < end; ++j) {\n        builder.startState();\n\n        if (typeSymbol(unit, j) === \"N\"\n        /* N */\n        && !ProteinBackboneAtoms.has(atomId(unit, j))) {\n          builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\n        }\n\n        builder.finishState(2\n        /* NegativeCharge */\n        , 0\n        /* None */\n        );\n        var group = 0\n        /* None */\n        ;\n\n        if (isSulfonicAcid(structure, unit, j)) {\n          group = 4\n          /* SulfonicAcid */\n          ;\n        } else if (isPhosphate(structure, unit, j)) {\n          group = 6\n          /* Phosphate */\n          ;\n        } else if (isSulfate(structure, unit, j)) {\n          group = 5\n          /* Sulfate */\n          ;\n        } else if (isCarboxylate(structure, unit, j)) {\n          group = 10\n          /* Carboxylate */\n          ;\n        }\n\n        if (group) {\n          builder.startState();\n          eachBondedAtom(structure, unit, j, function (_, k) {\n            if (typeSymbol(unit, k) === \"O\"\n            /* O */\n            ) {\n              addedElements.add(k);\n              builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\n            }\n          });\n          builder.finishState(2\n          /* NegativeCharge */\n          , group);\n        }\n      }\n\n      for (var j = start; j < end; ++j) {\n        if (charge[j] < 0 && !addedElements.has(j)) {\n          builder.add(2\n          /* NegativeCharge */\n          , 0\n          /* None */\n          , x[elements[j]], y[elements[j]], z[elements[j]], j);\n        }\n      }\n    }\n  }\n}\n\nfunction addUnitAromaticRings(structure, unit, builder) {\n  var elements = unit.elements;\n  var _a = unit.model.atomicConformation,\n      x = _a.x,\n      y = _a.y,\n      z = _a.z;\n\n  for (var _i = 0, _b = unit.rings.aromaticRings; _i < _b.length; _i++) {\n    var ringIndex = _b[_i];\n    var ring = unit.rings.all[ringIndex];\n    builder.startState();\n\n    for (var i = 0, il = ring.length; i < il; ++i) {\n      var j = ring[i];\n      builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\n    }\n\n    builder.finishState(3\n    /* AromaticRing */\n    , 0\n    /* None */\n    );\n  }\n}\n\nfunction isIonic(ti, tj) {\n  return ti === 2\n  /* NegativeCharge */\n  && tj === 1\n  /* PositiveCharge */\n  || ti === 1\n  /* PositiveCharge */\n  && tj === 2\n  /* NegativeCharge */\n  ;\n}\n\nfunction isPiStacking(ti, tj) {\n  return ti === 3\n  /* AromaticRing */\n  && tj === 3\n  /* AromaticRing */\n  ;\n}\n\nfunction isCationPi(ti, tj) {\n  return ti === 3\n  /* AromaticRing */\n  && tj === 1\n  /* PositiveCharge */\n  || ti === 1\n  /* PositiveCharge */\n  && tj === 3\n  /* AromaticRing */\n  ;\n}\n\nvar tmpPointA = Vec3();\nvar tmpPointB = Vec3();\n\nfunction areFeaturesWithinDistanceSq(infoA, infoB, distanceSq) {\n  var featureA = infoA.feature,\n      offsetsA = infoA.offsets,\n      membersA = infoA.members;\n  var featureB = infoB.feature,\n      offsetsB = infoB.offsets,\n      membersB = infoB.members;\n\n  for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\n    var elementA = membersA[i];\n    infoA.unit.conformation.position(infoA.unit.elements[elementA], tmpPointA);\n\n    for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\n      var elementB = membersB[j];\n      infoB.unit.conformation.position(infoB.unit.elements[elementB], tmpPointB);\n      if (Vec3.squaredDistance(tmpPointA, tmpPointB) < distanceSq) return true;\n    }\n  }\n\n  return false;\n}\n\nvar tmpVecA = Vec3();\nvar tmpVecB = Vec3();\nvar tmpVecC = Vec3();\nvar tmpVecD = Vec3();\n\nfunction getNormal(out, info) {\n  var unit = info.unit,\n      feature = info.feature,\n      offsets = info.offsets,\n      members = info.members;\n  var elements = unit.elements;\n  var i = offsets[feature];\n  info.unit.conformation.position(elements[members[i]], tmpVecA);\n  info.unit.conformation.position(elements[members[i + 1]], tmpVecB);\n  info.unit.conformation.position(elements[members[i + 2]], tmpVecC);\n  return Vec3.triangleNormal(out, tmpVecA, tmpVecB, tmpVecC);\n}\n\nvar getOffset = function (infoA, infoB, normal) {\n  Features.position(tmpVecA, infoA);\n  Features.position(tmpVecB, infoB);\n  Vec3.sub(tmpVecC, tmpVecA, tmpVecB);\n  Vec3.projectOnPlane(tmpVecD, tmpVecC, normal);\n  Vec3.add(tmpVecD, tmpVecD, tmpVecB);\n  return Vec3.distance(tmpVecD, tmpVecB);\n};\n\nfunction getIonicOptions(props) {\n  return {\n    distanceMaxSq: props.distanceMax * props.distanceMax\n  };\n}\n\nfunction getPiStackingOptions(props) {\n  return {\n    offsetMax: props.offsetMax,\n    angleDevMax: degToRad(props.angleDevMax)\n  };\n}\n\nfunction getCationPiOptions(props) {\n  return {\n    offsetMax: props.offsetMax\n  };\n}\n\nvar deg180InRad = degToRad(180);\nvar deg90InRad = degToRad(90);\nvar tmpNormalA = Vec3();\nvar tmpNormalB = Vec3();\n\nfunction testIonic(structure, infoA, infoB, distanceSq, opts) {\n  var typeA = infoA.types[infoA.feature];\n  var typeB = infoB.types[infoB.feature];\n\n  if (isIonic(typeA, typeB)) {\n    if (areFeaturesWithinDistanceSq(infoA, infoB, opts.distanceMaxSq)) {\n      return 1\n      /* Ionic */\n      ;\n    }\n  }\n}\n\nfunction testPiStacking(structure, infoA, infoB, distanceSq, opts) {\n  var typeA = infoA.types[infoA.feature];\n  var typeB = infoB.types[infoB.feature];\n\n  if (isPiStacking(typeA, typeB)) {\n    getNormal(tmpNormalA, infoA);\n    getNormal(tmpNormalB, infoB);\n    var angle = Vec3.angle(tmpNormalA, tmpNormalB);\n    var offset = Math.min(getOffset(infoA, infoB, tmpNormalB), getOffset(infoB, infoA, tmpNormalA));\n\n    if (offset <= opts.offsetMax) {\n      if (angle <= opts.angleDevMax || angle >= deg180InRad - opts.angleDevMax) {\n        return 3\n        /* PiStacking */\n        ; // parallel\n      } else if (angle <= opts.angleDevMax + deg90InRad && angle >= deg90InRad - opts.angleDevMax) {\n        return 3\n        /* PiStacking */\n        ; // t-shaped\n      }\n    }\n  }\n}\n\nfunction testCationPi(structure, infoA, infoB, distanceSq, opts) {\n  var typeA = infoA.types[infoA.feature];\n  var typeB = infoB.types[infoB.feature];\n\n  if (isCationPi(typeA, typeB)) {\n    var _a = typeA === 3\n    /* AromaticRing */\n    ? [infoA, infoB] : [infoB, infoA],\n        infoR = _a[0],\n        infoC = _a[1];\n\n    getNormal(tmpNormalA, infoR);\n    var offset = getOffset(infoC, infoR, tmpNormalA);\n\n    if (offset <= opts.offsetMax) {\n      return 2\n      /* CationPi */\n      ;\n    }\n  }\n} //\n\n\nexport var NegativChargeProvider = Features.Provider([2\n/* NegativeCharge */\n], addUnitNegativeCharges);\nexport var PositiveChargeProvider = Features.Provider([1\n/* PositiveCharge */\n], addUnitPositiveCharges);\nexport var AromaticRingProvider = Features.Provider([3\n/* AromaticRing */\n], addUnitAromaticRings);\nexport var IonicProvider = {\n  name: 'ionic',\n  params: IonicParams,\n  createTester: function (props) {\n    var opts = getIonicOptions(props);\n    return {\n      maxDistance: props.distanceMax,\n      requiredFeatures: new Set([2\n      /* NegativeCharge */\n      , 1\n      /* PositiveCharge */\n      ]),\n      getType: function (structure, infoA, infoB, distanceSq) {\n        return testIonic(structure, infoA, infoB, distanceSq, opts);\n      }\n    };\n  }\n};\nexport var PiStackingProvider = {\n  name: 'pi-stacking',\n  params: PiStackingParams,\n  createTester: function (props) {\n    var opts = getPiStackingOptions(props);\n    return {\n      maxDistance: props.distanceMax,\n      requiredFeatures: new Set([3\n      /* AromaticRing */\n      ]),\n      getType: function (structure, infoA, infoB, distanceSq) {\n        return testPiStacking(structure, infoA, infoB, distanceSq, opts);\n      }\n    };\n  }\n};\nexport var CationPiProvider = {\n  name: 'cation-pi',\n  params: CationPiParams,\n  createTester: function (props) {\n    var opts = getCationPiOptions(props);\n    return {\n      maxDistance: props.distanceMax,\n      requiredFeatures: new Set([3\n      /* AromaticRing */\n      , 1\n      /* PositiveCharge */\n      ]),\n      getType: function (structure, infoA, infoB, distanceSq) {\n        return testCationPi(structure, infoA, infoB, distanceSq, opts);\n      }\n    };\n  }\n};","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/interactions/charged.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Fred Ludlow <Fred.Ludlow@astx.com>\r\n *\r\n * based in part on NGL (https://github.com/arose/ngl)\r\n */\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { Features } from './features';\r\nimport { ProteinBackboneAtoms, PolymerNames, BaseNames } from '../../../mol-model/structure/model/types';\r\nimport { typeSymbol, atomId, eachBondedAtom } from '../chemistry/util';\r\nimport { ValenceModelProvider } from '../valence-model';\r\nimport { degToRad } from '../../../mol-math/misc';\r\nimport { Segmentation } from '../../../mol-data/int';\r\nimport { isGuanidine, isAcetamidine, isPhosphate, isSulfonicAcid, isSulfate, isCarboxylate } from '../chemistry/functional-group';\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nvar IonicParams = {\r\n    distanceMax: PD.Numeric(5.0, { min: 0, max: 8, step: 0.1 }),\r\n};\r\nvar PiStackingParams = {\r\n    distanceMax: PD.Numeric(5.5, { min: 1, max: 8, step: 0.1 }),\r\n    offsetMax: PD.Numeric(2.0, { min: 0, max: 4, step: 0.1 }),\r\n    angleDevMax: PD.Numeric(30, { min: 0, max: 180, step: 1 }),\r\n};\r\nvar CationPiParams = {\r\n    distanceMax: PD.Numeric(6.0, { min: 1, max: 8, step: 0.1 }),\r\n    offsetMax: PD.Numeric(2.0, { min: 0, max: 4, step: 0.1 }),\r\n};\r\n//\r\nvar PositvelyCharged = ['ARG', 'HIS', 'LYS'];\r\nvar NegativelyCharged = ['GLU', 'ASP'];\r\nfunction getUnitValenceModel(structure, unit) {\r\n    var valenceModel = ValenceModelProvider.get(structure).value;\r\n    if (!valenceModel)\r\n        throw Error('expected valence model to be available');\r\n    var unitValenceModel = valenceModel.get(unit.id);\r\n    if (!unitValenceModel)\r\n        throw Error('expected valence model for unit to be available');\r\n    return unitValenceModel;\r\n}\r\nfunction addUnitPositiveCharges(structure, unit, builder) {\r\n    var charge = getUnitValenceModel(structure, unit).charge;\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    var addedElements = new Set();\r\n    var label_comp_id = unit.model.atomicHierarchy.atoms.label_comp_id;\r\n    var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\r\n    while (residueIt.hasNext) {\r\n        var _b = residueIt.move(), residueIndex = _b.index, start = _b.start, end = _b.end;\r\n        var compId = label_comp_id.value(unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex]);\r\n        if (PositvelyCharged.includes(compId)) {\r\n            builder.startState();\r\n            for (var j = start; j < end; ++j) {\r\n                if (typeSymbol(unit, j) === \"N\" /* N */ && !ProteinBackboneAtoms.has(atomId(unit, j))) {\r\n                    builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n                }\r\n            }\r\n            builder.finishState(1 /* PositiveCharge */, 0 /* None */);\r\n        }\r\n        else if (!PolymerNames.has(compId)) {\r\n            addedElements.clear();\r\n            for (var j = start; j < end; ++j) {\r\n                var group = 0 /* None */;\r\n                if (isGuanidine(structure, unit, j)) {\r\n                    group = 8 /* Guanidine */;\r\n                }\r\n                else if (isAcetamidine(structure, unit, j)) {\r\n                    group = 9 /* Acetamidine */;\r\n                }\r\n                if (group) {\r\n                    builder.startState();\r\n                    eachBondedAtom(structure, unit, j, function (_, k) {\r\n                        if (typeSymbol(unit, k) === \"N\" /* N */) {\r\n                            addedElements.add(k);\r\n                            builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\r\n                        }\r\n                    });\r\n                    builder.finishState(1 /* PositiveCharge */, group);\r\n                }\r\n            }\r\n            for (var j = start; j < end; ++j) {\r\n                if (charge[j] > 0 && !addedElements.has(j)) {\r\n                    builder.add(1 /* PositiveCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction addUnitNegativeCharges(structure, unit, builder) {\r\n    var charge = getUnitValenceModel(structure, unit).charge;\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    var addedElements = new Set();\r\n    var label_comp_id = unit.model.atomicHierarchy.atoms.label_comp_id;\r\n    var residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\r\n    while (residueIt.hasNext) {\r\n        var _b = residueIt.move(), residueIndex = _b.index, start = _b.start, end = _b.end;\r\n        var compId = label_comp_id.value(unit.model.atomicHierarchy.residueAtomSegments.offsets[residueIndex]);\r\n        if (NegativelyCharged.includes(compId)) {\r\n            builder.startState();\r\n            for (var j = start; j < end; ++j) {\r\n                if (typeSymbol(unit, j) === \"O\" /* O */ && !ProteinBackboneAtoms.has(atomId(unit, j))) {\r\n                    builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n                }\r\n            }\r\n            builder.finishState(2 /* NegativeCharge */, 0 /* None */);\r\n        }\r\n        else if (BaseNames.has(compId)) {\r\n            for (var j = start; j < end; ++j) {\r\n                if (isPhosphate(structure, unit, j)) {\r\n                    builder.startState();\r\n                    eachBondedAtom(structure, unit, j, function (_, k) {\r\n                        if (typeSymbol(unit, k) === \"O\" /* O */) {\r\n                            builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\r\n                        }\r\n                    });\r\n                    builder.finishState(2 /* NegativeCharge */, 6 /* Phosphate */);\r\n                }\r\n            }\r\n        }\r\n        else if (!PolymerNames.has(compId)) {\r\n            for (var j = start; j < end; ++j) {\r\n                builder.startState();\r\n                if (typeSymbol(unit, j) === \"N\" /* N */ && !ProteinBackboneAtoms.has(atomId(unit, j))) {\r\n                    builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n                }\r\n                builder.finishState(2 /* NegativeCharge */, 0 /* None */);\r\n                var group = 0 /* None */;\r\n                if (isSulfonicAcid(structure, unit, j)) {\r\n                    group = 4 /* SulfonicAcid */;\r\n                }\r\n                else if (isPhosphate(structure, unit, j)) {\r\n                    group = 6 /* Phosphate */;\r\n                }\r\n                else if (isSulfate(structure, unit, j)) {\r\n                    group = 5 /* Sulfate */;\r\n                }\r\n                else if (isCarboxylate(structure, unit, j)) {\r\n                    group = 10 /* Carboxylate */;\r\n                }\r\n                if (group) {\r\n                    builder.startState();\r\n                    eachBondedAtom(structure, unit, j, function (_, k) {\r\n                        if (typeSymbol(unit, k) === \"O\" /* O */) {\r\n                            addedElements.add(k);\r\n                            builder.pushMember(x[elements[k]], y[elements[k]], z[elements[k]], k);\r\n                        }\r\n                    });\r\n                    builder.finishState(2 /* NegativeCharge */, group);\r\n                }\r\n            }\r\n            for (var j = start; j < end; ++j) {\r\n                if (charge[j] < 0 && !addedElements.has(j)) {\r\n                    builder.add(2 /* NegativeCharge */, 0 /* None */, x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction addUnitAromaticRings(structure, unit, builder) {\r\n    var elements = unit.elements;\r\n    var _a = unit.model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n    for (var _i = 0, _b = unit.rings.aromaticRings; _i < _b.length; _i++) {\r\n        var ringIndex = _b[_i];\r\n        var ring = unit.rings.all[ringIndex];\r\n        builder.startState();\r\n        for (var i = 0, il = ring.length; i < il; ++i) {\r\n            var j = ring[i];\r\n            builder.pushMember(x[elements[j]], y[elements[j]], z[elements[j]], j);\r\n        }\r\n        builder.finishState(3 /* AromaticRing */, 0 /* None */);\r\n    }\r\n}\r\nfunction isIonic(ti, tj) {\r\n    return ((ti === 2 /* NegativeCharge */ && tj === 1 /* PositiveCharge */) ||\r\n        (ti === 1 /* PositiveCharge */ && tj === 2 /* NegativeCharge */));\r\n}\r\nfunction isPiStacking(ti, tj) {\r\n    return ti === 3 /* AromaticRing */ && tj === 3 /* AromaticRing */;\r\n}\r\nfunction isCationPi(ti, tj) {\r\n    return ((ti === 3 /* AromaticRing */ && tj === 1 /* PositiveCharge */) ||\r\n        (ti === 1 /* PositiveCharge */ && tj === 3 /* AromaticRing */));\r\n}\r\nvar tmpPointA = Vec3();\r\nvar tmpPointB = Vec3();\r\nfunction areFeaturesWithinDistanceSq(infoA, infoB, distanceSq) {\r\n    var featureA = infoA.feature, offsetsA = infoA.offsets, membersA = infoA.members;\r\n    var featureB = infoB.feature, offsetsB = infoB.offsets, membersB = infoB.members;\r\n    for (var i = offsetsA[featureA], il = offsetsA[featureA + 1]; i < il; ++i) {\r\n        var elementA = membersA[i];\r\n        infoA.unit.conformation.position(infoA.unit.elements[elementA], tmpPointA);\r\n        for (var j = offsetsB[featureB], jl = offsetsB[featureB + 1]; j < jl; ++j) {\r\n            var elementB = membersB[j];\r\n            infoB.unit.conformation.position(infoB.unit.elements[elementB], tmpPointB);\r\n            if (Vec3.squaredDistance(tmpPointA, tmpPointB) < distanceSq)\r\n                return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nvar tmpVecA = Vec3();\r\nvar tmpVecB = Vec3();\r\nvar tmpVecC = Vec3();\r\nvar tmpVecD = Vec3();\r\nfunction getNormal(out, info) {\r\n    var unit = info.unit, feature = info.feature, offsets = info.offsets, members = info.members;\r\n    var elements = unit.elements;\r\n    var i = offsets[feature];\r\n    info.unit.conformation.position(elements[members[i]], tmpVecA);\r\n    info.unit.conformation.position(elements[members[i + 1]], tmpVecB);\r\n    info.unit.conformation.position(elements[members[i + 2]], tmpVecC);\r\n    return Vec3.triangleNormal(out, tmpVecA, tmpVecB, tmpVecC);\r\n}\r\nvar getOffset = function (infoA, infoB, normal) {\r\n    Features.position(tmpVecA, infoA);\r\n    Features.position(tmpVecB, infoB);\r\n    Vec3.sub(tmpVecC, tmpVecA, tmpVecB);\r\n    Vec3.projectOnPlane(tmpVecD, tmpVecC, normal);\r\n    Vec3.add(tmpVecD, tmpVecD, tmpVecB);\r\n    return Vec3.distance(tmpVecD, tmpVecB);\r\n};\r\nfunction getIonicOptions(props) {\r\n    return {\r\n        distanceMaxSq: props.distanceMax * props.distanceMax,\r\n    };\r\n}\r\nfunction getPiStackingOptions(props) {\r\n    return {\r\n        offsetMax: props.offsetMax,\r\n        angleDevMax: degToRad(props.angleDevMax),\r\n    };\r\n}\r\nfunction getCationPiOptions(props) {\r\n    return {\r\n        offsetMax: props.offsetMax\r\n    };\r\n}\r\nvar deg180InRad = degToRad(180);\r\nvar deg90InRad = degToRad(90);\r\nvar tmpNormalA = Vec3();\r\nvar tmpNormalB = Vec3();\r\nfunction testIonic(structure, infoA, infoB, distanceSq, opts) {\r\n    var typeA = infoA.types[infoA.feature];\r\n    var typeB = infoB.types[infoB.feature];\r\n    if (isIonic(typeA, typeB)) {\r\n        if (areFeaturesWithinDistanceSq(infoA, infoB, opts.distanceMaxSq)) {\r\n            return 1 /* Ionic */;\r\n        }\r\n    }\r\n}\r\nfunction testPiStacking(structure, infoA, infoB, distanceSq, opts) {\r\n    var typeA = infoA.types[infoA.feature];\r\n    var typeB = infoB.types[infoB.feature];\r\n    if (isPiStacking(typeA, typeB)) {\r\n        getNormal(tmpNormalA, infoA);\r\n        getNormal(tmpNormalB, infoB);\r\n        var angle = Vec3.angle(tmpNormalA, tmpNormalB);\r\n        var offset = Math.min(getOffset(infoA, infoB, tmpNormalB), getOffset(infoB, infoA, tmpNormalA));\r\n        if (offset <= opts.offsetMax) {\r\n            if (angle <= opts.angleDevMax || angle >= deg180InRad - opts.angleDevMax) {\r\n                return 3 /* PiStacking */; // parallel\r\n            }\r\n            else if (angle <= opts.angleDevMax + deg90InRad && angle >= deg90InRad - opts.angleDevMax) {\r\n                return 3 /* PiStacking */; // t-shaped\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction testCationPi(structure, infoA, infoB, distanceSq, opts) {\r\n    var typeA = infoA.types[infoA.feature];\r\n    var typeB = infoB.types[infoB.feature];\r\n    if (isCationPi(typeA, typeB)) {\r\n        var _a = typeA === 3 /* AromaticRing */ ? [infoA, infoB] : [infoB, infoA], infoR = _a[0], infoC = _a[1];\r\n        getNormal(tmpNormalA, infoR);\r\n        var offset = getOffset(infoC, infoR, tmpNormalA);\r\n        if (offset <= opts.offsetMax) {\r\n            return 2 /* CationPi */;\r\n        }\r\n    }\r\n}\r\n//\r\nexport var NegativChargeProvider = Features.Provider([2 /* NegativeCharge */], addUnitNegativeCharges);\r\nexport var PositiveChargeProvider = Features.Provider([1 /* PositiveCharge */], addUnitPositiveCharges);\r\nexport var AromaticRingProvider = Features.Provider([3 /* AromaticRing */], addUnitAromaticRings);\r\nexport var IonicProvider = {\r\n    name: 'ionic',\r\n    params: IonicParams,\r\n    createTester: function (props) {\r\n        var opts = getIonicOptions(props);\r\n        return {\r\n            maxDistance: props.distanceMax,\r\n            requiredFeatures: new Set([2 /* NegativeCharge */, 1 /* PositiveCharge */]),\r\n            getType: function (structure, infoA, infoB, distanceSq) { return testIonic(structure, infoA, infoB, distanceSq, opts); }\r\n        };\r\n    }\r\n};\r\nexport var PiStackingProvider = {\r\n    name: 'pi-stacking',\r\n    params: PiStackingParams,\r\n    createTester: function (props) {\r\n        var opts = getPiStackingOptions(props);\r\n        return {\r\n            maxDistance: props.distanceMax,\r\n            requiredFeatures: new Set([3 /* AromaticRing */]),\r\n            getType: function (structure, infoA, infoB, distanceSq) { return testPiStacking(structure, infoA, infoB, distanceSq, opts); }\r\n        };\r\n    }\r\n};\r\nexport var CationPiProvider = {\r\n    name: 'cation-pi',\r\n    params: CationPiParams,\r\n    createTester: function (props) {\r\n        var opts = getCationPiOptions(props);\r\n        return {\r\n            maxDistance: props.distanceMax,\r\n            requiredFeatures: new Set([3 /* AromaticRing */, 1 /* PositiveCharge */]),\r\n            getType: function (structure, infoA, infoB, distanceSq) { return testCationPi(structure, infoA, infoB, distanceSq, opts); }\r\n        };\r\n    }\r\n};\r\n//# sourceMappingURL=charged.js.map"]},"metadata":{},"sourceType":"module"}