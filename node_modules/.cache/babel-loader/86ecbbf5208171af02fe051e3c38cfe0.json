{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { UnitsMeshParams, UnitsTextureMeshParams, UnitsMeshVisual, UnitsTextureMeshVisual } from '../units-visual';\nimport { GaussianDensityParams, computeUnitGaussianDensity, computeUnitGaussianDensityTexture2d, computeStructureGaussianDensity, computeStructureGaussianDensityTexture2d } from './util/gaussian';\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\nimport { computeMarchingCubesMesh } from '../../../mol-geo/util/marching-cubes/algorithm';\nimport { ElementIterator, getElementLoci, eachElement, getSerialElementLoci, eachSerialElement } from './util/element';\nimport { TextureMesh } from '../../../mol-geo/geometry/texture-mesh/texture-mesh';\nimport { extractIsosurface } from '../../../mol-gl/compute/marching-cubes/isosurface';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { ComplexMeshParams, ComplexMeshVisual, ComplexTextureMeshVisual, ComplexTextureMeshParams } from '../complex-visual';\nimport { getUnitExtraRadius, getStructureExtraRadius, getVolumeSliceInfo } from './util/common';\nimport { applyMeshColorSmoothing, applyTextureMeshColorSmoothing, ColorSmoothingParams, getColorSmoothingProps } from './util/color';\n\nvar SharedParams = __assign(__assign(__assign({}, GaussianDensityParams), ColorSmoothingParams), {\n  ignoreHydrogens: PD.Boolean(false),\n  tryUseGpu: PD.Boolean(true),\n  includeParent: PD.Boolean(false, {\n    isHidden: true\n  })\n});\n\nexport var GaussianSurfaceMeshParams = __assign(__assign(__assign({}, UnitsMeshParams), UnitsTextureMeshParams), SharedParams);\nexport var StructureGaussianSurfaceMeshParams = __assign(__assign(__assign({}, ComplexMeshParams), ComplexTextureMeshParams), SharedParams);\n\nfunction gpuSupport(webgl) {\n  return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.blendMinMax && webgl.extensions.drawBuffers;\n}\n\nfunction suitableForGpu(structure, props, webgl) {\n  // lower resolutions are about as fast on CPU vs integrated GPU,\n  // very low resolutions have artifacts when calculated on GPU\n  if (props.resolution > 1) return false; // the GPU is much more memory contraint, especially true for integrated GPUs,\n  // being conservative here still allows for small and medium sized assemblies\n\n  var d = webgl.maxTextureSize / 3;\n\n  var _a = getVolumeSliceInfo(structure.boundary.box, props.resolution, d * d),\n      areaCells = _a.areaCells,\n      maxAreaCells = _a.maxAreaCells;\n\n  return areaCells < maxAreaCells;\n}\n\nexport function GaussianSurfaceVisual(materialId, structure, props, webgl) {\n  if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {\n    return GaussianSurfaceTextureMeshVisual(materialId);\n  }\n\n  return GaussianSurfaceMeshVisual(materialId);\n}\nexport function StructureGaussianSurfaceVisual(materialId, structure, props, webgl) {\n  if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {\n    return StructureGaussianSurfaceTextureMeshVisual(materialId);\n  }\n\n  return StructureGaussianSurfaceMeshVisual(materialId);\n} //\n\nfunction createGaussianSurfaceMesh(ctx, unit, structure, theme, props, mesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          smoothness = props.smoothness;\n          return [4\n          /*yield*/\n          , computeUnitGaussianDensity(structure, unit, props).runInContext(ctx.runtime)];\n\n        case 1:\n          _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;\n          params = {\n            isoLevel: Math.exp(-smoothness) / radiusFactor,\n            scalarField: field,\n            idField: idField\n          };\n          return [4\n          /*yield*/\n          , computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime)];\n\n        case 2:\n          surface = _b.sent();\n          surface.meta.resolution = resolution;\n          Mesh.transform(surface, transform);\n          if (ctx.webgl && !ctx.webgl.isWebGL2) Mesh.uniformTriangleGroup(surface);\n          sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, props.radiusOffset + getUnitExtraRadius(unit));\n          surface.setBoundingSphere(sphere);\n          return [2\n          /*return*/\n          , surface];\n      }\n    });\n  });\n}\n\nexport function GaussianSurfaceMeshVisual(materialId) {\n  return UnitsMeshVisual({\n    defaultProps: PD.getDefaultValues(GaussianSurfaceMeshParams),\n    createGeometry: createGaussianSurfaceMesh,\n    createLocationIterator: ElementIterator.fromGroup,\n    getLoci: getElementLoci,\n    eachLocation: eachElement,\n    setUpdateState: function (state, newProps, currentProps) {\n      if (newProps.resolution !== currentProps.resolution) state.createGeometry = true;\n      if (newProps.radiusOffset !== currentProps.radiusOffset) state.createGeometry = true;\n      if (newProps.smoothness !== currentProps.smoothness) state.createGeometry = true;\n      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens) state.createGeometry = true;\n      if (newProps.traceOnly !== currentProps.traceOnly) state.createGeometry = true;\n      if (newProps.includeParent !== currentProps.includeParent) state.createGeometry = true;\n\n      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\n        state.updateColor = true;\n      } else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\n        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor) state.updateColor = true;\n        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride) state.updateColor = true;\n      }\n    },\n    mustRecreate: function (structureGroup, props, webgl) {\n      return props.tryUseGpu && !!webgl && suitableForGpu(structureGroup.structure, props, webgl);\n    },\n    processValues: function (values, geometry, props, theme, webgl) {\n      var _a = geometry.meta,\n          resolution = _a.resolution,\n          colorTexture = _a.colorTexture;\n      var csp = getColorSmoothingProps(props, theme, resolution);\n\n      if (csp) {\n        applyMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\n        geometry.meta.colorTexture = values.tColorGrid.ref.value;\n      }\n    },\n    dispose: function (geometry) {\n      var _a;\n\n      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n  }, materialId);\n} //\n\nfunction createStructureGaussianSurfaceMesh(ctx, structure, theme, props, mesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          smoothness = props.smoothness;\n          return [4\n          /*yield*/\n          , computeStructureGaussianDensity(structure, props).runInContext(ctx.runtime)];\n\n        case 1:\n          _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;\n          params = {\n            isoLevel: Math.exp(-smoothness) / radiusFactor,\n            scalarField: field,\n            idField: idField\n          };\n          return [4\n          /*yield*/\n          , computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime)];\n\n        case 2:\n          surface = _b.sent();\n          surface.meta.resolution = resolution;\n          Mesh.transform(surface, transform);\n          if (ctx.webgl && !ctx.webgl.isWebGL2) Mesh.uniformTriangleGroup(surface);\n          sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\n          surface.setBoundingSphere(sphere);\n          return [2\n          /*return*/\n          , surface];\n      }\n    });\n  });\n}\n\nexport function StructureGaussianSurfaceMeshVisual(materialId) {\n  return ComplexMeshVisual({\n    defaultProps: PD.getDefaultValues(StructureGaussianSurfaceMeshParams),\n    createGeometry: createStructureGaussianSurfaceMesh,\n    createLocationIterator: ElementIterator.fromStructure,\n    getLoci: getSerialElementLoci,\n    eachLocation: eachSerialElement,\n    setUpdateState: function (state, newProps, currentProps) {\n      if (newProps.resolution !== currentProps.resolution) state.createGeometry = true;\n      if (newProps.radiusOffset !== currentProps.radiusOffset) state.createGeometry = true;\n      if (newProps.smoothness !== currentProps.smoothness) state.createGeometry = true;\n      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens) state.createGeometry = true;\n      if (newProps.traceOnly !== currentProps.traceOnly) state.createGeometry = true;\n\n      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\n        state.updateColor = true;\n      } else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\n        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor) state.updateColor = true;\n        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride) state.updateColor = true;\n      }\n    },\n    mustRecreate: function (structure, props, webgl) {\n      return props.tryUseGpu && !!webgl && suitableForGpu(structure, props, webgl);\n    },\n    processValues: function (values, geometry, props, theme, webgl) {\n      var _a = geometry.meta,\n          resolution = _a.resolution,\n          colorTexture = _a.colorTexture;\n      var csp = getColorSmoothingProps(props, theme, resolution);\n\n      if (csp) {\n        applyMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\n        geometry.meta.colorTexture = values.tColorGrid.ref.value;\n      }\n    },\n    dispose: function (geometry) {\n      var _a;\n\n      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n  }, materialId);\n} //\n\nvar GaussianSurfaceName = 'gaussian-surface';\n\nfunction createGaussianSurfaceTextureMesh(ctx, unit, structure, theme, props, textureMesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          if (!ctx.webgl) throw new Error('webgl context required to create gaussian surface texture-mesh');\n          _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;\n\n          if (!namedTextures[GaussianSurfaceName]) {\n            namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat ? resources.texture('image-float16', 'rgba', 'fp16', 'linear') : colorBufferFloat && textureFloat ? resources.texture('image-float32', 'rgba', 'float', 'linear') : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');\n          }\n\n          return [4\n          /*yield*/\n          , computeUnitGaussianDensityTexture2d(structure, unit, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];\n\n        case 1:\n          densityTextureData = _c.sent();\n          isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;\n          buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\n          gv = extractIsosurface(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\n          boundingSphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\n          surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);\n          surface.meta = {\n            resolution: densityTextureData.resolution\n          };\n          return [2\n          /*return*/\n          , surface];\n      }\n    });\n  });\n}\n\nexport function GaussianSurfaceTextureMeshVisual(materialId) {\n  return UnitsTextureMeshVisual({\n    defaultProps: PD.getDefaultValues(GaussianSurfaceMeshParams),\n    createGeometry: createGaussianSurfaceTextureMesh,\n    createLocationIterator: ElementIterator.fromGroup,\n    getLoci: getElementLoci,\n    eachLocation: eachElement,\n    setUpdateState: function (state, newProps, currentProps) {\n      if (newProps.resolution !== currentProps.resolution) state.createGeometry = true;\n      if (newProps.radiusOffset !== currentProps.radiusOffset) state.createGeometry = true;\n      if (newProps.smoothness !== currentProps.smoothness) state.createGeometry = true;\n      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens) state.createGeometry = true;\n      if (newProps.traceOnly !== currentProps.traceOnly) state.createGeometry = true;\n      if (newProps.includeParent !== currentProps.includeParent) state.createGeometry = true;\n\n      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\n        state.updateColor = true;\n      } else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\n        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor) state.updateColor = true;\n        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride) state.updateColor = true;\n      }\n    },\n    mustRecreate: function (structureGroup, props, webgl) {\n      return !props.tryUseGpu || !webgl || !suitableForGpu(structureGroup.structure, props, webgl);\n    },\n    processValues: function (values, geometry, props, theme, webgl) {\n      var _a = geometry.meta,\n          resolution = _a.resolution,\n          colorTexture = _a.colorTexture;\n      var csp = getColorSmoothingProps(props, theme, resolution);\n\n      if (csp && webgl) {\n        applyTextureMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\n        geometry.meta.colorTexture = values.tColorGrid.ref.value;\n      }\n    },\n    dispose: function (geometry) {\n      var _a;\n\n      geometry.vertexTexture.ref.value.destroy();\n      geometry.groupTexture.ref.value.destroy();\n      geometry.normalTexture.ref.value.destroy();\n      geometry.doubleBuffer.destroy();\n      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n  }, materialId);\n} //\n\nfunction createStructureGaussianSurfaceTextureMesh(ctx, structure, theme, props, textureMesh) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          if (!ctx.webgl) throw new Error('webgl context required to create structure gaussian surface texture-mesh');\n          _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;\n\n          if (!namedTextures[GaussianSurfaceName]) {\n            namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat ? resources.texture('image-float16', 'rgba', 'fp16', 'linear') : colorBufferFloat && textureFloat ? resources.texture('image-float32', 'rgba', 'float', 'linear') : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');\n          }\n\n          return [4\n          /*yield*/\n          , computeStructureGaussianDensityTexture2d(structure, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];\n\n        case 1:\n          densityTextureData = _c.sent();\n          isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;\n          buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\n          gv = extractIsosurface(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\n          boundingSphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\n          surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);\n          surface.meta = {\n            resolution: densityTextureData.resolution\n          };\n          return [2\n          /*return*/\n          , surface];\n      }\n    });\n  });\n}\n\nexport function StructureGaussianSurfaceTextureMeshVisual(materialId) {\n  return ComplexTextureMeshVisual({\n    defaultProps: PD.getDefaultValues(StructureGaussianSurfaceMeshParams),\n    createGeometry: createStructureGaussianSurfaceTextureMesh,\n    createLocationIterator: ElementIterator.fromStructure,\n    getLoci: getSerialElementLoci,\n    eachLocation: eachSerialElement,\n    setUpdateState: function (state, newProps, currentProps) {\n      if (newProps.resolution !== currentProps.resolution) state.createGeometry = true;\n      if (newProps.radiusOffset !== currentProps.radiusOffset) state.createGeometry = true;\n      if (newProps.smoothness !== currentProps.smoothness) state.createGeometry = true;\n      if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens) state.createGeometry = true;\n      if (newProps.traceOnly !== currentProps.traceOnly) state.createGeometry = true;\n      if (newProps.includeParent !== currentProps.includeParent) state.createGeometry = true;\n\n      if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\n        state.updateColor = true;\n      } else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\n        if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor) state.updateColor = true;\n        if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride) state.updateColor = true;\n      }\n    },\n    mustRecreate: function (structure, props, webgl) {\n      return !props.tryUseGpu || !webgl || !suitableForGpu(structure, props, webgl);\n    },\n    processValues: function (values, geometry, props, theme, webgl) {\n      var _a = geometry.meta,\n          resolution = _a.resolution,\n          colorTexture = _a.colorTexture;\n      var csp = getColorSmoothingProps(props, theme, resolution);\n\n      if (csp && webgl) {\n        applyTextureMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\n        geometry.meta.colorTexture = values.tColorGrid.ref.value;\n      }\n    },\n    dispose: function (geometry) {\n      var _a;\n\n      geometry.vertexTexture.ref.value.destroy();\n      geometry.groupTexture.ref.value.destroy();\n      geometry.normalTexture.ref.value.destroy();\n      geometry.doubleBuffer.destroy();\n      (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\n    }\n  }, materialId);\n}","map":{"version":3,"sources":["../../../../src/mol-repr/structure/visual/gaussian-surface-mesh.ts"],"names":[],"mappings":"AAAA;;;;AAIG;;AAEH,SAAS,eAAe,IAAI,EAA5B,QAAsC,oCAAtC;AACA,SAAS,eAAT,EAA0B,sBAA1B,EAA+D,eAA/D,EAAgF,sBAAhF,QAA8G,iBAA9G;AACA,SAAS,qBAAT,EAAgC,0BAAhC,EAA4D,mCAA5D,EAAuH,+BAAvH,EAAwJ,wCAAxJ,QAAwM,iBAAxM;AAIA,SAAS,IAAT,QAAqB,qCAArB;AACA,SAAS,wBAAT,QAAyC,gDAAzC;AACA,SAAS,eAAT,EAA0B,cAA1B,EAA0C,WAA1C,EAAuD,oBAAvD,EAA6E,iBAA7E,QAAsG,gBAAtG;AAEA,SAAS,WAAT,QAA4B,qDAA5B;AACA,SAAS,iBAAT,QAAkC,mDAAlC;AACA,SAAS,QAAT,QAAyB,4BAAzB;AACA,SAAwB,iBAAxB,EAA2C,iBAA3C,EAA8D,wBAA9D,EAAwF,wBAAxF,QAAwH,mBAAxH;AACA,SAAS,kBAAT,EAA6B,uBAA7B,EAAsD,kBAAtD,QAAgG,eAAhG;AAKA,SAAS,uBAAT,EAAkC,8BAAlC,EAAkE,oBAAlE,EAAwF,sBAAxF,QAAsH,cAAtH;;AAEA,IAAM,YAAY,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACX,qBADW,CAAA,EAEX,oBAFW,CAAA,EAES;AACvB,EAAA,eAAe,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,CADM;AAEvB,EAAA,SAAS,EAAE,EAAE,CAAC,OAAH,CAAW,IAAX,CAFY;AAGvB,EAAA,aAAa,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB;AAAE,IAAA,QAAQ,EAAE;AAAZ,GAAlB;AAHQ,CAFT,CAAlB;;AASA,OAAO,IAAM,yBAAyB,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAC/B,eAD+B,CAAA,EAE/B,sBAF+B,CAAA,EAG/B,YAH+B,CAA/B;AAOP,OAAO,IAAM,kCAAkC,GAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EACxC,iBADwC,CAAA,EAExC,wBAFwC,CAAA,EAGxC,YAHwC,CAAxC;;AAOP,SAAS,UAAT,CAAoB,KAApB,EAAuC;AACnC,SAAO,KAAK,CAAC,UAAN,CAAiB,gBAAjB,IAAqC,KAAK,CAAC,UAAN,CAAiB,YAAtD,IAAsE,KAAK,CAAC,UAAN,CAAiB,WAAvF,IAAsG,KAAK,CAAC,UAAN,CAAiB,WAA9H;AACH;;AAED,SAAS,cAAT,CAAwB,SAAxB,EAA8C,KAA9C,EAA8E,KAA9E,EAAiG;AAC7F;AACA;AACA,MAAI,KAAK,CAAC,UAAN,GAAmB,CAAvB,EAA0B,OAAO,KAAP,CAHmE,CAI7F;AACA;;AACA,MAAM,CAAC,GAAG,KAAK,CAAC,cAAN,GAAuB,CAAjC;;AACM,MAAA,EAAA,GAA8B,kBAAkB,CAAC,SAAS,CAAC,QAAV,CAAmB,GAApB,EAAyB,KAAK,CAAC,UAA/B,EAA2C,CAAC,GAAG,CAA/C,CAAhD;AAAA,MAAE,SAAS,GAAA,EAAA,CAAA,SAAX;AAAA,MAAa,YAAY,GAAA,EAAA,CAAA,YAAzB;;AACN,SAAO,SAAS,GAAG,YAAnB;AACH;;AAED,OAAM,SAAU,qBAAV,CAAgC,UAAhC,EAAoD,SAApD,EAA0E,KAA1E,EAAuH,KAAvH,EAA2I;AAC7I,MAAI,KAAK,CAAC,SAAN,IAAmB,KAAnB,IAA4B,UAAU,CAAC,KAAD,CAAtC,IAAiD,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,CAAnE,EAA8F;AAC1F,WAAO,gCAAgC,CAAC,UAAD,CAAvC;AACH;;AACD,SAAO,yBAAyB,CAAC,UAAD,CAAhC;AACH;AAED,OAAM,SAAU,8BAAV,CAAyC,UAAzC,EAA6D,SAA7D,EAAmF,KAAnF,EAAyI,KAAzI,EAA6J;AAC/J,MAAI,KAAK,CAAC,SAAN,IAAmB,KAAnB,IAA4B,UAAU,CAAC,KAAD,CAAtC,IAAiD,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,CAAnE,EAA8F;AAC1F,WAAO,yCAAyC,CAAC,UAAD,CAAhD;AACH;;AACD,SAAO,kCAAkC,CAAC,UAAD,CAAzC;AACH,C,CAOD;;AAEA,SAAe,yBAAf,CAAyC,GAAzC,EAA6D,IAA7D,EAAyE,SAAzE,EAA+F,KAA/F,EAA6G,KAA7G,EAA0I,IAA1I,EAAqJ;;;;;;;AACzI,UAAA,UAAU,GAAK,KAAK,CAAV,UAAV;AACwD,iBAAA,CAAA;AAAA;AAAA,YAAM,0BAA0B,CAAC,SAAD,EAAY,IAAZ,EAAkB,KAAlB,CAA1B,CAAmD,YAAnD,CAAgE,GAAG,CAAC,OAApE,CAAN,CAAA;;;AAA1D,UAAA,EAAA,GAA0D,EAAA,CAAA,IAAA,EAA1D,EAAE,SAAS,GAAA,EAAA,CAAA,SAAX,EAAa,KAAK,GAAA,EAAA,CAAA,KAAlB,EAAoB,OAAO,GAAA,EAAA,CAAA,OAA3B,EAA6B,YAAY,GAAA,EAAA,CAAA,YAAzC,EAA2C,UAAU,GAAA,EAAA,CAAA,UAArD;AAEA,UAAA,MAAM,GAAG;AACX,YAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,CAAC,UAAV,IAAwB,YADvB;AAEX,YAAA,WAAW,EAAE,KAFF;AAGX,YAAA,OAAO,EAAA;AAHI,WAAT;AAKU,iBAAA,CAAA;AAAA;AAAA,YAAM,wBAAwB,CAAC,MAAD,EAAS,IAAT,CAAxB,CAAuC,UAAvC,CAAkD,GAAG,CAAC,OAAtD,CAAN,CAAA;;;AAAV,UAAA,OAAO,GAAG,EAAA,CAAA,IAAA,EAAV;AACL,UAAA,OAAO,CAAC,IAAR,CAAa,UAAb,GAAgE,UAAhE;AAED,UAAA,IAAI,CAAC,SAAL,CAAe,OAAf,EAAwB,SAAxB;AACA,cAAI,GAAG,CAAC,KAAJ,IAAa,CAAC,GAAG,CAAC,KAAJ,CAAU,QAA5B,EAAsC,IAAI,CAAC,oBAAL,CAA0B,OAA1B;AAEhC,UAAA,MAAM,GAAG,QAAQ,CAAC,MAAT,CAAgB,QAAQ,EAAxB,EAA4B,IAAI,CAAC,QAAL,CAAc,MAA1C,EAAkD,KAAK,CAAC,YAAN,GAAqB,kBAAkB,CAAC,IAAD,CAAzF,CAAT;AACN,UAAA,OAAO,CAAC,iBAAR,CAA0B,MAA1B;AAEA,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAP,CAAA;;;;AACH;;AAED,OAAM,SAAU,yBAAV,CAAoC,UAApC,EAAsD;AACxD,SAAO,eAAe,CAA4B;AAC9C,IAAA,YAAY,EAAE,EAAE,CAAC,gBAAH,CAAoB,yBAApB,CADgC;AAE9C,IAAA,cAAc,EAAE,yBAF8B;AAG9C,IAAA,sBAAsB,EAAE,eAAe,CAAC,SAHM;AAI9C,IAAA,OAAO,EAAE,cAJqC;AAK9C,IAAA,YAAY,EAAE,WALgC;AAM9C,IAAA,cAAc,EAAE,UAAC,KAAD,EAA2B,QAA3B,EAA2E,YAA3E,EAA6H;AACzI,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,YAAT,KAA0B,YAAY,CAAC,YAA3C,EAAyD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACzD,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,eAAT,KAA6B,YAAY,CAAC,eAA9C,EAA+D,KAAK,CAAC,cAAN,GAAuB,IAAvB;AAC/D,UAAI,QAAQ,CAAC,SAAT,KAAuB,YAAY,CAAC,SAAxC,EAAmD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACnD,UAAI,QAAQ,CAAC,aAAT,KAA2B,YAAY,CAAC,aAA5C,EAA2D,KAAK,CAAC,cAAN,GAAuB,IAAvB;;AAC3D,UAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,YAAY,CAAC,YAAb,CAA0B,IAA7D,EAAmE;AAC/D,QAAA,KAAK,CAAC,WAAN,GAAoB,IAApB;AACH,OAFD,MAEO,IAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,IAA/B,IAAuC,YAAY,CAAC,YAAb,CAA0B,IAA1B,KAAmC,IAA9E,EAAoF;AACvF,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,gBAA7B,KAAkD,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,gBAAvF,EAAyG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACzG,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,YAA7B,KAA8C,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,YAAnF,EAAiG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACpG;AACJ,KAnB6C;AAoB9C,IAAA,YAAY,EAAE,UAAC,cAAD,EAAiC,KAAjC,EAA8E,KAA9E,EAAkG;AAC5G,aAAO,KAAK,CAAC,SAAN,IAAmB,CAAC,CAAC,KAArB,IAA8B,cAAc,CAAC,cAAc,CAAC,SAAhB,EAA2B,KAA3B,EAAkC,KAAlC,CAAnD;AACH,KAtB6C;AAuB9C,IAAA,aAAa,EAAE,UAAC,MAAD,EAAqB,QAArB,EAAqC,KAArC,EAAkF,KAAlF,EAAgG,KAAhG,EAAoH;AACzH,UAAA,EAAA,GAA+B,QAAQ,CAAC,IAAxC;AAAA,UAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;AAAA,UAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;AACN,UAAM,GAAG,GAAG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,UAAf,CAAlC;;AACA,UAAI,GAAJ,EAAS;AACL,QAAA,uBAAuB,CAAC,MAAD,EAAS,GAAG,CAAC,UAAb,EAAyB,GAAG,CAAC,MAA7B,EAAqC,KAArC,EAA4C,YAA5C,CAAvB;AACC,QAAA,QAAQ,CAAC,IAAT,CAAc,YAAd,GAAqE,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAsB,KAA3F;AACJ;AACJ,KA9B6C;AA+B9C,IAAA,OAAO,EAAE,UAAC,QAAD,EAAe;;;AACpB,OAAA,EAAA,GAAC,QAAQ,CAAC,IAAT,CAAsC,YAAvC,MAAmD,IAAnD,IAAmD,EAAA,KAAA,KAAA,CAAnD,GAAmD,KAAA,CAAnD,GAAmD,EAAA,CAAE,OAAF,EAAnD;AACH;AAjC6C,GAA5B,EAkCnB,UAlCmB,CAAtB;AAmCH,C,CAED;;AAEA,SAAe,kCAAf,CAAkD,GAAlD,EAAsE,SAAtE,EAA4F,KAA5F,EAA0G,KAA1G,EAAuI,IAAvI,EAAkJ;;;;;;;AACtI,UAAA,UAAU,GAAK,KAAK,CAAV,UAAV;AACwD,iBAAA,CAAA;AAAA;AAAA,YAAM,+BAA+B,CAAC,SAAD,EAAY,KAAZ,CAA/B,CAAkD,YAAlD,CAA+D,GAAG,CAAC,OAAnE,CAAN,CAAA;;;AAA1D,UAAA,EAAA,GAA0D,EAAA,CAAA,IAAA,EAA1D,EAAE,SAAS,GAAA,EAAA,CAAA,SAAX,EAAa,KAAK,GAAA,EAAA,CAAA,KAAlB,EAAoB,OAAO,GAAA,EAAA,CAAA,OAA3B,EAA6B,YAAY,GAAA,EAAA,CAAA,YAAzC,EAA2C,UAAU,GAAA,EAAA,CAAA,UAArD;AAEA,UAAA,MAAM,GAAG;AACX,YAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,CAAC,UAAV,IAAwB,YADvB;AAEX,YAAA,WAAW,EAAE,KAFF;AAGX,YAAA,OAAO,EAAA;AAHI,WAAT;AAKU,iBAAA,CAAA;AAAA;AAAA,YAAM,wBAAwB,CAAC,MAAD,EAAS,IAAT,CAAxB,CAAuC,UAAvC,CAAkD,GAAG,CAAC,OAAtD,CAAN,CAAA;;;AAAV,UAAA,OAAO,GAAG,EAAA,CAAA,IAAA,EAAV;AACL,UAAA,OAAO,CAAC,IAAR,CAAa,UAAb,GAAgE,UAAhE;AAED,UAAA,IAAI,CAAC,SAAL,CAAe,OAAf,EAAwB,SAAxB;AACA,cAAI,GAAG,CAAC,KAAJ,IAAa,CAAC,GAAG,CAAC,KAAJ,CAAU,QAA5B,EAAsC,IAAI,CAAC,oBAAL,CAA0B,OAA1B;AAEhC,UAAA,MAAM,GAAG,QAAQ,CAAC,MAAT,CAAgB,QAAQ,EAAxB,EAA4B,SAAS,CAAC,QAAV,CAAmB,MAA/C,EAAuD,KAAK,CAAC,YAAN,GAAqB,uBAAuB,CAAC,SAAD,CAAnG,CAAT;AACN,UAAA,OAAO,CAAC,iBAAR,CAA0B,MAA1B;AAEA,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAP,CAAA;;;;AACH;;AAED,OAAM,SAAU,kCAAV,CAA6C,UAA7C,EAA+D;AACjE,SAAO,iBAAiB,CAAqC;AACzD,IAAA,YAAY,EAAE,EAAE,CAAC,gBAAH,CAAoB,kCAApB,CAD2C;AAEzD,IAAA,cAAc,EAAE,kCAFyC;AAGzD,IAAA,sBAAsB,EAAE,eAAe,CAAC,aAHiB;AAIzD,IAAA,OAAO,EAAE,oBAJgD;AAKzD,IAAA,YAAY,EAAE,iBAL2C;AAMzD,IAAA,cAAc,EAAE,UAAC,KAAD,EAA2B,QAA3B,EAA2E,YAA3E,EAA6H;AACzI,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,YAAT,KAA0B,YAAY,CAAC,YAA3C,EAAyD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACzD,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,eAAT,KAA6B,YAAY,CAAC,eAA9C,EAA+D,KAAK,CAAC,cAAN,GAAuB,IAAvB;AAC/D,UAAI,QAAQ,CAAC,SAAT,KAAuB,YAAY,CAAC,SAAxC,EAAmD,KAAK,CAAC,cAAN,GAAuB,IAAvB;;AACnD,UAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,YAAY,CAAC,YAAb,CAA0B,IAA7D,EAAmE;AAC/D,QAAA,KAAK,CAAC,WAAN,GAAoB,IAApB;AACH,OAFD,MAEO,IAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,IAA/B,IAAuC,YAAY,CAAC,YAAb,CAA0B,IAA1B,KAAmC,IAA9E,EAAoF;AACvF,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,gBAA7B,KAAkD,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,gBAAvF,EAAyG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACzG,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,YAA7B,KAA8C,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,YAAnF,EAAiG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACpG;AACJ,KAlBwD;AAmBzD,IAAA,YAAY,EAAE,UAAC,SAAD,EAAuB,KAAvB,EAA6E,KAA7E,EAAiG;AAC3G,aAAO,KAAK,CAAC,SAAN,IAAmB,CAAC,CAAC,KAArB,IAA8B,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,CAAnD;AACH,KArBwD;AAsBzD,IAAA,aAAa,EAAE,UAAC,MAAD,EAAqB,QAArB,EAAqC,KAArC,EAAkF,KAAlF,EAAgG,KAAhG,EAAoH;AACzH,UAAA,EAAA,GAA+B,QAAQ,CAAC,IAAxC;AAAA,UAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;AAAA,UAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;AACN,UAAM,GAAG,GAAG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,UAAf,CAAlC;;AACA,UAAI,GAAJ,EAAS;AACL,QAAA,uBAAuB,CAAC,MAAD,EAAS,GAAG,CAAC,UAAb,EAAyB,GAAG,CAAC,MAA7B,EAAqC,KAArC,EAA4C,YAA5C,CAAvB;AACC,QAAA,QAAQ,CAAC,IAAT,CAAc,YAAd,GAAqE,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAsB,KAA3F;AACJ;AACJ,KA7BwD;AA8BzD,IAAA,OAAO,EAAE,UAAC,QAAD,EAAe;;;AACpB,OAAA,EAAA,GAAC,QAAQ,CAAC,IAAT,CAAsC,YAAvC,MAAmD,IAAnD,IAAmD,EAAA,KAAA,KAAA,CAAnD,GAAmD,KAAA,CAAnD,GAAmD,EAAA,CAAE,OAAF,EAAnD;AACH;AAhCwD,GAArC,EAiCrB,UAjCqB,CAAxB;AAkCH,C,CAED;;AAEA,IAAM,mBAAmB,GAAG,kBAA5B;;AAEA,SAAe,gCAAf,CAAgD,GAAhD,EAAoE,IAApE,EAAgF,SAAhF,EAAsG,KAAtG,EAAoH,KAApH,EAAiJ,WAAjJ,EAA0K;;;;;;;AACtK,cAAI,CAAC,GAAG,CAAC,KAAT,EAAgB,MAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AAEV,UAAA,EAAA,GAAuH,GAAG,CAAC,KAA3H,EAAE,aAAa,GAAA,EAAA,CAAA,aAAf,EAAiB,SAAS,GAAA,EAAA,CAAA,SAA1B,EAA4B,EAAA,GAAA,EAAA,CAAA,UAA5B,EAA0C,gBAAgB,GAAA,EAAA,CAAA,gBAA1D,EAA4D,YAAY,GAAA,EAAA,CAAA,YAAxE,EAA0E,oBAAoB,GAAA,EAAA,CAAA,oBAA9F,EAAgG,gBAAgB,GAAA,EAAA,CAAA,gBAAhH;;AACN,cAAI,CAAC,aAAa,CAAC,mBAAD,CAAlB,EAAyC;AACrC,YAAA,aAAa,CAAC,mBAAD,CAAb,GAAqC,oBAAoB,IAAI,gBAAxB,GAC/B,SAAS,CAAC,OAAV,CAAkB,eAAlB,EAAmC,MAAnC,EAA2C,MAA3C,EAAmD,QAAnD,CAD+B,GAE/B,gBAAgB,IAAI,YAApB,GACI,SAAS,CAAC,OAAV,CAAkB,eAAlB,EAAmC,MAAnC,EAA2C,OAA3C,EAAoD,QAApD,CADJ,GAEI,SAAS,CAAC,OAAV,CAAkB,aAAlB,EAAiC,MAAjC,EAAyC,OAAzC,EAAkD,QAAlD,CAJV;AAKH;;AAG0B,iBAAA,CAAA;AAAA;AAAA,YAAM,mCAAmC,CAAC,SAAD,EAAY,IAAZ,EAAkB,IAAlB,EAAwB,KAAxB,EAA+B,GAAG,CAAC,KAAnC,EAA0C,aAAa,CAAC,mBAAD,CAAvD,CAAnC,CAAiH,YAAjH,CAA8H,GAAG,CAAC,OAAlI,CAAN,CAAA;;;AAArB,UAAA,kBAAkB,GAAG,EAAA,CAAA,IAAA,EAArB;AAMA,UAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,KAAK,CAAC,UAAhB,IAA8B,kBAAkB,CAAC,YAA5D;AAEA,UAAA,MAAM,GAAG,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,YAAb,CAA0B,GAA1B,EAAT;AACA,UAAA,EAAE,GAAG,iBAAiB,CAAC,GAAG,CAAC,KAAL,EAAY,kBAAkB,CAAC,OAA/B,EAAwC,kBAAkB,CAAC,OAA3D,EAAoE,kBAAkB,CAAC,UAAvF,EAAmG,kBAAkB,CAAC,YAAtH,EAAoI,kBAAkB,CAAC,SAAvJ,EAAkK,QAAlK,EAA4K,KAA5K,EAAmL,IAAnL,EAAyL,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,MAAjM,EAAyM,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,KAAjN,EAAwN,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,MAAhO,CAAtB;AAEA,UAAA,cAAc,GAAG,QAAQ,CAAC,MAAT,CAAgB,QAAQ,EAAxB,EAA4B,IAAI,CAAC,QAAL,CAAc,MAA1C,EAAkD,KAAK,CAAC,YAAN,GAAqB,uBAAuB,CAAC,SAAD,CAA9F,CAAjB;AACA,UAAA,OAAO,GAAG,WAAW,CAAC,MAAZ,CAAmB,EAAE,CAAC,WAAtB,EAAmC,CAAnC,EAAsC,EAAE,CAAC,aAAzC,EAAwD,EAAE,CAAC,YAA3D,EAAyE,EAAE,CAAC,aAA5E,EAA2F,cAA3F,EAA2G,WAA3G,CAAV;AACL,UAAA,OAAO,CAAC,IAAR,GAAuC;AAAE,YAAA,UAAU,EAAE,kBAAkB,CAAC;AAAjC,WAAvC;AAED,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAP,CAAA;;;;AACH;;AAED,OAAM,SAAU,gCAAV,CAA2C,UAA3C,EAA6D;AAC/D,SAAO,sBAAsB,CAA4B;AACrD,IAAA,YAAY,EAAE,EAAE,CAAC,gBAAH,CAAoB,yBAApB,CADuC;AAErD,IAAA,cAAc,EAAE,gCAFqC;AAGrD,IAAA,sBAAsB,EAAE,eAAe,CAAC,SAHa;AAIrD,IAAA,OAAO,EAAE,cAJ4C;AAKrD,IAAA,YAAY,EAAE,WALuC;AAMrD,IAAA,cAAc,EAAE,UAAC,KAAD,EAA2B,QAA3B,EAA2E,YAA3E,EAA6H;AACzI,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,YAAT,KAA0B,YAAY,CAAC,YAA3C,EAAyD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACzD,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,eAAT,KAA6B,YAAY,CAAC,eAA9C,EAA+D,KAAK,CAAC,cAAN,GAAuB,IAAvB;AAC/D,UAAI,QAAQ,CAAC,SAAT,KAAuB,YAAY,CAAC,SAAxC,EAAmD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACnD,UAAI,QAAQ,CAAC,aAAT,KAA2B,YAAY,CAAC,aAA5C,EAA2D,KAAK,CAAC,cAAN,GAAuB,IAAvB;;AAC3D,UAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,YAAY,CAAC,YAAb,CAA0B,IAA7D,EAAmE;AAC/D,QAAA,KAAK,CAAC,WAAN,GAAoB,IAApB;AACH,OAFD,MAEO,IAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,IAA/B,IAAuC,YAAY,CAAC,YAAb,CAA0B,IAA1B,KAAmC,IAA9E,EAAoF;AACvF,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,gBAA7B,KAAkD,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,gBAAvF,EAAyG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACzG,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,YAA7B,KAA8C,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,YAAnF,EAAiG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACpG;AACJ,KAnBoD;AAoBrD,IAAA,YAAY,EAAE,UAAC,cAAD,EAAiC,KAAjC,EAA8E,KAA9E,EAAkG;AAC5G,aAAO,CAAC,KAAK,CAAC,SAAP,IAAoB,CAAC,KAArB,IAA8B,CAAC,cAAc,CAAC,cAAc,CAAC,SAAhB,EAA2B,KAA3B,EAAkC,KAAlC,CAApD;AACH,KAtBoD;AAuBrD,IAAA,aAAa,EAAE,UAAC,MAAD,EAA4B,QAA5B,EAAmD,KAAnD,EAAgG,KAAhG,EAA8G,KAA9G,EAAkI;AACvI,UAAA,EAAA,GAA+B,QAAQ,CAAC,IAAxC;AAAA,UAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;AAAA,UAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;AACN,UAAM,GAAG,GAAG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,UAAf,CAAlC;;AACA,UAAI,GAAG,IAAI,KAAX,EAAkB;AACd,QAAA,8BAA8B,CAAC,MAAD,EAAS,GAAG,CAAC,UAAb,EAAyB,GAAG,CAAC,MAA7B,EAAqC,KAArC,EAA4C,YAA5C,CAA9B;AACC,QAAA,QAAQ,CAAC,IAAT,CAAsC,YAAtC,GAAqD,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAsB,KAA3E;AACJ;AACJ,KA9BoD;AA+BrD,IAAA,OAAO,EAAE,UAAC,QAAD,EAAsB;;;AAC3B,MAAA,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAA2B,KAA3B,CAAiC,OAAjC;AACA,MAAA,QAAQ,CAAC,YAAT,CAAsB,GAAtB,CAA0B,KAA1B,CAAgC,OAAhC;AACA,MAAA,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAA2B,KAA3B,CAAiC,OAAjC;AACA,MAAA,QAAQ,CAAC,YAAT,CAAsB,OAAtB;AAEA,OAAA,EAAA,GAAC,QAAQ,CAAC,IAAT,CAAsC,YAAvC,MAAmD,IAAnD,IAAmD,EAAA,KAAA,KAAA,CAAnD,GAAmD,KAAA,CAAnD,GAAmD,EAAA,CAAE,OAAF,EAAnD;AACH;AAtCoD,GAA5B,EAuC1B,UAvC0B,CAA7B;AAwCH,C,CAED;;AAEA,SAAe,yCAAf,CAAyD,GAAzD,EAA6E,SAA7E,EAAmG,KAAnG,EAAiH,KAAjH,EAA8I,WAA9I,EAAuK;;;;;;;AACnK,cAAI,CAAC,GAAG,CAAC,KAAT,EAAgB,MAAM,IAAI,KAAJ,CAAU,0EAAV,CAAN;AAEV,UAAA,EAAA,GAAuH,GAAG,CAAC,KAA3H,EAAE,aAAa,GAAA,EAAA,CAAA,aAAf,EAAiB,SAAS,GAAA,EAAA,CAAA,SAA1B,EAA4B,EAAA,GAAA,EAAA,CAAA,UAA5B,EAA0C,gBAAgB,GAAA,EAAA,CAAA,gBAA1D,EAA4D,YAAY,GAAA,EAAA,CAAA,YAAxE,EAA0E,oBAAoB,GAAA,EAAA,CAAA,oBAA9F,EAAgG,gBAAgB,GAAA,EAAA,CAAA,gBAAhH;;AACN,cAAI,CAAC,aAAa,CAAC,mBAAD,CAAlB,EAAyC;AACrC,YAAA,aAAa,CAAC,mBAAD,CAAb,GAAqC,oBAAoB,IAAI,gBAAxB,GAC/B,SAAS,CAAC,OAAV,CAAkB,eAAlB,EAAmC,MAAnC,EAA2C,MAA3C,EAAmD,QAAnD,CAD+B,GAE/B,gBAAgB,IAAI,YAApB,GACI,SAAS,CAAC,OAAV,CAAkB,eAAlB,EAAmC,MAAnC,EAA2C,OAA3C,EAAoD,QAApD,CADJ,GAEI,SAAS,CAAC,OAAV,CAAkB,aAAlB,EAAiC,MAAjC,EAAyC,OAAzC,EAAkD,QAAlD,CAJV;AAKH;;AAG0B,iBAAA,CAAA;AAAA;AAAA,YAAM,wCAAwC,CAAC,SAAD,EAAY,IAAZ,EAAkB,KAAlB,EAAyB,GAAG,CAAC,KAA7B,EAAoC,aAAa,CAAC,mBAAD,CAAjD,CAAxC,CAAgH,YAAhH,CAA6H,GAAG,CAAC,OAAjI,CAAN,CAAA;;;AAArB,UAAA,kBAAkB,GAAG,EAAA,CAAA,IAAA,EAArB;AAMA,UAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,KAAK,CAAC,UAAhB,IAA8B,kBAAkB,CAAC,YAA5D;AAEA,UAAA,MAAM,GAAG,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAA,WAAW,CAAE,YAAb,CAA0B,GAA1B,EAAT;AACA,UAAA,EAAE,GAAG,iBAAiB,CAAC,GAAG,CAAC,KAAL,EAAY,kBAAkB,CAAC,OAA/B,EAAwC,kBAAkB,CAAC,OAA3D,EAAoE,kBAAkB,CAAC,UAAvF,EAAmG,kBAAkB,CAAC,YAAtH,EAAoI,kBAAkB,CAAC,SAAvJ,EAAkK,QAAlK,EAA4K,KAA5K,EAAmL,IAAnL,EAAyL,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,MAAjM,EAAyM,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,KAAjN,EAAwN,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,MAAhO,CAAtB;AAEA,UAAA,cAAc,GAAG,QAAQ,CAAC,MAAT,CAAgB,QAAQ,EAAxB,EAA4B,SAAS,CAAC,QAAV,CAAmB,MAA/C,EAAuD,KAAK,CAAC,YAAN,GAAqB,uBAAuB,CAAC,SAAD,CAAnG,CAAjB;AACA,UAAA,OAAO,GAAG,WAAW,CAAC,MAAZ,CAAmB,EAAE,CAAC,WAAtB,EAAmC,CAAnC,EAAsC,EAAE,CAAC,aAAzC,EAAwD,EAAE,CAAC,YAA3D,EAAyE,EAAE,CAAC,aAA5E,EAA2F,cAA3F,EAA2G,WAA3G,CAAV;AACL,UAAA,OAAO,CAAC,IAAR,GAAuC;AAAE,YAAA,UAAU,EAAE,kBAAkB,CAAC;AAAjC,WAAvC;AAED,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAP,CAAA;;;;AACH;;AAED,OAAM,SAAU,yCAAV,CAAoD,UAApD,EAAsE;AACxE,SAAO,wBAAwB,CAAqC;AAChE,IAAA,YAAY,EAAE,EAAE,CAAC,gBAAH,CAAoB,kCAApB,CADkD;AAEhE,IAAA,cAAc,EAAE,yCAFgD;AAGhE,IAAA,sBAAsB,EAAE,eAAe,CAAC,aAHwB;AAIhE,IAAA,OAAO,EAAE,oBAJuD;AAKhE,IAAA,YAAY,EAAE,iBALkD;AAMhE,IAAA,cAAc,EAAE,UAAC,KAAD,EAA2B,QAA3B,EAAoF,YAApF,EAA+I;AAC3J,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,YAAT,KAA0B,YAAY,CAAC,YAA3C,EAAyD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACzD,UAAI,QAAQ,CAAC,UAAT,KAAwB,YAAY,CAAC,UAAzC,EAAqD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACrD,UAAI,QAAQ,CAAC,eAAT,KAA6B,YAAY,CAAC,eAA9C,EAA+D,KAAK,CAAC,cAAN,GAAuB,IAAvB;AAC/D,UAAI,QAAQ,CAAC,SAAT,KAAuB,YAAY,CAAC,SAAxC,EAAmD,KAAK,CAAC,cAAN,GAAuB,IAAvB;AACnD,UAAI,QAAQ,CAAC,aAAT,KAA2B,YAAY,CAAC,aAA5C,EAA2D,KAAK,CAAC,cAAN,GAAuB,IAAvB;;AAC3D,UAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,YAAY,CAAC,YAAb,CAA0B,IAA7D,EAAmE;AAC/D,QAAA,KAAK,CAAC,WAAN,GAAoB,IAApB;AACH,OAFD,MAEO,IAAI,QAAQ,CAAC,YAAT,CAAsB,IAAtB,KAA+B,IAA/B,IAAuC,YAAY,CAAC,YAAb,CAA0B,IAA1B,KAAmC,IAA9E,EAAoF;AACvF,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,gBAA7B,KAAkD,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,gBAAvF,EAAyG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACzG,YAAI,QAAQ,CAAC,YAAT,CAAsB,MAAtB,CAA6B,YAA7B,KAA8C,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAiC,YAAnF,EAAiG,KAAK,CAAC,WAAN,GAAoB,IAApB;AACpG;AACJ,KAnB+D;AAoBhE,IAAA,YAAY,EAAE,UAAC,SAAD,EAAuB,KAAvB,EAA6E,KAA7E,EAAiG;AAC3G,aAAO,CAAC,KAAK,CAAC,SAAP,IAAoB,CAAC,KAArB,IAA8B,CAAC,cAAc,CAAC,SAAD,EAAY,KAAZ,EAAmB,KAAnB,CAApD;AACH,KAtB+D;AAuBhE,IAAA,aAAa,EAAE,UAAC,MAAD,EAA4B,QAA5B,EAAmD,KAAnD,EAAgG,KAAhG,EAA8G,KAA9G,EAAkI;AACvI,UAAA,EAAA,GAA+B,QAAQ,CAAC,IAAxC;AAAA,UAAE,UAAU,GAAA,EAAA,CAAA,UAAZ;AAAA,UAAc,YAAY,GAAA,EAAA,CAAA,YAA1B;AACN,UAAM,GAAG,GAAG,sBAAsB,CAAC,KAAD,EAAQ,KAAR,EAAe,UAAf,CAAlC;;AACA,UAAI,GAAG,IAAI,KAAX,EAAkB;AACd,QAAA,8BAA8B,CAAC,MAAD,EAAS,GAAG,CAAC,UAAb,EAAyB,GAAG,CAAC,MAA7B,EAAqC,KAArC,EAA4C,YAA5C,CAA9B;AACC,QAAA,QAAQ,CAAC,IAAT,CAAsC,YAAtC,GAAqD,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAsB,KAA3E;AACJ;AACJ,KA9B+D;AA+BhE,IAAA,OAAO,EAAE,UAAC,QAAD,EAAsB;;;AAC3B,MAAA,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAA2B,KAA3B,CAAiC,OAAjC;AACA,MAAA,QAAQ,CAAC,YAAT,CAAsB,GAAtB,CAA0B,KAA1B,CAAgC,OAAhC;AACA,MAAA,QAAQ,CAAC,aAAT,CAAuB,GAAvB,CAA2B,KAA3B,CAAiC,OAAjC;AACA,MAAA,QAAQ,CAAC,YAAT,CAAsB,OAAtB;AAEA,OAAA,EAAA,GAAC,QAAQ,CAAC,IAAT,CAAsC,YAAvC,MAAmD,IAAnD,IAAmD,EAAA,KAAA,KAAA,CAAnD,GAAmD,KAAA,CAAnD,GAAmD,EAAA,CAAE,OAAF,EAAnD;AACH;AAtC+D,GAArC,EAuC5B,UAvC4B,CAA/B;AAwCH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { UnitsMeshParams, UnitsTextureMeshParams, UnitsMeshVisual, UnitsTextureMeshVisual } from '../units-visual';\r\nimport { GaussianDensityParams, computeUnitGaussianDensity, computeUnitGaussianDensityTexture2d, computeStructureGaussianDensity, computeStructureGaussianDensityTexture2d } from './util/gaussian';\r\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\r\nimport { computeMarchingCubesMesh } from '../../../mol-geo/util/marching-cubes/algorithm';\r\nimport { ElementIterator, getElementLoci, eachElement, getSerialElementLoci, eachSerialElement } from './util/element';\r\nimport { TextureMesh } from '../../../mol-geo/geometry/texture-mesh/texture-mesh';\r\nimport { extractIsosurface } from '../../../mol-gl/compute/marching-cubes/isosurface';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { ComplexMeshParams, ComplexMeshVisual, ComplexTextureMeshVisual, ComplexTextureMeshParams } from '../complex-visual';\r\nimport { getUnitExtraRadius, getStructureExtraRadius, getVolumeSliceInfo } from './util/common';\r\nimport { applyMeshColorSmoothing, applyTextureMeshColorSmoothing, ColorSmoothingParams, getColorSmoothingProps } from './util/color';\r\nvar SharedParams = __assign(__assign(__assign({}, GaussianDensityParams), ColorSmoothingParams), { ignoreHydrogens: PD.Boolean(false), tryUseGpu: PD.Boolean(true), includeParent: PD.Boolean(false, { isHidden: true }) });\r\nexport var GaussianSurfaceMeshParams = __assign(__assign(__assign({}, UnitsMeshParams), UnitsTextureMeshParams), SharedParams);\r\nexport var StructureGaussianSurfaceMeshParams = __assign(__assign(__assign({}, ComplexMeshParams), ComplexTextureMeshParams), SharedParams);\r\nfunction gpuSupport(webgl) {\r\n    return webgl.extensions.colorBufferFloat && webgl.extensions.textureFloat && webgl.extensions.blendMinMax && webgl.extensions.drawBuffers;\r\n}\r\nfunction suitableForGpu(structure, props, webgl) {\r\n    // lower resolutions are about as fast on CPU vs integrated GPU,\r\n    // very low resolutions have artifacts when calculated on GPU\r\n    if (props.resolution > 1)\r\n        return false;\r\n    // the GPU is much more memory contraint, especially true for integrated GPUs,\r\n    // being conservative here still allows for small and medium sized assemblies\r\n    var d = webgl.maxTextureSize / 3;\r\n    var _a = getVolumeSliceInfo(structure.boundary.box, props.resolution, d * d), areaCells = _a.areaCells, maxAreaCells = _a.maxAreaCells;\r\n    return areaCells < maxAreaCells;\r\n}\r\nexport function GaussianSurfaceVisual(materialId, structure, props, webgl) {\r\n    if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {\r\n        return GaussianSurfaceTextureMeshVisual(materialId);\r\n    }\r\n    return GaussianSurfaceMeshVisual(materialId);\r\n}\r\nexport function StructureGaussianSurfaceVisual(materialId, structure, props, webgl) {\r\n    if (props.tryUseGpu && webgl && gpuSupport(webgl) && suitableForGpu(structure, props, webgl)) {\r\n        return StructureGaussianSurfaceTextureMeshVisual(materialId);\r\n    }\r\n    return StructureGaussianSurfaceMeshVisual(materialId);\r\n}\r\n//\r\nfunction createGaussianSurfaceMesh(ctx, unit, structure, theme, props, mesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    smoothness = props.smoothness;\r\n                    return [4 /*yield*/, computeUnitGaussianDensity(structure, unit, props).runInContext(ctx.runtime)];\r\n                case 1:\r\n                    _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;\r\n                    params = {\r\n                        isoLevel: Math.exp(-smoothness) / radiusFactor,\r\n                        scalarField: field,\r\n                        idField: idField\r\n                    };\r\n                    return [4 /*yield*/, computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime)];\r\n                case 2:\r\n                    surface = _b.sent();\r\n                    surface.meta.resolution = resolution;\r\n                    Mesh.transform(surface, transform);\r\n                    if (ctx.webgl && !ctx.webgl.isWebGL2)\r\n                        Mesh.uniformTriangleGroup(surface);\r\n                    sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, props.radiusOffset + getUnitExtraRadius(unit));\r\n                    surface.setBoundingSphere(sphere);\r\n                    return [2 /*return*/, surface];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function GaussianSurfaceMeshVisual(materialId) {\r\n    return UnitsMeshVisual({\r\n        defaultProps: PD.getDefaultValues(GaussianSurfaceMeshParams),\r\n        createGeometry: createGaussianSurfaceMesh,\r\n        createLocationIterator: ElementIterator.fromGroup,\r\n        getLoci: getElementLoci,\r\n        eachLocation: eachElement,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            if (newProps.resolution !== currentProps.resolution)\r\n                state.createGeometry = true;\r\n            if (newProps.radiusOffset !== currentProps.radiusOffset)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothness !== currentProps.smoothness)\r\n                state.createGeometry = true;\r\n            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)\r\n                state.createGeometry = true;\r\n            if (newProps.traceOnly !== currentProps.traceOnly)\r\n                state.createGeometry = true;\r\n            if (newProps.includeParent !== currentProps.includeParent)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\r\n                state.updateColor = true;\r\n            }\r\n            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\r\n                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)\r\n                    state.updateColor = true;\r\n                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)\r\n                    state.updateColor = true;\r\n            }\r\n        },\r\n        mustRecreate: function (structureGroup, props, webgl) {\r\n            return props.tryUseGpu && !!webgl && suitableForGpu(structureGroup.structure, props, webgl);\r\n        },\r\n        processValues: function (values, geometry, props, theme, webgl) {\r\n            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;\r\n            var csp = getColorSmoothingProps(props, theme, resolution);\r\n            if (csp) {\r\n                applyMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\r\n                geometry.meta.colorTexture = values.tColorGrid.ref.value;\r\n            }\r\n        },\r\n        dispose: function (geometry) {\r\n            var _a;\r\n            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\r\n        }\r\n    }, materialId);\r\n}\r\n//\r\nfunction createStructureGaussianSurfaceMesh(ctx, structure, theme, props, mesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var smoothness, _a, transform, field, idField, radiusFactor, resolution, params, surface, sphere;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    smoothness = props.smoothness;\r\n                    return [4 /*yield*/, computeStructureGaussianDensity(structure, props).runInContext(ctx.runtime)];\r\n                case 1:\r\n                    _a = _b.sent(), transform = _a.transform, field = _a.field, idField = _a.idField, radiusFactor = _a.radiusFactor, resolution = _a.resolution;\r\n                    params = {\r\n                        isoLevel: Math.exp(-smoothness) / radiusFactor,\r\n                        scalarField: field,\r\n                        idField: idField\r\n                    };\r\n                    return [4 /*yield*/, computeMarchingCubesMesh(params, mesh).runAsChild(ctx.runtime)];\r\n                case 2:\r\n                    surface = _b.sent();\r\n                    surface.meta.resolution = resolution;\r\n                    Mesh.transform(surface, transform);\r\n                    if (ctx.webgl && !ctx.webgl.isWebGL2)\r\n                        Mesh.uniformTriangleGroup(surface);\r\n                    sphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\r\n                    surface.setBoundingSphere(sphere);\r\n                    return [2 /*return*/, surface];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function StructureGaussianSurfaceMeshVisual(materialId) {\r\n    return ComplexMeshVisual({\r\n        defaultProps: PD.getDefaultValues(StructureGaussianSurfaceMeshParams),\r\n        createGeometry: createStructureGaussianSurfaceMesh,\r\n        createLocationIterator: ElementIterator.fromStructure,\r\n        getLoci: getSerialElementLoci,\r\n        eachLocation: eachSerialElement,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            if (newProps.resolution !== currentProps.resolution)\r\n                state.createGeometry = true;\r\n            if (newProps.radiusOffset !== currentProps.radiusOffset)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothness !== currentProps.smoothness)\r\n                state.createGeometry = true;\r\n            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)\r\n                state.createGeometry = true;\r\n            if (newProps.traceOnly !== currentProps.traceOnly)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\r\n                state.updateColor = true;\r\n            }\r\n            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\r\n                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)\r\n                    state.updateColor = true;\r\n                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)\r\n                    state.updateColor = true;\r\n            }\r\n        },\r\n        mustRecreate: function (structure, props, webgl) {\r\n            return props.tryUseGpu && !!webgl && suitableForGpu(structure, props, webgl);\r\n        },\r\n        processValues: function (values, geometry, props, theme, webgl) {\r\n            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;\r\n            var csp = getColorSmoothingProps(props, theme, resolution);\r\n            if (csp) {\r\n                applyMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\r\n                geometry.meta.colorTexture = values.tColorGrid.ref.value;\r\n            }\r\n        },\r\n        dispose: function (geometry) {\r\n            var _a;\r\n            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\r\n        }\r\n    }, materialId);\r\n}\r\n//\r\nvar GaussianSurfaceName = 'gaussian-surface';\r\nfunction createGaussianSurfaceTextureMesh(ctx, unit, structure, theme, props, textureMesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    if (!ctx.webgl)\r\n                        throw new Error('webgl context required to create gaussian surface texture-mesh');\r\n                    _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;\r\n                    if (!namedTextures[GaussianSurfaceName]) {\r\n                        namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat\r\n                            ? resources.texture('image-float16', 'rgba', 'fp16', 'linear')\r\n                            : colorBufferFloat && textureFloat\r\n                                ? resources.texture('image-float32', 'rgba', 'float', 'linear')\r\n                                : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');\r\n                    }\r\n                    return [4 /*yield*/, computeUnitGaussianDensityTexture2d(structure, unit, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];\r\n                case 1:\r\n                    densityTextureData = _c.sent();\r\n                    isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;\r\n                    buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\r\n                    gv = extractIsosurface(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\r\n                    boundingSphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\r\n                    surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);\r\n                    surface.meta = { resolution: densityTextureData.resolution };\r\n                    return [2 /*return*/, surface];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function GaussianSurfaceTextureMeshVisual(materialId) {\r\n    return UnitsTextureMeshVisual({\r\n        defaultProps: PD.getDefaultValues(GaussianSurfaceMeshParams),\r\n        createGeometry: createGaussianSurfaceTextureMesh,\r\n        createLocationIterator: ElementIterator.fromGroup,\r\n        getLoci: getElementLoci,\r\n        eachLocation: eachElement,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            if (newProps.resolution !== currentProps.resolution)\r\n                state.createGeometry = true;\r\n            if (newProps.radiusOffset !== currentProps.radiusOffset)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothness !== currentProps.smoothness)\r\n                state.createGeometry = true;\r\n            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)\r\n                state.createGeometry = true;\r\n            if (newProps.traceOnly !== currentProps.traceOnly)\r\n                state.createGeometry = true;\r\n            if (newProps.includeParent !== currentProps.includeParent)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\r\n                state.updateColor = true;\r\n            }\r\n            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\r\n                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)\r\n                    state.updateColor = true;\r\n                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)\r\n                    state.updateColor = true;\r\n            }\r\n        },\r\n        mustRecreate: function (structureGroup, props, webgl) {\r\n            return !props.tryUseGpu || !webgl || !suitableForGpu(structureGroup.structure, props, webgl);\r\n        },\r\n        processValues: function (values, geometry, props, theme, webgl) {\r\n            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;\r\n            var csp = getColorSmoothingProps(props, theme, resolution);\r\n            if (csp && webgl) {\r\n                applyTextureMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\r\n                geometry.meta.colorTexture = values.tColorGrid.ref.value;\r\n            }\r\n        },\r\n        dispose: function (geometry) {\r\n            var _a;\r\n            geometry.vertexTexture.ref.value.destroy();\r\n            geometry.groupTexture.ref.value.destroy();\r\n            geometry.normalTexture.ref.value.destroy();\r\n            geometry.doubleBuffer.destroy();\r\n            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\r\n        }\r\n    }, materialId);\r\n}\r\n//\r\nfunction createStructureGaussianSurfaceTextureMesh(ctx, structure, theme, props, textureMesh) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, namedTextures, resources, _b, colorBufferFloat, textureFloat, colorBufferHalfFloat, textureHalfFloat, densityTextureData, isoLevel, buffer, gv, boundingSphere, surface;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    if (!ctx.webgl)\r\n                        throw new Error('webgl context required to create structure gaussian surface texture-mesh');\r\n                    _a = ctx.webgl, namedTextures = _a.namedTextures, resources = _a.resources, _b = _a.extensions, colorBufferFloat = _b.colorBufferFloat, textureFloat = _b.textureFloat, colorBufferHalfFloat = _b.colorBufferHalfFloat, textureHalfFloat = _b.textureHalfFloat;\r\n                    if (!namedTextures[GaussianSurfaceName]) {\r\n                        namedTextures[GaussianSurfaceName] = colorBufferHalfFloat && textureHalfFloat\r\n                            ? resources.texture('image-float16', 'rgba', 'fp16', 'linear')\r\n                            : colorBufferFloat && textureFloat\r\n                                ? resources.texture('image-float32', 'rgba', 'float', 'linear')\r\n                                : resources.texture('image-uint8', 'rgba', 'ubyte', 'linear');\r\n                    }\r\n                    return [4 /*yield*/, computeStructureGaussianDensityTexture2d(structure, true, props, ctx.webgl, namedTextures[GaussianSurfaceName]).runInContext(ctx.runtime)];\r\n                case 1:\r\n                    densityTextureData = _c.sent();\r\n                    isoLevel = Math.exp(-props.smoothness) / densityTextureData.radiusFactor;\r\n                    buffer = textureMesh === null || textureMesh === void 0 ? void 0 : textureMesh.doubleBuffer.get();\r\n                    gv = extractIsosurface(ctx.webgl, densityTextureData.texture, densityTextureData.gridDim, densityTextureData.gridTexDim, densityTextureData.gridTexScale, densityTextureData.transform, isoLevel, false, true, buffer === null || buffer === void 0 ? void 0 : buffer.vertex, buffer === null || buffer === void 0 ? void 0 : buffer.group, buffer === null || buffer === void 0 ? void 0 : buffer.normal);\r\n                    boundingSphere = Sphere3D.expand(Sphere3D(), structure.boundary.sphere, props.radiusOffset + getStructureExtraRadius(structure));\r\n                    surface = TextureMesh.create(gv.vertexCount, 1, gv.vertexTexture, gv.groupTexture, gv.normalTexture, boundingSphere, textureMesh);\r\n                    surface.meta = { resolution: densityTextureData.resolution };\r\n                    return [2 /*return*/, surface];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function StructureGaussianSurfaceTextureMeshVisual(materialId) {\r\n    return ComplexTextureMeshVisual({\r\n        defaultProps: PD.getDefaultValues(StructureGaussianSurfaceMeshParams),\r\n        createGeometry: createStructureGaussianSurfaceTextureMesh,\r\n        createLocationIterator: ElementIterator.fromStructure,\r\n        getLoci: getSerialElementLoci,\r\n        eachLocation: eachSerialElement,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            if (newProps.resolution !== currentProps.resolution)\r\n                state.createGeometry = true;\r\n            if (newProps.radiusOffset !== currentProps.radiusOffset)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothness !== currentProps.smoothness)\r\n                state.createGeometry = true;\r\n            if (newProps.ignoreHydrogens !== currentProps.ignoreHydrogens)\r\n                state.createGeometry = true;\r\n            if (newProps.traceOnly !== currentProps.traceOnly)\r\n                state.createGeometry = true;\r\n            if (newProps.includeParent !== currentProps.includeParent)\r\n                state.createGeometry = true;\r\n            if (newProps.smoothColors.name !== currentProps.smoothColors.name) {\r\n                state.updateColor = true;\r\n            }\r\n            else if (newProps.smoothColors.name === 'on' && currentProps.smoothColors.name === 'on') {\r\n                if (newProps.smoothColors.params.resolutionFactor !== currentProps.smoothColors.params.resolutionFactor)\r\n                    state.updateColor = true;\r\n                if (newProps.smoothColors.params.sampleStride !== currentProps.smoothColors.params.sampleStride)\r\n                    state.updateColor = true;\r\n            }\r\n        },\r\n        mustRecreate: function (structure, props, webgl) {\r\n            return !props.tryUseGpu || !webgl || !suitableForGpu(structure, props, webgl);\r\n        },\r\n        processValues: function (values, geometry, props, theme, webgl) {\r\n            var _a = geometry.meta, resolution = _a.resolution, colorTexture = _a.colorTexture;\r\n            var csp = getColorSmoothingProps(props, theme, resolution);\r\n            if (csp && webgl) {\r\n                applyTextureMeshColorSmoothing(values, csp.resolution, csp.stride, webgl, colorTexture);\r\n                geometry.meta.colorTexture = values.tColorGrid.ref.value;\r\n            }\r\n        },\r\n        dispose: function (geometry) {\r\n            var _a;\r\n            geometry.vertexTexture.ref.value.destroy();\r\n            geometry.groupTexture.ref.value.destroy();\r\n            geometry.normalTexture.ref.value.destroy();\r\n            geometry.doubleBuffer.destroy();\r\n            (_a = geometry.meta.colorTexture) === null || _a === void 0 ? void 0 : _a.destroy();\r\n        }\r\n    }, materialId);\r\n}\r\n//# sourceMappingURL=gaussian-surface-mesh.js.map"]},"metadata":{},"sourceType":"module"}