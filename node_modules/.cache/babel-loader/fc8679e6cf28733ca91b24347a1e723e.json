{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Matrix } from './matrix';\nexport var EVD;\n\n(function (EVD) {\n  function createCache(size) {\n    return {\n      size: size,\n      matrix: Matrix.create(size, size),\n      eigenValues: new Float64Array(size),\n      D: new Float64Array(size),\n      E: new Float64Array(size)\n    };\n  }\n\n  EVD.createCache = createCache;\n  /**\r\n   * Computes EVD and stores the result in the cache.\r\n   */\n\n  function compute(cache) {\n    symmetricEigenDecomp(cache.size, cache.matrix.data, cache.eigenValues, cache.D, cache.E);\n  }\n\n  EVD.compute = compute;\n})(EVD || (EVD = {})); // The EVD code has been adapted from Math.NET, MIT license, Copyright (c) 2002-2015 Math.NET\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfunction symmetricEigenDecomp(order, matrixEv, vectorEv, d, e) {\n  for (var i = 0; i < order; i++) {\n    e[i] = 0.0;\n  }\n\n  var om1 = order - 1;\n\n  for (var i = 0; i < order; i++) {\n    d[i] = matrixEv[i * order + om1];\n  }\n\n  symmetricTridiagonalize(matrixEv, d, e, order);\n  symmetricDiagonalize(matrixEv, d, e, order);\n\n  for (var i = 0; i < order; i++) {\n    vectorEv[i] = d[i];\n  }\n}\n\nfunction symmetricTridiagonalize(a, d, e, order) {\n  // Householder reduction to tridiagonal form.\n  for (var i = order - 1; i > 0; i--) {\n    // Scale to avoid under/overflow.\n    var scale = 0.0;\n    var h = 0.0;\n\n    for (var k = 0; k < i; k++) {\n      scale = scale + Math.abs(d[k]);\n    }\n\n    if (scale === 0.0) {\n      e[i] = d[i - 1];\n\n      for (var j = 0; j < i; j++) {\n        d[j] = a[j * order + i - 1];\n        a[j * order + i] = 0.0;\n        a[i * order + j] = 0.0;\n      }\n    } else {\n      // Generate Householder vector.\n      for (var k = 0; k < i; k++) {\n        d[k] /= scale;\n        h += d[k] * d[k];\n      }\n\n      var f = d[i - 1];\n      var g = Math.sqrt(h);\n\n      if (f > 0) {\n        g = -g;\n      }\n\n      e[i] = scale * g;\n      h = h - f * g;\n      d[i - 1] = f - g;\n\n      for (var j = 0; j < i; j++) {\n        e[j] = 0.0;\n      } // Apply similarity transformation to remaining columns.\n\n\n      for (var j = 0; j < i; j++) {\n        f = d[j];\n        a[i * order + j] = f;\n        g = e[j] + a[j * order + j] * f;\n\n        for (var k = j + 1; k <= i - 1; k++) {\n          g += a[j * order + k] * d[k];\n          e[k] += a[j * order + k] * f;\n        }\n\n        e[j] = g;\n      }\n\n      f = 0.0;\n\n      for (var j = 0; j < i; j++) {\n        e[j] /= h;\n        f += e[j] * d[j];\n      }\n\n      var hh = f / (h + h);\n\n      for (var j = 0; j < i; j++) {\n        e[j] -= hh * d[j];\n      }\n\n      for (var j = 0; j < i; j++) {\n        f = d[j];\n        g = e[j];\n\n        for (var k = j; k <= i - 1; k++) {\n          a[j * order + k] -= f * e[k] + g * d[k];\n        }\n\n        d[j] = a[j * order + i - 1];\n        a[j * order + i] = 0.0;\n      }\n    }\n\n    d[i] = h;\n  } // Accumulate transformations.\n\n\n  for (var i = 0; i < order - 1; i++) {\n    a[i * order + order - 1] = a[i * order + i];\n    a[i * order + i] = 1.0;\n    var h = d[i + 1];\n\n    if (h !== 0.0) {\n      for (var k = 0; k <= i; k++) {\n        d[k] = a[(i + 1) * order + k] / h;\n      }\n\n      for (var j = 0; j <= i; j++) {\n        var g = 0.0;\n\n        for (var k = 0; k <= i; k++) {\n          g += a[(i + 1) * order + k] * a[j * order + k];\n        }\n\n        for (var k = 0; k <= i; k++) {\n          a[j * order + k] -= g * d[k];\n        }\n      }\n    }\n\n    for (var k = 0; k <= i; k++) {\n      a[(i + 1) * order + k] = 0.0;\n    }\n  }\n\n  for (var j = 0; j < order; j++) {\n    d[j] = a[j * order + order - 1];\n    a[j * order + order - 1] = 0.0;\n  }\n\n  a[order * order - 1] = 1.0;\n  e[0] = 0.0;\n}\n\nfunction symmetricDiagonalize(a, d, e, order) {\n  var maxiter = 1000;\n\n  for (var i = 1; i < order; i++) {\n    e[i - 1] = e[i];\n  }\n\n  e[order - 1] = 0.0;\n  var f = 0.0;\n  var tst1 = 0.0;\n  var eps = Math.pow(2, -53); // DoubleWidth = 53\n\n  for (var l = 0; l < order; l++) {\n    // Find small subdiagonal element\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n    var m = l;\n\n    while (m < order) {\n      if (Math.abs(e[m]) <= eps * tst1) {\n        break;\n      }\n\n      m++;\n    } // If m == l, d[l] is an eigenvalue,\n    // otherwise, iterate.\n\n\n    if (m > l) {\n      var iter = 0;\n\n      do {\n        iter = iter + 1; // (Could check iteration count here.)\n        // Compute implicit shift\n\n        var g = d[l];\n        var p = (d[l + 1] - g) / (2.0 * e[l]);\n        var r = hypotenuse(p, 1.0);\n\n        if (p < 0) {\n          r = -r;\n        }\n\n        d[l] = e[l] / (p + r);\n        d[l + 1] = e[l] * (p + r);\n        var dl1 = d[l + 1];\n        var h = g - d[l];\n\n        for (var i = l + 2; i < order; i++) {\n          d[i] -= h;\n        }\n\n        f = f + h; // Implicit QL transformation.\n\n        p = d[m];\n        var c = 1.0;\n        var c2 = c;\n        var c3 = c;\n        var el1 = e[l + 1];\n        var s = 0.0;\n        var s2 = 0.0;\n\n        for (var i = m - 1; i >= l; i--) {\n          c3 = c2;\n          c2 = c;\n          s2 = s;\n          g = c * e[i];\n          h = c * p;\n          r = hypotenuse(p, e[i]);\n          e[i + 1] = s * r;\n          s = e[i] / r;\n          c = p / r;\n          p = c * d[i] - s * g;\n          d[i + 1] = h + s * (c * g + s * d[i]); // Accumulate transformation.\n\n          for (var k = 0; k < order; k++) {\n            h = a[(i + 1) * order + k];\n            a[(i + 1) * order + k] = s * a[i * order + k] + c * h;\n            a[i * order + k] = c * a[i * order + k] - s * h;\n          }\n        }\n\n        p = -s * s2 * c3 * el1 * e[l] / dl1;\n        e[l] = s * p;\n        d[l] = c * p; // Check for convergence. If too many iterations have been performed,\n        // throw exception that Convergence Failed\n\n        if (iter >= maxiter) {\n          throw new Error('SVD: Not converging.');\n        }\n      } while (Math.abs(e[l]) > eps * tst1);\n    }\n\n    d[l] = d[l] + f;\n    e[l] = 0.0;\n  } // Sort eigenvalues and corresponding vectors.\n\n\n  for (var i = 0; i < order - 1; i++) {\n    var k = i;\n    var p = d[i];\n\n    for (var j = i + 1; j < order; j++) {\n      if (d[j] < p) {\n        k = j;\n        p = d[j];\n      }\n    }\n\n    if (k !== i) {\n      d[k] = d[i];\n      d[i] = p;\n\n      for (var j = 0; j < order; j++) {\n        p = a[i * order + j];\n        a[i * order + j] = a[k * order + j];\n        a[k * order + j] = p;\n      }\n    }\n  }\n}\n\nfunction hypotenuse(a, b) {\n  if (Math.abs(a) > Math.abs(b)) {\n    var r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n\n  if (b !== 0.0) {\n    var r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n\n  return 0.0;\n}","map":{"version":3,"sources":["../../../../src/mol-math/linear-algebra/matrix/evd.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Matrix } from './matrix';\r\nexport var EVD;\r\n(function (EVD) {\r\n    function createCache(size) {\r\n        return {\r\n            size: size,\r\n            matrix: Matrix.create(size, size),\r\n            eigenValues: new Float64Array(size),\r\n            D: new Float64Array(size),\r\n            E: new Float64Array(size)\r\n        };\r\n    }\r\n    EVD.createCache = createCache;\r\n    /**\r\n     * Computes EVD and stores the result in the cache.\r\n     */\r\n    function compute(cache) {\r\n        symmetricEigenDecomp(cache.size, cache.matrix.data, cache.eigenValues, cache.D, cache.E);\r\n    }\r\n    EVD.compute = compute;\r\n})(EVD || (EVD = {}));\r\n// The EVD code has been adapted from Math.NET, MIT license, Copyright (c) 2002-2015 Math.NET\r\n//\r\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\r\n// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\r\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\r\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\nfunction symmetricEigenDecomp(order, matrixEv, vectorEv, d, e) {\r\n    for (var i = 0; i < order; i++) {\r\n        e[i] = 0.0;\r\n    }\r\n    var om1 = order - 1;\r\n    for (var i = 0; i < order; i++) {\r\n        d[i] = matrixEv[i * order + om1];\r\n    }\r\n    symmetricTridiagonalize(matrixEv, d, e, order);\r\n    symmetricDiagonalize(matrixEv, d, e, order);\r\n    for (var i = 0; i < order; i++) {\r\n        vectorEv[i] = d[i];\r\n    }\r\n}\r\nfunction symmetricTridiagonalize(a, d, e, order) {\r\n    // Householder reduction to tridiagonal form.\r\n    for (var i = order - 1; i > 0; i--) {\r\n        // Scale to avoid under/overflow.\r\n        var scale = 0.0;\r\n        var h = 0.0;\r\n        for (var k = 0; k < i; k++) {\r\n            scale = scale + Math.abs(d[k]);\r\n        }\r\n        if (scale === 0.0) {\r\n            e[i] = d[i - 1];\r\n            for (var j = 0; j < i; j++) {\r\n                d[j] = a[(j * order) + i - 1];\r\n                a[(j * order) + i] = 0.0;\r\n                a[(i * order) + j] = 0.0;\r\n            }\r\n        }\r\n        else {\r\n            // Generate Householder vector.\r\n            for (var k = 0; k < i; k++) {\r\n                d[k] /= scale;\r\n                h += d[k] * d[k];\r\n            }\r\n            var f = d[i - 1];\r\n            var g = Math.sqrt(h);\r\n            if (f > 0) {\r\n                g = -g;\r\n            }\r\n            e[i] = scale * g;\r\n            h = h - (f * g);\r\n            d[i - 1] = f - g;\r\n            for (var j = 0; j < i; j++) {\r\n                e[j] = 0.0;\r\n            }\r\n            // Apply similarity transformation to remaining columns.\r\n            for (var j = 0; j < i; j++) {\r\n                f = d[j];\r\n                a[(i * order) + j] = f;\r\n                g = e[j] + (a[(j * order) + j] * f);\r\n                for (var k = j + 1; k <= i - 1; k++) {\r\n                    g += a[(j * order) + k] * d[k];\r\n                    e[k] += a[(j * order) + k] * f;\r\n                }\r\n                e[j] = g;\r\n            }\r\n            f = 0.0;\r\n            for (var j = 0; j < i; j++) {\r\n                e[j] /= h;\r\n                f += e[j] * d[j];\r\n            }\r\n            var hh = f / (h + h);\r\n            for (var j = 0; j < i; j++) {\r\n                e[j] -= hh * d[j];\r\n            }\r\n            for (var j = 0; j < i; j++) {\r\n                f = d[j];\r\n                g = e[j];\r\n                for (var k = j; k <= i - 1; k++) {\r\n                    a[(j * order) + k] -= (f * e[k]) + (g * d[k]);\r\n                }\r\n                d[j] = a[(j * order) + i - 1];\r\n                a[(j * order) + i] = 0.0;\r\n            }\r\n        }\r\n        d[i] = h;\r\n    }\r\n    // Accumulate transformations.\r\n    for (var i = 0; i < order - 1; i++) {\r\n        a[(i * order) + order - 1] = a[(i * order) + i];\r\n        a[(i * order) + i] = 1.0;\r\n        var h = d[i + 1];\r\n        if (h !== 0.0) {\r\n            for (var k = 0; k <= i; k++) {\r\n                d[k] = a[((i + 1) * order) + k] / h;\r\n            }\r\n            for (var j = 0; j <= i; j++) {\r\n                var g = 0.0;\r\n                for (var k = 0; k <= i; k++) {\r\n                    g += a[((i + 1) * order) + k] * a[(j * order) + k];\r\n                }\r\n                for (var k = 0; k <= i; k++) {\r\n                    a[(j * order) + k] -= g * d[k];\r\n                }\r\n            }\r\n        }\r\n        for (var k = 0; k <= i; k++) {\r\n            a[((i + 1) * order) + k] = 0.0;\r\n        }\r\n    }\r\n    for (var j = 0; j < order; j++) {\r\n        d[j] = a[(j * order) + order - 1];\r\n        a[(j * order) + order - 1] = 0.0;\r\n    }\r\n    a[(order * order) - 1] = 1.0;\r\n    e[0] = 0.0;\r\n}\r\nfunction symmetricDiagonalize(a, d, e, order) {\r\n    var maxiter = 1000;\r\n    for (var i = 1; i < order; i++) {\r\n        e[i - 1] = e[i];\r\n    }\r\n    e[order - 1] = 0.0;\r\n    var f = 0.0;\r\n    var tst1 = 0.0;\r\n    var eps = Math.pow(2, -53); // DoubleWidth = 53\r\n    for (var l = 0; l < order; l++) {\r\n        // Find small subdiagonal element\r\n        tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\r\n        var m = l;\r\n        while (m < order) {\r\n            if (Math.abs(e[m]) <= eps * tst1) {\r\n                break;\r\n            }\r\n            m++;\r\n        }\r\n        // If m == l, d[l] is an eigenvalue,\r\n        // otherwise, iterate.\r\n        if (m > l) {\r\n            var iter = 0;\r\n            do {\r\n                iter = iter + 1; // (Could check iteration count here.)\r\n                // Compute implicit shift\r\n                var g = d[l];\r\n                var p = (d[l + 1] - g) / (2.0 * e[l]);\r\n                var r = hypotenuse(p, 1.0);\r\n                if (p < 0) {\r\n                    r = -r;\r\n                }\r\n                d[l] = e[l] / (p + r);\r\n                d[l + 1] = e[l] * (p + r);\r\n                var dl1 = d[l + 1];\r\n                var h = g - d[l];\r\n                for (var i = l + 2; i < order; i++) {\r\n                    d[i] -= h;\r\n                }\r\n                f = f + h;\r\n                // Implicit QL transformation.\r\n                p = d[m];\r\n                var c = 1.0;\r\n                var c2 = c;\r\n                var c3 = c;\r\n                var el1 = e[l + 1];\r\n                var s = 0.0;\r\n                var s2 = 0.0;\r\n                for (var i = m - 1; i >= l; i--) {\r\n                    c3 = c2;\r\n                    c2 = c;\r\n                    s2 = s;\r\n                    g = c * e[i];\r\n                    h = c * p;\r\n                    r = hypotenuse(p, e[i]);\r\n                    e[i + 1] = s * r;\r\n                    s = e[i] / r;\r\n                    c = p / r;\r\n                    p = (c * d[i]) - (s * g);\r\n                    d[i + 1] = h + (s * ((c * g) + (s * d[i])));\r\n                    // Accumulate transformation.\r\n                    for (var k = 0; k < order; k++) {\r\n                        h = a[((i + 1) * order) + k];\r\n                        a[((i + 1) * order) + k] = (s * a[(i * order) + k]) + (c * h);\r\n                        a[(i * order) + k] = (c * a[(i * order) + k]) - (s * h);\r\n                    }\r\n                }\r\n                p = (-s) * s2 * c3 * el1 * e[l] / dl1;\r\n                e[l] = s * p;\r\n                d[l] = c * p;\r\n                // Check for convergence. If too many iterations have been performed,\r\n                // throw exception that Convergence Failed\r\n                if (iter >= maxiter) {\r\n                    throw new Error('SVD: Not converging.');\r\n                }\r\n            } while (Math.abs(e[l]) > eps * tst1);\r\n        }\r\n        d[l] = d[l] + f;\r\n        e[l] = 0.0;\r\n    }\r\n    // Sort eigenvalues and corresponding vectors.\r\n    for (var i = 0; i < order - 1; i++) {\r\n        var k = i;\r\n        var p = d[i];\r\n        for (var j = i + 1; j < order; j++) {\r\n            if (d[j] < p) {\r\n                k = j;\r\n                p = d[j];\r\n            }\r\n        }\r\n        if (k !== i) {\r\n            d[k] = d[i];\r\n            d[i] = p;\r\n            for (var j = 0; j < order; j++) {\r\n                p = a[(i * order) + j];\r\n                a[(i * order) + j] = a[(k * order) + j];\r\n                a[(k * order) + j] = p;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction hypotenuse(a, b) {\r\n    if (Math.abs(a) > Math.abs(b)) {\r\n        var r = b / a;\r\n        return Math.abs(a) * Math.sqrt(1 + (r * r));\r\n    }\r\n    if (b !== 0.0) {\r\n        var r = a / b;\r\n        return Math.abs(b) * Math.sqrt(1 + (r * r));\r\n    }\r\n    return 0.0;\r\n}\r\n//# sourceMappingURL=evd.js.map"]},"metadata":{},"sourceType":"module"}