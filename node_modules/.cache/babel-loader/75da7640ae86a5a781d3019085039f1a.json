{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __assign } from \"tslib\";\nimport { StateTransform } from './transform';\nimport { ParamDefinition as PD } from '../mol-util/param-definition';\nimport { StateAction } from './action';\nimport { capitalize } from '../mol-util/string';\nexport { Transformer as StateTransformer };\nvar Transformer;\n\n(function (Transformer) {\n  function getParamDefinition(t, a, globalCtx) {\n    return t.definition.params ? t.definition.params(a, globalCtx) : {};\n  }\n\n  Transformer.getParamDefinition = getParamDefinition;\n\n  function is(obj) {\n    return !!obj && typeof obj.toAction === 'function' && typeof obj.apply === 'function';\n  }\n\n  Transformer.is = is;\n  var UpdateResult;\n\n  (function (UpdateResult) {\n    UpdateResult[UpdateResult[\"Unchanged\"] = 0] = \"Unchanged\";\n    UpdateResult[UpdateResult[\"Updated\"] = 1] = \"Updated\";\n    UpdateResult[UpdateResult[\"Recreate\"] = 2] = \"Recreate\";\n    UpdateResult[UpdateResult[\"Null\"] = 3] = \"Null\";\n  })(UpdateResult = Transformer.UpdateResult || (Transformer.UpdateResult = {}));\n\n  var registry = new Map();\n  var fromTypeIndex = new Map();\n\n  function _index(tr) {\n    for (var _i = 0, _a = tr.definition.from; _i < _a.length; _i++) {\n      var t = _a[_i];\n\n      if (fromTypeIndex.has(t.type)) {\n        fromTypeIndex.get(t.type).push(tr);\n      } else {\n        fromTypeIndex.set(t.type, [tr]);\n      }\n    }\n  }\n\n  function getAll() {\n    return Array.from(registry.values());\n  }\n\n  Transformer.getAll = getAll;\n\n  function get(id) {\n    var t = registry.get(id);\n\n    if (!t) {\n      throw new Error(\"A transformer with signature '\" + id + \"' is not registered.\");\n    }\n\n    return t;\n  }\n\n  Transformer.get = get;\n\n  function fromType(type) {\n    return fromTypeIndex.get(type) || [];\n  }\n\n  Transformer.fromType = fromType;\n\n  function create(namespace, definition) {\n    var name = definition.name;\n    var id = namespace + \".\" + name;\n\n    if (registry.has(id)) {\n      throw new Error(\"A transform with id '\" + name + \"' is already registered. Please pick a unique identifier for your transforms and/or register them only once. This is to ensure that transforms can be serialized and replayed.\");\n    }\n\n    var t = {\n      apply: function (parent, params, props) {\n        return StateTransform.create(parent, t, params, props);\n      },\n      toAction: function () {\n        return StateAction.fromTransformer(t);\n      },\n      namespace: namespace,\n      id: id,\n      definition: definition,\n      createDefaultParams: function (a, globalCtx) {\n        return definition.params ? PD.getDefaultValues(definition.params(a, globalCtx)) : {};\n      }\n    };\n    registry.set(id, t);\n\n    _index(t);\n\n    return t;\n  }\n\n  Transformer.create = create;\n\n  function factory(namespace) {\n    return function (definition) {\n      return create(namespace, definition);\n    };\n  }\n\n  Transformer.factory = factory;\n\n  function builderFactory(namespace) {\n    return Builder.build(namespace);\n  }\n\n  Transformer.builderFactory = builderFactory;\n  var Builder;\n\n  (function (Builder) {\n    function root(namespace, info) {\n      return function (def) {\n        return create(namespace, __assign({\n          name: info.name,\n          from: info.from instanceof Array ? info.from : [info.from],\n          to: info.to instanceof Array ? info.to : [info.to],\n          display: typeof info.display === 'string' ? {\n            name: info.display\n          } : !!info.display ? info.display : {\n            name: capitalize(info.name.replace(/[-]/g, ' '))\n          },\n          params: typeof info.params === 'object' ? function () {\n            return info.params;\n          } : !!info.params ? info.params : void 0,\n          isDecorator: info.isDecorator\n        }, def));\n      };\n    }\n\n    function build(namespace) {\n      return function (info) {\n        return root(namespace, info);\n      };\n    }\n\n    Builder.build = build;\n  })(Builder = Transformer.Builder || (Transformer.Builder = {}));\n\n  function build(namespace) {\n    return Builder.build(namespace);\n  }\n\n  Transformer.build = build;\n  Transformer.ROOT = create('build-in', {\n    name: 'root',\n    from: [],\n    to: [],\n    display: {\n      name: 'Root',\n      description: 'For internal use.'\n    },\n    apply: function () {\n      throw new Error('should never be applied');\n    },\n    update: function () {\n      return UpdateResult.Unchanged;\n    }\n  });\n})(Transformer || (Transformer = {}));","map":{"version":3,"sources":["../../src/mol-state/transformer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { StateTransform } from './transform';\r\nimport { ParamDefinition as PD } from '../mol-util/param-definition';\r\nimport { StateAction } from './action';\r\nimport { capitalize } from '../mol-util/string';\r\nexport { Transformer as StateTransformer };\r\nvar Transformer;\r\n(function (Transformer) {\r\n    function getParamDefinition(t, a, globalCtx) {\r\n        return t.definition.params ? t.definition.params(a, globalCtx) : {};\r\n    }\r\n    Transformer.getParamDefinition = getParamDefinition;\r\n    function is(obj) {\r\n        return !!obj && typeof obj.toAction === 'function' && typeof obj.apply === 'function';\r\n    }\r\n    Transformer.is = is;\r\n    var UpdateResult;\r\n    (function (UpdateResult) {\r\n        UpdateResult[UpdateResult[\"Unchanged\"] = 0] = \"Unchanged\";\r\n        UpdateResult[UpdateResult[\"Updated\"] = 1] = \"Updated\";\r\n        UpdateResult[UpdateResult[\"Recreate\"] = 2] = \"Recreate\";\r\n        UpdateResult[UpdateResult[\"Null\"] = 3] = \"Null\";\r\n    })(UpdateResult = Transformer.UpdateResult || (Transformer.UpdateResult = {}));\r\n    var registry = new Map();\r\n    var fromTypeIndex = new Map();\r\n    function _index(tr) {\r\n        for (var _i = 0, _a = tr.definition.from; _i < _a.length; _i++) {\r\n            var t = _a[_i];\r\n            if (fromTypeIndex.has(t.type)) {\r\n                fromTypeIndex.get(t.type).push(tr);\r\n            }\r\n            else {\r\n                fromTypeIndex.set(t.type, [tr]);\r\n            }\r\n        }\r\n    }\r\n    function getAll() {\r\n        return Array.from(registry.values());\r\n    }\r\n    Transformer.getAll = getAll;\r\n    function get(id) {\r\n        var t = registry.get(id);\r\n        if (!t) {\r\n            throw new Error(\"A transformer with signature '\" + id + \"' is not registered.\");\r\n        }\r\n        return t;\r\n    }\r\n    Transformer.get = get;\r\n    function fromType(type) {\r\n        return fromTypeIndex.get(type) || [];\r\n    }\r\n    Transformer.fromType = fromType;\r\n    function create(namespace, definition) {\r\n        var name = definition.name;\r\n        var id = namespace + \".\" + name;\r\n        if (registry.has(id)) {\r\n            throw new Error(\"A transform with id '\" + name + \"' is already registered. Please pick a unique identifier for your transforms and/or register them only once. This is to ensure that transforms can be serialized and replayed.\");\r\n        }\r\n        var t = {\r\n            apply: function (parent, params, props) { return StateTransform.create(parent, t, params, props); },\r\n            toAction: function () { return StateAction.fromTransformer(t); },\r\n            namespace: namespace,\r\n            id: id,\r\n            definition: definition,\r\n            createDefaultParams: function (a, globalCtx) { return definition.params ? PD.getDefaultValues(definition.params(a, globalCtx)) : {}; }\r\n        };\r\n        registry.set(id, t);\r\n        _index(t);\r\n        return t;\r\n    }\r\n    Transformer.create = create;\r\n    function factory(namespace) {\r\n        return function (definition) { return create(namespace, definition); };\r\n    }\r\n    Transformer.factory = factory;\r\n    function builderFactory(namespace) {\r\n        return Builder.build(namespace);\r\n    }\r\n    Transformer.builderFactory = builderFactory;\r\n    var Builder;\r\n    (function (Builder) {\r\n        function root(namespace, info) {\r\n            return function (def) { return create(namespace, __assign({ name: info.name, from: info.from instanceof Array ? info.from : [info.from], to: info.to instanceof Array ? info.to : [info.to], display: typeof info.display === 'string'\r\n                    ? { name: info.display }\r\n                    : !!info.display\r\n                        ? info.display\r\n                        : { name: capitalize(info.name.replace(/[-]/g, ' ')) }, params: typeof info.params === 'object'\r\n                    ? function () { return info.params; }\r\n                    : !!info.params\r\n                        ? info.params\r\n                        : void 0, isDecorator: info.isDecorator }, def)); };\r\n        }\r\n        function build(namespace) {\r\n            return function (info) { return root(namespace, info); };\r\n        }\r\n        Builder.build = build;\r\n    })(Builder = Transformer.Builder || (Transformer.Builder = {}));\r\n    function build(namespace) {\r\n        return Builder.build(namespace);\r\n    }\r\n    Transformer.build = build;\r\n    Transformer.ROOT = create('build-in', {\r\n        name: 'root',\r\n        from: [],\r\n        to: [],\r\n        display: { name: 'Root', description: 'For internal use.' },\r\n        apply: function () { throw new Error('should never be applied'); },\r\n        update: function () { return UpdateResult.Unchanged; }\r\n    });\r\n})(Transformer || (Transformer = {}));\r\n//# sourceMappingURL=transformer.js.map"]},"metadata":{},"sourceType":"module"}