{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <fred.ludlow@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * ported from NGL (https://github.com/arose/ngl), licensed under MIT\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Vec3, Tensor } from '../../mol-math/linear-algebra';\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\nimport { OrderedSet } from '../../mol-data/int';\nimport { Mat4 } from '../../mol-math/linear-algebra/3d/mat4';\nimport { Box3D, GridLookup3D, fillGridDim } from '../../mol-math/geometry';\nimport { BaseGeometry } from '../../mol-geo/geometry/base';\n\nfunction normalToLine(out, p) {\n  out[0] = out[1] = out[2] = 1.0;\n\n  if (p[0] !== 0) {\n    out[0] = (p[1] + p[2]) / -p[0];\n  } else if (p[1] !== 0) {\n    out[1] = (p[0] + p[2]) / -p[1];\n  } else if (p[2] !== 0) {\n    out[2] = (p[0] + p[1]) / -p[2];\n  }\n\n  return out;\n}\n\nfunction getAngleTables(probePositions) {\n  var theta = 0.0;\n  var step = 2 * Math.PI / probePositions;\n  var cosTable = new Float32Array(probePositions);\n  var sinTable = new Float32Array(probePositions);\n\n  for (var i = 0; i < probePositions; i++) {\n    cosTable[i] = Math.cos(theta);\n    sinTable[i] = Math.sin(theta);\n    theta += step;\n  }\n\n  return {\n    cosTable: cosTable,\n    sinTable: sinTable\n  };\n} //\n\n\nexport var MolecularSurfaceCalculationParams = {\n  probeRadius: PD.Numeric(1.4, {\n    min: 0,\n    max: 10,\n    step: 0.1\n  }, {\n    description: 'Radius of the probe tracing the molecular surface.'\n  }),\n  resolution: PD.Numeric(0.5, {\n    min: 0.01,\n    max: 20,\n    step: 0.01\n  }, __assign({\n    description: 'Grid resolution/cell spacing.'\n  }, BaseGeometry.CustomQualityParamInfo)),\n  probePositions: PD.Numeric(36, {\n    min: 12,\n    max: 90,\n    step: 1\n  }, __assign({\n    description: 'Number of positions tested for probe target intersection.'\n  }, BaseGeometry.CustomQualityParamInfo))\n};\nexport var DefaultMolecularSurfaceCalculationProps = PD.getDefaultValues(MolecularSurfaceCalculationParams);\nexport function calcMolecularSurface(ctx, position, boundary, maxRadius, box, props) {\n  return __awaiter(this, void 0, void 0, function () {\n    /**\r\n     * Is the point at x,y,z obscured by any of the atoms specifeid by indices in neighbours.\r\n     * Ignore indices a and b (these are the relevant atoms in projectPoints/Torii)\r\n     *\r\n     * Cache the last clipped atom (as very often the same one in subsequent calls)\r\n     *\r\n     * `a` and `b` must be resolved indices\r\n     */\n    function obscured(x, y, z, a, b) {\n      if (lastClip !== -1) {\n        var ai = lastClip;\n\n        if (ai !== a && ai !== b && singleAtomObscures(ai, x, y, z)) {\n          return ai;\n        } else {\n          lastClip = -1;\n        }\n      }\n\n      for (var j = 0, jl = neighbours.count; j < jl; ++j) {\n        var ai = OrderedSet.getAt(indices, neighbours.indices[j]);\n\n        if (ai !== a && ai !== b && singleAtomObscures(ai, x, y, z)) {\n          lastClip = ai;\n          return ai;\n        }\n      }\n\n      return -1;\n    }\n    /**\r\n     * `ai` must be a resolved index\r\n     */\n\n\n    function singleAtomObscures(ai, x, y, z) {\n      var r = radius[ai];\n      var dx = px[ai] - x;\n      var dy = py[ai] - y;\n      var dz = pz[ai] - z;\n      var dSq = dx * dx + dy * dy + dz * dz;\n      return dSq < r * r;\n    }\n    /**\r\n     * For each atom:\r\n     *     Iterate over a subsection of the grid, for each point:\r\n     *         If current value < 0.0, unvisited, set positive\r\n     *\r\n     *         In any case: Project this point onto surface of the atomic sphere\r\n     *         If this projected point is not obscured by any other atom\r\n     *             Calculate delta distance and set grid value to minimum of\r\n     *             itself and delta\r\n     */\n\n\n    function projectPointsRange(begI, endI) {\n      for (var i = begI; i < endI; ++i) {\n        var j = OrderedSet.getAt(indices, i);\n        var vx = px[j],\n            vy = py[j],\n            vz = pz[j];\n        var rad = radius[j];\n        var rSq = rad * rad;\n        lookup3d.find(vx, vy, vz, rad); // Number of grid points, round this up...\n\n        var ng = Math.ceil(rad * scaleFactor); // Center of the atom, mapped to grid points (take floor)\n\n        var iax = Math.floor(scaleFactor * (vx - minX));\n        var iay = Math.floor(scaleFactor * (vy - minY));\n        var iaz = Math.floor(scaleFactor * (vz - minZ)); // Extents of grid to consider for this atom\n\n        var begX = Math.max(0, iax - ng);\n        var begY = Math.max(0, iay - ng);\n        var begZ = Math.max(0, iaz - ng); // Add two to these points:\n        // - iax are floor'd values so this ensures coverage\n        // - these are loop limits (exclusive)\n\n        var endX = Math.min(dimX, iax + ng + 2);\n        var endY = Math.min(dimY, iay + ng + 2);\n        var endZ = Math.min(dimZ, iaz + ng + 2);\n\n        for (var xi = begX; xi < endX; ++xi) {\n          var dx = gridx[xi] - vx;\n          var xIdx = xi * iuv;\n\n          for (var yi = begY; yi < endY; ++yi) {\n            var dy = gridy[yi] - vy;\n            var dxySq = dx * dx + dy * dy;\n            var xyIdx = yi * iu + xIdx;\n\n            for (var zi = begZ; zi < endZ; ++zi) {\n              var dz = gridz[zi] - vz;\n              var dSq = dxySq + dz * dz;\n\n              if (dSq < rSq) {\n                var idx = zi + xyIdx; // if unvisited, make positive\n\n                if (data[idx] < 0.0) data[idx] *= -1; // Project on to the surface of the sphere\n                // sp is the projected point ( dx, dy, dz ) * ( ra / d )\n\n                var d = Math.sqrt(dSq);\n                var ap = rad / d;\n                var spx = dx * ap + vx;\n                var spy = dy * ap + vy;\n                var spz = dz * ap + vz;\n\n                if (obscured(spx, spy, spz, j, -1) === -1) {\n                  var dd = rad - d;\n\n                  if (dd < data[idx]) {\n                    data[idx] = dd;\n                    idData[idx] = id[i];\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function projectPoints() {\n      return __awaiter(this, void 0, void 0, function () {\n        var i;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              i = 0;\n              _a.label = 1;\n\n            case 1:\n              if (!(i < n)) return [3\n              /*break*/\n              , 4];\n              projectPointsRange(i, Math.min(i + updateChunk, n));\n              if (!ctx.shouldUpdate) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , ctx.update({\n                message: 'projecting points',\n                current: i,\n                max: n\n              })];\n\n            case 2:\n              _a.sent();\n\n              _a.label = 3;\n\n            case 3:\n              i += updateChunk;\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n    /**\r\n     * `a` and `b` must be resolved indices\r\n     */\n\n\n    function projectTorus(a, b) {\n      var rA = radius[a];\n      var rB = radius[b];\n      var dx = atob[0] = px[b] - px[a];\n      var dy = atob[1] = py[b] - py[a];\n      var dz = atob[2] = pz[b] - pz[a];\n      var dSq = dx * dx + dy * dy + dz * dz; // This check now redundant as already done in AVHash.withinRadii\n      // if (dSq > ((rA + rB) * (rA + rB))) { return }\n\n      var d = Math.sqrt(dSq); // Find angle between a->b vector and the circle\n      // of their intersection by cosine rule\n\n      var cosA = (rA * rA + d * d - rB * rB) / (2.0 * rA * d); // distance along a->b at intersection\n\n      var dmp = rA * cosA;\n      Vec3.normalize(atob, atob); // Create normal to line\n\n      normalToLine(n1, atob);\n      Vec3.normalize(n1, n1); // Cross together for second normal vector\n\n      Vec3.cross(n2, atob, n1);\n      Vec3.normalize(n2, n2); // r is radius of circle of intersection\n\n      var rInt = Math.sqrt(rA * rA - dmp * dmp);\n      Vec3.scale(n1, n1, rInt);\n      Vec3.scale(n2, n2, rInt);\n      Vec3.scale(atob, atob, dmp);\n      mid[0] = atob[0] + px[a];\n      mid[1] = atob[1] + py[a];\n      mid[2] = atob[2] + pz[a];\n      lastClip = -1;\n\n      for (var i = 0; i < probePositions; ++i) {\n        var cost = cosTable[i];\n        var sint = sinTable[i];\n        var px_1 = mid[0] + cost * n1[0] + sint * n2[0];\n        var py_1 = mid[1] + cost * n1[1] + sint * n2[1];\n        var pz_1 = mid[2] + cost * n1[2] + sint * n2[2];\n\n        if (obscured(px_1, py_1, pz_1, a, b) === -1) {\n          var iax = Math.floor(scaleFactor * (px_1 - minX));\n          var iay = Math.floor(scaleFactor * (py_1 - minY));\n          var iaz = Math.floor(scaleFactor * (pz_1 - minZ));\n          var begX = Math.max(0, iax - ngTorus);\n          var begY = Math.max(0, iay - ngTorus);\n          var begZ = Math.max(0, iaz - ngTorus);\n          var endX = Math.min(dimX, iax + ngTorus + 2);\n          var endY = Math.min(dimY, iay + ngTorus + 2);\n          var endZ = Math.min(dimZ, iaz + ngTorus + 2);\n\n          for (var xi = begX; xi < endX; ++xi) {\n            var dx_1 = px_1 - gridx[xi];\n            var xIdx = xi * iuv;\n\n            for (var yi = begY; yi < endY; ++yi) {\n              var dy_1 = py_1 - gridy[yi];\n              var dxySq = dx_1 * dx_1 + dy_1 * dy_1;\n              var xyIdx = yi * iu + xIdx;\n\n              for (var zi = begZ; zi < endZ; ++zi) {\n                var dz_1 = pz_1 - gridz[zi];\n                var dSq_1 = dxySq + dz_1 * dz_1;\n                var idx = zi + xyIdx;\n                var current = data[idx];\n\n                if (current > 0.0 && dSq_1 < current * current) {\n                  data[idx] = Math.sqrt(dSq_1); // Is this grid point closer to a or b?\n                  // Take dot product of atob and gridpoint->p (dx, dy, dz)\n\n                  var dp = dx_1 * atob[0] + dy_1 * atob[1] + dz_1 * atob[2];\n                  idData[idx] = id[OrderedSet.indexOf(indices, dp < 0.0 ? b : a)];\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    function projectToriiRange(begI, endI) {\n      for (var i = begI; i < endI; ++i) {\n        var k = OrderedSet.getAt(indices, i);\n        lookup3d.find(px[k], py[k], pz[k], radius[k]);\n\n        for (var j = 0, jl = neighbours.count; j < jl; ++j) {\n          var l = OrderedSet.getAt(indices, neighbours.indices[j]);\n          if (k < l) projectTorus(k, l);\n        }\n      }\n    }\n\n    function projectTorii() {\n      return __awaiter(this, void 0, void 0, function () {\n        var i;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              i = 0;\n              _a.label = 1;\n\n            case 1:\n              if (!(i < n)) return [3\n              /*break*/\n              , 4];\n              projectToriiRange(i, Math.min(i + updateChunk, n));\n              if (!ctx.shouldUpdate) return [3\n              /*break*/\n              , 3];\n              return [4\n              /*yield*/\n              , ctx.update({\n                message: 'projecting torii',\n                current: i,\n                max: n\n              })];\n\n            case 2:\n              _a.sent();\n\n              _a.label = 3;\n\n            case 3:\n              i += updateChunk;\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n\n    var lastClip, atob, mid, n1, n2, resolution, probeRadius, probePositions, scaleFactor, ngTorus, cellSize, lookup3d, neighbours, indices, px, py, pz, id, radius, n, pad, expandedBox, _a, minX, minY, minZ, scaledBox, dim, dimX, dimY, dimZ, iu, iv, iuv, _b, cosTable, sinTable, space, data, idData, gridx, gridy, gridz, updateChunk, field, idField, transform;\n\n    return __generator(this, function (_c) {\n      switch (_c.label) {\n        case 0:\n          lastClip = -1;\n          atob = Vec3();\n          mid = Vec3();\n          n1 = Vec3();\n          n2 = Vec3();\n          resolution = props.resolution, probeRadius = props.probeRadius, probePositions = props.probePositions;\n          scaleFactor = 1 / resolution;\n          ngTorus = Math.max(5, 2 + Math.floor(probeRadius * scaleFactor));\n          cellSize = Vec3.create(maxRadius, maxRadius, maxRadius);\n          Vec3.scale(cellSize, cellSize, 2);\n          lookup3d = GridLookup3D(position, boundary, cellSize);\n          neighbours = lookup3d.result;\n          if (box === null) box = lookup3d.boundary.box;\n          indices = position.indices, px = position.x, py = position.y, pz = position.z, id = position.id, radius = position.radius;\n          n = OrderedSet.size(indices);\n          pad = maxRadius + resolution;\n          expandedBox = Box3D.expand(Box3D(), box, Vec3.create(pad, pad, pad));\n          _a = expandedBox.min, minX = _a[0], minY = _a[1], minZ = _a[2];\n          scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);\n          dim = Box3D.size(Vec3(), scaledBox);\n          Vec3.ceil(dim, dim);\n          dimX = dim[0], dimY = dim[1], dimZ = dim[2];\n          iu = dimZ, iv = dimY, iuv = iu * iv;\n          _b = getAngleTables(probePositions), cosTable = _b.cosTable, sinTable = _b.sinTable;\n          space = Tensor.Space(dim, [0, 1, 2], Float32Array);\n          data = space.create();\n          idData = space.create();\n          data.fill(-1001.0);\n          idData.fill(-1);\n          gridx = fillGridDim(dimX, minX, resolution);\n          gridy = fillGridDim(dimY, minY, resolution);\n          gridz = fillGridDim(dimZ, minZ, resolution);\n          updateChunk = Math.ceil(100000 / (Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor)); // console.timeEnd('MolecularSurface createState')\n          // console.time('MolecularSurface projectPoints')\n\n          return [4\n          /*yield*/\n          , projectPoints()];\n\n        case 1:\n          // console.timeEnd('MolecularSurface createState')\n          // console.time('MolecularSurface projectPoints')\n          _c.sent(); // console.timeEnd('MolecularSurface projectPoints')\n          // console.time('MolecularSurface projectTorii')\n\n\n          return [4\n          /*yield*/\n          , projectTorii()];\n\n        case 2:\n          // console.timeEnd('MolecularSurface projectPoints')\n          // console.time('MolecularSurface projectTorii')\n          _c.sent();\n\n          field = Tensor.create(space, data);\n          idField = Tensor.create(space, idData);\n          transform = Mat4.identity();\n          Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));\n          Mat4.setTranslation(transform, expandedBox.min); // console.log({ field, idField, transform, updateChunk })\n\n          return [2\n          /*return*/\n          , {\n            field: field,\n            idField: idField,\n            transform: transform,\n            resolution: resolution\n          }];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/mol-math/geometry/molecular-surface.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Fred Ludlow <fred.ludlow@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * ported from NGL (https://github.com/arose/ngl), licensed under MIT\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Vec3, Tensor } from '../../mol-math/linear-algebra';\r\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\r\nimport { OrderedSet } from '../../mol-data/int';\r\nimport { Mat4 } from '../../mol-math/linear-algebra/3d/mat4';\r\nimport { Box3D, GridLookup3D, fillGridDim } from '../../mol-math/geometry';\r\nimport { BaseGeometry } from '../../mol-geo/geometry/base';\r\nfunction normalToLine(out, p) {\r\n    out[0] = out[1] = out[2] = 1.0;\r\n    if (p[0] !== 0) {\r\n        out[0] = (p[1] + p[2]) / -p[0];\r\n    }\r\n    else if (p[1] !== 0) {\r\n        out[1] = (p[0] + p[2]) / -p[1];\r\n    }\r\n    else if (p[2] !== 0) {\r\n        out[2] = (p[0] + p[1]) / -p[2];\r\n    }\r\n    return out;\r\n}\r\nfunction getAngleTables(probePositions) {\r\n    var theta = 0.0;\r\n    var step = 2 * Math.PI / probePositions;\r\n    var cosTable = new Float32Array(probePositions);\r\n    var sinTable = new Float32Array(probePositions);\r\n    for (var i = 0; i < probePositions; i++) {\r\n        cosTable[i] = Math.cos(theta);\r\n        sinTable[i] = Math.sin(theta);\r\n        theta += step;\r\n    }\r\n    return { cosTable: cosTable, sinTable: sinTable };\r\n}\r\n//\r\nexport var MolecularSurfaceCalculationParams = {\r\n    probeRadius: PD.Numeric(1.4, { min: 0, max: 10, step: 0.1 }, { description: 'Radius of the probe tracing the molecular surface.' }),\r\n    resolution: PD.Numeric(0.5, { min: 0.01, max: 20, step: 0.01 }, __assign({ description: 'Grid resolution/cell spacing.' }, BaseGeometry.CustomQualityParamInfo)),\r\n    probePositions: PD.Numeric(36, { min: 12, max: 90, step: 1 }, __assign({ description: 'Number of positions tested for probe target intersection.' }, BaseGeometry.CustomQualityParamInfo)),\r\n};\r\nexport var DefaultMolecularSurfaceCalculationProps = PD.getDefaultValues(MolecularSurfaceCalculationParams);\r\nexport function calcMolecularSurface(ctx, position, boundary, maxRadius, box, props) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        /**\r\n         * Is the point at x,y,z obscured by any of the atoms specifeid by indices in neighbours.\r\n         * Ignore indices a and b (these are the relevant atoms in projectPoints/Torii)\r\n         *\r\n         * Cache the last clipped atom (as very often the same one in subsequent calls)\r\n         *\r\n         * `a` and `b` must be resolved indices\r\n         */\r\n        function obscured(x, y, z, a, b) {\r\n            if (lastClip !== -1) {\r\n                var ai = lastClip;\r\n                if (ai !== a && ai !== b && singleAtomObscures(ai, x, y, z)) {\r\n                    return ai;\r\n                }\r\n                else {\r\n                    lastClip = -1;\r\n                }\r\n            }\r\n            for (var j = 0, jl = neighbours.count; j < jl; ++j) {\r\n                var ai = OrderedSet.getAt(indices, neighbours.indices[j]);\r\n                if (ai !== a && ai !== b && singleAtomObscures(ai, x, y, z)) {\r\n                    lastClip = ai;\r\n                    return ai;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n        /**\r\n         * `ai` must be a resolved index\r\n         */\r\n        function singleAtomObscures(ai, x, y, z) {\r\n            var r = radius[ai];\r\n            var dx = px[ai] - x;\r\n            var dy = py[ai] - y;\r\n            var dz = pz[ai] - z;\r\n            var dSq = dx * dx + dy * dy + dz * dz;\r\n            return dSq < (r * r);\r\n        }\r\n        /**\r\n         * For each atom:\r\n         *     Iterate over a subsection of the grid, for each point:\r\n         *         If current value < 0.0, unvisited, set positive\r\n         *\r\n         *         In any case: Project this point onto surface of the atomic sphere\r\n         *         If this projected point is not obscured by any other atom\r\n         *             Calculate delta distance and set grid value to minimum of\r\n         *             itself and delta\r\n         */\r\n        function projectPointsRange(begI, endI) {\r\n            for (var i = begI; i < endI; ++i) {\r\n                var j = OrderedSet.getAt(indices, i);\r\n                var vx = px[j], vy = py[j], vz = pz[j];\r\n                var rad = radius[j];\r\n                var rSq = rad * rad;\r\n                lookup3d.find(vx, vy, vz, rad);\r\n                // Number of grid points, round this up...\r\n                var ng = Math.ceil(rad * scaleFactor);\r\n                // Center of the atom, mapped to grid points (take floor)\r\n                var iax = Math.floor(scaleFactor * (vx - minX));\r\n                var iay = Math.floor(scaleFactor * (vy - minY));\r\n                var iaz = Math.floor(scaleFactor * (vz - minZ));\r\n                // Extents of grid to consider for this atom\r\n                var begX = Math.max(0, iax - ng);\r\n                var begY = Math.max(0, iay - ng);\r\n                var begZ = Math.max(0, iaz - ng);\r\n                // Add two to these points:\r\n                // - iax are floor'd values so this ensures coverage\r\n                // - these are loop limits (exclusive)\r\n                var endX = Math.min(dimX, iax + ng + 2);\r\n                var endY = Math.min(dimY, iay + ng + 2);\r\n                var endZ = Math.min(dimZ, iaz + ng + 2);\r\n                for (var xi = begX; xi < endX; ++xi) {\r\n                    var dx = gridx[xi] - vx;\r\n                    var xIdx = xi * iuv;\r\n                    for (var yi = begY; yi < endY; ++yi) {\r\n                        var dy = gridy[yi] - vy;\r\n                        var dxySq = dx * dx + dy * dy;\r\n                        var xyIdx = yi * iu + xIdx;\r\n                        for (var zi = begZ; zi < endZ; ++zi) {\r\n                            var dz = gridz[zi] - vz;\r\n                            var dSq = dxySq + dz * dz;\r\n                            if (dSq < rSq) {\r\n                                var idx = zi + xyIdx;\r\n                                // if unvisited, make positive\r\n                                if (data[idx] < 0.0)\r\n                                    data[idx] *= -1;\r\n                                // Project on to the surface of the sphere\r\n                                // sp is the projected point ( dx, dy, dz ) * ( ra / d )\r\n                                var d = Math.sqrt(dSq);\r\n                                var ap = rad / d;\r\n                                var spx = dx * ap + vx;\r\n                                var spy = dy * ap + vy;\r\n                                var spz = dz * ap + vz;\r\n                                if (obscured(spx, spy, spz, j, -1) === -1) {\r\n                                    var dd = rad - d;\r\n                                    if (dd < data[idx]) {\r\n                                        data[idx] = dd;\r\n                                        idData[idx] = id[i];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function projectPoints() {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var i;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            i = 0;\r\n                            _a.label = 1;\r\n                        case 1:\r\n                            if (!(i < n)) return [3 /*break*/, 4];\r\n                            projectPointsRange(i, Math.min(i + updateChunk, n));\r\n                            if (!ctx.shouldUpdate) return [3 /*break*/, 3];\r\n                            return [4 /*yield*/, ctx.update({ message: 'projecting points', current: i, max: n })];\r\n                        case 2:\r\n                            _a.sent();\r\n                            _a.label = 3;\r\n                        case 3:\r\n                            i += updateChunk;\r\n                            return [3 /*break*/, 1];\r\n                        case 4: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        /**\r\n         * `a` and `b` must be resolved indices\r\n         */\r\n        function projectTorus(a, b) {\r\n            var rA = radius[a];\r\n            var rB = radius[b];\r\n            var dx = atob[0] = px[b] - px[a];\r\n            var dy = atob[1] = py[b] - py[a];\r\n            var dz = atob[2] = pz[b] - pz[a];\r\n            var dSq = dx * dx + dy * dy + dz * dz;\r\n            // This check now redundant as already done in AVHash.withinRadii\r\n            // if (dSq > ((rA + rB) * (rA + rB))) { return }\r\n            var d = Math.sqrt(dSq);\r\n            // Find angle between a->b vector and the circle\r\n            // of their intersection by cosine rule\r\n            var cosA = (rA * rA + d * d - rB * rB) / (2.0 * rA * d);\r\n            // distance along a->b at intersection\r\n            var dmp = rA * cosA;\r\n            Vec3.normalize(atob, atob);\r\n            // Create normal to line\r\n            normalToLine(n1, atob);\r\n            Vec3.normalize(n1, n1);\r\n            // Cross together for second normal vector\r\n            Vec3.cross(n2, atob, n1);\r\n            Vec3.normalize(n2, n2);\r\n            // r is radius of circle of intersection\r\n            var rInt = Math.sqrt(rA * rA - dmp * dmp);\r\n            Vec3.scale(n1, n1, rInt);\r\n            Vec3.scale(n2, n2, rInt);\r\n            Vec3.scale(atob, atob, dmp);\r\n            mid[0] = atob[0] + px[a];\r\n            mid[1] = atob[1] + py[a];\r\n            mid[2] = atob[2] + pz[a];\r\n            lastClip = -1;\r\n            for (var i = 0; i < probePositions; ++i) {\r\n                var cost = cosTable[i];\r\n                var sint = sinTable[i];\r\n                var px_1 = mid[0] + cost * n1[0] + sint * n2[0];\r\n                var py_1 = mid[1] + cost * n1[1] + sint * n2[1];\r\n                var pz_1 = mid[2] + cost * n1[2] + sint * n2[2];\r\n                if (obscured(px_1, py_1, pz_1, a, b) === -1) {\r\n                    var iax = Math.floor(scaleFactor * (px_1 - minX));\r\n                    var iay = Math.floor(scaleFactor * (py_1 - minY));\r\n                    var iaz = Math.floor(scaleFactor * (pz_1 - minZ));\r\n                    var begX = Math.max(0, iax - ngTorus);\r\n                    var begY = Math.max(0, iay - ngTorus);\r\n                    var begZ = Math.max(0, iaz - ngTorus);\r\n                    var endX = Math.min(dimX, iax + ngTorus + 2);\r\n                    var endY = Math.min(dimY, iay + ngTorus + 2);\r\n                    var endZ = Math.min(dimZ, iaz + ngTorus + 2);\r\n                    for (var xi = begX; xi < endX; ++xi) {\r\n                        var dx_1 = px_1 - gridx[xi];\r\n                        var xIdx = xi * iuv;\r\n                        for (var yi = begY; yi < endY; ++yi) {\r\n                            var dy_1 = py_1 - gridy[yi];\r\n                            var dxySq = dx_1 * dx_1 + dy_1 * dy_1;\r\n                            var xyIdx = yi * iu + xIdx;\r\n                            for (var zi = begZ; zi < endZ; ++zi) {\r\n                                var dz_1 = pz_1 - gridz[zi];\r\n                                var dSq_1 = dxySq + dz_1 * dz_1;\r\n                                var idx = zi + xyIdx;\r\n                                var current = data[idx];\r\n                                if (current > 0.0 && dSq_1 < (current * current)) {\r\n                                    data[idx] = Math.sqrt(dSq_1);\r\n                                    // Is this grid point closer to a or b?\r\n                                    // Take dot product of atob and gridpoint->p (dx, dy, dz)\r\n                                    var dp = dx_1 * atob[0] + dy_1 * atob[1] + dz_1 * atob[2];\r\n                                    idData[idx] = id[OrderedSet.indexOf(indices, dp < 0.0 ? b : a)];\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function projectToriiRange(begI, endI) {\r\n            for (var i = begI; i < endI; ++i) {\r\n                var k = OrderedSet.getAt(indices, i);\r\n                lookup3d.find(px[k], py[k], pz[k], radius[k]);\r\n                for (var j = 0, jl = neighbours.count; j < jl; ++j) {\r\n                    var l = OrderedSet.getAt(indices, neighbours.indices[j]);\r\n                    if (k < l)\r\n                        projectTorus(k, l);\r\n                }\r\n            }\r\n        }\r\n        function projectTorii() {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var i;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            i = 0;\r\n                            _a.label = 1;\r\n                        case 1:\r\n                            if (!(i < n)) return [3 /*break*/, 4];\r\n                            projectToriiRange(i, Math.min(i + updateChunk, n));\r\n                            if (!ctx.shouldUpdate) return [3 /*break*/, 3];\r\n                            return [4 /*yield*/, ctx.update({ message: 'projecting torii', current: i, max: n })];\r\n                        case 2:\r\n                            _a.sent();\r\n                            _a.label = 3;\r\n                        case 3:\r\n                            i += updateChunk;\r\n                            return [3 /*break*/, 1];\r\n                        case 4: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        var lastClip, atob, mid, n1, n2, resolution, probeRadius, probePositions, scaleFactor, ngTorus, cellSize, lookup3d, neighbours, indices, px, py, pz, id, radius, n, pad, expandedBox, _a, minX, minY, minZ, scaledBox, dim, dimX, dimY, dimZ, iu, iv, iuv, _b, cosTable, sinTable, space, data, idData, gridx, gridy, gridz, updateChunk, field, idField, transform;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    lastClip = -1;\r\n                    atob = Vec3();\r\n                    mid = Vec3();\r\n                    n1 = Vec3();\r\n                    n2 = Vec3();\r\n                    resolution = props.resolution, probeRadius = props.probeRadius, probePositions = props.probePositions;\r\n                    scaleFactor = 1 / resolution;\r\n                    ngTorus = Math.max(5, 2 + Math.floor(probeRadius * scaleFactor));\r\n                    cellSize = Vec3.create(maxRadius, maxRadius, maxRadius);\r\n                    Vec3.scale(cellSize, cellSize, 2);\r\n                    lookup3d = GridLookup3D(position, boundary, cellSize);\r\n                    neighbours = lookup3d.result;\r\n                    if (box === null)\r\n                        box = lookup3d.boundary.box;\r\n                    indices = position.indices, px = position.x, py = position.y, pz = position.z, id = position.id, radius = position.radius;\r\n                    n = OrderedSet.size(indices);\r\n                    pad = maxRadius + resolution;\r\n                    expandedBox = Box3D.expand(Box3D(), box, Vec3.create(pad, pad, pad));\r\n                    _a = expandedBox.min, minX = _a[0], minY = _a[1], minZ = _a[2];\r\n                    scaledBox = Box3D.scale(Box3D(), expandedBox, scaleFactor);\r\n                    dim = Box3D.size(Vec3(), scaledBox);\r\n                    Vec3.ceil(dim, dim);\r\n                    dimX = dim[0], dimY = dim[1], dimZ = dim[2];\r\n                    iu = dimZ, iv = dimY, iuv = iu * iv;\r\n                    _b = getAngleTables(probePositions), cosTable = _b.cosTable, sinTable = _b.sinTable;\r\n                    space = Tensor.Space(dim, [0, 1, 2], Float32Array);\r\n                    data = space.create();\r\n                    idData = space.create();\r\n                    data.fill(-1001.0);\r\n                    idData.fill(-1);\r\n                    gridx = fillGridDim(dimX, minX, resolution);\r\n                    gridy = fillGridDim(dimY, minY, resolution);\r\n                    gridz = fillGridDim(dimZ, minZ, resolution);\r\n                    updateChunk = Math.ceil(100000 / ((Math.pow(Math.pow(maxRadius, 3), 3) * scaleFactor)));\r\n                    // console.timeEnd('MolecularSurface createState')\r\n                    // console.time('MolecularSurface projectPoints')\r\n                    return [4 /*yield*/, projectPoints()];\r\n                case 1:\r\n                    // console.timeEnd('MolecularSurface createState')\r\n                    // console.time('MolecularSurface projectPoints')\r\n                    _c.sent();\r\n                    // console.timeEnd('MolecularSurface projectPoints')\r\n                    // console.time('MolecularSurface projectTorii')\r\n                    return [4 /*yield*/, projectTorii()];\r\n                case 2:\r\n                    // console.timeEnd('MolecularSurface projectPoints')\r\n                    // console.time('MolecularSurface projectTorii')\r\n                    _c.sent();\r\n                    field = Tensor.create(space, data);\r\n                    idField = Tensor.create(space, idData);\r\n                    transform = Mat4.identity();\r\n                    Mat4.fromScaling(transform, Vec3.create(resolution, resolution, resolution));\r\n                    Mat4.setTranslation(transform, expandedBox.min);\r\n                    // console.log({ field, idField, transform, updateChunk })\r\n                    return [2 /*return*/, { field: field, idField: idField, transform: transform, resolution: resolution }];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=molecular-surface.js.map"]},"metadata":{},"sourceType":"module"}