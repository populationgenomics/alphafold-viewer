{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Result } from './common';\nimport { Box3D } from '../primitives/box3d';\nimport { Vec3 } from '../../linear-algebra';\nimport { OrderedSet } from '../../../mol-data/int';\n\nfunction GridLookup3D(data, boundary, cellSizeOrCount) {\n  return new GridLookup3DImpl(data, boundary, cellSizeOrCount);\n}\n\nexport { GridLookup3D };\n\nvar GridLookup3DImpl =\n/** @class */\nfunction () {\n  function GridLookup3DImpl(data, boundary, cellSizeOrCount) {\n    var structure = build(data, boundary, cellSizeOrCount);\n    this.ctx = createContext(structure);\n    this.boundary = {\n      box: structure.boundingBox,\n      sphere: structure.boundingSphere\n    };\n    this.buckets = {\n      offset: structure.bucketOffset,\n      count: structure.bucketCounts,\n      array: structure.bucketArray\n    };\n    this.result = Result.create();\n  }\n\n  GridLookup3DImpl.prototype.find = function (x, y, z, radius, result) {\n    this.ctx.x = x;\n    this.ctx.y = y;\n    this.ctx.z = z;\n    this.ctx.radius = radius;\n    this.ctx.isCheck = false;\n    var ret = result !== null && result !== void 0 ? result : this.result;\n    query(this.ctx, ret);\n    return ret;\n  };\n\n  GridLookup3DImpl.prototype.check = function (x, y, z, radius) {\n    this.ctx.x = x;\n    this.ctx.y = y;\n    this.ctx.z = z;\n    this.ctx.radius = radius;\n    this.ctx.isCheck = true;\n    return query(this.ctx, this.result);\n  };\n\n  return GridLookup3DImpl;\n}();\n\nfunction _build(state) {\n  var expandedBox = state.expandedBox,\n      _a = state.size,\n      sX = _a[0],\n      sY = _a[1],\n      sZ = _a[2],\n      _b = state.data,\n      px = _b.x,\n      py = _b.y,\n      pz = _b.z,\n      radius = _b.radius,\n      indices = _b.indices,\n      elementCount = state.elementCount,\n      delta = state.delta;\n  var n = sX * sY * sZ;\n  var _c = expandedBox.min,\n      minX = _c[0],\n      minY = _c[1],\n      minZ = _c[2];\n  var maxRadius = 0;\n  var bucketCount = 0;\n  var grid = new Uint32Array(n);\n  var bucketIndex = new Int32Array(elementCount);\n\n  for (var t = 0; t < elementCount; t++) {\n    var i = OrderedSet.getAt(indices, t);\n    var x = Math.floor((px[i] - minX) / delta[0]);\n    var y = Math.floor((py[i] - minY) / delta[1]);\n    var z = Math.floor((pz[i] - minZ) / delta[2]);\n    var idx = (x * sY + y) * sZ + z;\n\n    if ((grid[idx] += 1) === 1) {\n      bucketCount += 1;\n    }\n\n    bucketIndex[t] = idx;\n  }\n\n  if (radius) {\n    for (var t = 0; t < elementCount; t++) {\n      var i = OrderedSet.getAt(indices, t);\n      if (radius[i] > maxRadius) maxRadius = radius[i];\n    }\n  }\n\n  var bucketCounts = new Int32Array(bucketCount);\n\n  for (var i = 0, j = 0; i < n; i++) {\n    var c = grid[i];\n\n    if (c > 0) {\n      grid[i] = j + 1;\n      bucketCounts[j] = c;\n      j += 1;\n    }\n  }\n\n  var bucketOffset = new Uint32Array(bucketCount);\n\n  for (var i = 1; i < bucketCount; ++i) {\n    bucketOffset[i] += bucketOffset[i - 1] + bucketCounts[i - 1];\n  }\n\n  var bucketFill = new Int32Array(bucketCount);\n  var bucketArray = new Int32Array(elementCount);\n\n  for (var i = 0; i < elementCount; i++) {\n    var bucketIdx = grid[bucketIndex[i]];\n\n    if (bucketIdx > 0) {\n      var k = bucketIdx - 1;\n      bucketArray[bucketOffset[k] + bucketFill[k]] = i;\n      bucketFill[k] += 1;\n    }\n  }\n\n  return {\n    size: state.size,\n    bucketArray: bucketArray,\n    bucketCounts: bucketCounts,\n    bucketOffset: bucketOffset,\n    grid: grid,\n    delta: delta,\n    min: state.expandedBox.min,\n    data: state.data,\n    maxRadius: maxRadius,\n    expandedBox: state.expandedBox,\n    boundingBox: state.boundingBox,\n    boundingSphere: state.boundingSphere\n  };\n}\n\nfunction build(data, boundary, cellSizeOrCount) {\n  // need to expand the grid bounds to avoid rounding errors\n  var expandedBox = Box3D.expand(Box3D(), boundary.box, Vec3.create(0.5, 0.5, 0.5));\n  var indices = data.indices;\n  var S = Box3D.size(Vec3.zero(), expandedBox);\n  var delta, size;\n  var elementCount = OrderedSet.size(indices);\n  var cellCount = typeof cellSizeOrCount === 'number' ? cellSizeOrCount : 32;\n  var cellSize = Array.isArray(cellSizeOrCount) && cellSizeOrCount;\n\n  if (cellSize) {\n    size = [Math.ceil(S[0] / cellSize[0]), Math.ceil(S[1] / cellSize[1]), Math.ceil(S[2] / cellSize[2])];\n    delta = cellSize;\n  } else if (elementCount > 0) {\n    // size of the box\n    // required \"grid volume\" so that each cell contains on average 'cellCount' elements.\n    var V = Math.ceil(elementCount / cellCount);\n    var f = Math.pow(V / (S[0] * S[1] * S[2]), 1 / 3);\n    size = [Math.ceil(S[0] * f), Math.ceil(S[1] * f), Math.ceil(S[2] * f)];\n    delta = [S[0] / size[0], S[1] / size[1], S[2] / size[2]];\n  } else {\n    delta = S;\n    size = [1, 1, 1];\n  }\n\n  var inputData = {\n    x: data.x,\n    y: data.y,\n    z: data.z,\n    indices: indices,\n    radius: data.radius\n  };\n  var state = {\n    size: size,\n    data: inputData,\n    expandedBox: expandedBox,\n    boundingBox: boundary.box,\n    boundingSphere: boundary.sphere,\n    elementCount: elementCount,\n    delta: delta\n  };\n  return _build(state);\n}\n\nfunction createContext(grid) {\n  return {\n    grid: grid,\n    x: 0.1,\n    y: 0.1,\n    z: 0.1,\n    radius: 0.1,\n    isCheck: false\n  };\n}\n\nfunction query(ctx, result) {\n  var _a = ctx.grid,\n      min = _a.min,\n      _b = _a.size,\n      sX = _b[0],\n      sY = _b[1],\n      sZ = _b[2],\n      bucketOffset = _a.bucketOffset,\n      bucketCounts = _a.bucketCounts,\n      bucketArray = _a.bucketArray,\n      grid = _a.grid,\n      _c = _a.data,\n      px = _c.x,\n      py = _c.y,\n      pz = _c.z,\n      indices = _c.indices,\n      radius = _c.radius,\n      delta = _a.delta,\n      maxRadius = _a.maxRadius;\n  var inputRadius = ctx.radius,\n      isCheck = ctx.isCheck,\n      x = ctx.x,\n      y = ctx.y,\n      z = ctx.z;\n  var r = inputRadius + maxRadius;\n  var rSq = r * r;\n  Result.reset(result);\n  var loX = Math.max(0, Math.floor((x - r - min[0]) / delta[0]));\n  var loY = Math.max(0, Math.floor((y - r - min[1]) / delta[1]));\n  var loZ = Math.max(0, Math.floor((z - r - min[2]) / delta[2]));\n  var hiX = Math.min(sX - 1, Math.floor((x + r - min[0]) / delta[0]));\n  var hiY = Math.min(sY - 1, Math.floor((y + r - min[1]) / delta[1]));\n  var hiZ = Math.min(sZ - 1, Math.floor((z + r - min[2]) / delta[2]));\n  if (loX > hiX || loY > hiY || loZ > hiZ) return false;\n\n  for (var ix = loX; ix <= hiX; ix++) {\n    for (var iy = loY; iy <= hiY; iy++) {\n      for (var iz = loZ; iz <= hiZ; iz++) {\n        var bucketIdx = grid[(ix * sY + iy) * sZ + iz];\n        if (bucketIdx === 0) continue;\n        var k = bucketIdx - 1;\n        var offset = bucketOffset[k];\n        var count = bucketCounts[k];\n        var end = offset + count;\n\n        for (var i = offset; i < end; i++) {\n          var idx = OrderedSet.getAt(indices, bucketArray[i]);\n          var dx = px[idx] - x;\n          var dy = py[idx] - y;\n          var dz = pz[idx] - z;\n          var distSq = dx * dx + dy * dy + dz * dz;\n\n          if (distSq <= rSq) {\n            if (maxRadius > 0 && Math.sqrt(distSq) - radius[idx] > inputRadius) continue;\n            if (isCheck) return true;\n            Result.add(result, bucketArray[i], distSq);\n          }\n        }\n      }\n    }\n  }\n\n  return result.count > 0;\n}","map":{"version":3,"sources":["../../../../src/mol-math/geometry/lookup3d/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Result } from './common';\r\nimport { Box3D } from '../primitives/box3d';\r\nimport { Vec3 } from '../../linear-algebra';\r\nimport { OrderedSet } from '../../../mol-data/int';\r\nfunction GridLookup3D(data, boundary, cellSizeOrCount) {\r\n    return new GridLookup3DImpl(data, boundary, cellSizeOrCount);\r\n}\r\nexport { GridLookup3D };\r\nvar GridLookup3DImpl = /** @class */ (function () {\r\n    function GridLookup3DImpl(data, boundary, cellSizeOrCount) {\r\n        var structure = build(data, boundary, cellSizeOrCount);\r\n        this.ctx = createContext(structure);\r\n        this.boundary = { box: structure.boundingBox, sphere: structure.boundingSphere };\r\n        this.buckets = { offset: structure.bucketOffset, count: structure.bucketCounts, array: structure.bucketArray };\r\n        this.result = Result.create();\r\n    }\r\n    GridLookup3DImpl.prototype.find = function (x, y, z, radius, result) {\r\n        this.ctx.x = x;\r\n        this.ctx.y = y;\r\n        this.ctx.z = z;\r\n        this.ctx.radius = radius;\r\n        this.ctx.isCheck = false;\r\n        var ret = result !== null && result !== void 0 ? result : this.result;\r\n        query(this.ctx, ret);\r\n        return ret;\r\n    };\r\n    GridLookup3DImpl.prototype.check = function (x, y, z, radius) {\r\n        this.ctx.x = x;\r\n        this.ctx.y = y;\r\n        this.ctx.z = z;\r\n        this.ctx.radius = radius;\r\n        this.ctx.isCheck = true;\r\n        return query(this.ctx, this.result);\r\n    };\r\n    return GridLookup3DImpl;\r\n}());\r\nfunction _build(state) {\r\n    var expandedBox = state.expandedBox, _a = state.size, sX = _a[0], sY = _a[1], sZ = _a[2], _b = state.data, px = _b.x, py = _b.y, pz = _b.z, radius = _b.radius, indices = _b.indices, elementCount = state.elementCount, delta = state.delta;\r\n    var n = sX * sY * sZ;\r\n    var _c = expandedBox.min, minX = _c[0], minY = _c[1], minZ = _c[2];\r\n    var maxRadius = 0;\r\n    var bucketCount = 0;\r\n    var grid = new Uint32Array(n);\r\n    var bucketIndex = new Int32Array(elementCount);\r\n    for (var t = 0; t < elementCount; t++) {\r\n        var i = OrderedSet.getAt(indices, t);\r\n        var x = Math.floor((px[i] - minX) / delta[0]);\r\n        var y = Math.floor((py[i] - minY) / delta[1]);\r\n        var z = Math.floor((pz[i] - minZ) / delta[2]);\r\n        var idx = (((x * sY) + y) * sZ) + z;\r\n        if ((grid[idx] += 1) === 1) {\r\n            bucketCount += 1;\r\n        }\r\n        bucketIndex[t] = idx;\r\n    }\r\n    if (radius) {\r\n        for (var t = 0; t < elementCount; t++) {\r\n            var i = OrderedSet.getAt(indices, t);\r\n            if (radius[i] > maxRadius)\r\n                maxRadius = radius[i];\r\n        }\r\n    }\r\n    var bucketCounts = new Int32Array(bucketCount);\r\n    for (var i = 0, j = 0; i < n; i++) {\r\n        var c = grid[i];\r\n        if (c > 0) {\r\n            grid[i] = j + 1;\r\n            bucketCounts[j] = c;\r\n            j += 1;\r\n        }\r\n    }\r\n    var bucketOffset = new Uint32Array(bucketCount);\r\n    for (var i = 1; i < bucketCount; ++i) {\r\n        bucketOffset[i] += bucketOffset[i - 1] + bucketCounts[i - 1];\r\n    }\r\n    var bucketFill = new Int32Array(bucketCount);\r\n    var bucketArray = new Int32Array(elementCount);\r\n    for (var i = 0; i < elementCount; i++) {\r\n        var bucketIdx = grid[bucketIndex[i]];\r\n        if (bucketIdx > 0) {\r\n            var k = bucketIdx - 1;\r\n            bucketArray[bucketOffset[k] + bucketFill[k]] = i;\r\n            bucketFill[k] += 1;\r\n        }\r\n    }\r\n    return {\r\n        size: state.size,\r\n        bucketArray: bucketArray,\r\n        bucketCounts: bucketCounts,\r\n        bucketOffset: bucketOffset,\r\n        grid: grid,\r\n        delta: delta,\r\n        min: state.expandedBox.min,\r\n        data: state.data,\r\n        maxRadius: maxRadius,\r\n        expandedBox: state.expandedBox,\r\n        boundingBox: state.boundingBox,\r\n        boundingSphere: state.boundingSphere\r\n    };\r\n}\r\nfunction build(data, boundary, cellSizeOrCount) {\r\n    // need to expand the grid bounds to avoid rounding errors\r\n    var expandedBox = Box3D.expand(Box3D(), boundary.box, Vec3.create(0.5, 0.5, 0.5));\r\n    var indices = data.indices;\r\n    var S = Box3D.size(Vec3.zero(), expandedBox);\r\n    var delta, size;\r\n    var elementCount = OrderedSet.size(indices);\r\n    var cellCount = typeof cellSizeOrCount === 'number' ? cellSizeOrCount : 32;\r\n    var cellSize = Array.isArray(cellSizeOrCount) && cellSizeOrCount;\r\n    if (cellSize) {\r\n        size = [Math.ceil(S[0] / cellSize[0]), Math.ceil(S[1] / cellSize[1]), Math.ceil(S[2] / cellSize[2])];\r\n        delta = cellSize;\r\n    }\r\n    else if (elementCount > 0) {\r\n        // size of the box\r\n        // required \"grid volume\" so that each cell contains on average 'cellCount' elements.\r\n        var V = Math.ceil(elementCount / cellCount);\r\n        var f = Math.pow(V / (S[0] * S[1] * S[2]), 1 / 3);\r\n        size = [Math.ceil(S[0] * f), Math.ceil(S[1] * f), Math.ceil(S[2] * f)];\r\n        delta = [S[0] / size[0], S[1] / size[1], S[2] / size[2]];\r\n    }\r\n    else {\r\n        delta = S;\r\n        size = [1, 1, 1];\r\n    }\r\n    var inputData = {\r\n        x: data.x,\r\n        y: data.y,\r\n        z: data.z,\r\n        indices: indices,\r\n        radius: data.radius\r\n    };\r\n    var state = {\r\n        size: size,\r\n        data: inputData,\r\n        expandedBox: expandedBox,\r\n        boundingBox: boundary.box,\r\n        boundingSphere: boundary.sphere,\r\n        elementCount: elementCount,\r\n        delta: delta\r\n    };\r\n    return _build(state);\r\n}\r\nfunction createContext(grid) {\r\n    return { grid: grid, x: 0.1, y: 0.1, z: 0.1, radius: 0.1, isCheck: false };\r\n}\r\nfunction query(ctx, result) {\r\n    var _a = ctx.grid, min = _a.min, _b = _a.size, sX = _b[0], sY = _b[1], sZ = _b[2], bucketOffset = _a.bucketOffset, bucketCounts = _a.bucketCounts, bucketArray = _a.bucketArray, grid = _a.grid, _c = _a.data, px = _c.x, py = _c.y, pz = _c.z, indices = _c.indices, radius = _c.radius, delta = _a.delta, maxRadius = _a.maxRadius;\r\n    var inputRadius = ctx.radius, isCheck = ctx.isCheck, x = ctx.x, y = ctx.y, z = ctx.z;\r\n    var r = inputRadius + maxRadius;\r\n    var rSq = r * r;\r\n    Result.reset(result);\r\n    var loX = Math.max(0, Math.floor((x - r - min[0]) / delta[0]));\r\n    var loY = Math.max(0, Math.floor((y - r - min[1]) / delta[1]));\r\n    var loZ = Math.max(0, Math.floor((z - r - min[2]) / delta[2]));\r\n    var hiX = Math.min(sX - 1, Math.floor((x + r - min[0]) / delta[0]));\r\n    var hiY = Math.min(sY - 1, Math.floor((y + r - min[1]) / delta[1]));\r\n    var hiZ = Math.min(sZ - 1, Math.floor((z + r - min[2]) / delta[2]));\r\n    if (loX > hiX || loY > hiY || loZ > hiZ)\r\n        return false;\r\n    for (var ix = loX; ix <= hiX; ix++) {\r\n        for (var iy = loY; iy <= hiY; iy++) {\r\n            for (var iz = loZ; iz <= hiZ; iz++) {\r\n                var bucketIdx = grid[(((ix * sY) + iy) * sZ) + iz];\r\n                if (bucketIdx === 0)\r\n                    continue;\r\n                var k = bucketIdx - 1;\r\n                var offset = bucketOffset[k];\r\n                var count = bucketCounts[k];\r\n                var end = offset + count;\r\n                for (var i = offset; i < end; i++) {\r\n                    var idx = OrderedSet.getAt(indices, bucketArray[i]);\r\n                    var dx = px[idx] - x;\r\n                    var dy = py[idx] - y;\r\n                    var dz = pz[idx] - z;\r\n                    var distSq = dx * dx + dy * dy + dz * dz;\r\n                    if (distSq <= rSq) {\r\n                        if (maxRadius > 0 && Math.sqrt(distSq) - radius[idx] > inputRadius)\r\n                            continue;\r\n                        if (isCheck)\r\n                            return true;\r\n                        Result.add(result, bucketArray[i], distSq);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.count > 0;\r\n}\r\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}