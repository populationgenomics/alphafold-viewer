{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __spreadArray } from \"tslib\";\n/**\r\n * Adapted from Parsimmon (https://github.com/jneen/parsimmon)\r\n * Copyright (c) 2011-present J. Adkisson (http://jneen.net).\r\n */\n\nvar MonadicParser =\n/** @class */\nfunction () {\n  function MonadicParser(_) {\n    this._ = _;\n  }\n\n  MonadicParser.prototype.parse = function (input) {\n    var result = this.skip(MonadicParser.eof)._(input, 0);\n\n    if (result.status) {\n      return {\n        success: true,\n        value: result.value\n      };\n    }\n\n    return {\n      success: false,\n      index: makeLineColumnIndex(input, result.furthest),\n      expected: result.expected\n    };\n  };\n\n  ;\n\n  MonadicParser.prototype.tryParse = function (str) {\n    var result = this.parse(str);\n\n    if (result.success) {\n      return result.value;\n    } else {\n      var msg = formatError(str, result);\n      var err = new Error(msg);\n      throw err;\n    }\n  };\n\n  MonadicParser.prototype.or = function (alternative) {\n    return MonadicParser.alt(this, alternative);\n  };\n\n  MonadicParser.prototype.trim = function (parser) {\n    return this.wrap(parser, parser);\n  };\n\n  MonadicParser.prototype.wrap = function (leftParser, rightParser) {\n    return seqPick(1, typeof leftParser === 'string' ? MonadicParser.string(leftParser) : leftParser, this, typeof rightParser === 'string' ? MonadicParser.string(rightParser) : rightParser);\n  };\n\n  MonadicParser.prototype.thru = function (wrapper) {\n    return wrapper(this);\n  };\n\n  MonadicParser.prototype.then = function (next) {\n    return seqPick(1, this, next);\n  };\n\n  MonadicParser.prototype.many = function () {\n    var _this = this;\n\n    return new MonadicParser(function (input, i) {\n      var accum = [];\n      var result = void 0;\n\n      while (true) {\n        result = mergeReplies(_this._(input, i), result);\n\n        if (result.status) {\n          if (i === result.index) {\n            throw new Error('infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause');\n          }\n\n          i = result.index;\n          accum.push(result.value);\n        } else {\n          return mergeReplies(makeSuccess(i, accum), result);\n        }\n      }\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.times = function (min, _max) {\n    var _this = this;\n\n    var max = typeof _max === 'undefined' ? min : _max;\n    return new MonadicParser(function (input, i) {\n      var accum = [];\n      var result = void 0;\n      var prevResult = void 0;\n      var times;\n\n      for (times = 0; times < min; times++) {\n        result = _this._(input, i);\n        prevResult = mergeReplies(result, prevResult);\n\n        if (result.status) {\n          i = result.index;\n          accum.push(result.value);\n        } else {\n          return prevResult;\n        }\n      }\n\n      for (; times < max; times += 1) {\n        result = _this._(input, i);\n        prevResult = mergeReplies(result, prevResult);\n\n        if (result.status) {\n          i = result.index;\n          accum.push(result.value);\n        } else {\n          break;\n        }\n      }\n\n      return mergeReplies(makeSuccess(i, accum), prevResult);\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.result = function (res) {\n    return this.map(function () {\n      return res;\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.atMost = function (n) {\n    return this.times(0, n);\n  };\n\n  ;\n\n  MonadicParser.prototype.atLeast = function (n) {\n    return MonadicParser.seq(this.times(n), this.many()).map(function (r) {\n      return __spreadArray(__spreadArray([], r[0], true), r[1], true);\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.map = function (f) {\n    var _this = this;\n\n    return new MonadicParser(function (input, i) {\n      var result = _this._(input, i);\n\n      if (!result.status) {\n        return result;\n      }\n\n      return mergeReplies(makeSuccess(result.index, f(result.value)), result);\n    });\n  };\n\n  MonadicParser.prototype.skip = function (next) {\n    return seqPick(0, this, next);\n  };\n\n  MonadicParser.prototype.mark = function () {\n    return MonadicParser.seq(MonadicParser.index, this, MonadicParser.index).map(function (r) {\n      return {\n        start: r[0],\n        value: r[1],\n        end: r[2]\n      };\n    });\n  };\n\n  MonadicParser.prototype.node = function (name) {\n    return MonadicParser.seq(MonadicParser.index, this, MonadicParser.index).map(function (r) {\n      return {\n        name: name,\n        start: r[0],\n        value: r[1],\n        end: r[2]\n      };\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.sepBy = function (separator) {\n    return MonadicParser.sepBy(this, separator);\n  };\n\n  MonadicParser.prototype.sepBy1 = function (separator) {\n    return MonadicParser.sepBy1(this, separator);\n  };\n\n  MonadicParser.prototype.lookahead = function (x) {\n    return this.skip(MonadicParser.lookahead(x));\n  };\n\n  ;\n\n  MonadicParser.prototype.notFollowedBy = function (x) {\n    return this.skip(MonadicParser.notFollowedBy(x));\n  };\n\n  ;\n\n  MonadicParser.prototype.desc = function (expected) {\n    var _this = this;\n\n    return new MonadicParser(function (input, i) {\n      var reply = _this._(input, i);\n\n      if (!reply.status) {\n        reply.expected = [expected];\n      }\n\n      return reply;\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.fallback = function (result) {\n    return this.or(MonadicParser.succeed(result));\n  };\n\n  ;\n\n  MonadicParser.prototype.ap = function (other) {\n    return MonadicParser.seq(other, this).map(function (_a) {\n      var f = _a[0],\n          x = _a[1];\n      return f(x);\n    });\n  };\n\n  ;\n\n  MonadicParser.prototype.chain = function (f) {\n    var _this = this;\n\n    return new MonadicParser(function (input, i) {\n      var result = _this._(input, i);\n\n      if (!result.status) {\n        return result;\n      }\n\n      var nextParser = f(result.value);\n      return mergeReplies(nextParser._(input, result.index), result);\n    });\n  };\n\n  ;\n  return MonadicParser;\n}();\n\nexport { MonadicParser };\n\n(function (MonadicParser) {\n  function seq() {\n    var parsers = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      parsers[_i] = arguments[_i];\n    }\n\n    var numParsers = parsers.length;\n    return new MonadicParser(function (input, index) {\n      var result;\n      var accum = new Array(numParsers);\n      var i = index;\n\n      for (var j = 0; j < numParsers; j++) {\n        result = mergeReplies(parsers[j]._(input, i), result);\n\n        if (!result.status) {\n          return result;\n        }\n\n        accum[j] = result.value;\n        i = result.index;\n      }\n\n      return mergeReplies(makeSuccess(i, accum), result);\n    });\n  }\n\n  MonadicParser.seq = seq;\n\n  function alt() {\n    var parsers = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      parsers[_i] = arguments[_i];\n    }\n\n    var numParsers = parsers.length;\n\n    if (numParsers === 0) {\n      return fail('zero alternates');\n    }\n\n    return new MonadicParser(function (input, i) {\n      var result;\n\n      for (var j = 0; j < parsers.length; j++) {\n        result = mergeReplies(parsers[j]._(input, i), result);\n\n        if (result.status) {\n          return result;\n        }\n      }\n\n      return result;\n    });\n  }\n\n  MonadicParser.alt = alt;\n\n  function sepBy(parser, separator) {\n    return sepBy1(parser, separator).or(succeed([]));\n  }\n\n  MonadicParser.sepBy = sepBy;\n\n  function sepBy1(parser, separator) {\n    var pairs = separator.then(parser).many();\n    return seq(parser, pairs).map(function (r) {\n      return __spreadArray([r[0]], r[1], true);\n    });\n  }\n\n  MonadicParser.sepBy1 = sepBy1;\n\n  function string(str) {\n    var expected = \"'\" + str + \"'\";\n\n    if (str.length === 1) {\n      var code_1 = str.charCodeAt(0);\n      return new MonadicParser(function (input, i) {\n        return input.charCodeAt(i) === code_1 ? makeSuccess(i + 1, str) : makeFailure(i, expected);\n      });\n    }\n\n    return new MonadicParser(function (input, i) {\n      var j = i + str.length;\n      if (input.slice(i, j) === str) return makeSuccess(j, str);else return makeFailure(i, expected);\n    });\n  }\n\n  MonadicParser.string = string;\n\n  function flags(re) {\n    var s = '' + re;\n    return s.slice(s.lastIndexOf('/') + 1);\n  }\n\n  function anchoredRegexp(re) {\n    return RegExp('^(?:' + re.source + ')', flags(re));\n  }\n\n  function regexp(re, group) {\n    if (group === void 0) {\n      group = 0;\n    }\n\n    var anchored = anchoredRegexp(re);\n    var expected = '' + re;\n    return new MonadicParser(function (input, i) {\n      var match = anchored.exec(input.slice(i));\n\n      if (match) {\n        if (0 <= group && group <= match.length) {\n          var fullMatch = match[0];\n          var groupMatch = match[group];\n          return makeSuccess(i + fullMatch.length, groupMatch);\n        }\n\n        var message = \"invalid match group (0 to \" + match.length + \") in \" + expected;\n        return makeFailure(i, message);\n      }\n\n      return makeFailure(i, expected);\n    });\n  }\n\n  MonadicParser.regexp = regexp;\n\n  function succeed(value) {\n    return new MonadicParser(function (input, i) {\n      return makeSuccess(i, value);\n    });\n  }\n\n  MonadicParser.succeed = succeed;\n\n  function fail(expected) {\n    return new MonadicParser(function (input, i) {\n      return makeFailure(i, expected);\n    });\n  }\n\n  MonadicParser.fail = fail;\n\n  function lookahead(x) {\n    if (isParser(x)) {\n      return new MonadicParser(function (input, i) {\n        var result = x._(input, i);\n\n        if (result.status) {\n          result.index = i;\n          result.value = null;\n        }\n\n        return result;\n      });\n    } else if (typeof x === 'string') {\n      return lookahead(string(x));\n    } else if (x instanceof RegExp) {\n      return lookahead(regexp(x));\n    }\n\n    throw new Error('not a string, regexp, or parser: ' + x);\n  }\n\n  MonadicParser.lookahead = lookahead;\n\n  function notFollowedBy(parser) {\n    return new MonadicParser(function (input, i) {\n      var result = parser._(input, i);\n\n      return result.status ? makeFailure(i, 'not \"' + input.slice(i, result.index) + '\"') : makeSuccess(i, null);\n    });\n  }\n\n  MonadicParser.notFollowedBy = notFollowedBy;\n\n  function test(predicate) {\n    return new MonadicParser(function (input, i) {\n      var char = input.charAt(i);\n\n      if (i < input.length && predicate(char)) {\n        return makeSuccess(i + 1, char);\n      } else {\n        return makeFailure(i, 'a character ' + predicate);\n      }\n    });\n  }\n\n  MonadicParser.test = test;\n\n  function oneOf(str) {\n    return test(function (ch) {\n      return str.indexOf(ch) >= 0;\n    });\n  }\n\n  MonadicParser.oneOf = oneOf;\n\n  function noneOf(str) {\n    return test(function (ch) {\n      return str.indexOf(ch) < 0;\n    });\n  }\n\n  MonadicParser.noneOf = noneOf;\n\n  function range(begin, end) {\n    return test(function (ch) {\n      return begin <= ch && ch <= end;\n    }).desc(begin + '-' + end);\n  }\n\n  MonadicParser.range = range;\n\n  function takeWhile(predicate) {\n    return new MonadicParser(function (input, i) {\n      var j = i;\n\n      while (j < input.length && predicate(input.charAt(j))) {\n        j++;\n      }\n\n      return makeSuccess(j, input.slice(i, j));\n    });\n  }\n\n  MonadicParser.takeWhile = takeWhile;\n\n  function lazy(f) {\n    var parser = new MonadicParser(function (input, i) {\n      var a = f()._;\n\n      parser._ = a;\n      return a(input, i);\n    });\n    return parser;\n  }\n\n  MonadicParser.lazy = lazy;\n\n  function empty() {\n    return fail('empty');\n  }\n\n  MonadicParser.empty = empty;\n  MonadicParser.index = new MonadicParser(function (input, i) {\n    return makeSuccess(i, makeLineColumnIndex(input, i));\n  });\n  MonadicParser.anyChar = new MonadicParser(function (input, i) {\n    if (i >= input.length) {\n      return makeFailure(i, 'any character');\n    }\n\n    return makeSuccess(i + 1, input.charAt(i));\n  });\n  MonadicParser.all = new MonadicParser(function (input, i) {\n    return makeSuccess(input.length, input.slice(i));\n  });\n  MonadicParser.eof = new MonadicParser(function (input, i) {\n    if (i < input.length) {\n      return makeFailure(i, 'EOF');\n    }\n\n    return makeSuccess(i, null);\n  });\n  MonadicParser.digit = regexp(/[0-9]/).desc('a digit');\n  MonadicParser.digits = regexp(/[0-9]*/).desc('optional digits');\n  MonadicParser.letter = regexp(/[a-z]/i).desc('a letter');\n  MonadicParser.letters = regexp(/[a-z]*/i).desc('optional letters');\n  MonadicParser.optWhitespace = regexp(/\\s*/).desc('optional whitespace');\n  MonadicParser.whitespace = regexp(/\\s+/).desc('whitespace');\n  MonadicParser.cr = string('\\r');\n  MonadicParser.lf = string('\\n');\n  MonadicParser.crlf = string('\\r\\n');\n  MonadicParser.newline = alt(MonadicParser.crlf, MonadicParser.lf, MonadicParser.cr).desc('newline');\n  MonadicParser.end = alt(MonadicParser.newline, MonadicParser.eof);\n})(MonadicParser || (MonadicParser = {}));\n\nfunction seqPick(idx) {\n  var parsers = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    parsers[_i - 1] = arguments[_i];\n  }\n\n  var numParsers = parsers.length;\n  return new MonadicParser(function (input, index) {\n    var result;\n    var picked;\n    var i = index;\n\n    for (var j = 0; j < numParsers; j++) {\n      result = mergeReplies(parsers[j]._(input, i), result);\n\n      if (!result.status) {\n        return result;\n      }\n\n      if (idx === j) picked = result.value;\n      i = result.index;\n    }\n\n    return mergeReplies(makeSuccess(i, picked), result);\n  });\n}\n\nfunction makeSuccess(index, value) {\n  return {\n    status: true,\n    index: index,\n    value: value\n  };\n}\n\nfunction makeFailure(index, expected) {\n  return {\n    status: false,\n    furthest: index,\n    expected: [expected]\n  };\n}\n\nfunction mergeReplies(result, last) {\n  if (!last || result.status || last.status || result.furthest > last.furthest) {\n    return result;\n  }\n\n  var expected = result.furthest === last.furthest ? unsafeUnion(result.expected, last.expected) : last.expected;\n  return {\n    status: result.status,\n    furthest: last.furthest,\n    expected: expected\n  };\n}\n\nfunction makeLineColumnIndex(input, i) {\n  var lines = input.slice(0, i).split('\\n'); // Note that unlike the character offset, the line and column offsets are\n  // 1-based.\n\n  var lineWeAreUpTo = lines.length;\n  var columnWeAreUpTo = lines[lines.length - 1].length + 1;\n  return {\n    offset: i,\n    line: lineWeAreUpTo,\n    column: columnWeAreUpTo\n  };\n}\n\nfunction formatExpected(expected) {\n  if (expected.length === 1) {\n    return expected[0];\n  }\n\n  return 'one of ' + expected.join(', ');\n}\n\nfunction formatGot(input, error) {\n  var index = error.index;\n  var i = index.offset;\n\n  if (i === input.length) {\n    return ', got the end of the input';\n  }\n\n  var prefix = i > 0 ? '\\'...' : '\\'';\n  var suffix = input.length - i > 12 ? '...\\'' : '\\'';\n  return \" at line \" + index.line + \" column \" + index.column + \", got \" + prefix + input.slice(i, i + 12) + suffix;\n}\n\nfunction formatError(input, error) {\n  return \"expected \" + formatExpected(error.expected) + formatGot(input, error);\n}\n\nfunction unsafeUnion(xs, ys) {\n  var xn = xs.length;\n  var yn = ys.length;\n  if (xn === 0) return ys;else if (yn === 0) return xs;\n  var set = new Set();\n  var ret = [];\n\n  for (var i = 0; i < xn; i++) {\n    if (!set.has(xs[i])) {\n      ret[ret.length] = xs[i];\n      set.add(xs[i]);\n    }\n  }\n\n  for (var i = 0; i < yn; i++) {\n    if (!set.has(ys[i])) {\n      ret[ret.length] = ys[i];\n      set.add(ys[i]);\n    }\n  }\n\n  ret.sort();\n  return ret;\n}\n\nfunction isParser(obj) {\n  return obj instanceof MonadicParser;\n}","map":{"version":3,"sources":["../../src/mol-util/monadic-parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __spreadArray } from \"tslib\";\r\n/**\r\n * Adapted from Parsimmon (https://github.com/jneen/parsimmon)\r\n * Copyright (c) 2011-present J. Adkisson (http://jneen.net).\r\n */\r\nvar MonadicParser = /** @class */ (function () {\r\n    function MonadicParser(_) {\r\n        this._ = _;\r\n    }\r\n    MonadicParser.prototype.parse = function (input) {\r\n        var result = this.skip(MonadicParser.eof)._(input, 0);\r\n        if (result.status) {\r\n            return { success: true, value: result.value };\r\n        }\r\n        return { success: false, index: makeLineColumnIndex(input, result.furthest), expected: result.expected };\r\n    };\r\n    ;\r\n    MonadicParser.prototype.tryParse = function (str) {\r\n        var result = this.parse(str);\r\n        if (result.success) {\r\n            return result.value;\r\n        }\r\n        else {\r\n            var msg = formatError(str, result);\r\n            var err = new Error(msg);\r\n            throw err;\r\n        }\r\n    };\r\n    MonadicParser.prototype.or = function (alternative) {\r\n        return MonadicParser.alt(this, alternative);\r\n    };\r\n    MonadicParser.prototype.trim = function (parser) {\r\n        return this.wrap(parser, parser);\r\n    };\r\n    MonadicParser.prototype.wrap = function (leftParser, rightParser) {\r\n        return seqPick(1, typeof leftParser === 'string' ? MonadicParser.string(leftParser) : leftParser, this, typeof rightParser === 'string' ? MonadicParser.string(rightParser) : rightParser);\r\n    };\r\n    MonadicParser.prototype.thru = function (wrapper) {\r\n        return wrapper(this);\r\n    };\r\n    MonadicParser.prototype.then = function (next) {\r\n        return seqPick(1, this, next);\r\n    };\r\n    MonadicParser.prototype.many = function () {\r\n        var _this = this;\r\n        return new MonadicParser(function (input, i) {\r\n            var accum = [];\r\n            var result = void 0;\r\n            while (true) {\r\n                result = mergeReplies(_this._(input, i), result);\r\n                if (result.status) {\r\n                    if (i === result.index) {\r\n                        throw new Error('infinite loop detected in .many() parser --- calling .many() on a parser which can accept zero characters is usually the cause');\r\n                    }\r\n                    i = result.index;\r\n                    accum.push(result.value);\r\n                }\r\n                else {\r\n                    return mergeReplies(makeSuccess(i, accum), result);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.times = function (min, _max) {\r\n        var _this = this;\r\n        var max = typeof _max === 'undefined' ? min : _max;\r\n        return new MonadicParser(function (input, i) {\r\n            var accum = [];\r\n            var result = void 0;\r\n            var prevResult = void 0;\r\n            var times;\r\n            for (times = 0; times < min; times++) {\r\n                result = _this._(input, i);\r\n                prevResult = mergeReplies(result, prevResult);\r\n                if (result.status) {\r\n                    i = result.index;\r\n                    accum.push(result.value);\r\n                }\r\n                else {\r\n                    return prevResult;\r\n                }\r\n            }\r\n            for (; times < max; times += 1) {\r\n                result = _this._(input, i);\r\n                prevResult = mergeReplies(result, prevResult);\r\n                if (result.status) {\r\n                    i = result.index;\r\n                    accum.push(result.value);\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            return mergeReplies(makeSuccess(i, accum), prevResult);\r\n        });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.result = function (res) {\r\n        return this.map(function () { return res; });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.atMost = function (n) {\r\n        return this.times(0, n);\r\n    };\r\n    ;\r\n    MonadicParser.prototype.atLeast = function (n) {\r\n        return MonadicParser.seq(this.times(n), this.many()).map(function (r) { return __spreadArray(__spreadArray([], r[0], true), r[1], true); });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.map = function (f) {\r\n        var _this = this;\r\n        return new MonadicParser(function (input, i) {\r\n            var result = _this._(input, i);\r\n            if (!result.status) {\r\n                return result;\r\n            }\r\n            return mergeReplies(makeSuccess(result.index, f(result.value)), result);\r\n        });\r\n    };\r\n    MonadicParser.prototype.skip = function (next) {\r\n        return seqPick(0, this, next);\r\n    };\r\n    MonadicParser.prototype.mark = function () {\r\n        return MonadicParser.seq(MonadicParser.index, this, MonadicParser.index).map(function (r) { return ({ start: r[0], value: r[1], end: r[2] }); });\r\n    };\r\n    MonadicParser.prototype.node = function (name) {\r\n        return MonadicParser.seq(MonadicParser.index, this, MonadicParser.index).map(function (r) { return ({ name: name, start: r[0], value: r[1], end: r[2] }); });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.sepBy = function (separator) {\r\n        return MonadicParser.sepBy(this, separator);\r\n    };\r\n    MonadicParser.prototype.sepBy1 = function (separator) {\r\n        return MonadicParser.sepBy1(this, separator);\r\n    };\r\n    MonadicParser.prototype.lookahead = function (x) {\r\n        return this.skip(MonadicParser.lookahead(x));\r\n    };\r\n    ;\r\n    MonadicParser.prototype.notFollowedBy = function (x) {\r\n        return this.skip(MonadicParser.notFollowedBy(x));\r\n    };\r\n    ;\r\n    MonadicParser.prototype.desc = function (expected) {\r\n        var _this = this;\r\n        return new MonadicParser(function (input, i) {\r\n            var reply = _this._(input, i);\r\n            if (!reply.status) {\r\n                reply.expected = [expected];\r\n            }\r\n            return reply;\r\n        });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.fallback = function (result) {\r\n        return this.or(MonadicParser.succeed(result));\r\n    };\r\n    ;\r\n    MonadicParser.prototype.ap = function (other) {\r\n        return MonadicParser.seq(other, this).map(function (_a) {\r\n            var f = _a[0], x = _a[1];\r\n            return f(x);\r\n        });\r\n    };\r\n    ;\r\n    MonadicParser.prototype.chain = function (f) {\r\n        var _this = this;\r\n        return new MonadicParser(function (input, i) {\r\n            var result = _this._(input, i);\r\n            if (!result.status) {\r\n                return result;\r\n            }\r\n            var nextParser = f(result.value);\r\n            return mergeReplies(nextParser._(input, result.index), result);\r\n        });\r\n    };\r\n    ;\r\n    return MonadicParser;\r\n}());\r\nexport { MonadicParser };\r\n(function (MonadicParser) {\r\n    function seq() {\r\n        var parsers = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            parsers[_i] = arguments[_i];\r\n        }\r\n        var numParsers = parsers.length;\r\n        return new MonadicParser(function (input, index) {\r\n            var result;\r\n            var accum = new Array(numParsers);\r\n            var i = index;\r\n            for (var j = 0; j < numParsers; j++) {\r\n                result = mergeReplies(parsers[j]._(input, i), result);\r\n                if (!result.status) {\r\n                    return result;\r\n                }\r\n                accum[j] = result.value;\r\n                i = result.index;\r\n            }\r\n            return mergeReplies(makeSuccess(i, accum), result);\r\n        });\r\n    }\r\n    MonadicParser.seq = seq;\r\n    function alt() {\r\n        var parsers = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            parsers[_i] = arguments[_i];\r\n        }\r\n        var numParsers = parsers.length;\r\n        if (numParsers === 0) {\r\n            return fail('zero alternates');\r\n        }\r\n        return new MonadicParser(function (input, i) {\r\n            var result;\r\n            for (var j = 0; j < parsers.length; j++) {\r\n                result = mergeReplies(parsers[j]._(input, i), result);\r\n                if (result.status) {\r\n                    return result;\r\n                }\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    MonadicParser.alt = alt;\r\n    function sepBy(parser, separator) {\r\n        return sepBy1(parser, separator).or(succeed([]));\r\n    }\r\n    MonadicParser.sepBy = sepBy;\r\n    function sepBy1(parser, separator) {\r\n        var pairs = separator.then(parser).many();\r\n        return seq(parser, pairs).map(function (r) { return __spreadArray([r[0]], r[1], true); });\r\n    }\r\n    MonadicParser.sepBy1 = sepBy1;\r\n    function string(str) {\r\n        var expected = \"'\" + str + \"'\";\r\n        if (str.length === 1) {\r\n            var code_1 = str.charCodeAt(0);\r\n            return new MonadicParser(function (input, i) { return input.charCodeAt(i) === code_1 ? makeSuccess(i + 1, str) : makeFailure(i, expected); });\r\n        }\r\n        return new MonadicParser(function (input, i) {\r\n            var j = i + str.length;\r\n            if (input.slice(i, j) === str)\r\n                return makeSuccess(j, str);\r\n            else\r\n                return makeFailure(i, expected);\r\n        });\r\n    }\r\n    MonadicParser.string = string;\r\n    function flags(re) {\r\n        var s = '' + re;\r\n        return s.slice(s.lastIndexOf('/') + 1);\r\n    }\r\n    function anchoredRegexp(re) {\r\n        return RegExp('^(?:' + re.source + ')', flags(re));\r\n    }\r\n    function regexp(re, group) {\r\n        if (group === void 0) { group = 0; }\r\n        var anchored = anchoredRegexp(re);\r\n        var expected = '' + re;\r\n        return new MonadicParser(function (input, i) {\r\n            var match = anchored.exec(input.slice(i));\r\n            if (match) {\r\n                if (0 <= group && group <= match.length) {\r\n                    var fullMatch = match[0];\r\n                    var groupMatch = match[group];\r\n                    return makeSuccess(i + fullMatch.length, groupMatch);\r\n                }\r\n                var message = \"invalid match group (0 to \" + match.length + \") in \" + expected;\r\n                return makeFailure(i, message);\r\n            }\r\n            return makeFailure(i, expected);\r\n        });\r\n    }\r\n    MonadicParser.regexp = regexp;\r\n    function succeed(value) {\r\n        return new MonadicParser(function (input, i) { return makeSuccess(i, value); });\r\n    }\r\n    MonadicParser.succeed = succeed;\r\n    function fail(expected) {\r\n        return new MonadicParser(function (input, i) { return makeFailure(i, expected); });\r\n    }\r\n    MonadicParser.fail = fail;\r\n    function lookahead(x) {\r\n        if (isParser(x)) {\r\n            return new MonadicParser(function (input, i) {\r\n                var result = x._(input, i);\r\n                if (result.status) {\r\n                    result.index = i;\r\n                    result.value = null;\r\n                }\r\n                return result;\r\n            });\r\n        }\r\n        else if (typeof x === 'string') {\r\n            return lookahead(string(x));\r\n        }\r\n        else if (x instanceof RegExp) {\r\n            return lookahead(regexp(x));\r\n        }\r\n        throw new Error('not a string, regexp, or parser: ' + x);\r\n    }\r\n    MonadicParser.lookahead = lookahead;\r\n    function notFollowedBy(parser) {\r\n        return new MonadicParser(function (input, i) {\r\n            var result = parser._(input, i);\r\n            return result.status\r\n                ? makeFailure(i, 'not \"' + input.slice(i, result.index) + '\"')\r\n                : makeSuccess(i, null);\r\n        });\r\n    }\r\n    MonadicParser.notFollowedBy = notFollowedBy;\r\n    function test(predicate) {\r\n        return new MonadicParser(function (input, i) {\r\n            var char = input.charAt(i);\r\n            if (i < input.length && predicate(char)) {\r\n                return makeSuccess(i + 1, char);\r\n            }\r\n            else {\r\n                return makeFailure(i, 'a character ' + predicate);\r\n            }\r\n        });\r\n    }\r\n    MonadicParser.test = test;\r\n    function oneOf(str) {\r\n        return test(function (ch) { return str.indexOf(ch) >= 0; });\r\n    }\r\n    MonadicParser.oneOf = oneOf;\r\n    function noneOf(str) {\r\n        return test(function (ch) { return str.indexOf(ch) < 0; });\r\n    }\r\n    MonadicParser.noneOf = noneOf;\r\n    function range(begin, end) {\r\n        return test(function (ch) { return begin <= ch && ch <= end; }).desc(begin + '-' + end);\r\n    }\r\n    MonadicParser.range = range;\r\n    function takeWhile(predicate) {\r\n        return new MonadicParser(function (input, i) {\r\n            var j = i;\r\n            while (j < input.length && predicate(input.charAt(j))) {\r\n                j++;\r\n            }\r\n            return makeSuccess(j, input.slice(i, j));\r\n        });\r\n    }\r\n    MonadicParser.takeWhile = takeWhile;\r\n    function lazy(f) {\r\n        var parser = new MonadicParser(function (input, i) {\r\n            var a = f()._;\r\n            parser._ = a;\r\n            return a(input, i);\r\n        });\r\n        return parser;\r\n    }\r\n    MonadicParser.lazy = lazy;\r\n    function empty() {\r\n        return fail('empty');\r\n    }\r\n    MonadicParser.empty = empty;\r\n    MonadicParser.index = new MonadicParser(function (input, i) {\r\n        return makeSuccess(i, makeLineColumnIndex(input, i));\r\n    });\r\n    MonadicParser.anyChar = new MonadicParser(function (input, i) {\r\n        if (i >= input.length) {\r\n            return makeFailure(i, 'any character');\r\n        }\r\n        return makeSuccess(i + 1, input.charAt(i));\r\n    });\r\n    MonadicParser.all = new MonadicParser(function (input, i) {\r\n        return makeSuccess(input.length, input.slice(i));\r\n    });\r\n    MonadicParser.eof = new MonadicParser(function (input, i) {\r\n        if (i < input.length) {\r\n            return makeFailure(i, 'EOF');\r\n        }\r\n        return makeSuccess(i, null);\r\n    });\r\n    MonadicParser.digit = regexp(/[0-9]/).desc('a digit');\r\n    MonadicParser.digits = regexp(/[0-9]*/).desc('optional digits');\r\n    MonadicParser.letter = regexp(/[a-z]/i).desc('a letter');\r\n    MonadicParser.letters = regexp(/[a-z]*/i).desc('optional letters');\r\n    MonadicParser.optWhitespace = regexp(/\\s*/).desc('optional whitespace');\r\n    MonadicParser.whitespace = regexp(/\\s+/).desc('whitespace');\r\n    MonadicParser.cr = string('\\r');\r\n    MonadicParser.lf = string('\\n');\r\n    MonadicParser.crlf = string('\\r\\n');\r\n    MonadicParser.newline = alt(MonadicParser.crlf, MonadicParser.lf, MonadicParser.cr).desc('newline');\r\n    MonadicParser.end = alt(MonadicParser.newline, MonadicParser.eof);\r\n})(MonadicParser || (MonadicParser = {}));\r\nfunction seqPick(idx) {\r\n    var parsers = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        parsers[_i - 1] = arguments[_i];\r\n    }\r\n    var numParsers = parsers.length;\r\n    return new MonadicParser(function (input, index) {\r\n        var result;\r\n        var picked;\r\n        var i = index;\r\n        for (var j = 0; j < numParsers; j++) {\r\n            result = mergeReplies(parsers[j]._(input, i), result);\r\n            if (!result.status) {\r\n                return result;\r\n            }\r\n            if (idx === j)\r\n                picked = result.value;\r\n            i = result.index;\r\n        }\r\n        return mergeReplies(makeSuccess(i, picked), result);\r\n    });\r\n}\r\nfunction makeSuccess(index, value) {\r\n    return { status: true, index: index, value: value };\r\n}\r\nfunction makeFailure(index, expected) {\r\n    return { status: false, furthest: index, expected: [expected] };\r\n}\r\nfunction mergeReplies(result, last) {\r\n    if (!last || result.status || last.status || result.furthest > last.furthest) {\r\n        return result;\r\n    }\r\n    var expected = result.furthest === last.furthest\r\n        ? unsafeUnion(result.expected, last.expected)\r\n        : last.expected;\r\n    return { status: result.status, furthest: last.furthest, expected: expected };\r\n}\r\nfunction makeLineColumnIndex(input, i) {\r\n    var lines = input.slice(0, i).split('\\n');\r\n    // Note that unlike the character offset, the line and column offsets are\r\n    // 1-based.\r\n    var lineWeAreUpTo = lines.length;\r\n    var columnWeAreUpTo = lines[lines.length - 1].length + 1;\r\n    return { offset: i, line: lineWeAreUpTo, column: columnWeAreUpTo };\r\n}\r\nfunction formatExpected(expected) {\r\n    if (expected.length === 1) {\r\n        return expected[0];\r\n    }\r\n    return 'one of ' + expected.join(', ');\r\n}\r\nfunction formatGot(input, error) {\r\n    var index = error.index;\r\n    var i = index.offset;\r\n    if (i === input.length) {\r\n        return ', got the end of the input';\r\n    }\r\n    var prefix = i > 0 ? '\\'...' : '\\'';\r\n    var suffix = input.length - i > 12 ? '...\\'' : '\\'';\r\n    return \" at line \" + index.line + \" column \" + index.column + \", got \" + prefix + input.slice(i, i + 12) + suffix;\r\n}\r\nfunction formatError(input, error) {\r\n    return \"expected \" + formatExpected(error.expected) + formatGot(input, error);\r\n}\r\nfunction unsafeUnion(xs, ys) {\r\n    var xn = xs.length;\r\n    var yn = ys.length;\r\n    if (xn === 0)\r\n        return ys;\r\n    else if (yn === 0)\r\n        return xs;\r\n    var set = new Set();\r\n    var ret = [];\r\n    for (var i = 0; i < xn; i++) {\r\n        if (!set.has(xs[i])) {\r\n            ret[ret.length] = xs[i];\r\n            set.add(xs[i]);\r\n        }\r\n    }\r\n    for (var i = 0; i < yn; i++) {\r\n        if (!set.has(ys[i])) {\r\n            ret[ret.length] = ys[i];\r\n            set.add(ys[i]);\r\n        }\r\n    }\r\n    ret.sort();\r\n    return ret;\r\n}\r\nfunction isParser(obj) {\r\n    return obj instanceof MonadicParser;\r\n}\r\n//# sourceMappingURL=monadic-parser.js.map"]},"metadata":{},"sourceType":"module"}