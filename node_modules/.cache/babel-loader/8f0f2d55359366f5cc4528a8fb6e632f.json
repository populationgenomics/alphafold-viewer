{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { UnitsMeshParams, UnitsMeshVisual } from '../../../mol-repr/structure/units-visual';\nimport { Unit, Structure, StructureElement } from '../../../mol-model/structure';\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\nimport { Vec3 } from '../../../mol-math/linear-algebra';\nimport { addEllipsoid } from '../../../mol-geo/geometry/mesh/builder/ellipsoid';\nimport { Axes3D, Sphere3D } from '../../../mol-math/geometry';\nimport { OrderedSet, Interval } from '../../../mol-data/int';\nimport { EmptyLoci } from '../../../mol-model/loci';\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\nexport var OrientationEllipsoidMeshParams = __assign(__assign({}, UnitsMeshParams), {\n  sizeFactor: PD.Numeric(1, {\n    min: 0,\n    max: 2,\n    step: 0.1\n  }),\n  detail: PD.Numeric(0, {\n    min: 0,\n    max: 3,\n    step: 1\n  }, BaseGeometry.CustomQualityParamInfo)\n});\nexport function OrientationEllipsoidMeshVisual(materialId) {\n  return UnitsMeshVisual({\n    defaultProps: PD.getDefaultValues(OrientationEllipsoidMeshParams),\n    createGeometry: createOrientationEllipsoidMesh,\n    createLocationIterator: UnitIterator,\n    getLoci: getUnitLoci,\n    eachLocation: eachUnit,\n    setUpdateState: function (state, newProps, currentProps) {\n      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail;\n    }\n  }, materialId);\n}\n\nfunction isUnitApplicable(unit) {\n  if (Unit.Traits.is(unit.traits, 1\n  /* MultiChain */\n  )) return false;\n  if (Unit.Traits.is(unit.traits, 2\n  /* Partitioned */\n  )) return false;\n  if (Unit.isCoarse(unit)) return true;\n  if (unit.elements.length === 0) return false;\n  unit.model.atomicHierarchy.derived.residue.moleculeType;\n  var rI = unit.residueIndex[unit.elements[0]];\n  var mt = unit.model.atomicHierarchy.derived.residue.moleculeType[rI];\n  if (mt === 3\n  /* Ion */\n  ) return false;\n  if (mt === 2\n  /* Water */\n  ) return false;\n  return true;\n}\n\nexport function createOrientationEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {\n  if (!isUnitApplicable(unit)) return Mesh.createEmpty(mesh);\n  var detail = props.detail,\n      sizeFactor = props.sizeFactor;\n  var vertexCount = 256;\n  var builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\n  var axes = unit.principalAxes.boxAxes;\n  var origin = axes.origin,\n      dirA = axes.dirA,\n      dirB = axes.dirB;\n  var size = Axes3D.size(Vec3(), axes);\n  Vec3.scale(size, size, sizeFactor / 2);\n  var radiusScale = Vec3.create(size[2], size[1], size[0]);\n  builderState.currentGroup = 0;\n  addEllipsoid(builderState, origin, dirA, dirB, radiusScale, detail + 1);\n  var m = MeshBuilder.getMesh(builderState);\n  var sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);\n  m.setBoundingSphere(sphere);\n  return m;\n} //\n\nfunction UnitIterator(structureGroup) {\n  var group = structureGroup.group,\n      structure = structureGroup.structure;\n  var groupCount = 1;\n  var instanceCount = group.units.length;\n  var location = StructureElement.Location.create(structure);\n\n  var getLocation = function (groupIndex, instanceIndex) {\n    var unit = group.units[instanceIndex];\n    location.unit = unit;\n    location.element = unit.elements[groupIndex];\n    return location;\n  };\n\n  return LocationIterator(groupCount, instanceCount, 1, getLocation);\n}\n\nfunction getUnitLoci(pickingId, structureGroup, id) {\n  var objectId = pickingId.objectId,\n      instanceId = pickingId.instanceId;\n\n  if (id === objectId) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    var unit = group.units[instanceId];\n    var indices = OrderedSet.ofBounds(0, unit.elements.length);\n    return StructureElement.Loci(structure, [{\n      unit: unit,\n      indices: indices\n    }]);\n  }\n\n  return EmptyLoci;\n}\n\nfunction eachUnit(loci, structureGroup, apply) {\n  var changed = false;\n  if (!StructureElement.Loci.is(loci)) return false;\n  var structure = structureGroup.structure,\n      group = structureGroup.group;\n  if (!Structure.areEquivalent(loci.structure, structure)) return false;\n  var elementCount = group.elements.length;\n\n  for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\n    var e = _a[_i];\n    var unitIdx = group.unitIndexMap.get(e.unit.id);\n\n    if (unitIdx !== undefined) {\n      if (OrderedSet.size(e.indices) === elementCount) {\n        if (apply(Interval.ofSingleton(unitIdx))) changed = true;\n      }\n    }\n  }\n\n  return changed;\n}","map":{"version":3,"sources":["../../../../src/mol-repr/structure/visual/orientation-ellipsoid-mesh.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { UnitsMeshParams, UnitsMeshVisual } from '../../../mol-repr/structure/units-visual';\r\nimport { Unit, Structure, StructureElement } from '../../../mol-model/structure';\r\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\r\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\r\nimport { Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { addEllipsoid } from '../../../mol-geo/geometry/mesh/builder/ellipsoid';\r\nimport { Axes3D, Sphere3D } from '../../../mol-math/geometry';\r\nimport { OrderedSet, Interval } from '../../../mol-data/int';\r\nimport { EmptyLoci } from '../../../mol-model/loci';\r\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\r\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\r\nexport var OrientationEllipsoidMeshParams = __assign(__assign({}, UnitsMeshParams), { sizeFactor: PD.Numeric(1, { min: 0, max: 2, step: 0.1 }), detail: PD.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo) });\r\nexport function OrientationEllipsoidMeshVisual(materialId) {\r\n    return UnitsMeshVisual({\r\n        defaultProps: PD.getDefaultValues(OrientationEllipsoidMeshParams),\r\n        createGeometry: createOrientationEllipsoidMesh,\r\n        createLocationIterator: UnitIterator,\r\n        getLoci: getUnitLoci,\r\n        eachLocation: eachUnit,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            state.createGeometry = (newProps.sizeFactor !== currentProps.sizeFactor ||\r\n                newProps.detail !== currentProps.detail);\r\n        }\r\n    }, materialId);\r\n}\r\nfunction isUnitApplicable(unit) {\r\n    if (Unit.Traits.is(unit.traits, 1 /* MultiChain */))\r\n        return false;\r\n    if (Unit.Traits.is(unit.traits, 2 /* Partitioned */))\r\n        return false;\r\n    if (Unit.isCoarse(unit))\r\n        return true;\r\n    if (unit.elements.length === 0)\r\n        return false;\r\n    unit.model.atomicHierarchy.derived.residue.moleculeType;\r\n    var rI = unit.residueIndex[unit.elements[0]];\r\n    var mt = unit.model.atomicHierarchy.derived.residue.moleculeType[rI];\r\n    if (mt === 3 /* Ion */)\r\n        return false;\r\n    if (mt === 2 /* Water */)\r\n        return false;\r\n    return true;\r\n}\r\nexport function createOrientationEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {\r\n    if (!isUnitApplicable(unit))\r\n        return Mesh.createEmpty(mesh);\r\n    var detail = props.detail, sizeFactor = props.sizeFactor;\r\n    var vertexCount = 256;\r\n    var builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\r\n    var axes = unit.principalAxes.boxAxes;\r\n    var origin = axes.origin, dirA = axes.dirA, dirB = axes.dirB;\r\n    var size = Axes3D.size(Vec3(), axes);\r\n    Vec3.scale(size, size, sizeFactor / 2);\r\n    var radiusScale = Vec3.create(size[2], size[1], size[0]);\r\n    builderState.currentGroup = 0;\r\n    addEllipsoid(builderState, origin, dirA, dirB, radiusScale, detail + 1);\r\n    var m = MeshBuilder.getMesh(builderState);\r\n    var sphere = Sphere3D.expand(Sphere3D(), unit.boundary.sphere, 1 * props.sizeFactor);\r\n    m.setBoundingSphere(sphere);\r\n    return m;\r\n}\r\n//\r\nfunction UnitIterator(structureGroup) {\r\n    var group = structureGroup.group, structure = structureGroup.structure;\r\n    var groupCount = 1;\r\n    var instanceCount = group.units.length;\r\n    var location = StructureElement.Location.create(structure);\r\n    var getLocation = function (groupIndex, instanceIndex) {\r\n        var unit = group.units[instanceIndex];\r\n        location.unit = unit;\r\n        location.element = unit.elements[groupIndex];\r\n        return location;\r\n    };\r\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n}\r\nfunction getUnitLoci(pickingId, structureGroup, id) {\r\n    var objectId = pickingId.objectId, instanceId = pickingId.instanceId;\r\n    if (id === objectId) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        var unit = group.units[instanceId];\r\n        var indices = OrderedSet.ofBounds(0, unit.elements.length);\r\n        return StructureElement.Loci(structure, [{ unit: unit, indices: indices }]);\r\n    }\r\n    return EmptyLoci;\r\n}\r\nfunction eachUnit(loci, structureGroup, apply) {\r\n    var changed = false;\r\n    if (!StructureElement.Loci.is(loci))\r\n        return false;\r\n    var structure = structureGroup.structure, group = structureGroup.group;\r\n    if (!Structure.areEquivalent(loci.structure, structure))\r\n        return false;\r\n    var elementCount = group.elements.length;\r\n    for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\r\n        var e = _a[_i];\r\n        var unitIdx = group.unitIndexMap.get(e.unit.id);\r\n        if (unitIdx !== undefined) {\r\n            if (OrderedSet.size(e.indices) === elementCount) {\r\n                if (apply(Interval.ofSingleton(unitIdx)))\r\n                    changed = true;\r\n            }\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n//# sourceMappingURL=orientation-ellipsoid-mesh.js.map"]},"metadata":{},"sourceType":"module"}