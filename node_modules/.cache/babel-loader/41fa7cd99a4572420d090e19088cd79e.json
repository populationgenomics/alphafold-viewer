{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nfunction shouldExtendLadder(ladder, bridge) {\n  // in order to extend ladders, same type must be present\n  if (bridge.type !== ladder.type) return false; // only extend if residue 1 is sequence neighbor with regard to ladder\n\n  if (bridge.partner1 !== ladder.firstEnd + 1) return false;\n\n  if (bridge.type === 0\n  /* PARALLEL */\n  ) {\n    if (bridge.partner2 === ladder.secondEnd + 1) {\n      return true;\n    }\n  } else {\n    if (bridge.partner2 === ladder.secondStart - 1) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\r\n * For beta structures, we define: a bulge-linked ladder consists of two ladders or bridges of the same type\r\n * connected by at most one extra residue of one strand and at most four extra residues  on the other strand,\r\n * all residues in bulge-linked ladders are marked E, including any extra residues.\r\n */\n\n\nfunction resemblesBulge(ladder1, ladder2) {\n  if (!(ladder1.type === ladder2.type && ladder2.firstStart - ladder1.firstEnd < 6 && ladder1.firstStart < ladder2.firstStart && ladder2.nextLadder === 0)) return false;\n\n  if (ladder1.type === 0\n  /* PARALLEL */\n  ) {\n    return bulgeCriterion2(ladder1, ladder2);\n  } else {\n    return bulgeCriterion2(ladder2, ladder1);\n  }\n}\n\nfunction bulgeCriterion2(ladder1, ladder2) {\n  return ladder2.secondStart - ladder1.secondEnd > 0 && (ladder2.secondStart - ladder1.secondEnd < 6 && ladder2.firstStart - ladder1.firstEnd < 3 || ladder2.secondStart - ladder1.secondEnd < 3);\n}\n/**\r\n * ladder=: set of one or more consecutive bridges of identical type\r\n *\r\n * Type: E\r\n */\n\n\nexport function assignLadders(ctx) {\n  var bridges = ctx.bridges,\n      ladders = ctx.ladders; // create ladders\n\n  for (var bridgeIndex = 0; bridgeIndex < bridges.length; bridgeIndex++) {\n    var bridge = bridges[bridgeIndex];\n    var found = false;\n\n    for (var ladderIndex = 0; ladderIndex < ladders.length; ladderIndex++) {\n      var ladder = ladders[ladderIndex];\n\n      if (shouldExtendLadder(ladder, bridge)) {\n        found = true;\n        ladder.firstEnd++;\n\n        if (bridge.type === 0\n        /* PARALLEL */\n        ) {\n          ladder.secondEnd++;\n        } else {\n          ladder.secondStart--;\n        }\n      }\n    } // no suitable assignment: create new ladder with single bridge as content\n\n\n    if (!found) {\n      ladders[ladders.length] = {\n        previousLadder: 0,\n        nextLadder: 0,\n        firstStart: bridge.partner1,\n        firstEnd: bridge.partner1,\n        secondStart: bridge.partner2,\n        secondEnd: bridge.partner2,\n        type: bridge.type\n      };\n    }\n  } // connect ladders\n\n\n  for (var ladderIndex1 = 0; ladderIndex1 < ladders.length; ladderIndex1++) {\n    var ladder1 = ladders[ladderIndex1];\n\n    for (var ladderIndex2 = ladderIndex1; ladderIndex2 < ladders.length; ladderIndex2++) {\n      var ladder2 = ladders[ladderIndex2];\n\n      if (resemblesBulge(ladder1, ladder2)) {\n        ladder1.nextLadder = ladderIndex2;\n        ladder2.previousLadder = ladderIndex1;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/ladders.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nfunction shouldExtendLadder(ladder, bridge) {\r\n    // in order to extend ladders, same type must be present\r\n    if (bridge.type !== ladder.type)\r\n        return false;\r\n    // only extend if residue 1 is sequence neighbor with regard to ladder\r\n    if (bridge.partner1 !== ladder.firstEnd + 1)\r\n        return false;\r\n    if (bridge.type === 0 /* PARALLEL */) {\r\n        if (bridge.partner2 === ladder.secondEnd + 1) {\r\n            return true;\r\n        }\r\n    }\r\n    else {\r\n        if (bridge.partner2 === ladder.secondStart - 1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * For beta structures, we define: a bulge-linked ladder consists of two ladders or bridges of the same type\r\n * connected by at most one extra residue of one strand and at most four extra residues  on the other strand,\r\n * all residues in bulge-linked ladders are marked E, including any extra residues.\r\n */\r\nfunction resemblesBulge(ladder1, ladder2) {\r\n    if (!(ladder1.type === ladder2.type && ladder2.firstStart - ladder1.firstEnd < 6 &&\r\n        ladder1.firstStart < ladder2.firstStart && ladder2.nextLadder === 0))\r\n        return false;\r\n    if (ladder1.type === 0 /* PARALLEL */) {\r\n        return bulgeCriterion2(ladder1, ladder2);\r\n    }\r\n    else {\r\n        return bulgeCriterion2(ladder2, ladder1);\r\n    }\r\n}\r\nfunction bulgeCriterion2(ladder1, ladder2) {\r\n    return ladder2.secondStart - ladder1.secondEnd > 0 && ((ladder2.secondStart - ladder1.secondEnd < 6 &&\r\n        ladder2.firstStart - ladder1.firstEnd < 3) || ladder2.secondStart - ladder1.secondEnd < 3);\r\n}\r\n/**\r\n * ladder=: set of one or more consecutive bridges of identical type\r\n *\r\n * Type: E\r\n */\r\nexport function assignLadders(ctx) {\r\n    var bridges = ctx.bridges, ladders = ctx.ladders;\r\n    // create ladders\r\n    for (var bridgeIndex = 0; bridgeIndex < bridges.length; bridgeIndex++) {\r\n        var bridge = bridges[bridgeIndex];\r\n        var found = false;\r\n        for (var ladderIndex = 0; ladderIndex < ladders.length; ladderIndex++) {\r\n            var ladder = ladders[ladderIndex];\r\n            if (shouldExtendLadder(ladder, bridge)) {\r\n                found = true;\r\n                ladder.firstEnd++;\r\n                if (bridge.type === 0 /* PARALLEL */) {\r\n                    ladder.secondEnd++;\r\n                }\r\n                else {\r\n                    ladder.secondStart--;\r\n                }\r\n            }\r\n        }\r\n        // no suitable assignment: create new ladder with single bridge as content\r\n        if (!found) {\r\n            ladders[ladders.length] = {\r\n                previousLadder: 0,\r\n                nextLadder: 0,\r\n                firstStart: bridge.partner1,\r\n                firstEnd: bridge.partner1,\r\n                secondStart: bridge.partner2,\r\n                secondEnd: bridge.partner2,\r\n                type: bridge.type\r\n            };\r\n        }\r\n    }\r\n    // connect ladders\r\n    for (var ladderIndex1 = 0; ladderIndex1 < ladders.length; ladderIndex1++) {\r\n        var ladder1 = ladders[ladderIndex1];\r\n        for (var ladderIndex2 = ladderIndex1; ladderIndex2 < ladders.length; ladderIndex2++) {\r\n            var ladder2 = ladders[ladderIndex2];\r\n            if (resemblesBulge(ladder1, ladder2)) {\r\n                ladder1.nextLadder = ladderIndex2;\r\n                ladder2.previousLadder = ladderIndex1;\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=ladders.js.map"]},"metadata":{},"sourceType":"module"}