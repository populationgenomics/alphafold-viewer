{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Task } from '../task';\nimport { now } from '../../mol-util/now';\nimport { Scheduler } from '../util/scheduler';\nimport { UserTiming } from '../util/user-timing';\nimport { isDebugMode } from '../../mol-util/debug';\nexport function ExecuteObservable(task, observer, updateRateMs) {\n  if (updateRateMs === void 0) {\n    updateRateMs = 250;\n  }\n\n  var info = ProgressInfo(task, observer, updateRateMs);\n  var ctx = new ObservableRuntimeContext(info, info.root);\n  return execute(task, ctx);\n}\nexport function CreateObservableCtx(task, observer, updateRateMs) {\n  if (updateRateMs === void 0) {\n    updateRateMs = 250;\n  }\n\n  var info = ProgressInfo(task, observer, updateRateMs);\n  return new ObservableRuntimeContext(info, info.root);\n}\nexport function ExecuteInContext(ctx, task) {\n  return execute(task, ctx);\n}\nexport function ExecuteObservableChild(ctx, task, progress) {\n  return ctx.runChild(task, progress);\n}\n\nfunction defaultProgress(task) {\n  return {\n    taskId: task.id,\n    taskName: task.name,\n    message: '',\n    startedTime: 0,\n    canAbort: true,\n    isIndeterminate: true,\n    current: 0,\n    max: 0\n  };\n}\n\nfunction ProgressInfo(task, observer, updateRateMs) {\n  var abortToken = {\n    abortRequested: false,\n    treeAborted: false,\n    reason: ''\n  };\n  return {\n    updateRateMs: updateRateMs,\n    lastNotified: now(),\n    observer: observer,\n    abortToken: abortToken,\n    taskId: task.id,\n    root: {\n      progress: defaultProgress(task),\n      children: []\n    },\n    tryAbort: createAbortFunction(abortToken)\n  };\n}\n\nfunction createAbortFunction(token) {\n  return function (reason) {\n    token.abortRequested = true;\n    token.reason = reason || token.reason;\n  };\n}\n\nfunction cloneTree(root) {\n  return {\n    progress: __assign({}, root.progress),\n    children: root.children.map(cloneTree)\n  };\n}\n\nfunction canAbort(root) {\n  return root.progress.canAbort && root.children.every(canAbort);\n}\n\nfunction snapshotProgress(info) {\n  return {\n    root: cloneTree(info.root),\n    canAbort: canAbort(info.root),\n    requestAbort: info.tryAbort\n  };\n}\n\nfunction execute(task, ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var ret, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          UserTiming.markStart(task);\n          ctx.node.progress.startedTime = now();\n          _a.label = 1;\n\n        case 1:\n          _a.trys.push([1, 3,, 7]);\n\n          return [4\n          /*yield*/\n          , task.f(ctx)];\n\n        case 2:\n          ret = _a.sent();\n          UserTiming.markEnd(task);\n          UserTiming.measure(task);\n\n          if (ctx.info.abortToken.abortRequested) {\n            abort(ctx.info);\n          }\n\n          return [2\n          /*return*/\n          , ret];\n\n        case 3:\n          e_1 = _a.sent();\n          if (!Task.isAbort(e_1)) return [3\n          /*break*/\n          , 6];\n          ctx.isAborted = true;\n          if (!(ctx.node.children.length > 0)) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , new Promise(function (res) {\n            ctx.onChildrenFinished = res;\n          })];\n\n        case 4:\n          _a.sent();\n\n          _a.label = 5;\n\n        case 5:\n          if (task.onAbort) {\n            task.onAbort();\n          }\n\n          _a.label = 6;\n\n        case 6:\n          if (isDebugMode) console.error(e_1);\n          throw e_1;\n\n        case 7:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction abort(info) {\n  if (!info.abortToken.treeAborted) {\n    info.abortToken.treeAborted = true;\n    abortTree(info.root);\n    notifyObserver(info, now());\n  }\n\n  throw Task.Aborted(info.abortToken.reason);\n}\n\nfunction abortTree(root) {\n  var progress = root.progress;\n  progress.isIndeterminate = true;\n  progress.canAbort = false;\n  progress.message = 'Aborting...';\n\n  for (var _a = 0, _b = root.children; _a < _b.length; _a++) {\n    var c = _b[_a];\n    abortTree(c);\n  }\n} // function shouldNotify(info: ProgressInfo, time: number) {\n//     return time - info.lastNotified > info.updateRateMs;\n// }\n\n\nfunction notifyObserver(info, time) {\n  info.lastNotified = time;\n  var snapshot = snapshotProgress(info);\n  info.observer(snapshot);\n}\n\nvar ObservableRuntimeContext =\n/** @class */\nfunction () {\n  function ObservableRuntimeContext(info, node) {\n    this.isSynchronous = false;\n    this.isExecuting = true;\n    this.lastUpdatedTime = 0; // used for waiting for cancelled computation trees\n\n    this.onChildrenFinished = void 0;\n    this.node = node;\n    this.info = info;\n  }\n\n  ObservableRuntimeContext.prototype.checkAborted = function () {\n    if (this.info.abortToken.abortRequested) {\n      this.isAborted = true;\n      abort(this.info);\n    }\n  };\n\n  Object.defineProperty(ObservableRuntimeContext.prototype, \"shouldUpdate\", {\n    get: function () {\n      this.checkAborted();\n      return now() - this.lastUpdatedTime > this.info.updateRateMs;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ObservableRuntimeContext.prototype.updateProgress = function (update) {\n    this.checkAborted();\n    if (!update) return;\n    var progress = this.node.progress;\n\n    if (typeof update === 'string') {\n      progress.message = update;\n      progress.isIndeterminate = true;\n    } else {\n      if (typeof update.canAbort !== 'undefined') progress.canAbort = update.canAbort;\n      if (typeof update.message !== 'undefined') progress.message = update.message;\n      if (typeof update.current !== 'undefined') progress.current = update.current;\n      if (typeof update.max !== 'undefined') progress.max = update.max;\n      progress.isIndeterminate = typeof progress.current === 'undefined' || typeof progress.max === 'undefined';\n      if (typeof update.isIndeterminate !== 'undefined') progress.isIndeterminate = update.isIndeterminate;\n    }\n  };\n\n  ObservableRuntimeContext.prototype.update = function (progress, dontNotify) {\n    // The progress tracking and observer notification are separated\n    // because the computation can have a tree structure.\n    // All nodes of the tree should be regualarly updated at the specified frequency,\n    // however, the notification should only be invoked once per the whole tree.\n    this.lastUpdatedTime = now();\n    this.updateProgress(progress); // TODO: do the shouldNotify check here?\n\n    if (!!dontNotify\n    /* || !shouldNotify(this.info, this.lastUpdatedTime)*/\n    ) return;\n    notifyObserver(this.info, this.lastUpdatedTime); // The computation could have been aborted during the notifycation phase.\n\n    this.checkAborted();\n    return Scheduler.immediatePromise();\n  };\n\n  ObservableRuntimeContext.prototype.runChild = function (task, progress) {\n    return __awaiter(this, void 0, void 0, function () {\n      var node, children, ctx, e_2, idx, i, _i;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.updateProgress(progress);\n            node = {\n              progress: defaultProgress(task),\n              children: []\n            };\n            children = this.node.children;\n            children.push(node);\n            ctx = new ObservableRuntimeContext(this.info, node);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n\n            return [4\n            /*yield*/\n            , execute(task, ctx)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_2 = _a.sent();\n\n            if (Task.isAbort(e_2)) {\n              // need to catch the error here because otherwise\n              // promises for running child tasks in a tree-like computation\n              // will get orphaned and cause \"uncaught error in Promise\".\n              if (this.isAborted) return [2\n              /*return*/\n              , void 0];\n            }\n\n            throw e_2;\n\n          case 4:\n            idx = children.indexOf(node);\n\n            if (idx >= 0) {\n              for (i = idx, _i = children.length - 1; i < _i; i++) {\n                children[i] = children[i + 1];\n              }\n\n              children.pop();\n            }\n\n            if (children.length === 0 && this.onChildrenFinished) this.onChildrenFinished();\n            return [7\n            /*endfinally*/\n            ];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return ObservableRuntimeContext;\n}();","map":{"version":3,"sources":["../../../src/mol-task/execution/observable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../task';\r\nimport { now } from '../../mol-util/now';\r\nimport { Scheduler } from '../util/scheduler';\r\nimport { UserTiming } from '../util/user-timing';\r\nimport { isDebugMode } from '../../mol-util/debug';\r\nexport function ExecuteObservable(task, observer, updateRateMs) {\r\n    if (updateRateMs === void 0) { updateRateMs = 250; }\r\n    var info = ProgressInfo(task, observer, updateRateMs);\r\n    var ctx = new ObservableRuntimeContext(info, info.root);\r\n    return execute(task, ctx);\r\n}\r\nexport function CreateObservableCtx(task, observer, updateRateMs) {\r\n    if (updateRateMs === void 0) { updateRateMs = 250; }\r\n    var info = ProgressInfo(task, observer, updateRateMs);\r\n    return new ObservableRuntimeContext(info, info.root);\r\n}\r\nexport function ExecuteInContext(ctx, task) {\r\n    return execute(task, ctx);\r\n}\r\nexport function ExecuteObservableChild(ctx, task, progress) {\r\n    return ctx.runChild(task, progress);\r\n}\r\nfunction defaultProgress(task) {\r\n    return {\r\n        taskId: task.id,\r\n        taskName: task.name,\r\n        message: '',\r\n        startedTime: 0,\r\n        canAbort: true,\r\n        isIndeterminate: true,\r\n        current: 0,\r\n        max: 0\r\n    };\r\n}\r\nfunction ProgressInfo(task, observer, updateRateMs) {\r\n    var abortToken = { abortRequested: false, treeAborted: false, reason: '' };\r\n    return {\r\n        updateRateMs: updateRateMs,\r\n        lastNotified: now(),\r\n        observer: observer,\r\n        abortToken: abortToken,\r\n        taskId: task.id,\r\n        root: { progress: defaultProgress(task), children: [] },\r\n        tryAbort: createAbortFunction(abortToken)\r\n    };\r\n}\r\nfunction createAbortFunction(token) {\r\n    return function (reason) {\r\n        token.abortRequested = true;\r\n        token.reason = reason || token.reason;\r\n    };\r\n}\r\nfunction cloneTree(root) {\r\n    return { progress: __assign({}, root.progress), children: root.children.map(cloneTree) };\r\n}\r\nfunction canAbort(root) {\r\n    return root.progress.canAbort && root.children.every(canAbort);\r\n}\r\nfunction snapshotProgress(info) {\r\n    return { root: cloneTree(info.root), canAbort: canAbort(info.root), requestAbort: info.tryAbort };\r\n}\r\nfunction execute(task, ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ret, e_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    UserTiming.markStart(task);\r\n                    ctx.node.progress.startedTime = now();\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 7]);\r\n                    return [4 /*yield*/, task.f(ctx)];\r\n                case 2:\r\n                    ret = _a.sent();\r\n                    UserTiming.markEnd(task);\r\n                    UserTiming.measure(task);\r\n                    if (ctx.info.abortToken.abortRequested) {\r\n                        abort(ctx.info);\r\n                    }\r\n                    return [2 /*return*/, ret];\r\n                case 3:\r\n                    e_1 = _a.sent();\r\n                    if (!Task.isAbort(e_1)) return [3 /*break*/, 6];\r\n                    ctx.isAborted = true;\r\n                    if (!(ctx.node.children.length > 0)) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, new Promise(function (res) { ctx.onChildrenFinished = res; })];\r\n                case 4:\r\n                    _a.sent();\r\n                    _a.label = 5;\r\n                case 5:\r\n                    if (task.onAbort) {\r\n                        task.onAbort();\r\n                    }\r\n                    _a.label = 6;\r\n                case 6:\r\n                    if (isDebugMode)\r\n                        console.error(e_1);\r\n                    throw e_1;\r\n                case 7: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction abort(info) {\r\n    if (!info.abortToken.treeAborted) {\r\n        info.abortToken.treeAborted = true;\r\n        abortTree(info.root);\r\n        notifyObserver(info, now());\r\n    }\r\n    throw Task.Aborted(info.abortToken.reason);\r\n}\r\nfunction abortTree(root) {\r\n    var progress = root.progress;\r\n    progress.isIndeterminate = true;\r\n    progress.canAbort = false;\r\n    progress.message = 'Aborting...';\r\n    for (var _a = 0, _b = root.children; _a < _b.length; _a++) {\r\n        var c = _b[_a];\r\n        abortTree(c);\r\n    }\r\n}\r\n// function shouldNotify(info: ProgressInfo, time: number) {\r\n//     return time - info.lastNotified > info.updateRateMs;\r\n// }\r\nfunction notifyObserver(info, time) {\r\n    info.lastNotified = time;\r\n    var snapshot = snapshotProgress(info);\r\n    info.observer(snapshot);\r\n}\r\nvar ObservableRuntimeContext = /** @class */ (function () {\r\n    function ObservableRuntimeContext(info, node) {\r\n        this.isSynchronous = false;\r\n        this.isExecuting = true;\r\n        this.lastUpdatedTime = 0;\r\n        // used for waiting for cancelled computation trees\r\n        this.onChildrenFinished = void 0;\r\n        this.node = node;\r\n        this.info = info;\r\n    }\r\n    ObservableRuntimeContext.prototype.checkAborted = function () {\r\n        if (this.info.abortToken.abortRequested) {\r\n            this.isAborted = true;\r\n            abort(this.info);\r\n        }\r\n    };\r\n    Object.defineProperty(ObservableRuntimeContext.prototype, \"shouldUpdate\", {\r\n        get: function () {\r\n            this.checkAborted();\r\n            return now() - this.lastUpdatedTime > this.info.updateRateMs;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    ObservableRuntimeContext.prototype.updateProgress = function (update) {\r\n        this.checkAborted();\r\n        if (!update)\r\n            return;\r\n        var progress = this.node.progress;\r\n        if (typeof update === 'string') {\r\n            progress.message = update;\r\n            progress.isIndeterminate = true;\r\n        }\r\n        else {\r\n            if (typeof update.canAbort !== 'undefined')\r\n                progress.canAbort = update.canAbort;\r\n            if (typeof update.message !== 'undefined')\r\n                progress.message = update.message;\r\n            if (typeof update.current !== 'undefined')\r\n                progress.current = update.current;\r\n            if (typeof update.max !== 'undefined')\r\n                progress.max = update.max;\r\n            progress.isIndeterminate = typeof progress.current === 'undefined' || typeof progress.max === 'undefined';\r\n            if (typeof update.isIndeterminate !== 'undefined')\r\n                progress.isIndeterminate = update.isIndeterminate;\r\n        }\r\n    };\r\n    ObservableRuntimeContext.prototype.update = function (progress, dontNotify) {\r\n        // The progress tracking and observer notification are separated\r\n        // because the computation can have a tree structure.\r\n        // All nodes of the tree should be regualarly updated at the specified frequency,\r\n        // however, the notification should only be invoked once per the whole tree.\r\n        this.lastUpdatedTime = now();\r\n        this.updateProgress(progress);\r\n        // TODO: do the shouldNotify check here?\r\n        if (!!dontNotify /* || !shouldNotify(this.info, this.lastUpdatedTime)*/)\r\n            return;\r\n        notifyObserver(this.info, this.lastUpdatedTime);\r\n        // The computation could have been aborted during the notifycation phase.\r\n        this.checkAborted();\r\n        return Scheduler.immediatePromise();\r\n    };\r\n    ObservableRuntimeContext.prototype.runChild = function (task, progress) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var node, children, ctx, e_2, idx, i, _i;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.updateProgress(progress);\r\n                        node = { progress: defaultProgress(task), children: [] };\r\n                        children = this.node.children;\r\n                        children.push(node);\r\n                        ctx = new ObservableRuntimeContext(this.info, node);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, 4, 5]);\r\n                        return [4 /*yield*/, execute(task, ctx)];\r\n                    case 2: return [2 /*return*/, _a.sent()];\r\n                    case 3:\r\n                        e_2 = _a.sent();\r\n                        if (Task.isAbort(e_2)) {\r\n                            // need to catch the error here because otherwise\r\n                            // promises for running child tasks in a tree-like computation\r\n                            // will get orphaned and cause \"uncaught error in Promise\".\r\n                            if (this.isAborted)\r\n                                return [2 /*return*/, void 0];\r\n                        }\r\n                        throw e_2;\r\n                    case 4:\r\n                        idx = children.indexOf(node);\r\n                        if (idx >= 0) {\r\n                            for (i = idx, _i = children.length - 1; i < _i; i++) {\r\n                                children[i] = children[i + 1];\r\n                            }\r\n                            children.pop();\r\n                        }\r\n                        if (children.length === 0 && this.onChildrenFinished)\r\n                            this.onChildrenFinished();\r\n                        return [7 /*endfinally*/];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ObservableRuntimeContext;\r\n}());\r\n//# sourceMappingURL=observable.js.map"]},"metadata":{},"sourceType":"module"}