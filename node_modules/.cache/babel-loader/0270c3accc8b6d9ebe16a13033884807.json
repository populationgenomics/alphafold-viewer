{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { OrderedSet } from '../ordered-set';\nimport { Interval } from '../interval';\nimport { SortedArray } from '../sorted-array';\nexport function create(values) {\n  var offsets = SortedArray.ofSortedArray(values);\n  var max = SortedArray.max(offsets);\n  var index = new Int32Array(max);\n\n  for (var i = 0, _i = values.length - 1; i < _i; i++) {\n    for (var j = values[i], _j = values[i + 1]; j < _j; j++) {\n      index[j] = i;\n    }\n  }\n\n  return {\n    offsets: offsets,\n    index: index,\n    count: values.length - 1\n  };\n}\nexport function ofOffsets(offsets, bounds) {\n  var s = Interval.start(bounds);\n  var segments = new Int32Array(offsets.length + 1);\n\n  for (var i = 0, _i = offsets.length; i < _i; i++) {\n    segments[i] = offsets[i] - s;\n  }\n\n  segments[offsets.length] = Interval.end(bounds) - s;\n  return create(segments);\n}\n/** Get number of segments in a segmentation */\n\nexport function count(_a) {\n  var count = _a.count;\n  return count;\n}\nexport function getSegment(_a, value) {\n  var index = _a.index;\n  return index[value];\n}\nexport function projectValue(_a, set, value) {\n  var offsets = _a.offsets;\n  var last = OrderedSet.max(offsets);\n  var idx = value >= last ? -1 : OrderedSet.findPredecessorIndex(offsets, value - 1);\n  return OrderedSet.findRange(set, OrderedSet.getAt(offsets, idx), OrderedSet.getAt(offsets, idx + 1) - 1);\n}\n\nvar SegmentIterator =\n/** @class */\nfunction () {\n  function SegmentIterator(segments, segmentMap, set, inputRange) {\n    this.segments = segments;\n    this.segmentMap = segmentMap;\n    this.set = set;\n    this.segmentMin = 0;\n    this.segmentMax = 0;\n    this.setRange = Interval.Empty;\n    this.value = {\n      index: 0,\n      start: 0,\n      end: 0\n    };\n    this.hasNext = false;\n    this.setRange = inputRange;\n    this.updateSegmentRange();\n  }\n\n  SegmentIterator.prototype.move = function () {\n    while (this.hasNext) {\n      if (this.updateValue()) {\n        this.value.index = this.segmentMin++;\n        this.hasNext = this.segmentMax >= this.segmentMin && Interval.size(this.setRange) > 0;\n        break;\n      } else {\n        this.updateSegmentRange();\n      }\n    }\n\n    return this.value;\n  };\n\n  SegmentIterator.prototype.updateValue = function () {\n    var segmentEnd = this.segments[this.segmentMin + 1]; // TODO: add optimized version for interval and array?\n\n    var setEnd = OrderedSet.findPredecessorIndexInInterval(this.set, segmentEnd, this.setRange);\n    this.value.start = Interval.start(this.setRange);\n    this.value.end = setEnd;\n    this.setRange = Interval.ofBounds(setEnd, Interval.end(this.setRange));\n    return setEnd > this.value.start;\n  };\n\n  SegmentIterator.prototype.updateSegmentRange = function () {\n    var sMin = Interval.min(this.setRange),\n        sMax = Interval.max(this.setRange);\n\n    if (sMax < sMin) {\n      this.hasNext = false;\n      return;\n    }\n\n    this.segmentMin = this.segmentMap[OrderedSet.getAt(this.set, sMin)];\n    this.segmentMax = this.segmentMap[OrderedSet.getAt(this.set, sMax)];\n    this.hasNext = this.segmentMax >= this.segmentMin;\n  };\n\n  SegmentIterator.prototype.setSegment = function (segment) {\n    this.setRange = Interval.ofBounds(segment.start, segment.end);\n    this.updateSegmentRange();\n  };\n\n  return SegmentIterator;\n}();\n\nexport { SegmentIterator };\nexport function segments(segs, set, segment) {\n  var int = typeof segment !== 'undefined' ? Interval.ofBounds(segment.start, segment.end) : Interval.ofBounds(0, OrderedSet.size(set));\n  return new SegmentIterator(segs.offsets, segs.index, set, int);\n}","map":{"version":3,"sources":["../../../../src/mol-data/int/impl/segmentation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { OrderedSet } from '../ordered-set';\r\nimport { Interval } from '../interval';\r\nimport { SortedArray } from '../sorted-array';\r\nexport function create(values) {\r\n    var offsets = SortedArray.ofSortedArray(values);\r\n    var max = SortedArray.max(offsets);\r\n    var index = new Int32Array(max);\r\n    for (var i = 0, _i = values.length - 1; i < _i; i++) {\r\n        for (var j = values[i], _j = values[i + 1]; j < _j; j++) {\r\n            index[j] = i;\r\n        }\r\n    }\r\n    return { offsets: offsets, index: index, count: values.length - 1 };\r\n}\r\nexport function ofOffsets(offsets, bounds) {\r\n    var s = Interval.start(bounds);\r\n    var segments = new Int32Array(offsets.length + 1);\r\n    for (var i = 0, _i = offsets.length; i < _i; i++) {\r\n        segments[i] = offsets[i] - s;\r\n    }\r\n    segments[offsets.length] = Interval.end(bounds) - s;\r\n    return create(segments);\r\n}\r\n/** Get number of segments in a segmentation */\r\nexport function count(_a) {\r\n    var count = _a.count;\r\n    return count;\r\n}\r\nexport function getSegment(_a, value) {\r\n    var index = _a.index;\r\n    return index[value];\r\n}\r\nexport function projectValue(_a, set, value) {\r\n    var offsets = _a.offsets;\r\n    var last = OrderedSet.max(offsets);\r\n    var idx = value >= last ? -1 : OrderedSet.findPredecessorIndex(offsets, value - 1);\r\n    return OrderedSet.findRange(set, OrderedSet.getAt(offsets, idx), OrderedSet.getAt(offsets, idx + 1) - 1);\r\n}\r\nvar SegmentIterator = /** @class */ (function () {\r\n    function SegmentIterator(segments, segmentMap, set, inputRange) {\r\n        this.segments = segments;\r\n        this.segmentMap = segmentMap;\r\n        this.set = set;\r\n        this.segmentMin = 0;\r\n        this.segmentMax = 0;\r\n        this.setRange = Interval.Empty;\r\n        this.value = { index: 0, start: 0, end: 0 };\r\n        this.hasNext = false;\r\n        this.setRange = inputRange;\r\n        this.updateSegmentRange();\r\n    }\r\n    SegmentIterator.prototype.move = function () {\r\n        while (this.hasNext) {\r\n            if (this.updateValue()) {\r\n                this.value.index = this.segmentMin++;\r\n                this.hasNext = this.segmentMax >= this.segmentMin && Interval.size(this.setRange) > 0;\r\n                break;\r\n            }\r\n            else {\r\n                this.updateSegmentRange();\r\n            }\r\n        }\r\n        return this.value;\r\n    };\r\n    SegmentIterator.prototype.updateValue = function () {\r\n        var segmentEnd = this.segments[this.segmentMin + 1];\r\n        // TODO: add optimized version for interval and array?\r\n        var setEnd = OrderedSet.findPredecessorIndexInInterval(this.set, segmentEnd, this.setRange);\r\n        this.value.start = Interval.start(this.setRange);\r\n        this.value.end = setEnd;\r\n        this.setRange = Interval.ofBounds(setEnd, Interval.end(this.setRange));\r\n        return setEnd > this.value.start;\r\n    };\r\n    SegmentIterator.prototype.updateSegmentRange = function () {\r\n        var sMin = Interval.min(this.setRange), sMax = Interval.max(this.setRange);\r\n        if (sMax < sMin) {\r\n            this.hasNext = false;\r\n            return;\r\n        }\r\n        this.segmentMin = this.segmentMap[OrderedSet.getAt(this.set, sMin)];\r\n        this.segmentMax = this.segmentMap[OrderedSet.getAt(this.set, sMax)];\r\n        this.hasNext = this.segmentMax >= this.segmentMin;\r\n    };\r\n    SegmentIterator.prototype.setSegment = function (segment) {\r\n        this.setRange = Interval.ofBounds(segment.start, segment.end);\r\n        this.updateSegmentRange();\r\n    };\r\n    return SegmentIterator;\r\n}());\r\nexport { SegmentIterator };\r\nexport function segments(segs, set, segment) {\r\n    var int = typeof segment !== 'undefined' ? Interval.ofBounds(segment.start, segment.end) : Interval.ofBounds(0, OrderedSet.size(set));\r\n    return new SegmentIterator(segs.offsets, segs.index, set, int);\r\n}\r\n//# sourceMappingURL=segmentation.js.map"]},"metadata":{},"sourceType":"module"}