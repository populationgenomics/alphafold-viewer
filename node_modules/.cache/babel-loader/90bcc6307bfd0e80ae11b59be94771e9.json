{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { transpileMolScript } from './script/mol-script/symbols';\nimport { parseMolScript } from './language/parser';\nimport { QueryContext, StructureSelection } from '../mol-model/structure';\nimport { compile } from './runtime/query/compiler';\nimport { MolScriptBuilder } from './language/builder';\nexport { Script };\n\nfunction Script(expression, language) {\n  return {\n    expression: expression,\n    language: language\n  };\n}\n\n(function (Script) {\n  function is(x) {\n    return !!x && typeof x.expression === 'string' && !!x.language;\n  }\n\n  Script.is = is;\n\n  function areEqual(a, b) {\n    return a.language === b.language && a.expression === b.expression;\n  }\n\n  Script.areEqual = areEqual;\n\n  function toExpression(script) {\n    switch (script.language) {\n      case 'mol-script':\n        var parsed = parseMolScript(script.expression);\n        if (parsed.length === 0) throw new Error('No query');\n        return transpileMolScript(parsed[0]);\n    }\n\n    throw new Error('unsupported script language');\n  }\n\n  Script.toExpression = toExpression;\n\n  function toQuery(script) {\n    var expression = toExpression(script);\n    return compile(expression);\n  }\n\n  Script.toQuery = toQuery;\n\n  function toLoci(script, structure) {\n    var query = toQuery(script);\n    var result = query(new QueryContext(structure));\n    return StructureSelection.toLociWithSourceUnits(result);\n  }\n\n  Script.toLoci = toLoci;\n\n  function getStructureSelection(expr, structure, options) {\n    var e = typeof expr === 'function' ? expr(MolScriptBuilder) : expr;\n    var query = compile(e);\n    return query(new QueryContext(structure, options));\n  }\n\n  Script.getStructureSelection = getStructureSelection;\n})(Script || (Script = {}));","map":{"version":3,"sources":["../../src/mol-script/script.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,SAAS,kBAAT,QAAmC,6BAAnC;AACA,SAAS,cAAT,QAA+B,mBAA/B;AAEA,SAA2B,YAA3B,EAAyC,kBAAzC,QAA4G,wBAA5G;AACA,SAAS,OAAT,QAAwB,0BAAxB;AACA,SAAS,gBAAT,QAAiC,oBAAjC;AAEA,SAAS,MAAT;;AAIA,SAAS,MAAT,CAAgB,UAAhB,EAAoC,QAApC,EAA6D;AACzD,SAAO;AAAE,IAAA,UAAU,EAAA,UAAZ;AAAc,IAAA,QAAQ,EAAA;AAAtB,GAAP;AACH;;AAED,CAAA,UAAU,MAAV,EAAgB;AAGZ,WAAgB,EAAhB,CAAmB,CAAnB,EAAyB;AACrB,WAAO,CAAC,CAAC,CAAF,IAAO,OAAQ,CAAY,CAAC,UAArB,KAAoC,QAA3C,IAAuD,CAAC,CAAE,CAAY,CAAC,QAA9E;AACH;;AAFe,EAAA,MAAA,CAAA,EAAA,GAAE,EAAF;;AAIhB,WAAgB,QAAhB,CAAyB,CAAzB,EAAoC,CAApC,EAA6C;AACzC,WAAO,CAAC,CAAC,QAAF,KAAe,CAAC,CAAC,QAAjB,IAA6B,CAAC,CAAC,UAAF,KAAiB,CAAC,CAAC,UAAvD;AACH;;AAFe,EAAA,MAAA,CAAA,QAAA,GAAQ,QAAR;;AAIhB,WAAgB,YAAhB,CAA6B,MAA7B,EAA2C;AACvC,YAAQ,MAAM,CAAC,QAAf;AACI,WAAK,YAAL;AACI,YAAM,MAAM,GAAG,cAAc,CAAC,MAAM,CAAC,UAAR,CAA7B;AACA,YAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB,MAAM,IAAI,KAAJ,CAAU,UAAV,CAAN;AACzB,eAAO,kBAAkB,CAAC,MAAM,CAAC,CAAD,CAAP,CAAzB;AAJR;;AAMA,UAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;AACH;;AARe,EAAA,MAAA,CAAA,YAAA,GAAY,YAAZ;;AAUhB,WAAgB,OAAhB,CAAwB,MAAxB,EAAsC;AAClC,QAAM,UAAU,GAAG,YAAY,CAAC,MAAD,CAA/B;AACA,WAAO,OAAO,CAAqB,UAArB,CAAd;AACH;;AAHe,EAAA,MAAA,CAAA,OAAA,GAAO,OAAP;;AAKhB,WAAgB,MAAhB,CAAuB,MAAvB,EAAuC,SAAvC,EAA2D;AACvD,QAAM,KAAK,GAAG,OAAO,CAAC,MAAD,CAArB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,IAAI,YAAJ,CAAiB,SAAjB,CAAD,CAApB;AACA,WAAO,kBAAkB,CAAC,qBAAnB,CAAyC,MAAzC,CAAP;AACH;;AAJe,EAAA,MAAA,CAAA,MAAA,GAAM,MAAN;;AAMhB,WAAgB,qBAAhB,CAAsC,IAAtC,EAA6G,SAA7G,EAAmI,OAAnI,EAAgK;AAC5J,QAAM,CAAC,GAAG,OAAO,IAAP,KAAgB,UAAhB,GAA6B,IAAI,CAAC,gBAAD,CAAjC,GAAsD,IAAhE;AACA,QAAM,KAAK,GAAG,OAAO,CAAqB,CAArB,CAArB;AACA,WAAO,KAAK,CAAC,IAAI,YAAJ,CAAiB,SAAjB,EAA4B,OAA5B,CAAD,CAAZ;AACH;;AAJe,EAAA,MAAA,CAAA,qBAAA,GAAqB,qBAArB;AAKnB,CArCD,EAAU,MAAM,KAAN,MAAM,GAAA,EAAA,CAAhB","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { transpileMolScript } from './script/mol-script/symbols';\r\nimport { parseMolScript } from './language/parser';\r\nimport { QueryContext, StructureSelection } from '../mol-model/structure';\r\nimport { compile } from './runtime/query/compiler';\r\nimport { MolScriptBuilder } from './language/builder';\r\nexport { Script };\r\nfunction Script(expression, language) {\r\n    return { expression: expression, language: language };\r\n}\r\n(function (Script) {\r\n    function is(x) {\r\n        return !!x && typeof x.expression === 'string' && !!x.language;\r\n    }\r\n    Script.is = is;\r\n    function areEqual(a, b) {\r\n        return a.language === b.language && a.expression === b.expression;\r\n    }\r\n    Script.areEqual = areEqual;\r\n    function toExpression(script) {\r\n        switch (script.language) {\r\n            case 'mol-script':\r\n                var parsed = parseMolScript(script.expression);\r\n                if (parsed.length === 0)\r\n                    throw new Error('No query');\r\n                return transpileMolScript(parsed[0]);\r\n        }\r\n        throw new Error('unsupported script language');\r\n    }\r\n    Script.toExpression = toExpression;\r\n    function toQuery(script) {\r\n        var expression = toExpression(script);\r\n        return compile(expression);\r\n    }\r\n    Script.toQuery = toQuery;\r\n    function toLoci(script, structure) {\r\n        var query = toQuery(script);\r\n        var result = query(new QueryContext(structure));\r\n        return StructureSelection.toLociWithSourceUnits(result);\r\n    }\r\n    Script.toLoci = toLoci;\r\n    function getStructureSelection(expr, structure, options) {\r\n        var e = typeof expr === 'function' ? expr(MolScriptBuilder) : expr;\r\n        var query = compile(e);\r\n        return query(new QueryContext(structure, options));\r\n    }\r\n    Script.getStructureSelection = getStructureSelection;\r\n})(Script || (Script = {}));\r\n//# sourceMappingURL=script.js.map"]},"metadata":{},"sourceType":"module"}