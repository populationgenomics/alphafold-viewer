{"ast":null,"code":"/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Segmentation } from '../../../../mol-data/int';\nimport { MinimizeRmsd } from '../../../../mol-math/linear-algebra/3d/minimize-rmsd';\nimport { BestDatabaseSequenceMapping } from '../../../../mol-model-props/sequence/best-database-mapping';\nexport function alignAndSuperposeWithBestDatabaseMapping(structures) {\n  var indexMap = new Map();\n\n  for (var i = 0; i < structures.length; i++) {\n    buildIndex(structures[i], indexMap, i);\n  }\n\n  var index = Array.from(indexMap.values()); // TODO: support non-first structure pivots\n\n  var pairs = findPairs(structures.length, index);\n  var ret = [];\n\n  for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {\n    var p = pairs_1[_i];\n\n    var _a = getPositionTables(index, p.i, p.j, p.count),\n        a = _a[0],\n        b = _a[1];\n\n    var transform = MinimizeRmsd.compute({\n      a: a,\n      b: b\n    });\n    ret.push({\n      transform: transform,\n      pivot: p.i,\n      other: p.j\n    });\n  }\n\n  return ret;\n}\n\nfunction getPositionTables(index, pivot, other, N) {\n  var xs = MinimizeRmsd.Positions.empty(N);\n  var ys = MinimizeRmsd.Positions.empty(N);\n  var o = 0;\n\n  for (var _i = 0, index_1 = index; _i < index_1.length; _i++) {\n    var pivots = index_1[_i].pivots;\n    var a = pivots[pivot];\n    var b = pivots[other];\n    if (!a || !b) continue;\n    var l = Math.min(a[2] - a[1], b[2] - b[1]);\n\n    for (var i = 0; i < l; i++) {\n      var eI = a[1] + i;\n      xs.x[o] = a[0].conformation.x(eI);\n      xs.y[o] = a[0].conformation.y(eI);\n      xs.z[o] = a[0].conformation.z(eI);\n      eI = b[1] + i;\n      ys.x[o] = b[0].conformation.x(eI);\n      ys.y[o] = b[0].conformation.y(eI);\n      ys.z[o] = b[0].conformation.z(eI);\n      o++;\n    }\n  }\n\n  return [xs, ys];\n}\n\nfunction findPairs(N, index) {\n  var pairwiseCounts = [];\n\n  for (var i = 0; i < N; i++) {\n    pairwiseCounts[i] = [];\n\n    for (var j = 0; j < N; j++) pairwiseCounts[i][j] = 0;\n  }\n\n  for (var _i = 0, index_2 = index; _i < index_2.length; _i++) {\n    var pivots = index_2[_i].pivots;\n\n    for (var i = 0; i < N; i++) {\n      if (!pivots[i]) continue;\n      var lI = pivots[i][2] - pivots[i][1];\n\n      for (var j = i + 1; j < N; j++) {\n        if (!pivots[j]) continue;\n        var lJ = pivots[j][2] - pivots[j][1];\n        pairwiseCounts[i][j] = pairwiseCounts[i][j] + Math.min(lI, lJ);\n      }\n    }\n  }\n\n  var ret = [];\n\n  for (var j = 1; j < N; j++) {\n    ret[j - 1] = {\n      i: 0,\n      j: j,\n      count: pairwiseCounts[0][j]\n    };\n  } // TODO: support non-first structure pivots\n  // for (let i = 0; i < N - 1; i++) {\n  //     let max = 0, maxJ = i;\n  //     for (let j = i + 1; j < N; j++) {\n  //         if (pairwiseCounts[i][j] > max) {\n  //             maxJ = j;\n  //             max = pairwiseCounts[i][j];\n  //         }\n  //     }\n  //     ret[i] = { i, j: maxJ, count: max };\n  // }\n\n\n  return ret;\n}\n\nfunction buildIndex(structure, index, sI) {\n  var _a;\n\n  for (var _i = 0, _b = structure.units; _i < _b.length; _i++) {\n    var unit = _b[_i];\n    if (unit.kind !== 0\n    /* Atomic */\n    ) continue;\n    var elements = unit.elements,\n        model = unit.model;\n    var residueOffset = model.atomicHierarchy.residueAtomSegments.offsets;\n    var map = BestDatabaseSequenceMapping.Provider.get(model).value;\n    if (!map) return;\n    var dbName = map.dbName,\n        accession = map.accession,\n        num = map.num;\n    var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\n    var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\n\n    while (chainsIt.hasNext) {\n      var chainSegment = chainsIt.move();\n      residuesIt.setSegment(chainSegment);\n\n      while (residuesIt.hasNext) {\n        var residueSegment = residuesIt.move();\n        var eI = elements[residueSegment.start];\n        var rI = residueOffset[eI];\n        if (!dbName[rI]) continue;\n        var key = dbName[rI] + \"-\" + accession[rI] + \"-\" + num[rI];\n\n        if (!index.has(key)) {\n          index.set(key, {\n            key: key,\n            pivots: (_a = {}, _a[sI] = [unit, eI, elements[residueSegment.end]], _a)\n          });\n        } else {\n          var entry = index.get(key);\n\n          if (!entry.pivots[sI]) {\n            entry.pivots[sI] = [unit, eI, elements[residueSegment.end]];\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model/structure/structure/util/superposition-db-mapping.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Segmentation } from '../../../../mol-data/int';\r\nimport { MinimizeRmsd } from '../../../../mol-math/linear-algebra/3d/minimize-rmsd';\r\nimport { BestDatabaseSequenceMapping } from '../../../../mol-model-props/sequence/best-database-mapping';\r\nexport function alignAndSuperposeWithBestDatabaseMapping(structures) {\r\n    var indexMap = new Map();\r\n    for (var i = 0; i < structures.length; i++) {\r\n        buildIndex(structures[i], indexMap, i);\r\n    }\r\n    var index = Array.from(indexMap.values());\r\n    // TODO: support non-first structure pivots\r\n    var pairs = findPairs(structures.length, index);\r\n    var ret = [];\r\n    for (var _i = 0, pairs_1 = pairs; _i < pairs_1.length; _i++) {\r\n        var p = pairs_1[_i];\r\n        var _a = getPositionTables(index, p.i, p.j, p.count), a = _a[0], b = _a[1];\r\n        var transform = MinimizeRmsd.compute({ a: a, b: b });\r\n        ret.push({ transform: transform, pivot: p.i, other: p.j });\r\n    }\r\n    return ret;\r\n}\r\nfunction getPositionTables(index, pivot, other, N) {\r\n    var xs = MinimizeRmsd.Positions.empty(N);\r\n    var ys = MinimizeRmsd.Positions.empty(N);\r\n    var o = 0;\r\n    for (var _i = 0, index_1 = index; _i < index_1.length; _i++) {\r\n        var pivots = index_1[_i].pivots;\r\n        var a = pivots[pivot];\r\n        var b = pivots[other];\r\n        if (!a || !b)\r\n            continue;\r\n        var l = Math.min(a[2] - a[1], b[2] - b[1]);\r\n        for (var i = 0; i < l; i++) {\r\n            var eI = (a[1] + i);\r\n            xs.x[o] = a[0].conformation.x(eI);\r\n            xs.y[o] = a[0].conformation.y(eI);\r\n            xs.z[o] = a[0].conformation.z(eI);\r\n            eI = (b[1] + i);\r\n            ys.x[o] = b[0].conformation.x(eI);\r\n            ys.y[o] = b[0].conformation.y(eI);\r\n            ys.z[o] = b[0].conformation.z(eI);\r\n            o++;\r\n        }\r\n    }\r\n    return [xs, ys];\r\n}\r\nfunction findPairs(N, index) {\r\n    var pairwiseCounts = [];\r\n    for (var i = 0; i < N; i++) {\r\n        pairwiseCounts[i] = [];\r\n        for (var j = 0; j < N; j++)\r\n            pairwiseCounts[i][j] = 0;\r\n    }\r\n    for (var _i = 0, index_2 = index; _i < index_2.length; _i++) {\r\n        var pivots = index_2[_i].pivots;\r\n        for (var i = 0; i < N; i++) {\r\n            if (!pivots[i])\r\n                continue;\r\n            var lI = pivots[i][2] - pivots[i][1];\r\n            for (var j = i + 1; j < N; j++) {\r\n                if (!pivots[j])\r\n                    continue;\r\n                var lJ = pivots[j][2] - pivots[j][1];\r\n                pairwiseCounts[i][j] = pairwiseCounts[i][j] + Math.min(lI, lJ);\r\n            }\r\n        }\r\n    }\r\n    var ret = [];\r\n    for (var j = 1; j < N; j++) {\r\n        ret[j - 1] = { i: 0, j: j, count: pairwiseCounts[0][j] };\r\n    }\r\n    // TODO: support non-first structure pivots\r\n    // for (let i = 0; i < N - 1; i++) {\r\n    //     let max = 0, maxJ = i;\r\n    //     for (let j = i + 1; j < N; j++) {\r\n    //         if (pairwiseCounts[i][j] > max) {\r\n    //             maxJ = j;\r\n    //             max = pairwiseCounts[i][j];\r\n    //         }\r\n    //     }\r\n    //     ret[i] = { i, j: maxJ, count: max };\r\n    // }\r\n    return ret;\r\n}\r\nfunction buildIndex(structure, index, sI) {\r\n    var _a;\r\n    for (var _i = 0, _b = structure.units; _i < _b.length; _i++) {\r\n        var unit = _b[_i];\r\n        if (unit.kind !== 0 /* Atomic */)\r\n            continue;\r\n        var elements = unit.elements, model = unit.model;\r\n        var residueOffset = model.atomicHierarchy.residueAtomSegments.offsets;\r\n        var map = BestDatabaseSequenceMapping.Provider.get(model).value;\r\n        if (!map)\r\n            return;\r\n        var dbName = map.dbName, accession = map.accession, num = map.num;\r\n        var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\r\n        var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\r\n        while (chainsIt.hasNext) {\r\n            var chainSegment = chainsIt.move();\r\n            residuesIt.setSegment(chainSegment);\r\n            while (residuesIt.hasNext) {\r\n                var residueSegment = residuesIt.move();\r\n                var eI = elements[residueSegment.start];\r\n                var rI = residueOffset[eI];\r\n                if (!dbName[rI])\r\n                    continue;\r\n                var key = dbName[rI] + \"-\" + accession[rI] + \"-\" + num[rI];\r\n                if (!index.has(key)) {\r\n                    index.set(key, { key: key, pivots: (_a = {}, _a[sI] = [unit, eI, elements[residueSegment.end]], _a) });\r\n                }\r\n                else {\r\n                    var entry = index.get(key);\r\n                    if (!entry.pivots[sI]) {\r\n                        entry.pivots[sI] = [unit, eI, elements[residueSegment.end]];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=superposition-db-mapping.js.map"]},"metadata":{},"sourceType":"module"}