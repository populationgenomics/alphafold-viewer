{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../../../mol-task';\nimport { getUnitConformationAndRadius, ensureReasonableResolution } from './common';\nimport { calcMolecularSurface } from '../../../../mol-math/geometry/molecular-surface';\nimport { OrderedSet } from '../../../../mol-data/int';\n\nfunction getPositionDataAndMaxRadius(structure, unit, props) {\n  var probeRadius = props.probeRadius;\n\n  var _a = getUnitConformationAndRadius(structure, unit, props),\n      position = _a.position,\n      boundary = _a.boundary,\n      radius = _a.radius;\n\n  var indices = position.indices;\n  var n = OrderedSet.size(indices);\n  var radii = new Float32Array(OrderedSet.end(indices));\n  var maxRadius = 0;\n\n  for (var i = 0; i < n; ++i) {\n    var j = OrderedSet.getAt(indices, i);\n    var r = radius(j);\n    if (maxRadius < r) maxRadius = r;\n    radii[j] = r + probeRadius;\n  }\n\n  return {\n    position: __assign(__assign({}, position), {\n      radius: radii\n    }),\n    boundary: boundary,\n    maxRadius: maxRadius\n  };\n}\n\nexport function computeUnitMolecularSurface(structure, unit, props) {\n  var _this = this;\n\n  var box = unit.lookup3d.boundary.box;\n  var p = ensureReasonableResolution(box, props);\n\n  var _a = getPositionDataAndMaxRadius(structure, unit, p),\n      position = _a.position,\n      boundary = _a.boundary,\n      maxRadius = _a.maxRadius;\n\n  return Task.create('Molecular Surface', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , MolecularSurface(ctx, position, boundary, maxRadius, box, p)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  });\n} //\n\nfunction MolecularSurface(ctx, position, boundary, maxRadius, box, props) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      return [2\n      /*return*/\n      , calcMolecularSurface(ctx, position, boundary, maxRadius, box, props)];\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/molecular-surface.ts"],"names":[],"mappings":"AAAA;;;;AAIG;;AAGH,SAAS,IAAT,QAAqC,sBAArC;AACA,SAAS,4BAAT,EAA2D,0BAA3D,QAA6F,UAA7F;AAEA,SAA2C,oBAA3C,QAAuE,iDAAvE;AACA,SAAS,UAAT,QAA2B,0BAA3B;;AAKA,SAAS,2BAAT,CAAqC,SAArC,EAA2D,IAA3D,EAAuE,KAAvE,EAAmG;AACvF,MAAA,WAAW,GAAK,KAAK,CAAV,WAAX;;AACF,MAAA,EAAA,GAAiC,4BAA4B,CAAC,SAAD,EAAY,IAAZ,EAAkB,KAAlB,CAA7D;AAAA,MAAE,QAAQ,GAAA,EAAA,CAAA,QAAV;AAAA,MAAY,QAAQ,GAAA,EAAA,CAAA,QAApB;AAAA,MAAsB,MAAM,GAAA,EAAA,CAAA,MAA5B;;AACE,MAAA,OAAO,GAAK,QAAQ,CAAb,OAAP;AACR,MAAM,CAAC,GAAG,UAAU,CAAC,IAAX,CAAgB,OAAhB,CAAV;AACA,MAAM,KAAK,GAAG,IAAI,YAAJ,CAAiB,UAAU,CAAC,GAAX,CAAe,OAAf,CAAjB,CAAd;AAEA,MAAI,SAAS,GAAG,CAAhB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,EAAE,CAAzB,EAA4B;AACxB,QAAM,CAAC,GAAG,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,CAA1B,CAAV;AACA,QAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB;AACA,QAAI,SAAS,GAAG,CAAhB,EAAmB,SAAS,GAAG,CAAZ;AACnB,IAAA,KAAK,CAAC,CAAD,CAAL,GAAW,CAAC,GAAG,WAAf;AACH;;AAED,SAAO;AAAE,IAAA,QAAQ,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAO,QAAP,CAAA,EAAe;AAAE,MAAA,MAAM,EAAE;AAAV,KAAf,CAAV;AAA4C,IAAA,QAAQ,EAAA,QAApD;AAAsD,IAAA,SAAS,EAAA;AAA/D,GAAP;AACH;;AAED,OAAM,SAAU,2BAAV,CAAsC,SAAtC,EAA4D,IAA5D,EAAwE,KAAxE,EAAoG;AAA1G,MAAA,KAAA,GAAA,IAAA;;AACY,MAAA,GAAG,GAAK,IAAI,CAAC,QAAL,CAAc,QAAd,CAAL,GAAH;AACR,MAAM,CAAC,GAAG,0BAA0B,CAAC,GAAD,EAAM,KAAN,CAApC;;AACM,MAAA,EAAA,GAAoC,2BAA2B,CAAC,SAAD,EAAY,IAAZ,EAAkB,CAAlB,CAA/D;AAAA,MAAE,QAAQ,GAAA,EAAA,CAAA,QAAV;AAAA,MAAY,QAAQ,GAAA,EAAA,CAAA,QAApB;AAAA,MAAsB,SAAS,GAAA,EAAA,CAAA,SAA/B;;AACN,SAAO,IAAI,CAAC,MAAL,CAAY,mBAAZ,EAAiC,UAAM,GAAN,EAAS;AAAA,WAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;AACtC,mBAAA,CAAA;AAAA;AAAA,cAAM,gBAAgB,CAAC,GAAD,EAAM,QAAN,EAAgB,QAAhB,EAA0B,SAA1B,EAAqC,GAArC,EAA0C,CAA1C,CAAtB,CAAA;;;AAAP,mBAAA,CAAA;AAAA;AAAA,cAAO,EAAA,CAAA,IAAA,EAAP,CAAA;;;KAD6C,CAAA;AAEhD,GAFM,CAAP;AAGH,C,CAED;;AAEA,SAAe,gBAAf,CAAgC,GAAhC,EAAqD,QAArD,EAAuF,QAAvF,EAA2G,SAA3G,EAA8H,GAA9H,EAAiJ,KAAjJ,EAAwL;;;AACpL,aAAA,CAAA;AAAA;AAAA,QAAO,oBAAoB,CAAC,GAAD,EAAM,QAAN,EAAgB,QAAhB,EAA0B,SAA1B,EAAqC,GAArC,EAA0C,KAA1C,CAA3B,CAAA;;;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../../../mol-task';\r\nimport { getUnitConformationAndRadius, ensureReasonableResolution } from './common';\r\nimport { calcMolecularSurface } from '../../../../mol-math/geometry/molecular-surface';\r\nimport { OrderedSet } from '../../../../mol-data/int';\r\nfunction getPositionDataAndMaxRadius(structure, unit, props) {\r\n    var probeRadius = props.probeRadius;\r\n    var _a = getUnitConformationAndRadius(structure, unit, props), position = _a.position, boundary = _a.boundary, radius = _a.radius;\r\n    var indices = position.indices;\r\n    var n = OrderedSet.size(indices);\r\n    var radii = new Float32Array(OrderedSet.end(indices));\r\n    var maxRadius = 0;\r\n    for (var i = 0; i < n; ++i) {\r\n        var j = OrderedSet.getAt(indices, i);\r\n        var r = radius(j);\r\n        if (maxRadius < r)\r\n            maxRadius = r;\r\n        radii[j] = r + probeRadius;\r\n    }\r\n    return { position: __assign(__assign({}, position), { radius: radii }), boundary: boundary, maxRadius: maxRadius };\r\n}\r\nexport function computeUnitMolecularSurface(structure, unit, props) {\r\n    var _this = this;\r\n    var box = unit.lookup3d.boundary.box;\r\n    var p = ensureReasonableResolution(box, props);\r\n    var _a = getPositionDataAndMaxRadius(structure, unit, p), position = _a.position, boundary = _a.boundary, maxRadius = _a.maxRadius;\r\n    return Task.create('Molecular Surface', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, MolecularSurface(ctx, position, boundary, maxRadius, box, p)];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    }); });\r\n}\r\n//\r\nfunction MolecularSurface(ctx, position, boundary, maxRadius, box, props) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            return [2 /*return*/, calcMolecularSurface(ctx, position, boundary, maxRadius, box, props)];\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=molecular-surface.js.map"]},"metadata":{},"sourceType":"module"}