"use strict";
/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyTextureMeshColorSmoothing = exports.applyMeshColorSmoothing = exports.getColorSmoothingProps = exports.ColorSmoothingParams = void 0;
var color_smoothing_1 = require("../../../../mol-geo/geometry/mesh/color-smoothing");
var color_smoothing_2 = require("../../../../mol-geo/geometry/texture-mesh/color-smoothing");
var interpolate_1 = require("../../../../mol-math/interpolate");
var mol_util_1 = require("../../../../mol-util");
var param_definition_1 = require("../../../../mol-util/param-definition");
exports.ColorSmoothingParams = {
    smoothColors: param_definition_1.ParamDefinition.MappedStatic('auto', {
        auto: param_definition_1.ParamDefinition.Group({}),
        on: param_definition_1.ParamDefinition.Group({
            resolutionFactor: param_definition_1.ParamDefinition.Numeric(2, { min: 0.5, max: 6, step: 0.1 }),
            sampleStride: param_definition_1.ParamDefinition.Numeric(3, { min: 1, max: 12, step: 1 }),
        }),
        off: param_definition_1.ParamDefinition.Group({})
    }),
};
function getColorSmoothingProps(props, theme, resolution) {
    if ((props.smoothColors.name === 'on' || (props.smoothColors.name === 'auto' && theme.color.preferSmoothing)) && resolution && resolution < 3) {
        var stride = 3;
        if (props.smoothColors.name === 'on') {
            resolution *= props.smoothColors.params.resolutionFactor;
            stride = props.smoothColors.params.sampleStride;
        }
        else {
            // https://graphtoy.com/?f1(x,t)=(2-smoothstep(0,1.1,x))*x&coords=0.7,0.6,1.8
            resolution *= 2 - (0, interpolate_1.smoothstep)(0, 1.1, resolution);
            resolution = Math.max(0.5, resolution);
            if (resolution > 1.2)
                stride = 2;
        }
        return { resolution: resolution, stride: stride };
    }
    ;
}
exports.getColorSmoothingProps = getColorSmoothingProps;
function isSupportedColorType(x) {
    return x === 'group' || x === 'groupInstance';
}
function applyMeshColorSmoothing(values, resolution, stride, webgl, colorTexture) {
    if (!isSupportedColorType(values.dColorType.ref.value))
        return;
    var smoothingData = (0, color_smoothing_1.calcMeshColorSmoothing)({
        vertexCount: values.uVertexCount.ref.value,
        instanceCount: values.uInstanceCount.ref.value,
        groupCount: values.uGroupCount.ref.value,
        transformBuffer: values.aTransform.ref.value,
        instanceBuffer: values.aInstance.ref.value,
        positionBuffer: values.aPosition.ref.value,
        groupBuffer: values.aGroup.ref.value,
        colorData: values.tColor.ref.value,
        colorType: values.dColorType.ref.value,
        boundingSphere: values.boundingSphere.ref.value,
        invariantBoundingSphere: values.invariantBoundingSphere.ref.value,
    }, resolution, stride, webgl, colorTexture);
    if (smoothingData.kind === 'volume') {
        mol_util_1.ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
        mol_util_1.ValueCell.update(values.tColorGrid, smoothingData.texture);
        mol_util_1.ValueCell.update(values.uColorTexDim, smoothingData.gridTexDim);
        mol_util_1.ValueCell.update(values.uColorGridDim, smoothingData.gridDim);
        mol_util_1.ValueCell.update(values.uColorGridTransform, smoothingData.gridTransform);
    }
    else if (smoothingData.kind === 'vertex') {
        mol_util_1.ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
        mol_util_1.ValueCell.update(values.tColor, smoothingData.texture);
        mol_util_1.ValueCell.update(values.uColorTexDim, smoothingData.texDim);
    }
}
exports.applyMeshColorSmoothing = applyMeshColorSmoothing;
function applyTextureMeshColorSmoothing(values, resolution, stride, webgl, colorTexture) {
    if (!isSupportedColorType(values.dColorType.ref.value))
        return;
    stride *= 3; // triple because TextureMesh is never indexed (no elements buffer)
    var smoothingData = (0, color_smoothing_2.calcTextureMeshColorSmoothing)({
        vertexCount: values.uVertexCount.ref.value,
        instanceCount: values.uInstanceCount.ref.value,
        groupCount: values.uGroupCount.ref.value,
        transformBuffer: values.aTransform.ref.value,
        instanceBuffer: values.aInstance.ref.value,
        positionTexture: values.tPosition.ref.value,
        groupTexture: values.tGroup.ref.value,
        colorData: values.tColor.ref.value,
        colorType: values.dColorType.ref.value,
        boundingSphere: values.boundingSphere.ref.value,
        invariantBoundingSphere: values.invariantBoundingSphere.ref.value,
    }, resolution, stride, webgl, colorTexture);
    mol_util_1.ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
    mol_util_1.ValueCell.update(values.tColorGrid, smoothingData.texture);
    mol_util_1.ValueCell.update(values.uColorTexDim, smoothingData.gridTexDim);
    mol_util_1.ValueCell.update(values.uColorGridDim, smoothingData.gridDim);
    mol_util_1.ValueCell.update(values.uColorGridTransform, smoothingData.gridTransform);
}
exports.applyTextureMeshColorSmoothing = applyTextureMeshColorSmoothing;
//# sourceMappingURL=color.js.map