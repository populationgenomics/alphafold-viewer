{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Vec3 } from '../../mol-math/linear-algebra';\nimport { NullLocation } from '../../mol-model/location';\nexport function LocationIterator(groupCount, instanceCount, stride, getLocation, nonInstanceable, isSecondary) {\n  if (nonInstanceable === void 0) {\n    nonInstanceable = false;\n  }\n\n  if (isSecondary === void 0) {\n    isSecondary = function () {\n      return false;\n    };\n  }\n\n  if (groupCount % stride !== 0) {\n    throw new Error('incompatible groupCount and stride');\n  }\n\n  var value = {\n    location: NullLocation,\n    index: 0,\n    groupIndex: 0,\n    instanceIndex: 0,\n    isSecondary: false\n  };\n  var hasNext = value.groupIndex < groupCount;\n  var isNextNewInstance = false;\n  var groupIndex = 0;\n  var instanceIndex = 0;\n  var voidInstances = false;\n  return {\n    get hasNext() {\n      return hasNext;\n    },\n\n    get isNextNewInstance() {\n      return isNextNewInstance;\n    },\n\n    groupCount: groupCount,\n    instanceCount: instanceCount,\n    count: groupCount * instanceCount,\n    stride: stride,\n    nonInstanceable: nonInstanceable,\n    move: function () {\n      if (hasNext) {\n        value.groupIndex = groupIndex;\n        value.instanceIndex = instanceIndex;\n        value.index = instanceIndex * groupCount + groupIndex;\n        value.location = getLocation(groupIndex, voidInstances ? -1 : instanceIndex);\n        value.isSecondary = isSecondary(groupIndex, voidInstances ? -1 : instanceIndex);\n        groupIndex += stride;\n\n        if (groupIndex === groupCount) {\n          ++instanceIndex;\n          isNextNewInstance = true;\n          if (instanceIndex < instanceCount) groupIndex = 0;\n        } else {\n          isNextNewInstance = false;\n        }\n\n        hasNext = groupIndex < groupCount;\n      }\n\n      return value;\n    },\n    reset: function () {\n      value.location = NullLocation;\n      value.index = 0;\n      value.groupIndex = 0;\n      value.instanceIndex = 0;\n      value.isSecondary = false;\n      hasNext = value.groupIndex < groupCount;\n      isNextNewInstance = false;\n      groupIndex = 0;\n      instanceIndex = 0;\n      voidInstances = false;\n    },\n    skipInstance: function () {\n      if (hasNext && value.instanceIndex === instanceIndex) {\n        ++instanceIndex;\n        groupIndex = 0;\n        hasNext = instanceIndex < instanceCount;\n      }\n    },\n    voidInstances: function () {\n      voidInstances = true;\n    }\n  };\n}\nexport function PositionLocation(position) {\n  return {\n    kind: 'position-location',\n    position: position ? Vec3.clone(position) : Vec3()\n  };\n}\nexport function isPositionLocation(x) {\n  return !!x && x.kind === 'position-location';\n}","map":{"version":3,"sources":["../../../src/mol-geo/util/location-iterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Vec3 } from '../../mol-math/linear-algebra';\r\nimport { NullLocation } from '../../mol-model/location';\r\nexport function LocationIterator(groupCount, instanceCount, stride, getLocation, nonInstanceable, isSecondary) {\r\n    if (nonInstanceable === void 0) { nonInstanceable = false; }\r\n    if (isSecondary === void 0) { isSecondary = function () { return false; }; }\r\n    if (groupCount % stride !== 0) {\r\n        throw new Error('incompatible groupCount and stride');\r\n    }\r\n    var value = {\r\n        location: NullLocation,\r\n        index: 0,\r\n        groupIndex: 0,\r\n        instanceIndex: 0,\r\n        isSecondary: false\r\n    };\r\n    var hasNext = value.groupIndex < groupCount;\r\n    var isNextNewInstance = false;\r\n    var groupIndex = 0;\r\n    var instanceIndex = 0;\r\n    var voidInstances = false;\r\n    return {\r\n        get hasNext() { return hasNext; },\r\n        get isNextNewInstance() { return isNextNewInstance; },\r\n        groupCount: groupCount,\r\n        instanceCount: instanceCount,\r\n        count: groupCount * instanceCount,\r\n        stride: stride,\r\n        nonInstanceable: nonInstanceable,\r\n        move: function () {\r\n            if (hasNext) {\r\n                value.groupIndex = groupIndex;\r\n                value.instanceIndex = instanceIndex;\r\n                value.index = instanceIndex * groupCount + groupIndex;\r\n                value.location = getLocation(groupIndex, voidInstances ? -1 : instanceIndex);\r\n                value.isSecondary = isSecondary(groupIndex, voidInstances ? -1 : instanceIndex);\r\n                groupIndex += stride;\r\n                if (groupIndex === groupCount) {\r\n                    ++instanceIndex;\r\n                    isNextNewInstance = true;\r\n                    if (instanceIndex < instanceCount)\r\n                        groupIndex = 0;\r\n                }\r\n                else {\r\n                    isNextNewInstance = false;\r\n                }\r\n                hasNext = groupIndex < groupCount;\r\n            }\r\n            return value;\r\n        },\r\n        reset: function () {\r\n            value.location = NullLocation;\r\n            value.index = 0;\r\n            value.groupIndex = 0;\r\n            value.instanceIndex = 0;\r\n            value.isSecondary = false;\r\n            hasNext = value.groupIndex < groupCount;\r\n            isNextNewInstance = false;\r\n            groupIndex = 0;\r\n            instanceIndex = 0;\r\n            voidInstances = false;\r\n        },\r\n        skipInstance: function () {\r\n            if (hasNext && value.instanceIndex === instanceIndex) {\r\n                ++instanceIndex;\r\n                groupIndex = 0;\r\n                hasNext = instanceIndex < instanceCount;\r\n            }\r\n        },\r\n        voidInstances: function () {\r\n            voidInstances = true;\r\n        }\r\n    };\r\n}\r\nexport function PositionLocation(position) {\r\n    return { kind: 'position-location', position: position ? Vec3.clone(position) : Vec3() };\r\n}\r\nexport function isPositionLocation(x) {\r\n    return !!x && x.kind === 'position-location';\r\n}\r\n//# sourceMappingURL=location-iterator.js.map"]},"metadata":{},"sourceType":"module"}