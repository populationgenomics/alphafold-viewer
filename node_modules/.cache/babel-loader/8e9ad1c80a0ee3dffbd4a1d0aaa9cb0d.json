{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Vec3 } from '../mol-math/linear-algebra';\nimport { arrayMax } from '../mol-util/array';\nexport function normalizeVec3Array(a, count) {\n  for (var i = 0, il = count * 3; i < il; i += 3) {\n    var x = a[i];\n    var y = a[i + 1];\n    var z = a[i + 2];\n    var s = 1 / Math.sqrt(x * x + y * y + z * z);\n    a[i] = x * s;\n    a[i + 1] = y * s;\n    a[i + 2] = z * s;\n  }\n\n  return a;\n}\nvar tmpV3 = Vec3();\nexport function transformPositionArray(t, array, offset, count) {\n  for (var i = 0, il = count * 3; i < il; i += 3) {\n    Vec3.fromArray(tmpV3, array, offset + i);\n    Vec3.transformMat4(tmpV3, tmpV3, t);\n    Vec3.toArray(tmpV3, array, offset + i);\n  }\n}\nexport function transformDirectionArray(n, array, offset, count) {\n  for (var i = 0, il = count * 3; i < il; i += 3) {\n    Vec3.fromArray(tmpV3, array, offset + i);\n    Vec3.transformMat3(tmpV3, tmpV3, n);\n    Vec3.toArray(tmpV3, array, offset + i);\n  }\n}\n/** iterate over the entire array and apply the radius to each vertex */\n\nexport function appplyRadius(vertices, radius) {\n  for (var i = 0, il = vertices.length; i < il; i += 3) {\n    Vec3.fromArray(tmpV3, vertices, i);\n    Vec3.normalize(tmpV3, tmpV3);\n    Vec3.scale(tmpV3, tmpV3, radius);\n    Vec3.toArray(tmpV3, vertices, i);\n  }\n}\nvar a = Vec3();\nvar b = Vec3();\nvar c = Vec3();\nvar cb = Vec3();\nvar ab = Vec3();\n/**\r\n * indexed vertex normals weighted by triangle areas\r\n *      http://www.iquilezles.org/www/articles/normals/normals.htm\r\n * - normals array must contain only zeros\r\n */\n\nexport function computeIndexedVertexNormals(vertices, indices, normals, vertexCount, triangleCount) {\n  for (var i = 0, il = triangleCount * 3; i < il; i += 3) {\n    var ai = indices[i] * 3;\n    var bi = indices[i + 1] * 3;\n    var ci = indices[i + 2] * 3;\n    Vec3.fromArray(a, vertices, ai);\n    Vec3.fromArray(b, vertices, bi);\n    Vec3.fromArray(c, vertices, ci);\n    Vec3.sub(cb, c, b);\n    Vec3.sub(ab, a, b);\n    Vec3.cross(cb, cb, ab);\n    normals[ai] += cb[0];\n    normals[ai + 1] += cb[1];\n    normals[ai + 2] += cb[2];\n    normals[bi] += cb[0];\n    normals[bi + 1] += cb[1];\n    normals[bi + 2] += cb[2];\n    normals[ci] += cb[0];\n    normals[ci + 1] += cb[1];\n    normals[ci + 2] += cb[2];\n  }\n\n  return normalizeVec3Array(normals, vertexCount);\n}\n/**\r\n * vertex normals for unindexed triangle soup\r\n * - normals array must contain only zeros\r\n */\n\nexport function computeVertexNormals(vertices, normals, vertexCount) {\n  for (var i = 0, il = vertexCount * 3; i < il; i += 9) {\n    Vec3.fromArray(a, vertices, i);\n    Vec3.fromArray(b, vertices, i + 3);\n    Vec3.fromArray(c, vertices, i + 6);\n    Vec3.sub(cb, c, b);\n    Vec3.sub(ab, a, b);\n    Vec3.cross(cb, cb, ab);\n    normals[i] = cb[0];\n    normals[i + 1] = cb[1];\n    normals[i + 2] = cb[2];\n    normals[i + 3] = cb[0];\n    normals[i + 4] = cb[1];\n    normals[i + 5] = cb[2];\n    normals[i + 6] = cb[0];\n    normals[i + 7] = cb[1];\n    normals[i + 8] = cb[2];\n  }\n\n  return normalizeVec3Array(normals, vertexCount);\n}\n/**\r\n * The `step` parameter allows to skip over repeated values in `groups`\r\n */\n\nexport function createGroupMapping(groups, dataCount, step) {\n  if (step === void 0) {\n    step = 1;\n  }\n\n  var maxId = arrayMax(groups);\n  var offsets = new Int32Array(maxId + 2);\n  var bucketFill = new Int32Array(dataCount);\n  var bucketSizes = new Int32Array(dataCount);\n\n  for (var i = 0, il = dataCount * step; i < il; i += step) ++bucketSizes[groups[i]];\n\n  var offset = 0;\n\n  for (var i = 0; i < dataCount; i++) {\n    offsets[i] = offset;\n    offset += bucketSizes[i];\n  }\n\n  offsets[dataCount] = offset;\n  var indices = new Int32Array(offset);\n\n  for (var i = 0, il = dataCount * step; i < il; i += step) {\n    var g = groups[i];\n    var og = offsets[g] + bucketFill[g];\n    indices[og] = i;\n    ++bucketFill[g];\n  }\n\n  return {\n    indices: indices,\n    offsets: offsets\n  };\n}","map":{"version":3,"sources":["../../src/mol-geo/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Vec3 } from '../mol-math/linear-algebra';\r\nimport { arrayMax } from '../mol-util/array';\r\nexport function normalizeVec3Array(a, count) {\r\n    for (var i = 0, il = count * 3; i < il; i += 3) {\r\n        var x = a[i];\r\n        var y = a[i + 1];\r\n        var z = a[i + 2];\r\n        var s = 1 / Math.sqrt(x * x + y * y + z * z);\r\n        a[i] = x * s;\r\n        a[i + 1] = y * s;\r\n        a[i + 2] = z * s;\r\n    }\r\n    return a;\r\n}\r\nvar tmpV3 = Vec3();\r\nexport function transformPositionArray(t, array, offset, count) {\r\n    for (var i = 0, il = count * 3; i < il; i += 3) {\r\n        Vec3.fromArray(tmpV3, array, offset + i);\r\n        Vec3.transformMat4(tmpV3, tmpV3, t);\r\n        Vec3.toArray(tmpV3, array, offset + i);\r\n    }\r\n}\r\nexport function transformDirectionArray(n, array, offset, count) {\r\n    for (var i = 0, il = count * 3; i < il; i += 3) {\r\n        Vec3.fromArray(tmpV3, array, offset + i);\r\n        Vec3.transformMat3(tmpV3, tmpV3, n);\r\n        Vec3.toArray(tmpV3, array, offset + i);\r\n    }\r\n}\r\n/** iterate over the entire array and apply the radius to each vertex */\r\nexport function appplyRadius(vertices, radius) {\r\n    for (var i = 0, il = vertices.length; i < il; i += 3) {\r\n        Vec3.fromArray(tmpV3, vertices, i);\r\n        Vec3.normalize(tmpV3, tmpV3);\r\n        Vec3.scale(tmpV3, tmpV3, radius);\r\n        Vec3.toArray(tmpV3, vertices, i);\r\n    }\r\n}\r\nvar a = Vec3();\r\nvar b = Vec3();\r\nvar c = Vec3();\r\nvar cb = Vec3();\r\nvar ab = Vec3();\r\n/**\r\n * indexed vertex normals weighted by triangle areas\r\n *      http://www.iquilezles.org/www/articles/normals/normals.htm\r\n * - normals array must contain only zeros\r\n */\r\nexport function computeIndexedVertexNormals(vertices, indices, normals, vertexCount, triangleCount) {\r\n    for (var i = 0, il = triangleCount * 3; i < il; i += 3) {\r\n        var ai = indices[i] * 3;\r\n        var bi = indices[i + 1] * 3;\r\n        var ci = indices[i + 2] * 3;\r\n        Vec3.fromArray(a, vertices, ai);\r\n        Vec3.fromArray(b, vertices, bi);\r\n        Vec3.fromArray(c, vertices, ci);\r\n        Vec3.sub(cb, c, b);\r\n        Vec3.sub(ab, a, b);\r\n        Vec3.cross(cb, cb, ab);\r\n        normals[ai] += cb[0];\r\n        normals[ai + 1] += cb[1];\r\n        normals[ai + 2] += cb[2];\r\n        normals[bi] += cb[0];\r\n        normals[bi + 1] += cb[1];\r\n        normals[bi + 2] += cb[2];\r\n        normals[ci] += cb[0];\r\n        normals[ci + 1] += cb[1];\r\n        normals[ci + 2] += cb[2];\r\n    }\r\n    return normalizeVec3Array(normals, vertexCount);\r\n}\r\n/**\r\n * vertex normals for unindexed triangle soup\r\n * - normals array must contain only zeros\r\n */\r\nexport function computeVertexNormals(vertices, normals, vertexCount) {\r\n    for (var i = 0, il = vertexCount * 3; i < il; i += 9) {\r\n        Vec3.fromArray(a, vertices, i);\r\n        Vec3.fromArray(b, vertices, i + 3);\r\n        Vec3.fromArray(c, vertices, i + 6);\r\n        Vec3.sub(cb, c, b);\r\n        Vec3.sub(ab, a, b);\r\n        Vec3.cross(cb, cb, ab);\r\n        normals[i] = cb[0];\r\n        normals[i + 1] = cb[1];\r\n        normals[i + 2] = cb[2];\r\n        normals[i + 3] = cb[0];\r\n        normals[i + 4] = cb[1];\r\n        normals[i + 5] = cb[2];\r\n        normals[i + 6] = cb[0];\r\n        normals[i + 7] = cb[1];\r\n        normals[i + 8] = cb[2];\r\n    }\r\n    return normalizeVec3Array(normals, vertexCount);\r\n}\r\n/**\r\n * The `step` parameter allows to skip over repeated values in `groups`\r\n */\r\nexport function createGroupMapping(groups, dataCount, step) {\r\n    if (step === void 0) { step = 1; }\r\n    var maxId = arrayMax(groups);\r\n    var offsets = new Int32Array(maxId + 2);\r\n    var bucketFill = new Int32Array(dataCount);\r\n    var bucketSizes = new Int32Array(dataCount);\r\n    for (var i = 0, il = dataCount * step; i < il; i += step)\r\n        ++bucketSizes[groups[i]];\r\n    var offset = 0;\r\n    for (var i = 0; i < dataCount; i++) {\r\n        offsets[i] = offset;\r\n        offset += bucketSizes[i];\r\n    }\r\n    offsets[dataCount] = offset;\r\n    var indices = new Int32Array(offset);\r\n    for (var i = 0, il = dataCount * step; i < il; i += step) {\r\n        var g = groups[i];\r\n        var og = offsets[g] + bucketFill[g];\r\n        indices[og] = i;\r\n        ++bucketFill[g];\r\n    }\r\n    return { indices: indices, offsets: offsets };\r\n}\r\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}