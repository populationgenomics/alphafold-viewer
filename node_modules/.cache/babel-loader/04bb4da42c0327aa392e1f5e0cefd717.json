{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __spreadArray } from \"tslib\";\nimport { Database, Column, ColumnHelpers } from '../../../mol-data/db';\nimport { Tensor } from '../../../mol-math/linear-algebra';\nimport { arrayEqual } from '../../../mol-util';\nimport * as Data from './data-model';\nexport var FieldPath;\n\n(function (FieldPath) {\n  function canonical(path) {\n    return path.replace('.', '_').replace(/\\[/, '_').replace(/(\\[|\\])/g, '');\n  }\n\n  FieldPath.canonical = canonical;\n\n  function equal(pathA, pathB) {\n    return canonical(pathA) === canonical(pathB);\n  }\n\n  FieldPath.equal = equal;\n\n  function create(category, field, asCanonical) {\n    if (asCanonical === void 0) {\n      asCanonical = false;\n    }\n\n    var p = \"\" + category + (field ? \".\" + field : '');\n    return asCanonical ? canonical(p) : p;\n  }\n\n  FieldPath.create = create;\n})(FieldPath || (FieldPath = {}));\n\nexport function toDatabaseCollection(schema, file, aliases) {\n  var dbc = {};\n\n  for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {\n    var data = _a[_i];\n    dbc[data.header] = toDatabase(schema, data, aliases);\n  }\n\n  return dbc;\n}\nexport function toDatabase(schema, frame, aliases) {\n  return createDatabase(schema, frame, aliases);\n}\nexport function toTable(schema, category) {\n  return new CategoryTable(category, schema, true);\n}\n\nfunction getColumnCtor(t) {\n  switch (t.valueType) {\n    case 'str':\n      return function (f, c, k) {\n        return createColumn(t, f, f.str, f.toStringArray);\n      };\n\n    case 'int':\n      return function (f, c, k) {\n        return createColumn(t, f, f.int, f.toIntArray);\n      };\n\n    case 'float':\n      return function (f, c, k) {\n        return createColumn(t, f, f.float, f.toFloatArray);\n      };\n\n    case 'list':\n      throw new Error('Use createListColumn instead.');\n\n    case 'tensor':\n      throw new Error('Use createTensorColumn instead.');\n  }\n}\n\nfunction createColumn(schema, field, value, toArray) {\n  return {\n    schema: schema,\n    __array: field.__array,\n    isDefined: field.isDefined,\n    rowCount: field.rowCount,\n    value: value,\n    valueKind: field.valueKind,\n    areValuesEqual: field.areValuesEqual,\n    toArray: toArray\n  };\n}\n\nfunction createListColumn(schema, category, key) {\n  var separator = schema.separator;\n  var itemParse = schema.itemParse;\n  var f = category.getField(key);\n  var value = f ? function (row) {\n    return f.str(row).split(separator).map(function (x) {\n      return itemParse(x.trim());\n    }).filter(function (x) {\n      return !!x;\n    });\n  } : function (row) {\n    return [];\n  };\n\n  var toArray = function (params) {\n    return ColumnHelpers.createAndFillArray(category.rowCount, value, params);\n  };\n\n  return {\n    schema: schema,\n    __array: void 0,\n    isDefined: !!f,\n    rowCount: category.rowCount,\n    value: value,\n    valueKind: f ? f.valueKind : function () {\n      return 1\n      /* NotPresent */\n      ;\n    },\n    areValuesEqual: function (rowA, rowB) {\n      return arrayEqual(value(rowA), value(rowB));\n    },\n    toArray: toArray\n  };\n}\n\nfunction createTensorColumn(schema, category, key) {\n  var space = schema.space;\n  var zeroOffset = category.fieldNames.includes(key + \"[0]\") || category.fieldNames.includes(key + \"[0][0]\") || category.fieldNames.includes(key + \"[0][0][0]\");\n  var fst = zeroOffset ? 0 : 1;\n  var namingVariant = category.fieldNames.includes(key + \"_1\") || category.fieldNames.includes(key + \"_11\") || category.fieldNames.includes(key + \"_111\") ? 'underscore' : 'brackets';\n  var getName = Data.tensorFieldNameGetter(key, space.rank, zeroOffset, namingVariant);\n  var first = category.getField(getName(fst, fst, fst)) || Column.Undefined(category.rowCount, schema);\n\n  var value = function (row) {\n    return Data.getTensor(category, space, row, getName);\n  };\n\n  var toArray = function (params) {\n    return ColumnHelpers.createAndFillArray(category.rowCount, value, params);\n  };\n\n  return {\n    schema: schema,\n    __array: void 0,\n    isDefined: first.isDefined,\n    rowCount: category.rowCount,\n    value: value,\n    valueKind: first.valueKind,\n    areValuesEqual: function (rowA, rowB) {\n      return Tensor.areEqualExact(value(rowA), value(rowB));\n    },\n    toArray: toArray\n  };\n}\n\nvar CategoryTable =\n/** @class */\nfunction () {\n  function CategoryTable(category, schema, _isDefined) {\n    this._isDefined = _isDefined;\n    var fieldKeys = Object.keys(schema);\n    this._rowCount = category.rowCount;\n    this._columns = fieldKeys;\n    this._schema = schema;\n    var cache = Object.create(null);\n\n    var _loop_1 = function (k) {\n      Object.defineProperty(this_1, k, {\n        get: function () {\n          if (cache[k]) return cache[k];\n          var fType = schema[k];\n\n          if (fType.valueType === 'list') {\n            cache[k] = createListColumn(fType, category, k);\n          } else if (fType.valueType === 'tensor') {\n            cache[k] = createTensorColumn(fType, category, k);\n          } else {\n            var ctor = getColumnCtor(fType);\n            var field = category.getField(k);\n            cache[k] = !!field ? ctor(field, category, k) : Column.Undefined(category.rowCount, fType);\n          }\n\n          return cache[k];\n        },\n        enumerable: true,\n        configurable: false\n      });\n    };\n\n    var this_1 = this;\n\n    for (var _i = 0, fieldKeys_1 = fieldKeys; _i < fieldKeys_1.length; _i++) {\n      var k = fieldKeys_1[_i];\n\n      _loop_1(k);\n    }\n  }\n\n  return CategoryTable;\n}();\n\nfunction createDatabase(schema, frame, aliases) {\n  var tables = Object.create(null);\n\n  for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\n    var k = _a[_i];\n    tables[k] = createTable(k, schema[k], frame, aliases);\n  }\n\n  return Database.ofTables(frame.header, schema, tables);\n}\n\nfunction flattenFrame(frame) {\n  var flatFrame = Object.create(null);\n\n  for (var _i = 0, _a = Object.keys(frame.categories); _i < _a.length; _i++) {\n    var c = _a[_i];\n\n    for (var _b = 0, _c = frame.categories[c].fieldNames; _b < _c.length; _b++) {\n      var f = _c[_b];\n      var p = FieldPath.create(c, f, true);\n      flatFrame[p] = frame.categories[c].getField(f);\n    }\n  }\n\n  return flatFrame;\n}\n\nfunction getField(field, category, flatFrame, aliases) {\n  var path = FieldPath.create(category, field);\n  var canonicalPath = FieldPath.canonical(path);\n  if (canonicalPath in flatFrame) return flatFrame[canonicalPath];\n\n  if (aliases && path in aliases) {\n    for (var _i = 0, _a = aliases[path]; _i < _a.length; _i++) {\n      var aliased = _a[_i];\n      var canonicalAliased = FieldPath.canonical(aliased);\n      if (canonicalAliased in flatFrame) return flatFrame[canonicalAliased];\n    }\n  }\n}\n\nfunction createTable(key, schema, frame, aliases) {\n  var cat = frame.categories[key];\n\n  if (aliases) {\n    var flatFrame = flattenFrame(frame);\n    var fields_1 = Object.create(null);\n    var fieldNames = [];\n    var rowCount = 0;\n\n    for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\n      var k = _a[_i];\n      var field = getField(k, key, flatFrame, aliases);\n\n      if (field) {\n        fields_1[k] = field;\n        fieldNames.push(k);\n        rowCount = field.rowCount;\n      }\n    }\n\n    cat = {\n      rowCount: rowCount,\n      name: key,\n      fieldNames: __spreadArray([], fieldNames, true),\n      getField: function (name) {\n        return fields_1[name];\n      }\n    };\n  }\n\n  return new CategoryTable(cat || Data.CifCategory.empty(key), schema, !!cat);\n}","map":{"version":3,"sources":["../../../../src/mol-io/reader/cif/schema.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __spreadArray } from \"tslib\";\r\nimport { Database, Column, ColumnHelpers } from '../../../mol-data/db';\r\nimport { Tensor } from '../../../mol-math/linear-algebra';\r\nimport { arrayEqual } from '../../../mol-util';\r\nimport * as Data from './data-model';\r\nexport var FieldPath;\r\n(function (FieldPath) {\r\n    function canonical(path) {\r\n        return path.replace('.', '_').replace(/\\[/, '_').replace(/(\\[|\\])/g, '');\r\n    }\r\n    FieldPath.canonical = canonical;\r\n    function equal(pathA, pathB) {\r\n        return canonical(pathA) === canonical(pathB);\r\n    }\r\n    FieldPath.equal = equal;\r\n    function create(category, field, asCanonical) {\r\n        if (asCanonical === void 0) { asCanonical = false; }\r\n        var p = \"\" + category + (field ? \".\" + field : '');\r\n        return asCanonical ? canonical(p) : p;\r\n    }\r\n    FieldPath.create = create;\r\n})(FieldPath || (FieldPath = {}));\r\nexport function toDatabaseCollection(schema, file, aliases) {\r\n    var dbc = {};\r\n    for (var _i = 0, _a = file.blocks; _i < _a.length; _i++) {\r\n        var data = _a[_i];\r\n        dbc[data.header] = toDatabase(schema, data, aliases);\r\n    }\r\n    return dbc;\r\n}\r\nexport function toDatabase(schema, frame, aliases) {\r\n    return createDatabase(schema, frame, aliases);\r\n}\r\nexport function toTable(schema, category) {\r\n    return new CategoryTable(category, schema, true);\r\n}\r\nfunction getColumnCtor(t) {\r\n    switch (t.valueType) {\r\n        case 'str': return function (f, c, k) { return createColumn(t, f, f.str, f.toStringArray); };\r\n        case 'int': return function (f, c, k) { return createColumn(t, f, f.int, f.toIntArray); };\r\n        case 'float': return function (f, c, k) { return createColumn(t, f, f.float, f.toFloatArray); };\r\n        case 'list': throw new Error('Use createListColumn instead.');\r\n        case 'tensor': throw new Error('Use createTensorColumn instead.');\r\n    }\r\n}\r\nfunction createColumn(schema, field, value, toArray) {\r\n    return {\r\n        schema: schema,\r\n        __array: field.__array,\r\n        isDefined: field.isDefined,\r\n        rowCount: field.rowCount,\r\n        value: value,\r\n        valueKind: field.valueKind,\r\n        areValuesEqual: field.areValuesEqual,\r\n        toArray: toArray\r\n    };\r\n}\r\nfunction createListColumn(schema, category, key) {\r\n    var separator = schema.separator;\r\n    var itemParse = schema.itemParse;\r\n    var f = category.getField(key);\r\n    var value = f ? function (row) { return f.str(row).split(separator).map(function (x) { return itemParse(x.trim()); }).filter(function (x) { return !!x; }); } : function (row) { return []; };\r\n    var toArray = function (params) { return ColumnHelpers.createAndFillArray(category.rowCount, value, params); };\r\n    return {\r\n        schema: schema,\r\n        __array: void 0,\r\n        isDefined: !!f,\r\n        rowCount: category.rowCount,\r\n        value: value,\r\n        valueKind: f ? f.valueKind : function () { return 1 /* NotPresent */; },\r\n        areValuesEqual: function (rowA, rowB) { return arrayEqual(value(rowA), value(rowB)); },\r\n        toArray: toArray\r\n    };\r\n}\r\nfunction createTensorColumn(schema, category, key) {\r\n    var space = schema.space;\r\n    var zeroOffset = (category.fieldNames.includes(key + \"[0]\") ||\r\n        category.fieldNames.includes(key + \"[0][0]\") ||\r\n        category.fieldNames.includes(key + \"[0][0][0]\"));\r\n    var fst = zeroOffset ? 0 : 1;\r\n    var namingVariant = (category.fieldNames.includes(key + \"_1\") ||\r\n        category.fieldNames.includes(key + \"_11\") ||\r\n        category.fieldNames.includes(key + \"_111\")) ? 'underscore' : 'brackets';\r\n    var getName = Data.tensorFieldNameGetter(key, space.rank, zeroOffset, namingVariant);\r\n    var first = category.getField(getName(fst, fst, fst)) || Column.Undefined(category.rowCount, schema);\r\n    var value = function (row) { return Data.getTensor(category, space, row, getName); };\r\n    var toArray = function (params) { return ColumnHelpers.createAndFillArray(category.rowCount, value, params); };\r\n    return {\r\n        schema: schema,\r\n        __array: void 0,\r\n        isDefined: first.isDefined,\r\n        rowCount: category.rowCount,\r\n        value: value,\r\n        valueKind: first.valueKind,\r\n        areValuesEqual: function (rowA, rowB) { return Tensor.areEqualExact(value(rowA), value(rowB)); },\r\n        toArray: toArray\r\n    };\r\n}\r\nvar CategoryTable = /** @class */ (function () {\r\n    function CategoryTable(category, schema, _isDefined) {\r\n        this._isDefined = _isDefined;\r\n        var fieldKeys = Object.keys(schema);\r\n        this._rowCount = category.rowCount;\r\n        this._columns = fieldKeys;\r\n        this._schema = schema;\r\n        var cache = Object.create(null);\r\n        var _loop_1 = function (k) {\r\n            Object.defineProperty(this_1, k, {\r\n                get: function () {\r\n                    if (cache[k])\r\n                        return cache[k];\r\n                    var fType = schema[k];\r\n                    if (fType.valueType === 'list') {\r\n                        cache[k] = createListColumn(fType, category, k);\r\n                    }\r\n                    else if (fType.valueType === 'tensor') {\r\n                        cache[k] = createTensorColumn(fType, category, k);\r\n                    }\r\n                    else {\r\n                        var ctor = getColumnCtor(fType);\r\n                        var field = category.getField(k);\r\n                        cache[k] = !!field ? ctor(field, category, k) : Column.Undefined(category.rowCount, fType);\r\n                    }\r\n                    return cache[k];\r\n                },\r\n                enumerable: true,\r\n                configurable: false\r\n            });\r\n        };\r\n        var this_1 = this;\r\n        for (var _i = 0, fieldKeys_1 = fieldKeys; _i < fieldKeys_1.length; _i++) {\r\n            var k = fieldKeys_1[_i];\r\n            _loop_1(k);\r\n        }\r\n    }\r\n    return CategoryTable;\r\n}());\r\nfunction createDatabase(schema, frame, aliases) {\r\n    var tables = Object.create(null);\r\n    for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\r\n        var k = _a[_i];\r\n        tables[k] = createTable(k, schema[k], frame, aliases);\r\n    }\r\n    return Database.ofTables(frame.header, schema, tables);\r\n}\r\nfunction flattenFrame(frame) {\r\n    var flatFrame = Object.create(null);\r\n    for (var _i = 0, _a = Object.keys(frame.categories); _i < _a.length; _i++) {\r\n        var c = _a[_i];\r\n        for (var _b = 0, _c = frame.categories[c].fieldNames; _b < _c.length; _b++) {\r\n            var f = _c[_b];\r\n            var p = FieldPath.create(c, f, true);\r\n            flatFrame[p] = frame.categories[c].getField(f);\r\n        }\r\n    }\r\n    return flatFrame;\r\n}\r\nfunction getField(field, category, flatFrame, aliases) {\r\n    var path = FieldPath.create(category, field);\r\n    var canonicalPath = FieldPath.canonical(path);\r\n    if (canonicalPath in flatFrame)\r\n        return flatFrame[canonicalPath];\r\n    if (aliases && path in aliases) {\r\n        for (var _i = 0, _a = aliases[path]; _i < _a.length; _i++) {\r\n            var aliased = _a[_i];\r\n            var canonicalAliased = FieldPath.canonical(aliased);\r\n            if (canonicalAliased in flatFrame)\r\n                return flatFrame[canonicalAliased];\r\n        }\r\n    }\r\n}\r\nfunction createTable(key, schema, frame, aliases) {\r\n    var cat = frame.categories[key];\r\n    if (aliases) {\r\n        var flatFrame = flattenFrame(frame);\r\n        var fields_1 = Object.create(null);\r\n        var fieldNames = [];\r\n        var rowCount = 0;\r\n        for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\r\n            var k = _a[_i];\r\n            var field = getField(k, key, flatFrame, aliases);\r\n            if (field) {\r\n                fields_1[k] = field;\r\n                fieldNames.push(k);\r\n                rowCount = field.rowCount;\r\n            }\r\n        }\r\n        cat = {\r\n            rowCount: rowCount,\r\n            name: key,\r\n            fieldNames: __spreadArray([], fieldNames, true),\r\n            getField: function (name) {\r\n                return fields_1[name];\r\n            }\r\n        };\r\n    }\r\n    return new CategoryTable(cat || Data.CifCategory.empty(key), schema, !!cat);\r\n}\r\n//# sourceMappingURL=schema.js.map"]},"metadata":{},"sourceType":"module"}