{"ast":null,"code":"/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { createTextureImage } from '../../../mol-gl/renderable/util';\nimport { Box3D } from '../../../mol-math/geometry';\nimport { Vec2, Vec3, Vec4 } from '../../../mol-math/linear-algebra';\nimport { getVolumeTexture2dLayout } from '../../../mol-repr/volume/util';\nimport { Color } from '../../../mol-util/color';\nexport function calcMeshColorSmoothing(input, resolution, stride, webgl, texture) {\n  var colorType = input.colorType,\n      vertexCount = input.vertexCount,\n      groupCount = input.groupCount,\n      positionBuffer = input.positionBuffer,\n      transformBuffer = input.transformBuffer,\n      groupBuffer = input.groupBuffer;\n  var isInstanceType = colorType.endsWith('Instance');\n  var box = Box3D.fromSphere3D(Box3D(), isInstanceType ? input.boundingSphere : input.invariantBoundingSphere);\n  var scaleFactor = 1 / resolution;\n  var scaledBox = Box3D.scale(Box3D(), box, scaleFactor);\n  var gridDim = Box3D.size(Vec3(), scaledBox);\n  Vec3.ceil(gridDim, gridDim);\n  Vec3.add(gridDim, gridDim, Vec3.create(2, 2, 2));\n  var min = box.min;\n  var xn = gridDim[0],\n      yn = gridDim[1];\n\n  var _a = getVolumeTexture2dLayout(gridDim),\n      width = _a.width,\n      height = _a.height; // console.log({ width, height, dim });\n\n\n  var itemSize = 3;\n  var data = new Float32Array(width * height * itemSize);\n  var count = new Float32Array(width * height);\n  var grid = new Uint8Array(width * height * itemSize);\n  var textureImage = {\n    array: grid,\n    width: width,\n    height: height,\n    filter: 'linear'\n  };\n  var instanceCount = isInstanceType ? input.instanceCount : 1;\n  var colors = input.colorData.array;\n\n  function getIndex(x, y, z) {\n    var column = Math.floor(z * xn % width / xn);\n    var row = Math.floor(z * xn / width);\n    var px = column * xn + x;\n    return itemSize * (row * yn * width + y * width + px);\n  }\n\n  var p = 2;\n  var dimX = gridDim[0],\n      dimY = gridDim[1],\n      dimZ = gridDim[2];\n  var v = Vec3();\n\n  for (var i = 0; i < instanceCount; ++i) {\n    for (var j = 0; j < vertexCount; j += stride) {\n      Vec3.fromArray(v, positionBuffer, j * 3);\n      if (isInstanceType) Vec3.transformMat4Offset(v, v, transformBuffer, 0, 0, i * 16);\n      Vec3.sub(v, v, min);\n      Vec3.scale(v, v, scaleFactor);\n      var vx = v[0],\n          vy = v[1],\n          vz = v[2]; // vertex mapped to grid\n\n      var x = Math.floor(vx);\n      var y = Math.floor(vy);\n      var z = Math.floor(vz); // group colors\n\n      var ci = i * groupCount + groupBuffer[j];\n      var r = colors[ci * 3];\n      var g = colors[ci * 3 + 1];\n      var b = colors[ci * 3 + 2]; // Extents of grid to consider for this atom\n\n      var begX = Math.max(0, x - p);\n      var begY = Math.max(0, y - p);\n      var begZ = Math.max(0, z - p); // Add two to these points:\n      // - x, y, z are floor'd values so this ensures coverage\n      // - these are loop limits (exclusive)\n\n      var endX = Math.min(dimX, x + p + 2);\n      var endY = Math.min(dimY, y + p + 2);\n      var endZ = Math.min(dimZ, z + p + 2);\n\n      for (var xi = begX; xi < endX; ++xi) {\n        var dx = xi - vx;\n\n        for (var yi = begY; yi < endY; ++yi) {\n          var dy = yi - vy;\n\n          for (var zi = begZ; zi < endZ; ++zi) {\n            var dz = zi - vz;\n            var d = Math.sqrt(dx * dx + dy * dy + dz * dz);\n            if (d > p) continue;\n            var s = p - d;\n            var index = getIndex(xi, yi, zi);\n            data[index] += r * s;\n            data[index + 1] += g * s;\n            data[index + 2] += b * s;\n            count[index / 3] += s;\n          }\n        }\n      }\n    }\n  }\n\n  for (var i = 0, il = count.length; i < il; ++i) {\n    var i3 = i * 3;\n    var c = count[i];\n    grid[i3] = Math.round(data[i3] / c);\n    grid[i3 + 1] = Math.round(data[i3 + 1] / c);\n    grid[i3 + 2] = Math.round(data[i3 + 2] / c);\n  }\n\n  var gridTexDim = Vec2.create(width, height);\n  var gridTransform = Vec4.create(min[0], min[1], min[2], scaleFactor);\n  var type = isInstanceType ? 'volumeInstance' : 'volume';\n\n  if (webgl) {\n    if (!texture) texture = webgl.resources.texture('image-uint8', 'rgb', 'ubyte', 'linear');\n    texture.load(textureImage);\n    return {\n      kind: 'volume',\n      texture: texture,\n      gridTexDim: gridTexDim,\n      gridDim: gridDim,\n      gridTransform: gridTransform,\n      type: type\n    };\n  } else {\n    var interpolated = getTrilinearlyInterpolated({\n      vertexCount: vertexCount,\n      instanceCount: instanceCount,\n      transformBuffer: transformBuffer,\n      positionBuffer: positionBuffer,\n      colorType: type,\n      grid: grid,\n      gridDim: gridDim,\n      gridTexDim: gridTexDim,\n      gridTransform: gridTransform,\n      vertexStride: 3,\n      colorStride: 3\n    });\n    return {\n      kind: 'vertex',\n      texture: interpolated,\n      texDim: Vec2.create(interpolated.width, interpolated.height),\n      type: isInstanceType ? 'vertexInstance' : 'vertex'\n    };\n  }\n}\nexport function getTrilinearlyInterpolated(input) {\n  var vertexCount = input.vertexCount,\n      positionBuffer = input.positionBuffer,\n      transformBuffer = input.transformBuffer,\n      grid = input.grid,\n      gridDim = input.gridDim,\n      gridTexDim = input.gridTexDim,\n      gridTransform = input.gridTransform,\n      vertexStride = input.vertexStride,\n      colorStride = input.colorStride;\n  var isInstanceType = input.colorType.endsWith('Instance');\n  var instanceCount = isInstanceType ? input.instanceCount : 1;\n  var image = createTextureImage(Math.max(1, instanceCount * vertexCount), 3, Uint8Array);\n  var array = image.array;\n  var xn = gridDim[0],\n      yn = gridDim[1];\n  var width = gridTexDim[0];\n  var min = Vec3.fromArray(Vec3(), gridTransform, 0);\n  var scaleFactor = gridTransform[3];\n\n  function getIndex(x, y, z) {\n    var column = Math.floor(z * xn % width / xn);\n    var row = Math.floor(z * xn / width);\n    var px = column * xn + x;\n    return colorStride * (row * yn * width + y * width + px);\n  }\n\n  var v = Vec3();\n  var v0 = Vec3();\n  var v1 = Vec3();\n  var vd = Vec3();\n\n  for (var i = 0; i < instanceCount; ++i) {\n    for (var j = 0; j < vertexCount; ++j) {\n      Vec3.fromArray(v, positionBuffer, j * vertexStride);\n      if (isInstanceType) Vec3.transformMat4Offset(v, v, transformBuffer, 0, 0, i * 16);\n      Vec3.sub(v, v, min);\n      Vec3.scale(v, v, scaleFactor);\n      Vec3.floor(v0, v);\n      Vec3.ceil(v1, v);\n      Vec3.sub(vd, v, v0);\n      Vec3.sub(v, v1, v0);\n      Vec3.div(vd, vd, v);\n      var x0 = v0[0],\n          y0 = v0[1],\n          z0 = v0[2];\n      var x1 = v1[0],\n          y1 = v1[1],\n          z1 = v1[2];\n      var xd = vd[0],\n          yd = vd[1],\n          zd = vd[2];\n      var s000 = Color.fromArray(grid, getIndex(x0, y0, z0));\n      var s100 = Color.fromArray(grid, getIndex(x1, y0, z0));\n      var s001 = Color.fromArray(grid, getIndex(x0, y0, z1));\n      var s101 = Color.fromArray(grid, getIndex(x1, y0, z1));\n      var s010 = Color.fromArray(grid, getIndex(x0, y1, z0));\n      var s110 = Color.fromArray(grid, getIndex(x1, y1, z0));\n      var s011 = Color.fromArray(grid, getIndex(x0, y1, z1));\n      var s111 = Color.fromArray(grid, getIndex(x1, y1, z1));\n      var s00 = Color.interpolate(s000, s100, xd);\n      var s01 = Color.interpolate(s001, s101, xd);\n      var s10 = Color.interpolate(s010, s110, xd);\n      var s11 = Color.interpolate(s011, s111, xd);\n      var s0 = Color.interpolate(s00, s10, yd);\n      var s1 = Color.interpolate(s01, s11, yd);\n      Color.toArray(Color.interpolate(s0, s1, zd), array, (i * vertexCount + j) * 3);\n    }\n  }\n\n  return image;\n}","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/mesh/color-smoothing.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { createTextureImage } from '../../../mol-gl/renderable/util';\r\nimport { Box3D } from '../../../mol-math/geometry';\r\nimport { Vec2, Vec3, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { getVolumeTexture2dLayout } from '../../../mol-repr/volume/util';\r\nimport { Color } from '../../../mol-util/color';\r\nexport function calcMeshColorSmoothing(input, resolution, stride, webgl, texture) {\r\n    var colorType = input.colorType, vertexCount = input.vertexCount, groupCount = input.groupCount, positionBuffer = input.positionBuffer, transformBuffer = input.transformBuffer, groupBuffer = input.groupBuffer;\r\n    var isInstanceType = colorType.endsWith('Instance');\r\n    var box = Box3D.fromSphere3D(Box3D(), isInstanceType ? input.boundingSphere : input.invariantBoundingSphere);\r\n    var scaleFactor = 1 / resolution;\r\n    var scaledBox = Box3D.scale(Box3D(), box, scaleFactor);\r\n    var gridDim = Box3D.size(Vec3(), scaledBox);\r\n    Vec3.ceil(gridDim, gridDim);\r\n    Vec3.add(gridDim, gridDim, Vec3.create(2, 2, 2));\r\n    var min = box.min;\r\n    var xn = gridDim[0], yn = gridDim[1];\r\n    var _a = getVolumeTexture2dLayout(gridDim), width = _a.width, height = _a.height;\r\n    // console.log({ width, height, dim });\r\n    var itemSize = 3;\r\n    var data = new Float32Array(width * height * itemSize);\r\n    var count = new Float32Array(width * height);\r\n    var grid = new Uint8Array(width * height * itemSize);\r\n    var textureImage = { array: grid, width: width, height: height, filter: 'linear' };\r\n    var instanceCount = isInstanceType ? input.instanceCount : 1;\r\n    var colors = input.colorData.array;\r\n    function getIndex(x, y, z) {\r\n        var column = Math.floor(((z * xn) % width) / xn);\r\n        var row = Math.floor((z * xn) / width);\r\n        var px = column * xn + x;\r\n        return itemSize * ((row * yn * width) + (y * width) + px);\r\n    }\r\n    var p = 2;\r\n    var dimX = gridDim[0], dimY = gridDim[1], dimZ = gridDim[2];\r\n    var v = Vec3();\r\n    for (var i = 0; i < instanceCount; ++i) {\r\n        for (var j = 0; j < vertexCount; j += stride) {\r\n            Vec3.fromArray(v, positionBuffer, j * 3);\r\n            if (isInstanceType)\r\n                Vec3.transformMat4Offset(v, v, transformBuffer, 0, 0, i * 16);\r\n            Vec3.sub(v, v, min);\r\n            Vec3.scale(v, v, scaleFactor);\r\n            var vx = v[0], vy = v[1], vz = v[2];\r\n            // vertex mapped to grid\r\n            var x = Math.floor(vx);\r\n            var y = Math.floor(vy);\r\n            var z = Math.floor(vz);\r\n            // group colors\r\n            var ci = i * groupCount + groupBuffer[j];\r\n            var r = colors[ci * 3];\r\n            var g = colors[ci * 3 + 1];\r\n            var b = colors[ci * 3 + 2];\r\n            // Extents of grid to consider for this atom\r\n            var begX = Math.max(0, x - p);\r\n            var begY = Math.max(0, y - p);\r\n            var begZ = Math.max(0, z - p);\r\n            // Add two to these points:\r\n            // - x, y, z are floor'd values so this ensures coverage\r\n            // - these are loop limits (exclusive)\r\n            var endX = Math.min(dimX, x + p + 2);\r\n            var endY = Math.min(dimY, y + p + 2);\r\n            var endZ = Math.min(dimZ, z + p + 2);\r\n            for (var xi = begX; xi < endX; ++xi) {\r\n                var dx = xi - vx;\r\n                for (var yi = begY; yi < endY; ++yi) {\r\n                    var dy = yi - vy;\r\n                    for (var zi = begZ; zi < endZ; ++zi) {\r\n                        var dz = zi - vz;\r\n                        var d = Math.sqrt(dx * dx + dy * dy + dz * dz);\r\n                        if (d > p)\r\n                            continue;\r\n                        var s = p - d;\r\n                        var index = getIndex(xi, yi, zi);\r\n                        data[index] += r * s;\r\n                        data[index + 1] += g * s;\r\n                        data[index + 2] += b * s;\r\n                        count[index / 3] += s;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (var i = 0, il = count.length; i < il; ++i) {\r\n        var i3 = i * 3;\r\n        var c = count[i];\r\n        grid[i3] = Math.round(data[i3] / c);\r\n        grid[i3 + 1] = Math.round(data[i3 + 1] / c);\r\n        grid[i3 + 2] = Math.round(data[i3 + 2] / c);\r\n    }\r\n    var gridTexDim = Vec2.create(width, height);\r\n    var gridTransform = Vec4.create(min[0], min[1], min[2], scaleFactor);\r\n    var type = isInstanceType ? 'volumeInstance' : 'volume';\r\n    if (webgl) {\r\n        if (!texture)\r\n            texture = webgl.resources.texture('image-uint8', 'rgb', 'ubyte', 'linear');\r\n        texture.load(textureImage);\r\n        return { kind: 'volume', texture: texture, gridTexDim: gridTexDim, gridDim: gridDim, gridTransform: gridTransform, type: type };\r\n    }\r\n    else {\r\n        var interpolated = getTrilinearlyInterpolated({ vertexCount: vertexCount, instanceCount: instanceCount, transformBuffer: transformBuffer, positionBuffer: positionBuffer, colorType: type, grid: grid, gridDim: gridDim, gridTexDim: gridTexDim, gridTransform: gridTransform, vertexStride: 3, colorStride: 3 });\r\n        return {\r\n            kind: 'vertex',\r\n            texture: interpolated,\r\n            texDim: Vec2.create(interpolated.width, interpolated.height),\r\n            type: isInstanceType ? 'vertexInstance' : 'vertex'\r\n        };\r\n    }\r\n}\r\nexport function getTrilinearlyInterpolated(input) {\r\n    var vertexCount = input.vertexCount, positionBuffer = input.positionBuffer, transformBuffer = input.transformBuffer, grid = input.grid, gridDim = input.gridDim, gridTexDim = input.gridTexDim, gridTransform = input.gridTransform, vertexStride = input.vertexStride, colorStride = input.colorStride;\r\n    var isInstanceType = input.colorType.endsWith('Instance');\r\n    var instanceCount = isInstanceType ? input.instanceCount : 1;\r\n    var image = createTextureImage(Math.max(1, instanceCount * vertexCount), 3, Uint8Array);\r\n    var array = image.array;\r\n    var xn = gridDim[0], yn = gridDim[1];\r\n    var width = gridTexDim[0];\r\n    var min = Vec3.fromArray(Vec3(), gridTransform, 0);\r\n    var scaleFactor = gridTransform[3];\r\n    function getIndex(x, y, z) {\r\n        var column = Math.floor(((z * xn) % width) / xn);\r\n        var row = Math.floor((z * xn) / width);\r\n        var px = column * xn + x;\r\n        return colorStride * ((row * yn * width) + (y * width) + px);\r\n    }\r\n    var v = Vec3();\r\n    var v0 = Vec3();\r\n    var v1 = Vec3();\r\n    var vd = Vec3();\r\n    for (var i = 0; i < instanceCount; ++i) {\r\n        for (var j = 0; j < vertexCount; ++j) {\r\n            Vec3.fromArray(v, positionBuffer, j * vertexStride);\r\n            if (isInstanceType)\r\n                Vec3.transformMat4Offset(v, v, transformBuffer, 0, 0, i * 16);\r\n            Vec3.sub(v, v, min);\r\n            Vec3.scale(v, v, scaleFactor);\r\n            Vec3.floor(v0, v);\r\n            Vec3.ceil(v1, v);\r\n            Vec3.sub(vd, v, v0);\r\n            Vec3.sub(v, v1, v0);\r\n            Vec3.div(vd, vd, v);\r\n            var x0 = v0[0], y0 = v0[1], z0 = v0[2];\r\n            var x1 = v1[0], y1 = v1[1], z1 = v1[2];\r\n            var xd = vd[0], yd = vd[1], zd = vd[2];\r\n            var s000 = Color.fromArray(grid, getIndex(x0, y0, z0));\r\n            var s100 = Color.fromArray(grid, getIndex(x1, y0, z0));\r\n            var s001 = Color.fromArray(grid, getIndex(x0, y0, z1));\r\n            var s101 = Color.fromArray(grid, getIndex(x1, y0, z1));\r\n            var s010 = Color.fromArray(grid, getIndex(x0, y1, z0));\r\n            var s110 = Color.fromArray(grid, getIndex(x1, y1, z0));\r\n            var s011 = Color.fromArray(grid, getIndex(x0, y1, z1));\r\n            var s111 = Color.fromArray(grid, getIndex(x1, y1, z1));\r\n            var s00 = Color.interpolate(s000, s100, xd);\r\n            var s01 = Color.interpolate(s001, s101, xd);\r\n            var s10 = Color.interpolate(s010, s110, xd);\r\n            var s11 = Color.interpolate(s011, s111, xd);\r\n            var s0 = Color.interpolate(s00, s10, yd);\r\n            var s1 = Color.interpolate(s01, s11, yd);\r\n            Color.toArray(Color.interpolate(s0, s1, zd), array, (i * vertexCount + j) * 3);\r\n        }\r\n    }\r\n    return image;\r\n}\r\n//# sourceMappingURL=color-smoothing.js.map"]},"metadata":{},"sourceType":"module"}