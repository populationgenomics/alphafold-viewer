{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Mat4, Tensor } from '../../mol-math/linear-algebra';\nimport { Task } from '../../mol-task';\nimport { arrayMax, arrayMean, arrayMin, arrayRms } from '../../mol-util/array';\nimport { CustomProperties } from '../../mol-model/custom-property';\nexport function volumeFromCube(source, params) {\n  var _this = this;\n\n  return Task.create('Create Volume', function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var header, sourceValues, space, values, _a, h, k, l, nth, o, s, u, v, w, data, matrix, basis;\n\n      return __generator(this, function (_b) {\n        header = source.header, sourceValues = source.values;\n        space = Tensor.Space(header.dim, [0, 1, 2], Float64Array);\n\n        if (header.dataSetIds.length === 0) {\n          values = sourceValues;\n        } else {\n          _a = header.dim, h = _a[0], k = _a[1], l = _a[2];\n          nth = ((params === null || params === void 0 ? void 0 : params.dataIndex) || 0) + 1;\n          o = 0, s = 0;\n          values = new Float64Array(h * k * l);\n\n          for (u = 0; u < h; u++) {\n            for (v = 0; v < k; v++) {\n              for (w = 0; w < l; w++) {\n                values[o++] = sourceValues[s];\n                s += nth;\n              }\n            }\n          }\n        }\n\n        data = Tensor.create(space, Tensor.Data1(values));\n        matrix = Mat4.fromTranslation(Mat4(), header.origin);\n        basis = Mat4.fromBasis(Mat4(), header.basisX, header.basisY, header.basisZ);\n        Mat4.mul(matrix, matrix, basis);\n        return [2\n        /*return*/\n        , {\n          label: params === null || params === void 0 ? void 0 : params.label,\n          entryId: params === null || params === void 0 ? void 0 : params.entryId,\n          grid: {\n            transform: {\n              kind: 'matrix',\n              matrix: matrix\n            },\n            cells: data,\n            stats: {\n              min: arrayMin(values),\n              max: arrayMax(values),\n              mean: arrayMean(values),\n              sigma: arrayRms(values)\n            }\n          },\n          sourceData: CubeFormat.create(source),\n          customProperties: new CustomProperties(),\n          _propertyData: Object.create(null)\n        }];\n      });\n    });\n  });\n} //\n\nexport { CubeFormat };\nvar CubeFormat;\n\n(function (CubeFormat) {\n  function is(x) {\n    return (x === null || x === void 0 ? void 0 : x.kind) === 'cube';\n  }\n\n  CubeFormat.is = is;\n\n  function create(cube) {\n    return {\n      kind: 'cube',\n      name: cube.name,\n      data: cube\n    };\n  }\n\n  CubeFormat.create = create;\n})(CubeFormat || (CubeFormat = {}));","map":{"version":3,"sources":["../../../src/mol-model-formats/volume/cube.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Mat4, Tensor } from '../../mol-math/linear-algebra';\r\nimport { Task } from '../../mol-task';\r\nimport { arrayMax, arrayMean, arrayMin, arrayRms } from '../../mol-util/array';\r\nimport { CustomProperties } from '../../mol-model/custom-property';\r\nexport function volumeFromCube(source, params) {\r\n    var _this = this;\r\n    return Task.create('Create Volume', function () { return __awaiter(_this, void 0, void 0, function () {\r\n        var header, sourceValues, space, values, _a, h, k, l, nth, o, s, u, v, w, data, matrix, basis;\r\n        return __generator(this, function (_b) {\r\n            header = source.header, sourceValues = source.values;\r\n            space = Tensor.Space(header.dim, [0, 1, 2], Float64Array);\r\n            if (header.dataSetIds.length === 0) {\r\n                values = sourceValues;\r\n            }\r\n            else {\r\n                _a = header.dim, h = _a[0], k = _a[1], l = _a[2];\r\n                nth = ((params === null || params === void 0 ? void 0 : params.dataIndex) || 0) + 1;\r\n                o = 0, s = 0;\r\n                values = new Float64Array(h * k * l);\r\n                for (u = 0; u < h; u++) {\r\n                    for (v = 0; v < k; v++) {\r\n                        for (w = 0; w < l; w++) {\r\n                            values[o++] = sourceValues[s];\r\n                            s += nth;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            data = Tensor.create(space, Tensor.Data1(values));\r\n            matrix = Mat4.fromTranslation(Mat4(), header.origin);\r\n            basis = Mat4.fromBasis(Mat4(), header.basisX, header.basisY, header.basisZ);\r\n            Mat4.mul(matrix, matrix, basis);\r\n            return [2 /*return*/, {\r\n                    label: params === null || params === void 0 ? void 0 : params.label,\r\n                    entryId: params === null || params === void 0 ? void 0 : params.entryId,\r\n                    grid: {\r\n                        transform: { kind: 'matrix', matrix: matrix },\r\n                        cells: data,\r\n                        stats: {\r\n                            min: arrayMin(values),\r\n                            max: arrayMax(values),\r\n                            mean: arrayMean(values),\r\n                            sigma: arrayRms(values)\r\n                        },\r\n                    },\r\n                    sourceData: CubeFormat.create(source),\r\n                    customProperties: new CustomProperties(),\r\n                    _propertyData: Object.create(null),\r\n                }];\r\n        });\r\n    }); });\r\n}\r\n//\r\nexport { CubeFormat };\r\nvar CubeFormat;\r\n(function (CubeFormat) {\r\n    function is(x) {\r\n        return (x === null || x === void 0 ? void 0 : x.kind) === 'cube';\r\n    }\r\n    CubeFormat.is = is;\r\n    function create(cube) {\r\n        return { kind: 'cube', name: cube.name, data: cube };\r\n    }\r\n    CubeFormat.create = create;\r\n})(CubeFormat || (CubeFormat = {}));\r\n//# sourceMappingURL=cube.js.map"]},"metadata":{},"sourceType":"module"}