{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Box3D, Sphere3D } from '../../mol-math/geometry';\nimport { Tensor, Mat4, Vec3 } from '../../mol-math/linear-algebra';\nimport { calculateHistogram } from '../../mol-math/histogram';\nvar Grid;\n\n(function (Grid) {\n  Grid.One = {\n    transform: {\n      kind: 'matrix',\n      matrix: Mat4.identity()\n    },\n    cells: Tensor.create(Tensor.Space([1, 1, 1], [0, 1, 2]), Tensor.Data1([0])),\n    stats: {\n      min: 0,\n      max: 0,\n      mean: 0,\n      sigma: 0\n    }\n  };\n\n  var _scale = Mat4.zero(),\n      _translate = Mat4.zero();\n\n  function getGridToCartesianTransform(grid) {\n    if (grid.transform.kind === 'matrix') {\n      return Mat4.copy(Mat4(), grid.transform.matrix);\n    }\n\n    if (grid.transform.kind === 'spacegroup') {\n      var space = grid.cells.space;\n      var scale = Mat4.fromScaling(_scale, Vec3.div(Vec3.zero(), Box3D.size(Vec3.zero(), grid.transform.fractionalBox), Vec3.ofArray(space.dimensions)));\n      var translate = Mat4.fromTranslation(_translate, grid.transform.fractionalBox.min);\n      return Mat4.mul3(Mat4.zero(), grid.transform.cell.fromFractional, translate, scale);\n    }\n\n    return Mat4.identity();\n  }\n\n  Grid.getGridToCartesianTransform = getGridToCartesianTransform;\n\n  function areEquivalent(gridA, gridB) {\n    return gridA === gridB;\n  }\n\n  Grid.areEquivalent = areEquivalent;\n\n  function isEmpty(grid) {\n    return grid.cells.data.length === 0;\n  }\n\n  Grid.isEmpty = isEmpty;\n\n  function getBoundingSphere(grid, boundingSphere) {\n    if (!boundingSphere) boundingSphere = Sphere3D();\n    var dimensions = grid.cells.space.dimensions;\n    var transform = Grid.getGridToCartesianTransform(grid);\n    return Sphere3D.fromDimensionsAndTransform(boundingSphere, dimensions, transform);\n  }\n\n  Grid.getBoundingSphere = getBoundingSphere;\n  /**\r\n   * Compute histogram with given bin count.\r\n   * Cached on the Grid object.\r\n   */\n\n  function getHistogram(grid, binCount) {\n    var histograms = grid._historams;\n\n    if (!histograms) {\n      histograms = grid._historams = {};\n    }\n\n    if (!histograms[binCount]) {\n      histograms[binCount] = calculateHistogram(grid.cells.data, binCount, {\n        min: grid.stats.min,\n        max: grid.stats.max\n      });\n    }\n\n    return histograms[binCount];\n  }\n\n  Grid.getHistogram = getHistogram;\n})(Grid || (Grid = {}));\n\nexport { Grid };","map":{"version":3,"sources":["../../../src/mol-model/volume/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Box3D, Sphere3D } from '../../mol-math/geometry';\r\nimport { Tensor, Mat4, Vec3 } from '../../mol-math/linear-algebra';\r\nimport { calculateHistogram } from '../../mol-math/histogram';\r\nvar Grid;\r\n(function (Grid) {\r\n    Grid.One = {\r\n        transform: { kind: 'matrix', matrix: Mat4.identity() },\r\n        cells: Tensor.create(Tensor.Space([1, 1, 1], [0, 1, 2]), Tensor.Data1([0])),\r\n        stats: { min: 0, max: 0, mean: 0, sigma: 0 },\r\n    };\r\n    var _scale = Mat4.zero(), _translate = Mat4.zero();\r\n    function getGridToCartesianTransform(grid) {\r\n        if (grid.transform.kind === 'matrix') {\r\n            return Mat4.copy(Mat4(), grid.transform.matrix);\r\n        }\r\n        if (grid.transform.kind === 'spacegroup') {\r\n            var space = grid.cells.space;\r\n            var scale = Mat4.fromScaling(_scale, Vec3.div(Vec3.zero(), Box3D.size(Vec3.zero(), grid.transform.fractionalBox), Vec3.ofArray(space.dimensions)));\r\n            var translate = Mat4.fromTranslation(_translate, grid.transform.fractionalBox.min);\r\n            return Mat4.mul3(Mat4.zero(), grid.transform.cell.fromFractional, translate, scale);\r\n        }\r\n        return Mat4.identity();\r\n    }\r\n    Grid.getGridToCartesianTransform = getGridToCartesianTransform;\r\n    function areEquivalent(gridA, gridB) {\r\n        return gridA === gridB;\r\n    }\r\n    Grid.areEquivalent = areEquivalent;\r\n    function isEmpty(grid) {\r\n        return grid.cells.data.length === 0;\r\n    }\r\n    Grid.isEmpty = isEmpty;\r\n    function getBoundingSphere(grid, boundingSphere) {\r\n        if (!boundingSphere)\r\n            boundingSphere = Sphere3D();\r\n        var dimensions = grid.cells.space.dimensions;\r\n        var transform = Grid.getGridToCartesianTransform(grid);\r\n        return Sphere3D.fromDimensionsAndTransform(boundingSphere, dimensions, transform);\r\n    }\r\n    Grid.getBoundingSphere = getBoundingSphere;\r\n    /**\r\n     * Compute histogram with given bin count.\r\n     * Cached on the Grid object.\r\n     */\r\n    function getHistogram(grid, binCount) {\r\n        var histograms = grid._historams;\r\n        if (!histograms) {\r\n            histograms = grid._historams = {};\r\n        }\r\n        if (!histograms[binCount]) {\r\n            histograms[binCount] = calculateHistogram(grid.cells.data, binCount, { min: grid.stats.min, max: grid.stats.max });\r\n        }\r\n        return histograms[binCount];\r\n    }\r\n    Grid.getHistogram = getHistogram;\r\n})(Grid || (Grid = {}));\r\nexport { Grid };\r\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}