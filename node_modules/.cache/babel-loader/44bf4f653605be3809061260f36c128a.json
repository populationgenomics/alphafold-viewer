{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Segmentation, Interval } from '../../../../../mol-data/int';\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\nimport { isPolymer } from '../../types';\nimport { getAtomIdForAtomRole } from '../../../util';\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\n\nfunction areBackboneConnected(riStart, riEnd, conformation, index, derived) {\n  var _a = derived.residue,\n      polymerType = _a.polymerType,\n      traceElementIndex = _a.traceElementIndex,\n      directionFromElementIndex = _a.directionFromElementIndex,\n      directionToElementIndex = _a.directionToElementIndex;\n  var ptStart = polymerType[riStart];\n  var ptEnd = polymerType[riEnd];\n  if (ptStart === 0\n  /* NA */\n  || ptEnd === 0\n  /* NA */\n  ) return false;\n  if (traceElementIndex[riStart] === -1 || traceElementIndex[riEnd] === -1) return false;\n  var eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, 'backboneStart'));\n  var eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, 'backboneEnd'));\n\n  if (eiStart === -1 || eiEnd === -1) {\n    eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, 'coarseBackbone'));\n    eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, 'coarseBackbone'));\n  }\n\n  var x = conformation.x,\n      y = conformation.y,\n      z = conformation.z;\n  var pStart = Vec3.create(x[eiStart], y[eiStart], z[eiStart]);\n  var pEnd = Vec3.create(x[eiEnd], y[eiEnd], z[eiEnd]);\n  var isCoarse = directionFromElementIndex[riStart] === -1 || directionToElementIndex[riStart] === -1 || directionFromElementIndex[riEnd] === -1 || directionToElementIndex[riEnd] === -1;\n  return Vec3.distance(pStart, pEnd) < (isCoarse ? 10 : 3);\n}\n\nexport function getAtomicRanges(hierarchy, entities, conformation, sequence) {\n  var polymerRanges = [];\n  var gapRanges = [];\n  var cyclicPolymerMap = new Map();\n  var chainIt = Segmentation.transientSegments(hierarchy.chainAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));\n  var residueIt = Segmentation.transientSegments(hierarchy.residueAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));\n  var index = hierarchy.index,\n      derived = hierarchy.derived;\n  var label_seq_id = hierarchy.residues.label_seq_id;\n  var label_entity_id = hierarchy.chains.label_entity_id;\n  var _a = derived.residue,\n      moleculeType = _a.moleculeType,\n      traceElementIndex = _a.traceElementIndex;\n  var prevSeqId;\n  var prevStart;\n  var prevEnd;\n  var startIndex;\n\n  while (chainIt.hasNext) {\n    var chainSegment = chainIt.move();\n    residueIt.setSegment(chainSegment);\n    prevSeqId = -1;\n    prevStart = -1;\n    prevEnd = -1;\n    startIndex = -1;\n    var eI = entities.getEntityIndex(label_entity_id.value(chainSegment.index));\n    var seq = sequence.byEntityKey[eI];\n    var maxSeqId = seq ? seq.sequence.seqId.value(seq.sequence.seqId.rowCount - 1) : -1; // check cyclic peptides, seqIds and distance must be compatible\n\n    var riStart = hierarchy.residueAtomSegments.index[chainSegment.start];\n    var riEnd = hierarchy.residueAtomSegments.index[chainSegment.end - 1];\n    var seqIdStart = label_seq_id.value(riStart);\n    var seqIdEnd = label_seq_id.value(riEnd);\n\n    if (seqIdStart === 1 && seqIdEnd === maxSeqId && conformation.xyzDefined && areBackboneConnected(riStart, riEnd, conformation, index, derived)) {\n      cyclicPolymerMap.set(riStart, riEnd);\n      cyclicPolymerMap.set(riEnd, riStart);\n    }\n\n    while (residueIt.hasNext) {\n      var residueSegment = residueIt.move();\n      var residueIndex = residueSegment.index;\n      var seqId = label_seq_id.value(residueIndex); // treat polymers residues that don't have a trace element resolved as gaps\n\n      if (isPolymer(moleculeType[residueIndex]) && traceElementIndex[residueIndex] !== -1) {\n        if (startIndex !== -1) {\n          if (seqId !== prevSeqId + 1) {\n            polymerRanges.push(startIndex, prevEnd - 1);\n            gapRanges.push(prevStart, residueSegment.end - 1);\n            startIndex = residueSegment.start;\n          } else if (!residueIt.hasNext) {\n            polymerRanges.push(startIndex, residueSegment.end - 1); // TODO store terminal gaps\n          } else {\n            var riStart_1 = hierarchy.residueAtomSegments.index[residueSegment.start];\n            var riEnd_1 = hierarchy.residueAtomSegments.index[prevEnd - 1];\n\n            if (conformation.xyzDefined && !areBackboneConnected(riStart_1, riEnd_1, conformation, hierarchy.index, derived)) {\n              polymerRanges.push(startIndex, prevEnd - 1); // add gap even for consecutive residues if they are not connected\n\n              gapRanges.push(prevStart, residueSegment.end - 1);\n              startIndex = residueSegment.start;\n            }\n          }\n        } else {\n          startIndex = residueSegment.start; // start polymer\n          // TODO store terminal gaps\n        }\n      } else {\n        if (startIndex !== -1) {\n          polymerRanges.push(startIndex, prevEnd - 1);\n          startIndex = -1;\n        }\n      }\n\n      prevStart = residueSegment.start;\n      prevEnd = residueSegment.end;\n      prevSeqId = seqId;\n    }\n  }\n\n  return {\n    polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),\n    gapRanges: SortedRanges.ofSortedRanges(gapRanges),\n    cyclicPolymerMap: cyclicPolymerMap\n  };\n}","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/model/properties/utils/atomic-ranges.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAGH,SAAS,YAAT,EAAuB,QAAvB,QAAuC,6BAAvC;AACA,SAAS,YAAT,QAA6B,2CAA7B;AACA,SAAS,SAAT,QAAuC,aAAvC;AAEA,SAAS,oBAAT,QAAqC,eAArC;AAEA,SAAS,IAAT,QAAqB,wCAArB;;AAIA,SAAS,oBAAT,CAA8B,OAA9B,EAAqD,KAArD,EAA0E,YAA1E,EAA4G,KAA5G,EAAgI,OAAhI,EAA0J;AAChJ,MAAA,EAAA,GAAyF,OAAO,CAAC,OAAjG;AAAA,MAAE,WAAW,GAAA,EAAA,CAAA,WAAb;AAAA,MAAe,iBAAiB,GAAA,EAAA,CAAA,iBAAhC;AAAA,MAAkC,yBAAyB,GAAA,EAAA,CAAA,yBAA3D;AAAA,MAA6D,uBAAuB,GAAA,EAAA,CAAA,uBAApF;AACN,MAAM,OAAO,GAAG,WAAW,CAAC,OAAD,CAA3B;AACA,MAAM,KAAK,GAAG,WAAW,CAAC,KAAD,CAAzB;AACA,MAAI,OAAO,KAAA;AAAA;AAAP,KAA8B,KAAK,KAAA;AAAA;AAAvC,IAA4D,OAAO,KAAP;AAC5D,MAAI,iBAAiB,CAAC,OAAD,CAAjB,KAA+B,CAAC,CAAhC,IAAqC,iBAAiB,CAAC,KAAD,CAAjB,KAA6B,CAAC,CAAvE,EAA0E,OAAO,KAAP;AAE1E,MAAI,OAAO,GAAG,KAAK,CAAC,kBAAN,CAAyB,OAAzB,EAAkC,oBAAoB,CAAC,OAAD,EAAU,eAAV,CAAtD,CAAd;AACA,MAAI,KAAK,GAAG,KAAK,CAAC,kBAAN,CAAyB,KAAzB,EAAgC,oBAAoB,CAAC,KAAD,EAAQ,aAAR,CAApD,CAAZ;;AAEA,MAAI,OAAO,KAAK,CAAC,CAAb,IAAkB,KAAK,KAAK,CAAC,CAAjC,EAAoC;AAChC,IAAA,OAAO,GAAG,KAAK,CAAC,kBAAN,CAAyB,OAAzB,EAAkC,oBAAoB,CAAC,OAAD,EAAU,gBAAV,CAAtD,CAAV;AACA,IAAA,KAAK,GAAG,KAAK,CAAC,kBAAN,CAAyB,KAAzB,EAAgC,oBAAoB,CAAC,KAAD,EAAQ,gBAAR,CAApD,CAAR;AACH;;AAEO,MAAA,CAAC,GAAW,YAAY,CAAvB,CAAD;AAAA,MAAG,CAAC,GAAQ,YAAY,CAApB,CAAJ;AAAA,MAAM,CAAC,GAAK,YAAY,CAAjB,CAAP;AACR,MAAM,MAAM,GAAG,IAAI,CAAC,MAAL,CAAY,CAAC,CAAC,OAAD,CAAb,EAAwB,CAAC,CAAC,OAAD,CAAzB,EAAoC,CAAC,CAAC,OAAD,CAArC,CAAf;AACA,MAAM,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,CAAC,CAAC,KAAD,CAAb,EAAsB,CAAC,CAAC,KAAD,CAAvB,EAAgC,CAAC,CAAC,KAAD,CAAjC,CAAb;AACA,MAAM,QAAQ,GAAG,yBAAyB,CAAC,OAAD,CAAzB,KAAuC,CAAC,CAAxC,IAA6C,uBAAuB,CAAC,OAAD,CAAvB,KAAqC,CAAC,CAAnF,IAAwF,yBAAyB,CAAC,KAAD,CAAzB,KAAqC,CAAC,CAA9H,IAAmI,uBAAuB,CAAC,KAAD,CAAvB,KAAmC,CAAC,CAAxL;AACA,SAAO,IAAI,CAAC,QAAL,CAAc,MAAd,EAAsB,IAAtB,KAA+B,QAAQ,GAAG,EAAH,GAAQ,CAA/C,CAAP;AACH;;AAED,OAAM,SAAU,eAAV,CAA0B,SAA1B,EAAsD,QAAtD,EAA0E,YAA1E,EAA4G,QAA5G,EAAuI;AACzI,MAAM,aAAa,GAAa,EAAhC;AACA,MAAM,SAAS,GAAa,EAA5B;AACA,MAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB;AACA,MAAM,OAAO,GAAG,YAAY,CAAC,iBAAb,CAA+B,SAAS,CAAC,iBAAzC,EAA4D,QAAQ,CAAC,QAAT,CAAkB,CAAlB,EAAqB,SAAS,CAAC,KAAV,CAAgB,SAArC,CAA5D,CAAhB;AACA,MAAM,SAAS,GAAG,YAAY,CAAC,iBAAb,CAA+B,SAAS,CAAC,mBAAzC,EAA8D,QAAQ,CAAC,QAAT,CAAkB,CAAlB,EAAqB,SAAS,CAAC,KAAV,CAAgB,SAArC,CAA9D,CAAlB;AACQ,MAAA,KAAK,GAAc,SAAS,CAAvB,KAAL;AAAA,MAAO,OAAO,GAAK,SAAS,CAAd,OAAd;AACA,MAAA,YAAY,GAAK,SAAS,CAAC,QAAV,CAAL,YAAZ;AACA,MAAA,eAAe,GAAK,SAAS,CAAC,MAAV,CAAL,eAAf;AACF,MAAA,EAAA,GAAsC,OAAO,CAAC,OAA9C;AAAA,MAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,MAAgB,iBAAiB,GAAA,EAAA,CAAA,iBAAjC;AAEN,MAAI,SAAJ;AACA,MAAI,SAAJ;AACA,MAAI,OAAJ;AACA,MAAI,UAAJ;;AAEA,SAAO,OAAO,CAAC,OAAf,EAAwB;AACpB,QAAM,YAAY,GAAG,OAAO,CAAC,IAAR,EAArB;AACA,IAAA,SAAS,CAAC,UAAV,CAAqB,YAArB;AACA,IAAA,SAAS,GAAG,CAAC,CAAb;AACA,IAAA,SAAS,GAAG,CAAC,CAAb;AACA,IAAA,OAAO,GAAG,CAAC,CAAX;AACA,IAAA,UAAU,GAAG,CAAC,CAAd;AAEA,QAAM,EAAE,GAAG,QAAQ,CAAC,cAAT,CAAwB,eAAe,CAAC,KAAhB,CAAsB,YAAY,CAAC,KAAnC,CAAxB,CAAX;AACA,QAAM,GAAG,GAAG,QAAQ,CAAC,WAAT,CAAqB,EAArB,CAAZ;AACA,QAAM,QAAQ,GAAG,GAAG,GAAG,GAAG,CAAC,QAAJ,CAAa,KAAb,CAAmB,KAAnB,CAAyB,GAAG,CAAC,QAAJ,CAAa,KAAb,CAAmB,QAAnB,GAA8B,CAAvD,CAAH,GAA+D,CAAC,CAApF,CAVoB,CAYpB;;AACA,QAAM,OAAO,GAAG,SAAS,CAAC,mBAAV,CAA8B,KAA9B,CAAoC,YAAY,CAAC,KAAjD,CAAhB;AACA,QAAM,KAAK,GAAG,SAAS,CAAC,mBAAV,CAA8B,KAA9B,CAAoC,YAAY,CAAC,GAAb,GAAmB,CAAvD,CAAd;AACA,QAAM,UAAU,GAAG,YAAY,CAAC,KAAb,CAAmB,OAAnB,CAAnB;AACA,QAAM,QAAQ,GAAG,YAAY,CAAC,KAAb,CAAmB,KAAnB,CAAjB;;AACA,QAAI,UAAU,KAAK,CAAf,IAAoB,QAAQ,KAAK,QAAjC,IAA6C,YAAY,CAAC,UAA1D,IAAwE,oBAAoB,CAAC,OAAD,EAAU,KAAV,EAAiB,YAAjB,EAA+B,KAA/B,EAAsC,OAAtC,CAAhG,EAAgJ;AAC5I,MAAA,gBAAgB,CAAC,GAAjB,CAAqB,OAArB,EAA8B,KAA9B;AACA,MAAA,gBAAgB,CAAC,GAAjB,CAAqB,KAArB,EAA4B,OAA5B;AACH;;AAED,WAAO,SAAS,CAAC,OAAjB,EAA0B;AACtB,UAAM,cAAc,GAAG,SAAS,CAAC,IAAV,EAAvB;AACA,UAAM,YAAY,GAAG,cAAc,CAAC,KAApC;AACA,UAAM,KAAK,GAAG,YAAY,CAAC,KAAb,CAAmB,YAAnB,CAAd,CAHsB,CAItB;;AACA,UAAI,SAAS,CAAC,YAAY,CAAC,YAAD,CAAb,CAAT,IAAyC,iBAAiB,CAAC,YAAD,CAAjB,KAAoC,CAAC,CAAlF,EAAqF;AACjF,YAAI,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB,cAAI,KAAK,KAAK,SAAS,GAAG,CAA1B,EAA6B;AACzB,YAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,OAAO,GAAG,CAAzC;AACA,YAAA,SAAS,CAAC,IAAV,CAAe,SAAf,EAA0B,cAAc,CAAC,GAAf,GAAqB,CAA/C;AACA,YAAA,UAAU,GAAG,cAAc,CAAC,KAA5B;AACH,WAJD,MAIO,IAAI,CAAC,SAAS,CAAC,OAAf,EAAwB;AAC3B,YAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,cAAc,CAAC,GAAf,GAAqB,CAApD,EAD2B,CAE3B;AACH,WAHM,MAGA;AACH,gBAAM,SAAO,GAAG,SAAS,CAAC,mBAAV,CAA8B,KAA9B,CAAoC,cAAc,CAAC,KAAnD,CAAhB;AACA,gBAAM,OAAK,GAAG,SAAS,CAAC,mBAAV,CAA8B,KAA9B,CAAoC,OAAO,GAAG,CAA9C,CAAd;;AACA,gBAAI,YAAY,CAAC,UAAb,IAA2B,CAAC,oBAAoB,CAAC,SAAD,EAAU,OAAV,EAAiB,YAAjB,EAA+B,SAAS,CAAC,KAAzC,EAAgD,OAAhD,CAApD,EAA8G;AAC1G,cAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,OAAO,GAAG,CAAzC,EAD0G,CAE1G;;AACA,cAAA,SAAS,CAAC,IAAV,CAAe,SAAf,EAA0B,cAAc,CAAC,GAAf,GAAqB,CAA/C;AACA,cAAA,UAAU,GAAG,cAAc,CAAC,KAA5B;AACH;AACJ;AACJ,SAlBD,MAkBO;AACH,UAAA,UAAU,GAAG,cAAc,CAAC,KAA5B,CADG,CACgC;AACnC;AACH;AACJ,OAvBD,MAuBO;AACH,YAAI,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnB,UAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,OAAO,GAAG,CAAzC;AACA,UAAA,UAAU,GAAG,CAAC,CAAd;AACH;AACJ;;AAED,MAAA,SAAS,GAAG,cAAc,CAAC,KAA3B;AACA,MAAA,OAAO,GAAG,cAAc,CAAC,GAAzB;AACA,MAAA,SAAS,GAAG,KAAZ;AACH;AACJ;;AAED,SAAO;AACH,IAAA,aAAa,EAAE,YAAY,CAAC,cAAb,CAA4B,aAA5B,CADZ;AAEH,IAAA,SAAS,EAAE,YAAY,CAAC,cAAb,CAA4B,SAA5B,CAFR;AAGH,IAAA,gBAAgB,EAAA;AAHb,GAAP;AAKH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Segmentation, Interval } from '../../../../../mol-data/int';\r\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\r\nimport { isPolymer } from '../../types';\r\nimport { getAtomIdForAtomRole } from '../../../util';\r\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\r\nfunction areBackboneConnected(riStart, riEnd, conformation, index, derived) {\r\n    var _a = derived.residue, polymerType = _a.polymerType, traceElementIndex = _a.traceElementIndex, directionFromElementIndex = _a.directionFromElementIndex, directionToElementIndex = _a.directionToElementIndex;\r\n    var ptStart = polymerType[riStart];\r\n    var ptEnd = polymerType[riEnd];\r\n    if (ptStart === 0 /* NA */ || ptEnd === 0 /* NA */)\r\n        return false;\r\n    if (traceElementIndex[riStart] === -1 || traceElementIndex[riEnd] === -1)\r\n        return false;\r\n    var eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, 'backboneStart'));\r\n    var eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, 'backboneEnd'));\r\n    if (eiStart === -1 || eiEnd === -1) {\r\n        eiStart = index.findAtomsOnResidue(riStart, getAtomIdForAtomRole(ptStart, 'coarseBackbone'));\r\n        eiEnd = index.findAtomsOnResidue(riEnd, getAtomIdForAtomRole(ptEnd, 'coarseBackbone'));\r\n    }\r\n    var x = conformation.x, y = conformation.y, z = conformation.z;\r\n    var pStart = Vec3.create(x[eiStart], y[eiStart], z[eiStart]);\r\n    var pEnd = Vec3.create(x[eiEnd], y[eiEnd], z[eiEnd]);\r\n    var isCoarse = directionFromElementIndex[riStart] === -1 || directionToElementIndex[riStart] === -1 || directionFromElementIndex[riEnd] === -1 || directionToElementIndex[riEnd] === -1;\r\n    return Vec3.distance(pStart, pEnd) < (isCoarse ? 10 : 3);\r\n}\r\nexport function getAtomicRanges(hierarchy, entities, conformation, sequence) {\r\n    var polymerRanges = [];\r\n    var gapRanges = [];\r\n    var cyclicPolymerMap = new Map();\r\n    var chainIt = Segmentation.transientSegments(hierarchy.chainAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));\r\n    var residueIt = Segmentation.transientSegments(hierarchy.residueAtomSegments, Interval.ofBounds(0, hierarchy.atoms._rowCount));\r\n    var index = hierarchy.index, derived = hierarchy.derived;\r\n    var label_seq_id = hierarchy.residues.label_seq_id;\r\n    var label_entity_id = hierarchy.chains.label_entity_id;\r\n    var _a = derived.residue, moleculeType = _a.moleculeType, traceElementIndex = _a.traceElementIndex;\r\n    var prevSeqId;\r\n    var prevStart;\r\n    var prevEnd;\r\n    var startIndex;\r\n    while (chainIt.hasNext) {\r\n        var chainSegment = chainIt.move();\r\n        residueIt.setSegment(chainSegment);\r\n        prevSeqId = -1;\r\n        prevStart = -1;\r\n        prevEnd = -1;\r\n        startIndex = -1;\r\n        var eI = entities.getEntityIndex(label_entity_id.value(chainSegment.index));\r\n        var seq = sequence.byEntityKey[eI];\r\n        var maxSeqId = seq ? seq.sequence.seqId.value(seq.sequence.seqId.rowCount - 1) : -1;\r\n        // check cyclic peptides, seqIds and distance must be compatible\r\n        var riStart = hierarchy.residueAtomSegments.index[chainSegment.start];\r\n        var riEnd = hierarchy.residueAtomSegments.index[chainSegment.end - 1];\r\n        var seqIdStart = label_seq_id.value(riStart);\r\n        var seqIdEnd = label_seq_id.value(riEnd);\r\n        if (seqIdStart === 1 && seqIdEnd === maxSeqId && conformation.xyzDefined && areBackboneConnected(riStart, riEnd, conformation, index, derived)) {\r\n            cyclicPolymerMap.set(riStart, riEnd);\r\n            cyclicPolymerMap.set(riEnd, riStart);\r\n        }\r\n        while (residueIt.hasNext) {\r\n            var residueSegment = residueIt.move();\r\n            var residueIndex = residueSegment.index;\r\n            var seqId = label_seq_id.value(residueIndex);\r\n            // treat polymers residues that don't have a trace element resolved as gaps\r\n            if (isPolymer(moleculeType[residueIndex]) && traceElementIndex[residueIndex] !== -1) {\r\n                if (startIndex !== -1) {\r\n                    if (seqId !== prevSeqId + 1) {\r\n                        polymerRanges.push(startIndex, prevEnd - 1);\r\n                        gapRanges.push(prevStart, residueSegment.end - 1);\r\n                        startIndex = residueSegment.start;\r\n                    }\r\n                    else if (!residueIt.hasNext) {\r\n                        polymerRanges.push(startIndex, residueSegment.end - 1);\r\n                        // TODO store terminal gaps\r\n                    }\r\n                    else {\r\n                        var riStart_1 = hierarchy.residueAtomSegments.index[residueSegment.start];\r\n                        var riEnd_1 = hierarchy.residueAtomSegments.index[prevEnd - 1];\r\n                        if (conformation.xyzDefined && !areBackboneConnected(riStart_1, riEnd_1, conformation, hierarchy.index, derived)) {\r\n                            polymerRanges.push(startIndex, prevEnd - 1);\r\n                            // add gap even for consecutive residues if they are not connected\r\n                            gapRanges.push(prevStart, residueSegment.end - 1);\r\n                            startIndex = residueSegment.start;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    startIndex = residueSegment.start; // start polymer\r\n                    // TODO store terminal gaps\r\n                }\r\n            }\r\n            else {\r\n                if (startIndex !== -1) {\r\n                    polymerRanges.push(startIndex, prevEnd - 1);\r\n                    startIndex = -1;\r\n                }\r\n            }\r\n            prevStart = residueSegment.start;\r\n            prevEnd = residueSegment.end;\r\n            prevSeqId = seqId;\r\n        }\r\n    }\r\n    return {\r\n        polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),\r\n        gapRanges: SortedRanges.ofSortedRanges(gapRanges),\r\n        cyclicPolymerMap: cyclicPolymerMap\r\n    };\r\n}\r\n//# sourceMappingURL=atomic-ranges.js.map"]},"metadata":{},"sourceType":"module"}