{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { PluginStateObject as SO } from '../../objects';\nimport { StateObject } from '../../../mol-state';\nexport function buildVolumeHierarchy(state, previous) {\n  var build = BuildState(state, previous || VolumeHierarchy());\n  doPreOrder(state.tree, build);\n  if (previous) previous.refs.forEach(isRemoved, build);\n  return {\n    hierarchy: build.hierarchy,\n    added: build.added,\n    changed: build.changed\n  };\n}\nexport function VolumeHierarchy() {\n  return {\n    volumes: [],\n    lazyVolumes: [],\n    refs: new Map()\n  };\n}\n\nfunction VolumeRef(cell) {\n  return {\n    kind: 'volume',\n    cell: cell,\n    version: cell.transform.version,\n    representations: []\n  };\n}\n\nfunction LazyVolumeRef(cell) {\n  return {\n    kind: 'lazy-volume',\n    cell: cell,\n    version: cell.transform.version\n  };\n}\n\nfunction VolumeRepresentationRef(cell, volume) {\n  return {\n    kind: 'volume-representation',\n    cell: cell,\n    version: cell.transform.version,\n    volume: volume\n  };\n}\n\nfunction BuildState(state, oldHierarchy) {\n  return {\n    state: state,\n    oldHierarchy: oldHierarchy,\n    hierarchy: VolumeHierarchy(),\n    changed: false,\n    added: new Set()\n  };\n}\n\nfunction createOrUpdateRefList(state, cell, list, ctor) {\n  var args = [];\n\n  for (var _i = 4; _i < arguments.length; _i++) {\n    args[_i - 4] = arguments[_i];\n  }\n\n  var ref = ctor.apply(void 0, args);\n  list.push(ref);\n  state.hierarchy.refs.set(cell.transform.ref, ref);\n  var old = state.oldHierarchy.refs.get(cell.transform.ref);\n\n  if (old) {\n    if (old.version !== cell.transform.version) state.changed = true;\n  } else {\n    state.added.add(ref.cell.transform.ref);\n    state.changed = true;\n  }\n\n  return ref;\n}\n\nfunction isTypeRoot(t, target) {\n  return function (cell, state) {\n    return !target(state) && t.is(cell.obj);\n  };\n}\n\nfunction noop() {}\n\nvar Mapping = [[isTypeRoot(SO.Volume.Data, function (t) {\n  return t.currentVolume;\n}), function (state, cell) {\n  state.currentVolume = createOrUpdateRefList(state, cell, state.hierarchy.volumes, VolumeRef, cell);\n}, function (state) {\n  return state.currentVolume = void 0;\n}], [function (cell) {\n  return SO.Volume.Lazy.is(cell.obj);\n}, function (state, cell) {\n  createOrUpdateRefList(state, cell, state.hierarchy.lazyVolumes, LazyVolumeRef, cell);\n}, noop], [function (cell, state) {\n  return !cell.state.isGhost && !!state.currentVolume && SO.Volume.Representation3D.is(cell.obj);\n}, function (state, cell) {\n  if (state.currentVolume) {\n    createOrUpdateRefList(state, cell, state.currentVolume.representations, VolumeRepresentationRef, cell, state.currentVolume);\n  }\n\n  return false;\n}, noop]];\n\nfunction isValidCell(cell) {\n  if (!cell || !(cell === null || cell === void 0 ? void 0 : cell.parent) || !cell.parent.cells.has(cell.transform.ref)) return false;\n  var obj = cell.obj;\n  if (!obj || obj === StateObject.Null || cell.status !== 'ok' && cell.status !== 'error') return false;\n  return true;\n}\n\nfunction isRemoved(ref) {\n  var cell = ref.cell;\n  if (isValidCell(cell)) return;\n  this.changed = true;\n}\n\nfunction _preOrderFunc(c) {\n  _doPreOrder(this, this.tree.transforms.get(c));\n}\n\nfunction _doPreOrder(ctx, root) {\n  var state = ctx.state;\n  var cell = state.state.cells.get(root.ref);\n  if (!isValidCell(cell)) return;\n  var onLeave = void 0;\n  var end = false;\n\n  for (var _i = 0, Mapping_1 = Mapping; _i < Mapping_1.length; _i++) {\n    var _a = Mapping_1[_i],\n        test_1 = _a[0],\n        f = _a[1],\n        l = _a[2];\n\n    if (test_1(cell, state)) {\n      var cont = f(state, cell);\n\n      if (cont === false) {\n        end = true;\n        break;\n      }\n\n      onLeave = l;\n      break;\n    }\n  } // TODO: might be needed in the future\n  // const { currentComponent, currentModel, currentStructure, currentTrajectory } = ctx.state;\n  // const inTrackedSubtree = currentComponent || currentModel || currentStructure || currentTrajectory;\n  // if (inTrackedSubtree && cell.transform.transformer.definition.isDecorator) {\n  //     const ref = cell.transform.ref;\n  //     const old = ctx.state.oldHierarchy.decorators.get(ref);\n  //     if (old && old.version !== cell.transform.version) {\n  //         ctx.state.changed = true;\n  //     }\n  //     ctx.state.hierarchy.decorators.set(cell.transform.ref, cell.transform);\n  // }\n\n\n  if (end) return;\n  var children = ctx.tree.children.get(root.ref);\n\n  if (children && children.size) {\n    children.forEach(_preOrderFunc, ctx);\n  }\n\n  if (onLeave) onLeave(state);\n}\n\nfunction doPreOrder(tree, state) {\n  var ctx = {\n    tree: tree,\n    state: state\n  };\n\n  _doPreOrder(ctx, tree.root);\n\n  return ctx.state;\n}","map":{"version":3,"sources":["../../../../src/mol-plugin-state/manager/volume/hierarchy-state.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,SAAS,iBAAiB,IAAI,EAA9B,QAAwC,eAAxC;AACA,SAAS,WAAT,QAAiG,oBAAjG;AAGA,OAAM,SAAU,oBAAV,CAA+B,KAA/B,EAA6C,QAA7C,EAAuE;AACzE,MAAM,KAAK,GAAG,UAAU,CAAC,KAAD,EAAQ,QAAQ,IAAI,eAAe,EAAnC,CAAxB;AACA,EAAA,UAAU,CAAC,KAAK,CAAC,IAAP,EAAa,KAAb,CAAV;AACA,MAAI,QAAJ,EAAc,QAAQ,CAAC,IAAT,CAAc,OAAd,CAAsB,SAAtB,EAAiC,KAAjC;AACd,SAAO;AAAE,IAAA,SAAS,EAAE,KAAK,CAAC,SAAnB;AAA8B,IAAA,KAAK,EAAE,KAAK,CAAC,KAA3C;AAAkD,IAAA,OAAO,EAAE,KAAK,CAAC;AAAjE,GAAP;AACH;AAUD,OAAM,SAAU,eAAV,GAAyB;AAC3B,SAAO;AAAE,IAAA,OAAO,EAAE,EAAX;AAAe,IAAA,WAAW,EAAE,EAA5B;AAAgC,IAAA,IAAI,EAAE,IAAI,GAAJ;AAAtC,GAAP;AACH;;AAcD,SAAS,SAAT,CAAmB,IAAnB,EAAwD;AACpD,SAAO;AAAE,IAAA,IAAI,EAAE,QAAR;AAAkB,IAAA,IAAI,EAAA,IAAtB;AAAwB,IAAA,OAAO,EAAE,IAAI,CAAC,SAAL,CAAe,OAAhD;AAAyD,IAAA,eAAe,EAAE;AAA1E,GAAP;AACH;;AAKD,SAAS,aAAT,CAAuB,IAAvB,EAA4D;AACxD,SAAO;AAAE,IAAA,IAAI,EAAE,aAAR;AAAuB,IAAA,IAAI,EAAA,IAA3B;AAA6B,IAAA,OAAO,EAAE,IAAI,CAAC,SAAL,CAAe;AAArD,GAAP;AACH;;AAMD,SAAS,uBAAT,CAAiC,IAAjC,EAAoF,MAApF,EAAqG;AACjG,SAAO;AAAE,IAAA,IAAI,EAAE,uBAAR;AAAiC,IAAA,IAAI,EAAA,IAArC;AAAuC,IAAA,OAAO,EAAE,IAAI,CAAC,SAAL,CAAe,OAA/D;AAAwE,IAAA,MAAM,EAAA;AAA9E,GAAP;AACH;;AAcD,SAAS,UAAT,CAAoB,KAApB,EAAkC,YAAlC,EAA+D;AAC3D,SAAO;AAAE,IAAA,KAAK,EAAA,KAAP;AAAS,IAAA,YAAY,EAAA,YAArB;AAAuB,IAAA,SAAS,EAAE,eAAe,EAAjD;AAAqD,IAAA,OAAO,EAAE,KAA9D;AAAqE,IAAA,KAAK,EAAE,IAAI,GAAJ;AAA5E,GAAP;AACH;;AAED,SAAS,qBAAT,CAA8E,KAA9E,EAAiG,IAAjG,EAAwH,IAAxH,EAAmI,IAAnI,EAA0J;AAAE,MAAA,IAAA,GAAA,EAAA;;OAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAU;AAAV,IAAA,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACxJ,MAAM,GAAG,GAAM,IAAI,CAAA,KAAJ,CAAI,KAAA,CAAJ,EAAQ,IAAR,CAAf;AACA,EAAA,IAAI,CAAC,IAAL,CAAU,GAAV;AACA,EAAA,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,GAArB,CAAyB,IAAI,CAAC,SAAL,CAAe,GAAxC,EAA6C,GAA7C;AACA,MAAM,GAAG,GAAG,KAAK,CAAC,YAAN,CAAmB,IAAnB,CAAwB,GAAxB,CAA4B,IAAI,CAAC,SAAL,CAAe,GAA3C,CAAZ;;AACA,MAAI,GAAJ,EAAS;AACL,QAAI,GAAG,CAAC,OAAJ,KAAgB,IAAI,CAAC,SAAL,CAAe,OAAnC,EAA4C,KAAK,CAAC,OAAN,GAAgB,IAAhB;AAC/C,GAFD,MAEO;AACH,IAAA,KAAK,CAAC,KAAN,CAAY,GAAZ,CAAgB,GAAG,CAAC,IAAJ,CAAS,SAAT,CAAmB,GAAnC;AACA,IAAA,KAAK,CAAC,OAAN,GAAgB,IAAhB;AACH;;AACD,SAAO,GAAP;AACH;;AAMD,SAAS,UAAT,CAAoB,CAApB,EAAyC,MAAzC,EAA2E;AACvE,SAAO,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,WAAA,CAAC,MAAM,CAAC,KAAD,CAAP,IAAkB,CAAC,CAAC,EAAF,CAAK,IAAI,CAA3B,GAAkB,CAAlB;AAAgC,GAAxD;AACH;;AAED,SAAS,IAAT,GAAa,CAAM;;AAEnB,IAAM,OAAO,GAAqC,CAC9C,CAAC,UAAU,CAAC,EAAE,CAAC,MAAH,CAAU,IAAX,EAAiB,UAAA,CAAA,EAAC;AAAI,SAAA,CAAC,CAAD,aAAA;AAAe,CAArC,CAAX,EAAmD,UAAC,KAAD,EAAQ,IAAR,EAAY;AAC3D,EAAA,KAAK,CAAC,aAAN,GAAsB,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAK,CAAC,SAAN,CAAgB,OAA9B,EAAuC,SAAvC,EAAkD,IAAlD,CAA3C;AACH,CAFD,EAEG,UAAA,KAAA,EAAK;AAAI,SAAA,KAAK,CAAC,aAAN,GAAsB,KAAtB,CAAA;AAA4B,CAFxC,CAD8C,EAK9C,CAAC,UAAA,IAAA,EAAI;AAAI,SAAA,EAAE,CAAC,MAAH,CAAU,IAAV,CAAe,EAAf,CAAkB,IAAI,CAAtB,GAAA,CAAA;AAA2B,CAApC,EAAsC,UAAC,KAAD,EAAQ,IAAR,EAAY;AAC9C,EAAA,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAK,CAAC,SAAN,CAAgB,WAA9B,EAA2C,aAA3C,EAA0D,IAA1D,CAArB;AACH,CAFD,EAEG,IAFH,CAL8C,EAS9C,CAAC,UAAC,IAAD,EAAO,KAAP,EAAY;AACT,SAAO,CAAC,IAAI,CAAC,KAAL,CAAW,OAAZ,IAAuB,CAAC,CAAC,KAAK,CAAC,aAA/B,IAAgD,EAAE,CAAC,MAAH,CAAU,gBAAV,CAA2B,EAA3B,CAA8B,IAAI,CAAC,GAAnC,CAAvD;AACH,CAFD,EAEG,UAAC,KAAD,EAAQ,IAAR,EAAY;AACX,MAAI,KAAK,CAAC,aAAV,EAAyB;AACrB,IAAA,qBAAqB,CAAC,KAAD,EAAQ,IAAR,EAAc,KAAK,CAAC,aAAN,CAAoB,eAAlC,EAAmD,uBAAnD,EAA4E,IAA5E,EAAkF,KAAK,CAAC,aAAxF,CAArB;AACH;;AACD,SAAO,KAAP;AACH,CAPD,EAOG,IAPH,CAT8C,CAAlD;;AAmBA,SAAS,WAAT,CAAqB,IAArB,EAA2C;AACvC,MAAI,CAAC,IAAD,IAAS,EAAC,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,MAAP,CAAT,IAA0B,CAAC,IAAI,CAAC,MAAL,CAAY,KAAZ,CAAkB,GAAlB,CAAsB,IAAI,CAAC,SAAL,CAAe,GAArC,CAA/B,EAA0E,OAAO,KAAP;AAClE,MAAA,GAAG,GAAK,IAAI,CAAT,GAAH;AACR,MAAI,CAAC,GAAD,IAAQ,GAAG,KAAK,WAAW,CAAC,IAA5B,IAAqC,IAAI,CAAC,MAAL,KAAgB,IAAhB,IAAwB,IAAI,CAAC,MAAL,KAAgB,OAAjF,EAA2F,OAAO,KAAP;AAC3F,SAAO,IAAP;AACH;;AAED,SAAS,SAAT,CAAqC,GAArC,EAA4D;AAChD,MAAA,IAAI,GAAK,GAAG,CAAR,IAAJ;AACR,MAAI,WAAW,CAAC,IAAD,CAAf,EAAuB;AACvB,OAAK,OAAL,GAAe,IAAf;AACH;;AAID,SAAS,aAAT,CAAyC,CAAzC,EAA0E;AAAI,EAAA,WAAW,CAAC,IAAD,EAAO,KAAK,IAAL,CAAU,UAAV,CAAqB,GAArB,CAAyB,CAAzB,CAAP,CAAX;AAAmD;;AACjI,SAAS,WAAT,CAAqB,GAArB,EAAsC,IAAtC,EAA0D;AAC9C,MAAA,KAAK,GAAK,GAAG,CAAR,KAAL;AACR,MAAM,IAAI,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAkB,GAAlB,CAAsB,IAAI,CAAC,GAA3B,CAAb;AACA,MAAI,CAAC,WAAW,CAAC,IAAD,CAAhB,EAAwB;AAExB,MAAI,OAAO,GAA6C,KAAK,CAA7D;AACA,MAAI,GAAG,GAAG,KAAV;;AACA,OAA2B,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAA3B,EAA2B,EAAA,GAAA,SAAA,CAAA,MAA3B,EAA2B,EAAA,EAA3B,EAAoC;AAAzB,QAAA,EAAA,GAAA,SAAA,CAAA,EAAA,CAAA;AAAA,QAAC,MAAI,GAAA,EAAA,CAAA,CAAA,CAAL;AAAA,QAAO,CAAC,GAAA,EAAA,CAAA,CAAA,CAAR;AAAA,QAAU,CAAC,GAAA,EAAA,CAAA,CAAA,CAAX;;AACP,QAAI,MAAI,CAAC,IAAD,EAAO,KAAP,CAAR,EAAuB;AACnB,UAAM,IAAI,GAAG,CAAC,CAAC,KAAD,EAAQ,IAAR,CAAd;;AACA,UAAI,IAAI,KAAK,KAAb,EAAoB;AAChB,QAAA,GAAG,GAAG,IAAN;AACA;AACH;;AACD,MAAA,OAAO,GAAG,CAAV;AACA;AACH;AACJ,GAjBqD,CAmBtD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAI,GAAJ,EAAS;AAET,MAAM,QAAQ,GAAG,GAAG,CAAC,IAAJ,CAAS,QAAT,CAAkB,GAAlB,CAAsB,IAAI,CAAC,GAA3B,CAAjB;;AACA,MAAI,QAAQ,IAAI,QAAQ,CAAC,IAAzB,EAA+B;AAC3B,IAAA,QAAQ,CAAC,OAAT,CAAiB,aAAjB,EAAgC,GAAhC;AACH;;AAED,MAAI,OAAJ,EAAa,OAAO,CAAC,KAAD,CAAP;AAChB;;AAED,SAAS,UAAT,CAAoB,IAApB,EAAqC,KAArC,EAAsD;AAClD,MAAM,GAAG,GAAe;AAAE,IAAA,IAAI,EAAA,IAAN;AAAQ,IAAA,KAAK,EAAA;AAAb,GAAxB;;AACA,EAAA,WAAW,CAAC,GAAD,EAAM,IAAI,CAAC,IAAX,CAAX;;AACA,SAAO,GAAG,CAAC,KAAX;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { PluginStateObject as SO } from '../../objects';\r\nimport { StateObject } from '../../../mol-state';\r\nexport function buildVolumeHierarchy(state, previous) {\r\n    var build = BuildState(state, previous || VolumeHierarchy());\r\n    doPreOrder(state.tree, build);\r\n    if (previous)\r\n        previous.refs.forEach(isRemoved, build);\r\n    return { hierarchy: build.hierarchy, added: build.added, changed: build.changed };\r\n}\r\nexport function VolumeHierarchy() {\r\n    return { volumes: [], lazyVolumes: [], refs: new Map() };\r\n}\r\nfunction VolumeRef(cell) {\r\n    return { kind: 'volume', cell: cell, version: cell.transform.version, representations: [] };\r\n}\r\nfunction LazyVolumeRef(cell) {\r\n    return { kind: 'lazy-volume', cell: cell, version: cell.transform.version };\r\n}\r\nfunction VolumeRepresentationRef(cell, volume) {\r\n    return { kind: 'volume-representation', cell: cell, version: cell.transform.version, volume: volume };\r\n}\r\nfunction BuildState(state, oldHierarchy) {\r\n    return { state: state, oldHierarchy: oldHierarchy, hierarchy: VolumeHierarchy(), changed: false, added: new Set() };\r\n}\r\nfunction createOrUpdateRefList(state, cell, list, ctor) {\r\n    var args = [];\r\n    for (var _i = 4; _i < arguments.length; _i++) {\r\n        args[_i - 4] = arguments[_i];\r\n    }\r\n    var ref = ctor.apply(void 0, args);\r\n    list.push(ref);\r\n    state.hierarchy.refs.set(cell.transform.ref, ref);\r\n    var old = state.oldHierarchy.refs.get(cell.transform.ref);\r\n    if (old) {\r\n        if (old.version !== cell.transform.version)\r\n            state.changed = true;\r\n    }\r\n    else {\r\n        state.added.add(ref.cell.transform.ref);\r\n        state.changed = true;\r\n    }\r\n    return ref;\r\n}\r\nfunction isTypeRoot(t, target) {\r\n    return function (cell, state) { return !target(state) && t.is(cell.obj); };\r\n}\r\nfunction noop() { }\r\nvar Mapping = [\r\n    [isTypeRoot(SO.Volume.Data, function (t) { return t.currentVolume; }), function (state, cell) {\r\n            state.currentVolume = createOrUpdateRefList(state, cell, state.hierarchy.volumes, VolumeRef, cell);\r\n        }, function (state) { return state.currentVolume = void 0; }],\r\n    [function (cell) { return SO.Volume.Lazy.is(cell.obj); }, function (state, cell) {\r\n            createOrUpdateRefList(state, cell, state.hierarchy.lazyVolumes, LazyVolumeRef, cell);\r\n        }, noop],\r\n    [function (cell, state) {\r\n            return !cell.state.isGhost && !!state.currentVolume && SO.Volume.Representation3D.is(cell.obj);\r\n        }, function (state, cell) {\r\n            if (state.currentVolume) {\r\n                createOrUpdateRefList(state, cell, state.currentVolume.representations, VolumeRepresentationRef, cell, state.currentVolume);\r\n            }\r\n            return false;\r\n        }, noop]\r\n];\r\nfunction isValidCell(cell) {\r\n    if (!cell || !(cell === null || cell === void 0 ? void 0 : cell.parent) || !cell.parent.cells.has(cell.transform.ref))\r\n        return false;\r\n    var obj = cell.obj;\r\n    if (!obj || obj === StateObject.Null || (cell.status !== 'ok' && cell.status !== 'error'))\r\n        return false;\r\n    return true;\r\n}\r\nfunction isRemoved(ref) {\r\n    var cell = ref.cell;\r\n    if (isValidCell(cell))\r\n        return;\r\n    this.changed = true;\r\n}\r\nfunction _preOrderFunc(c) { _doPreOrder(this, this.tree.transforms.get(c)); }\r\nfunction _doPreOrder(ctx, root) {\r\n    var state = ctx.state;\r\n    var cell = state.state.cells.get(root.ref);\r\n    if (!isValidCell(cell))\r\n        return;\r\n    var onLeave = void 0;\r\n    var end = false;\r\n    for (var _i = 0, Mapping_1 = Mapping; _i < Mapping_1.length; _i++) {\r\n        var _a = Mapping_1[_i], test_1 = _a[0], f = _a[1], l = _a[2];\r\n        if (test_1(cell, state)) {\r\n            var cont = f(state, cell);\r\n            if (cont === false) {\r\n                end = true;\r\n                break;\r\n            }\r\n            onLeave = l;\r\n            break;\r\n        }\r\n    }\r\n    // TODO: might be needed in the future\r\n    // const { currentComponent, currentModel, currentStructure, currentTrajectory } = ctx.state;\r\n    // const inTrackedSubtree = currentComponent || currentModel || currentStructure || currentTrajectory;\r\n    // if (inTrackedSubtree && cell.transform.transformer.definition.isDecorator) {\r\n    //     const ref = cell.transform.ref;\r\n    //     const old = ctx.state.oldHierarchy.decorators.get(ref);\r\n    //     if (old && old.version !== cell.transform.version) {\r\n    //         ctx.state.changed = true;\r\n    //     }\r\n    //     ctx.state.hierarchy.decorators.set(cell.transform.ref, cell.transform);\r\n    // }\r\n    if (end)\r\n        return;\r\n    var children = ctx.tree.children.get(root.ref);\r\n    if (children && children.size) {\r\n        children.forEach(_preOrderFunc, ctx);\r\n    }\r\n    if (onLeave)\r\n        onLeave(state);\r\n}\r\nfunction doPreOrder(tree, state) {\r\n    var ctx = { tree: tree, state: state };\r\n    _doPreOrder(ctx, tree.root);\r\n    return ctx.state;\r\n}\r\n//# sourceMappingURL=hierarchy-state.js.map"]},"metadata":{},"sourceType":"module"}