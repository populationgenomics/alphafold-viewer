{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __extends } from \"tslib\";\nimport { Structure, StructureElement } from '../../mol-model/structure';\nimport { SequenceWrapper } from './wrapper';\nimport { OrderedSet, Segmentation, Interval, SortedArray } from '../../mol-data/int';\nimport { ColorNames } from '../../mol-util/color/names';\nimport { applyMarkerAction } from '../../mol-util/marker-action';\n\nvar HeteroSequenceWrapper =\n/** @class */\nfunction (_super) {\n  __extends(HeteroSequenceWrapper, _super);\n\n  function HeteroSequenceWrapper(data) {\n    var _this = this;\n\n    var sequence = [];\n    var sequenceIndices = new Map();\n    var residueIndices = new Map();\n    var seqToUnit = new Map();\n\n    for (var i = 0, il = data.units.length; i < il; ++i) {\n      var unit = data.units[i];\n      var _a = unit.model.atomicHierarchy,\n          residueAtomSegments = _a.residueAtomSegments,\n          atoms = _a.atoms;\n      var residueIt = Segmentation.transientSegments(residueAtomSegments, unit.elements);\n\n      while (residueIt.hasNext) {\n        var index = residueIt.move().index;\n        sequenceIndices.set(index, sequence.length);\n        residueIndices.set(sequence.length, index);\n        seqToUnit.set(sequence.length, unit);\n        sequence.push(atoms.label_comp_id.value(residueAtomSegments.offsets[index]));\n      }\n    }\n\n    var length = sequence.length;\n    var markerArray = new Uint8Array(length);\n    _this = _super.call(this, data, markerArray, length) || this;\n    _this.unitMap = new Map();\n\n    for (var _i = 0, _b = data.units; _i < _b.length; _i++) {\n      var unit = _b[_i];\n\n      _this.unitMap.set(unit.id, unit);\n    }\n\n    _this.sequence = sequence;\n    _this.sequenceIndices = sequenceIndices;\n    _this.residueIndices = residueIndices;\n    _this.seqToUnit = seqToUnit;\n    return _this;\n  }\n\n  HeteroSequenceWrapper.prototype.residueLabel = function (seqIdx) {\n    return this.sequence[seqIdx];\n  };\n\n  HeteroSequenceWrapper.prototype.residueColor = function (seqIdx) {\n    return ColorNames.black;\n  };\n\n  HeteroSequenceWrapper.prototype.residueClass = function (seqIdx) {\n    return 'msp-sequence-present';\n  };\n\n  HeteroSequenceWrapper.prototype.mark = function (loci, action) {\n    var _this = this;\n\n    var changed = false;\n    var structure = this.data.structure;\n\n    if (StructureElement.Loci.is(loci)) {\n      if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n      loci = StructureElement.Loci.remap(loci, structure);\n\n      var _loop_1 = function (e) {\n        var unit = this_1.unitMap.get(e.unit.id);\n\n        if (unit) {\n          var residueIndex_1 = e.unit.model.atomicHierarchy.residueAtomSegments.index;\n          OrderedSet.forEach(e.indices, function (v) {\n            var seqIdx = _this.sequenceIndices.get(residueIndex_1[unit.elements[v]]);\n\n            if (seqIdx !== undefined && applyMarkerAction(_this.markerArray, Interval.ofSingleton(seqIdx), action)) changed = true;\n          });\n        }\n      };\n\n      var this_1 = this;\n\n      for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\n        var e = _a[_i];\n\n        _loop_1(e);\n      }\n    } else if (Structure.isLoci(loci)) {\n      if (!Structure.areRootsEquivalent(loci.structure, structure)) return false;\n      if (applyMarkerAction(this.markerArray, Interval.ofBounds(0, this.length), action)) changed = true;\n    }\n\n    return changed;\n  };\n\n  HeteroSequenceWrapper.prototype.getLoci = function (seqIdx) {\n    var elements = [];\n    var rI = this.residueIndices.get(seqIdx);\n\n    if (rI !== undefined) {\n      var unit = this.seqToUnit.get(seqIdx);\n      var offsets = unit.model.atomicHierarchy.residueAtomSegments.offsets;\n      var start = SortedArray.findPredecessorIndex(unit.elements, offsets[rI]);\n      var end = SortedArray.findPredecessorIndex(unit.elements, offsets[rI + 1]);\n      elements.push({\n        unit: unit,\n        indices: Interval.ofBounds(start, end)\n      });\n    }\n\n    return StructureElement.Loci(this.data.structure, elements);\n  };\n\n  return HeteroSequenceWrapper;\n}(SequenceWrapper);\n\nexport { HeteroSequenceWrapper };","map":{"version":3,"sources":["../../../src/mol-plugin-ui/sequence/hetero.ts"],"names":[],"mappings":"AAAA;;;;AAIG;;AAEH,SAAS,SAAT,EAAoB,gBAApB,QAAgE,2BAAhE;AACA,SAAS,eAAT,QAA+C,WAA/C;AACA,SAAS,UAAT,EAAqB,YAArB,EAAmC,QAAnC,EAA6C,WAA7C,QAAgE,oBAAhE;AAEA,SAAS,UAAT,QAA2B,4BAA3B;AACA,SAAuB,iBAAvB,QAAgD,8BAAhD;;AAEA,IAAA,qBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAA2C,EAAA,SAAA,CAAA,qBAAA,EAAA,MAAA,CAAA;;AAuDvC,WAAA,qBAAA,CAAY,IAAZ,EAA+B;AAA/B,QAAA,KAAA,GAAA,IAAA;;AACI,QAAM,QAAQ,GAAa,EAA3B;AACA,QAAM,eAAe,GAAG,IAAI,GAAJ,EAAxB;AACA,QAAM,cAAc,GAAG,IAAI,GAAJ,EAAvB;AACA,QAAM,SAAS,GAAG,IAAI,GAAJ,EAAlB;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,IAAI,CAAC,KAAL,CAAW,MAAhC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,EAAE,CAAlD,EAAqD;AACjD,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,CAAb;AACM,UAAA,EAAA,GAAiC,IAAI,CAAC,KAAL,CAAW,eAA5C;AAAA,UAAE,mBAAmB,GAAA,EAAA,CAAA,mBAArB;AAAA,UAAuB,KAAK,GAAA,EAAA,CAAA,KAA5B;AACN,UAAM,SAAS,GAAG,YAAY,CAAC,iBAAb,CAA+B,mBAA/B,EAAoD,IAAI,CAAC,QAAzD,CAAlB;;AACA,aAAO,SAAS,CAAC,OAAjB,EAA0B;AACd,YAAA,KAAK,GAAK,SAAS,CAAC,IAAV,GAAL,KAAL;AACR,QAAA,eAAe,CAAC,GAAhB,CAAoB,KAApB,EAA2B,QAAQ,CAAC,MAApC;AACA,QAAA,cAAc,CAAC,GAAf,CAAmB,QAAQ,CAAC,MAA5B,EAAoC,KAApC;AACA,QAAA,SAAS,CAAC,GAAV,CAAc,QAAQ,CAAC,MAAvB,EAA+B,IAA/B;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,KAAK,CAAC,aAAN,CAAoB,KAApB,CAA0B,mBAAmB,CAAC,OAApB,CAA4B,KAA5B,CAA1B,CAAd;AACH;AACJ;;AAED,QAAM,MAAM,GAAG,QAAQ,CAAC,MAAxB;AACA,QAAM,WAAW,GAAG,IAAI,UAAJ,CAAe,MAAf,CAApB;AAEA,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,IAAN,EAAY,WAAZ,EAAyB,MAAzB,KAAgC,IAAhC;AAEA,IAAA,KAAI,CAAC,OAAL,GAAe,IAAI,GAAJ,EAAf;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,IAAI,CAAC,KAAxB,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAA6B;AAAxB,UAAM,IAAI,GAAA,EAAA,CAAA,EAAA,CAAV;;AAA0B,MAAA,KAAI,CAAC,OAAL,CAAa,GAAb,CAAiB,IAAI,CAAC,EAAtB,EAA0B,IAA1B;AAAgC;;AAE/D,IAAA,KAAI,CAAC,QAAL,GAAgB,QAAhB;AACA,IAAA,KAAI,CAAC,eAAL,GAAuB,eAAvB;AACA,IAAA,KAAI,CAAC,cAAL,GAAsB,cAAtB;AACA,IAAA,KAAI,CAAC,SAAL,GAAiB,SAAjB;;AACH;;AA/ED,EAAA,qBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,MAAb,EAA2B;AACvB,WAAO,KAAK,QAAL,CAAc,MAAd,CAAP;AACH,GAFD;;AAGA,EAAA,qBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,MAAb,EAA2B;AACvB,WAAO,UAAU,CAAC,KAAlB;AACH,GAFD;;AAGA,EAAA,qBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,MAAb,EAA2B;AACvB,WAAO,sBAAP;AACH,GAFD;;AAIA,EAAA,qBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,IAAL,EAAiB,MAAjB,EAAqC;AAArC,QAAA,KAAA,GAAA,IAAA;;AACI,QAAI,OAAO,GAAG,KAAd;AACQ,QAAA,SAAS,GAAK,KAAK,IAAL,CAAL,SAAT;;AACR,QAAI,gBAAgB,CAAC,IAAjB,CAAsB,EAAtB,CAAyB,IAAzB,CAAJ,EAAoC;AAChC,UAAI,CAAC,SAAS,CAAC,kBAAV,CAA6B,IAAI,CAAC,SAAlC,EAA6C,SAA7C,CAAL,EAA8D,OAAO,KAAP;AAC9D,MAAA,IAAI,GAAG,gBAAgB,CAAC,IAAjB,CAAsB,KAAtB,CAA4B,IAA5B,EAAkC,SAAlC,CAAP;;8BAEW,C,EAAC;AACR,YAAM,IAAI,GAAG,MAAA,CAAK,OAAL,CAAa,GAAb,CAAiB,CAAC,CAAC,IAAF,CAAO,EAAxB,CAAb;;AACA,YAAI,IAAJ,EAAU;AACE,cAAO,cAAY,GAAK,CAAC,CAAC,IAAF,CAAO,KAAP,CAAa,eAAb,CAA6B,mBAA7B,CAAL,KAAnB;AACR,UAAA,UAAU,CAAC,OAAX,CAAmB,CAAC,CAAC,OAArB,EAA8B,UAAA,CAAA,EAAC;AAC3B,gBAAM,MAAM,GAAG,KAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,cAAY,CAAC,IAAI,CAAC,QAAL,CAAc,CAAd,CAAD,CAArC,CAAf;;AACA,gBAAI,MAAM,KAAK,SAAX,IAAwB,iBAAiB,CAAC,KAAI,CAAC,WAAN,EAAmB,QAAQ,CAAC,WAAT,CAAqB,MAArB,CAAnB,EAAiD,MAAjD,CAA7C,EAAuG,OAAO,GAAG,IAAV;AAC1G,WAHD;AAIH;;;;;AARL,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,IAAI,CAAC,QAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA6B;AAAxB,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;;gBAAM,C;AASV;AACJ,KAdD,MAcO,IAAI,SAAS,CAAC,MAAV,CAAiB,IAAjB,CAAJ,EAA4B;AAC/B,UAAI,CAAC,SAAS,CAAC,kBAAV,CAA6B,IAAI,CAAC,SAAlC,EAA6C,SAA7C,CAAL,EAA8D,OAAO,KAAP;AAE9D,UAAI,iBAAiB,CAAC,KAAK,WAAN,EAAmB,QAAQ,CAAC,QAAT,CAAkB,CAAlB,EAAqB,KAAK,MAA1B,CAAnB,EAAsD,MAAtD,CAArB,EAAoF,OAAO,GAAG,IAAV;AACvF;;AACD,WAAO,OAAP;AACH,GAvBD;;AAyBA,EAAA,qBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,MAAR,EAAsB;AAClB,QAAM,QAAQ,GAA2C,EAAzD;AACA,QAAM,EAAE,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,MAAxB,CAAX;;AACA,QAAI,EAAE,KAAK,SAAX,EAAsB;AAClB,UAAM,IAAI,GAAG,KAAK,SAAL,CAAe,GAAf,CAAmB,MAAnB,CAAb;AACQ,UAAA,OAAO,GAAK,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,mBAA3B,CAAL,OAAP;AACR,UAAM,KAAK,GAAG,WAAW,CAAC,oBAAZ,CAAiC,IAAI,CAAC,QAAtC,EAAgD,OAAO,CAAC,EAAD,CAAvD,CAAd;AACA,UAAM,GAAG,GAAG,WAAW,CAAC,oBAAZ,CAAiC,IAAI,CAAC,QAAtC,EAAgD,OAAO,CAAC,EAAE,GAAG,CAAN,CAAvD,CAAZ;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc;AAAE,QAAA,IAAI,EAAA,IAAN;AAAQ,QAAA,OAAO,EAAE,QAAQ,CAAC,QAAT,CAAkB,KAAlB,EAAyB,GAAzB;AAAjB,OAAd;AACH;;AACD,WAAO,gBAAgB,CAAC,IAAjB,CAAsB,KAAK,IAAL,CAAU,SAAhC,EAA2C,QAA3C,CAAP;AACH,GAXD;;AA6CJ,SAAA,qBAAA;AAAC,CAvFD,CAA2C,eAA3C,CAAA","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __extends } from \"tslib\";\r\nimport { Structure, StructureElement } from '../../mol-model/structure';\r\nimport { SequenceWrapper } from './wrapper';\r\nimport { OrderedSet, Segmentation, Interval, SortedArray } from '../../mol-data/int';\r\nimport { ColorNames } from '../../mol-util/color/names';\r\nimport { applyMarkerAction } from '../../mol-util/marker-action';\r\nvar HeteroSequenceWrapper = /** @class */ (function (_super) {\r\n    __extends(HeteroSequenceWrapper, _super);\r\n    function HeteroSequenceWrapper(data) {\r\n        var _this = this;\r\n        var sequence = [];\r\n        var sequenceIndices = new Map();\r\n        var residueIndices = new Map();\r\n        var seqToUnit = new Map();\r\n        for (var i = 0, il = data.units.length; i < il; ++i) {\r\n            var unit = data.units[i];\r\n            var _a = unit.model.atomicHierarchy, residueAtomSegments = _a.residueAtomSegments, atoms = _a.atoms;\r\n            var residueIt = Segmentation.transientSegments(residueAtomSegments, unit.elements);\r\n            while (residueIt.hasNext) {\r\n                var index = residueIt.move().index;\r\n                sequenceIndices.set(index, sequence.length);\r\n                residueIndices.set(sequence.length, index);\r\n                seqToUnit.set(sequence.length, unit);\r\n                sequence.push(atoms.label_comp_id.value(residueAtomSegments.offsets[index]));\r\n            }\r\n        }\r\n        var length = sequence.length;\r\n        var markerArray = new Uint8Array(length);\r\n        _this = _super.call(this, data, markerArray, length) || this;\r\n        _this.unitMap = new Map();\r\n        for (var _i = 0, _b = data.units; _i < _b.length; _i++) {\r\n            var unit = _b[_i];\r\n            _this.unitMap.set(unit.id, unit);\r\n        }\r\n        _this.sequence = sequence;\r\n        _this.sequenceIndices = sequenceIndices;\r\n        _this.residueIndices = residueIndices;\r\n        _this.seqToUnit = seqToUnit;\r\n        return _this;\r\n    }\r\n    HeteroSequenceWrapper.prototype.residueLabel = function (seqIdx) {\r\n        return this.sequence[seqIdx];\r\n    };\r\n    HeteroSequenceWrapper.prototype.residueColor = function (seqIdx) {\r\n        return ColorNames.black;\r\n    };\r\n    HeteroSequenceWrapper.prototype.residueClass = function (seqIdx) {\r\n        return 'msp-sequence-present';\r\n    };\r\n    HeteroSequenceWrapper.prototype.mark = function (loci, action) {\r\n        var _this = this;\r\n        var changed = false;\r\n        var structure = this.data.structure;\r\n        if (StructureElement.Loci.is(loci)) {\r\n            if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n                return false;\r\n            loci = StructureElement.Loci.remap(loci, structure);\r\n            var _loop_1 = function (e) {\r\n                var unit = this_1.unitMap.get(e.unit.id);\r\n                if (unit) {\r\n                    var residueIndex_1 = e.unit.model.atomicHierarchy.residueAtomSegments.index;\r\n                    OrderedSet.forEach(e.indices, function (v) {\r\n                        var seqIdx = _this.sequenceIndices.get(residueIndex_1[unit.elements[v]]);\r\n                        if (seqIdx !== undefined && applyMarkerAction(_this.markerArray, Interval.ofSingleton(seqIdx), action))\r\n                            changed = true;\r\n                    });\r\n                }\r\n            };\r\n            var this_1 = this;\r\n            for (var _i = 0, _a = loci.elements; _i < _a.length; _i++) {\r\n                var e = _a[_i];\r\n                _loop_1(e);\r\n            }\r\n        }\r\n        else if (Structure.isLoci(loci)) {\r\n            if (!Structure.areRootsEquivalent(loci.structure, structure))\r\n                return false;\r\n            if (applyMarkerAction(this.markerArray, Interval.ofBounds(0, this.length), action))\r\n                changed = true;\r\n        }\r\n        return changed;\r\n    };\r\n    HeteroSequenceWrapper.prototype.getLoci = function (seqIdx) {\r\n        var elements = [];\r\n        var rI = this.residueIndices.get(seqIdx);\r\n        if (rI !== undefined) {\r\n            var unit = this.seqToUnit.get(seqIdx);\r\n            var offsets = unit.model.atomicHierarchy.residueAtomSegments.offsets;\r\n            var start = SortedArray.findPredecessorIndex(unit.elements, offsets[rI]);\r\n            var end = SortedArray.findPredecessorIndex(unit.elements, offsets[rI + 1]);\r\n            elements.push({ unit: unit, indices: Interval.ofBounds(start, end) });\r\n        }\r\n        return StructureElement.Loci(this.data.structure, elements);\r\n    };\r\n    return HeteroSequenceWrapper;\r\n}(SequenceWrapper));\r\nexport { HeteroSequenceWrapper };\r\n//# sourceMappingURL=hetero.js.map"]},"metadata":{},"sourceType":"module"}