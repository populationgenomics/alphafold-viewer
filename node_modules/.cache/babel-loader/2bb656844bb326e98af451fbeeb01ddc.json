{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Mat4, Tensor, Vec3 } from '../../../mol-math/linear-algebra';\nimport { SymmetryOperator } from '../../../mol-math/geometry/symmetry-operator';\nimport { Assembly } from '../../../mol-model/structure/model/properties/symmetry';\nimport { Queries as Q } from '../../../mol-model/structure';\nimport { StructureProperties } from '../../../mol-model/structure';\nexport function createAssemblies(pdbx_struct_assembly, pdbx_struct_assembly_gen, pdbx_struct_oper_list) {\n  if (!pdbx_struct_assembly._rowCount) return [];\n  var matrices = getMatrices(pdbx_struct_oper_list);\n  var assemblies = [];\n\n  for (var i = 0; i < pdbx_struct_assembly._rowCount; i++) {\n    assemblies[assemblies.length] = createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, i, matrices);\n  }\n\n  return assemblies;\n}\n\nfunction createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, index, matrices) {\n  var id = pdbx_struct_assembly.id.value(index);\n  var details = pdbx_struct_assembly.details.value(index);\n  var generators = [];\n  var assembly_id = pdbx_struct_assembly_gen.assembly_id,\n      oper_expression = pdbx_struct_assembly_gen.oper_expression,\n      asym_id_list = pdbx_struct_assembly_gen.asym_id_list;\n\n  for (var i = 0, _i = pdbx_struct_assembly_gen._rowCount; i < _i; i++) {\n    if (assembly_id.value(i) !== id) continue;\n    generators[generators.length] = {\n      assemblyId: id,\n      expression: oper_expression.value(i),\n      asymIds: asym_id_list.value(i)\n    };\n  }\n\n  return Assembly.create(id, details, operatorGroupsProvider(generators, matrices));\n}\n\nfunction operatorGroupsProvider(generators, matrices) {\n  return function () {\n    var groups = [];\n    var operatorOffset = 0;\n\n    for (var i = 0; i < generators.length; i++) {\n      var gen = generators[i];\n      var operatorList = parseOperatorList(gen.expression);\n      var operatorNames = expandOperators(operatorList);\n      var operators = getAssemblyOperators(matrices, operatorNames, operatorOffset, gen.assemblyId);\n      var selector = Q.generators.atoms({\n        chainTest: Q.pred.and(Q.pred.eq(function (ctx) {\n          return StructureProperties.unit.operator_name(ctx.element);\n        }, SymmetryOperator.DefaultName), Q.pred.inSet(function (ctx) {\n          return StructureProperties.chain.label_asym_id(ctx.element);\n        }, gen.asymIds))\n      });\n      groups[groups.length] = {\n        selector: selector,\n        operators: operators\n      };\n      operatorOffset += operators.length;\n    }\n\n    return groups;\n  };\n}\n\nfunction getMatrices(pdbx_struct_oper_list) {\n  var id = pdbx_struct_oper_list.id,\n      matrix = pdbx_struct_oper_list.matrix,\n      vector = pdbx_struct_oper_list.vector,\n      _schema = pdbx_struct_oper_list._schema;\n  var matrices = new Map();\n\n  for (var i = 0, _i = pdbx_struct_oper_list._rowCount; i < _i; i++) {\n    var m = Tensor.toMat4(Mat4(), _schema.matrix.space, matrix.value(i));\n    var t = Tensor.toVec3(Vec3(), _schema.vector.space, vector.value(i));\n    Mat4.setTranslation(m, t);\n    Mat4.setValue(m, 3, 3, 1);\n    matrices.set(id.value(i), m);\n  }\n\n  return matrices;\n}\n\nfunction expandOperators(operatorList) {\n  var ops = [];\n  var currentOp = [];\n\n  for (var i = 0; i < operatorList.length; i++) currentOp[i] = '';\n\n  expandOperators1(operatorList, ops, operatorList.length - 1, currentOp);\n  return ops;\n}\n\nfunction expandOperators1(operatorNames, list, i, current) {\n  if (i < 0) {\n    list[list.length] = current.slice(0);\n    return;\n  }\n\n  var ops = operatorNames[i],\n      len = ops.length;\n\n  for (var j = 0; j < len; j++) {\n    current[i] = ops[j];\n    expandOperators1(operatorNames, list, i - 1, current);\n  }\n}\n\nfunction getAssemblyOperators(matrices, operatorNames, startIndex, assemblyId) {\n  var operators = [];\n  var index = startIndex;\n\n  for (var _a = 0, operatorNames_1 = operatorNames; _a < operatorNames_1.length; _a++) {\n    var op = operatorNames_1[_a];\n    var m = Mat4.identity();\n\n    for (var i = 0; i < op.length; i++) {\n      Mat4.mul(m, m, matrices.get(op[i]));\n    }\n\n    index++;\n    operators[operators.length] = SymmetryOperator.create(\"ASM_\" + index, m, {\n      assembly: {\n        id: assemblyId,\n        operId: index,\n        operList: op\n      }\n    });\n  }\n\n  return operators;\n}\n\nfunction parseOperatorList(value) {\n  // '(X0)(1-5)' becomes [['X0'], ['1', '2', '3', '4', '5']]\n  // kudos to Glen van Ginkel.\n  var oeRegex = /\\(?([^\\(\\)]+)\\)?]*/g,\n      groups = [],\n      ret = [];\n  var g;\n\n  while (g = oeRegex.exec(value)) groups[groups.length] = g[1];\n\n  groups.forEach(function (g) {\n    var group = [];\n    g.split(',').forEach(function (e) {\n      var dashIndex = e.indexOf('-');\n\n      if (dashIndex > 0) {\n        var from = parseInt(e.substring(0, dashIndex)),\n            to = parseInt(e.substr(dashIndex + 1));\n\n        for (var i = from; i <= to; i++) group[group.length] = i.toString();\n      } else {\n        group[group.length] = e.trim();\n      }\n    });\n    ret[ret.length] = group;\n  });\n  return ret;\n}","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/property/assembly.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Mat4, Tensor, Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { SymmetryOperator } from '../../../mol-math/geometry/symmetry-operator';\r\nimport { Assembly } from '../../../mol-model/structure/model/properties/symmetry';\r\nimport { Queries as Q } from '../../../mol-model/structure';\r\nimport { StructureProperties } from '../../../mol-model/structure';\r\nexport function createAssemblies(pdbx_struct_assembly, pdbx_struct_assembly_gen, pdbx_struct_oper_list) {\r\n    if (!pdbx_struct_assembly._rowCount)\r\n        return [];\r\n    var matrices = getMatrices(pdbx_struct_oper_list);\r\n    var assemblies = [];\r\n    for (var i = 0; i < pdbx_struct_assembly._rowCount; i++) {\r\n        assemblies[assemblies.length] = createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, i, matrices);\r\n    }\r\n    return assemblies;\r\n}\r\nfunction createAssembly(pdbx_struct_assembly, pdbx_struct_assembly_gen, index, matrices) {\r\n    var id = pdbx_struct_assembly.id.value(index);\r\n    var details = pdbx_struct_assembly.details.value(index);\r\n    var generators = [];\r\n    var assembly_id = pdbx_struct_assembly_gen.assembly_id, oper_expression = pdbx_struct_assembly_gen.oper_expression, asym_id_list = pdbx_struct_assembly_gen.asym_id_list;\r\n    for (var i = 0, _i = pdbx_struct_assembly_gen._rowCount; i < _i; i++) {\r\n        if (assembly_id.value(i) !== id)\r\n            continue;\r\n        generators[generators.length] = {\r\n            assemblyId: id,\r\n            expression: oper_expression.value(i),\r\n            asymIds: asym_id_list.value(i)\r\n        };\r\n    }\r\n    return Assembly.create(id, details, operatorGroupsProvider(generators, matrices));\r\n}\r\nfunction operatorGroupsProvider(generators, matrices) {\r\n    return function () {\r\n        var groups = [];\r\n        var operatorOffset = 0;\r\n        for (var i = 0; i < generators.length; i++) {\r\n            var gen = generators[i];\r\n            var operatorList = parseOperatorList(gen.expression);\r\n            var operatorNames = expandOperators(operatorList);\r\n            var operators = getAssemblyOperators(matrices, operatorNames, operatorOffset, gen.assemblyId);\r\n            var selector = Q.generators.atoms({ chainTest: Q.pred.and(Q.pred.eq(function (ctx) { return StructureProperties.unit.operator_name(ctx.element); }, SymmetryOperator.DefaultName), Q.pred.inSet(function (ctx) { return StructureProperties.chain.label_asym_id(ctx.element); }, gen.asymIds)) });\r\n            groups[groups.length] = { selector: selector, operators: operators };\r\n            operatorOffset += operators.length;\r\n        }\r\n        return groups;\r\n    };\r\n}\r\nfunction getMatrices(pdbx_struct_oper_list) {\r\n    var id = pdbx_struct_oper_list.id, matrix = pdbx_struct_oper_list.matrix, vector = pdbx_struct_oper_list.vector, _schema = pdbx_struct_oper_list._schema;\r\n    var matrices = new Map();\r\n    for (var i = 0, _i = pdbx_struct_oper_list._rowCount; i < _i; i++) {\r\n        var m = Tensor.toMat4(Mat4(), _schema.matrix.space, matrix.value(i));\r\n        var t = Tensor.toVec3(Vec3(), _schema.vector.space, vector.value(i));\r\n        Mat4.setTranslation(m, t);\r\n        Mat4.setValue(m, 3, 3, 1);\r\n        matrices.set(id.value(i), m);\r\n    }\r\n    return matrices;\r\n}\r\nfunction expandOperators(operatorList) {\r\n    var ops = [];\r\n    var currentOp = [];\r\n    for (var i = 0; i < operatorList.length; i++)\r\n        currentOp[i] = '';\r\n    expandOperators1(operatorList, ops, operatorList.length - 1, currentOp);\r\n    return ops;\r\n}\r\nfunction expandOperators1(operatorNames, list, i, current) {\r\n    if (i < 0) {\r\n        list[list.length] = current.slice(0);\r\n        return;\r\n    }\r\n    var ops = operatorNames[i], len = ops.length;\r\n    for (var j = 0; j < len; j++) {\r\n        current[i] = ops[j];\r\n        expandOperators1(operatorNames, list, i - 1, current);\r\n    }\r\n}\r\nfunction getAssemblyOperators(matrices, operatorNames, startIndex, assemblyId) {\r\n    var operators = [];\r\n    var index = startIndex;\r\n    for (var _a = 0, operatorNames_1 = operatorNames; _a < operatorNames_1.length; _a++) {\r\n        var op = operatorNames_1[_a];\r\n        var m = Mat4.identity();\r\n        for (var i = 0; i < op.length; i++) {\r\n            Mat4.mul(m, m, matrices.get(op[i]));\r\n        }\r\n        index++;\r\n        operators[operators.length] = SymmetryOperator.create(\"ASM_\" + index, m, { assembly: { id: assemblyId, operId: index, operList: op } });\r\n    }\r\n    return operators;\r\n}\r\nfunction parseOperatorList(value) {\r\n    // '(X0)(1-5)' becomes [['X0'], ['1', '2', '3', '4', '5']]\r\n    // kudos to Glen van Ginkel.\r\n    var oeRegex = /\\(?([^\\(\\)]+)\\)?]*/g, groups = [], ret = [];\r\n    var g;\r\n    while (g = oeRegex.exec(value))\r\n        groups[groups.length] = g[1];\r\n    groups.forEach(function (g) {\r\n        var group = [];\r\n        g.split(',').forEach(function (e) {\r\n            var dashIndex = e.indexOf('-');\r\n            if (dashIndex > 0) {\r\n                var from = parseInt(e.substring(0, dashIndex)), to = parseInt(e.substr(dashIndex + 1));\r\n                for (var i = from; i <= to; i++)\r\n                    group[group.length] = i.toString();\r\n            }\r\n            else {\r\n                group[group.length] = e.trim();\r\n            }\r\n        });\r\n        ret[ret.length] = group;\r\n    });\r\n    return ret;\r\n}\r\n//# sourceMappingURL=assembly.js.map"]},"metadata":{},"sourceType":"module"}