{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from CIFTools.js (https://github.com/dsehnal/CIFTools.js; MIT) and MMTF (https://github.com/rcsb/mmtf-javascript/; MIT)\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { ChunkedArray } from '../../../mol-data/util';\nimport { Encoding } from './encoding';\nimport { classifyIntArray } from './classifier';\n\nvar ArrayEncoderImpl =\n/** @class */\nfunction () {\n  function ArrayEncoderImpl(providers) {\n    this.providers = providers;\n  }\n\n  ArrayEncoderImpl.prototype.and = function (f) {\n    return new ArrayEncoderImpl(this.providers.concat([f]));\n  };\n\n  ArrayEncoderImpl.prototype.encode = function (data) {\n    var encoding = [];\n\n    for (var _i = 0, _a = this.providers; _i < _a.length; _i++) {\n      var p = _a[_i];\n      var t = p(data);\n\n      if (!t.encodings.length) {\n        throw new Error('Encodings must be non-empty.');\n      }\n\n      data = t.data;\n\n      for (var _b = 0, _c = t.encodings; _b < _c.length; _b++) {\n        var e = _c[_b];\n        encoding.push(e);\n      }\n    }\n\n    if (!(data instanceof Uint8Array)) {\n      throw new Error('The encoding must result in a Uint8Array. Fix your encoding chain.');\n    }\n\n    return {\n      encoding: encoding,\n      data: data\n    };\n  };\n\n  return ArrayEncoderImpl;\n}();\n\nexport { ArrayEncoderImpl };\nexport var ArrayEncoder;\n\n(function (ArrayEncoder) {\n  function by(f) {\n    return new ArrayEncoderImpl([f]);\n  }\n\n  ArrayEncoder.by = by;\n\n  function fromEncoding(encoding) {\n    var e = by(getProvider(encoding[0]));\n\n    for (var i = 1; i < encoding.length; i++) e = e.and(getProvider(encoding[i]));\n\n    return e;\n  }\n\n  ArrayEncoder.fromEncoding = fromEncoding;\n\n  function getProvider(e) {\n    switch (e.kind) {\n      case 'ByteArray':\n        return ArrayEncoding.byteArray;\n\n      case 'FixedPoint':\n        return ArrayEncoding.fixedPoint(e.factor);\n\n      case 'IntervalQuantization':\n        return ArrayEncoding.intervalQuantizaiton(e.min, e.max, e.numSteps);\n\n      case 'RunLength':\n        return ArrayEncoding.runLength;\n\n      case 'Delta':\n        return ArrayEncoding.delta;\n\n      case 'IntegerPacking':\n        return ArrayEncoding.integerPacking;\n\n      case 'StringArray':\n        return ArrayEncoding.stringArray;\n    }\n  }\n})(ArrayEncoder || (ArrayEncoder = {}));\n\nexport var ArrayEncoding;\n\n(function (ArrayEncoding) {\n  var _a, _b;\n\n  function by(f) {\n    return new ArrayEncoderImpl([f]);\n  }\n\n  ArrayEncoding.by = by;\n\n  function uint8(data) {\n    return {\n      encodings: [{\n        kind: 'ByteArray',\n        type: 4\n        /* Uint8 */\n\n      }],\n      data: data\n    };\n  }\n\n  function int8(data) {\n    return {\n      encodings: [{\n        kind: 'ByteArray',\n        type: 1\n        /* Int8 */\n\n      }],\n      data: new Uint8Array(data.buffer, data.byteOffset)\n    };\n  }\n\n  var writers = (_a = {}, _a[2\n  /* Int16 */\n  ] = function (v, i, a) {\n    v.setInt16(2 * i, a, true);\n  }, _a[5\n  /* Uint16 */\n  ] = function (v, i, a) {\n    v.setUint16(2 * i, a, true);\n  }, _a[3\n  /* Int32 */\n  ] = function (v, i, a) {\n    v.setInt32(4 * i, a, true);\n  }, _a[6\n  /* Uint32 */\n  ] = function (v, i, a) {\n    v.setUint32(4 * i, a, true);\n  }, _a[32\n  /* Float32 */\n  ] = function (v, i, a) {\n    v.setFloat32(4 * i, a, true);\n  }, _a[33\n  /* Float64 */\n  ] = function (v, i, a) {\n    v.setFloat64(8 * i, a, true);\n  }, _a);\n  var byteSizes = (_b = {}, _b[2\n  /* Int16 */\n  ] = 2, _b[5\n  /* Uint16 */\n  ] = 2, _b[3\n  /* Int32 */\n  ] = 4, _b[6\n  /* Uint32 */\n  ] = 4, _b[32\n  /* Float32 */\n  ] = 4, _b[33\n  /* Float64 */\n  ] = 8, _b);\n\n  function byteArray(data) {\n    var type = Encoding.getDataType(data);\n    if (type === 1\n    /* Int8 */\n    ) return int8(data);else if (type === 4\n    /* Uint8 */\n    ) return uint8(data);\n    var result = new Uint8Array(data.length * byteSizes[type]);\n    var w = writers[type];\n    var view = new DataView(result.buffer);\n\n    for (var i = 0, n = data.length; i < n; i++) {\n      w(view, i, data[i]);\n    }\n\n    return {\n      encodings: [{\n        kind: 'ByteArray',\n        type: type\n      }],\n      data: result\n    };\n  }\n\n  ArrayEncoding.byteArray = byteArray;\n\n  function _fixedPoint(data, factor) {\n    var srcType = Encoding.getDataType(data);\n    var result = new Int32Array(data.length);\n\n    for (var i = 0, n = data.length; i < n; i++) {\n      result[i] = Math.round(data[i] * factor);\n    }\n\n    return {\n      encodings: [{\n        kind: 'FixedPoint',\n        factor: factor,\n        srcType: srcType\n      }],\n      data: result\n    };\n  }\n\n  function fixedPoint(factor) {\n    return function (data) {\n      return _fixedPoint(data, factor);\n    };\n  }\n\n  ArrayEncoding.fixedPoint = fixedPoint;\n\n  function _intervalQuantizaiton(data, min, max, numSteps, arrayType) {\n    var srcType = Encoding.getDataType(data);\n\n    if (!data.length) {\n      return {\n        encodings: [{\n          kind: 'IntervalQuantization',\n          min: min,\n          max: max,\n          numSteps: numSteps,\n          srcType: srcType\n        }],\n        data: new Int32Array(0)\n      };\n    }\n\n    if (max < min) {\n      var t = min;\n      min = max;\n      max = t;\n    }\n\n    var delta = (max - min) / (numSteps - 1);\n    var output = new arrayType(data.length);\n\n    for (var i = 0, n = data.length; i < n; i++) {\n      var v = data[i];\n      if (v <= min) output[i] = 0;else if (v >= max) output[i] = numSteps - 1;else output[i] = Math.round((v - min) / delta) | 0;\n    }\n\n    return {\n      encodings: [{\n        kind: 'IntervalQuantization',\n        min: min,\n        max: max,\n        numSteps: numSteps,\n        srcType: srcType\n      }],\n      data: output\n    };\n  }\n\n  function intervalQuantizaiton(min, max, numSteps, arrayType) {\n    if (arrayType === void 0) {\n      arrayType = Int32Array;\n    }\n\n    return function (data) {\n      return _intervalQuantizaiton(data, min, max, numSteps, arrayType);\n    };\n  }\n\n  ArrayEncoding.intervalQuantizaiton = intervalQuantizaiton;\n\n  function runLength(data) {\n    var srcType = Encoding.getDataType(data);\n\n    if (srcType === void 0) {\n      data = new Int32Array(data);\n      srcType = 3\n      /* Int32 */\n      ;\n    }\n\n    if (!data.length) {\n      return {\n        encodings: [{\n          kind: 'RunLength',\n          srcType: srcType,\n          srcSize: 0\n        }],\n        data: new Int32Array(0)\n      };\n    } // calculate output size\n\n\n    var fullLength = 2;\n\n    for (var i = 1, il = data.length; i < il; i++) {\n      if (data[i - 1] !== data[i]) {\n        fullLength += 2;\n      }\n    }\n\n    var output = new Int32Array(fullLength);\n    var offset = 0;\n    var runLength = 1;\n\n    for (var i = 1, il = data.length; i < il; i++) {\n      if (data[i - 1] !== data[i]) {\n        output[offset] = data[i - 1];\n        output[offset + 1] = runLength;\n        runLength = 1;\n        offset += 2;\n      } else {\n        ++runLength;\n      }\n    }\n\n    output[offset] = data[data.length - 1];\n    output[offset + 1] = runLength;\n    return {\n      encodings: [{\n        kind: 'RunLength',\n        srcType: srcType,\n        srcSize: data.length\n      }],\n      data: output\n    };\n  }\n\n  ArrayEncoding.runLength = runLength;\n\n  function delta(data) {\n    if (!Encoding.isSignedIntegerDataType(data)) {\n      throw new Error('Only signed integer types can be encoded using delta encoding.');\n    }\n\n    var srcType = Encoding.getDataType(data);\n\n    if (srcType === void 0) {\n      data = new Int32Array(data);\n      srcType = 3\n      /* Int32 */\n      ;\n    }\n\n    if (!data.length) {\n      return {\n        encodings: [{\n          kind: 'Delta',\n          origin: 0,\n          srcType: srcType\n        }],\n        data: new data.constructor(0)\n      };\n    }\n\n    var output = new data.constructor(data.length);\n    var origin = data[0];\n    output[0] = data[0];\n\n    for (var i = 1, n = data.length; i < n; i++) {\n      output[i] = data[i] - data[i - 1];\n    }\n\n    output[0] = 0;\n    return {\n      encodings: [{\n        kind: 'Delta',\n        origin: origin,\n        srcType: srcType\n      }],\n      data: output\n    };\n  }\n\n  ArrayEncoding.delta = delta;\n\n  function isSigned(data) {\n    for (var i = 0, n = data.length; i < n; i++) {\n      if (data[i] < 0) return true;\n    }\n\n    return false;\n  }\n\n  function packingSize(data, upperLimit) {\n    var lowerLimit = -upperLimit - 1;\n    var size = 0;\n\n    for (var i = 0, n = data.length; i < n; i++) {\n      var value = data[i];\n\n      if (value === 0) {\n        size += 1;\n      } else if (value > 0) {\n        size += Math.ceil(value / upperLimit);\n        if (value % upperLimit === 0) size += 1;\n      } else {\n        size += Math.ceil(value / lowerLimit);\n        if (value % lowerLimit === 0) size += 1;\n      }\n    }\n\n    return size;\n  }\n\n  function determinePacking(data) {\n    var signed = isSigned(data);\n    var size8 = signed ? packingSize(data, 0x7F) : packingSize(data, 0xFF);\n    var size16 = signed ? packingSize(data, 0x7FFF) : packingSize(data, 0xFFFF);\n\n    if (data.length * 4 < size16 * 2) {\n      // 4 byte packing is the most effective\n      return {\n        isSigned: signed,\n        size: data.length,\n        bytesPerElement: 4\n      };\n    } else if (size16 * 2 < size8) {\n      // 2 byte packing is the most effective\n      return {\n        isSigned: signed,\n        size: size16,\n        bytesPerElement: 2\n      };\n    } else {\n      // 1 byte packing is the most effective\n      return {\n        isSigned: signed,\n        size: size8,\n        bytesPerElement: 1\n      };\n    }\n\n    ;\n  }\n\n  function _integerPacking(data, packing) {\n    var upperLimit = packing.isSigned ? packing.bytesPerElement === 1 ? 0x7F : 0x7FFF : packing.bytesPerElement === 1 ? 0xFF : 0xFFFF;\n    var lowerLimit = -upperLimit - 1;\n    var n = data.length;\n    var packed = packing.isSigned ? packing.bytesPerElement === 1 ? new Int8Array(packing.size) : new Int16Array(packing.size) : packing.bytesPerElement === 1 ? new Uint8Array(packing.size) : new Uint16Array(packing.size);\n    var j = 0;\n\n    for (var i = 0; i < n; i++) {\n      var value = data[i];\n\n      if (value >= 0) {\n        while (value >= upperLimit) {\n          packed[j] = upperLimit;\n          ++j;\n          value -= upperLimit;\n        }\n      } else {\n        while (value <= lowerLimit) {\n          packed[j] = lowerLimit;\n          ++j;\n          value -= lowerLimit;\n        }\n      }\n\n      packed[j] = value;\n      ++j;\n    }\n\n    var result = byteArray(packed);\n    return {\n      encodings: [{\n        kind: 'IntegerPacking',\n        byteCount: packing.bytesPerElement,\n        isUnsigned: !packing.isSigned,\n        srcSize: n\n      }, result.encodings[0]],\n      data: result.data\n    };\n  }\n  /**\r\n   * Packs Int32 array. The packing level is determined automatically to either 1-, 2-, or 4-byte words.\r\n   */\n\n\n  function integerPacking(data) {\n    // if (!(data instanceof Int32Array)) {\n    //     throw new Error('Integer packing can only be applied to Int32 data.');\n    // }\n    var packing = determinePacking(data);\n\n    if (packing.bytesPerElement === 4) {\n      // no packing done, Int32 encoding will be used\n      return byteArray(data);\n    }\n\n    return _integerPacking(data, packing);\n  }\n\n  ArrayEncoding.integerPacking = integerPacking;\n\n  function stringArray(data) {\n    var map = Object.create(null);\n    var strings = [];\n    var output = new Int32Array(data.length);\n    var offsets = ChunkedArray.create(Int32Array, 1, Math.min(1024, data.length < 32 ? data.length + 1 : Math.round(data.length / 8) + 1));\n    ChunkedArray.add(offsets, 0);\n    var accLength = 0;\n    var i = 0;\n\n    for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n      var s = data_1[_i]; // handle null strings.\n\n      if (s === null || s === void 0) {\n        output[i++] = -1;\n        continue;\n      }\n\n      var index = map[s];\n\n      if (index === void 0) {\n        // increment the length\n        accLength += s.length; // store the string and index\n\n        index = strings.length;\n        strings[index] = s;\n        map[s] = index; // write the offset\n\n        ChunkedArray.add(offsets, accLength);\n      }\n\n      output[i++] = index;\n    }\n\n    var offsetArray = ChunkedArray.compact(offsets);\n    var offsetEncoding = classifyIntArray(offsetArray);\n    var encodedOddsets = offsetEncoding.encode(offsetArray);\n    var dataEncoding = classifyIntArray(output);\n    var encodedData = dataEncoding.encode(output);\n    return {\n      encodings: [{\n        kind: 'StringArray',\n        dataEncoding: encodedData.encoding,\n        stringData: strings.join(''),\n        offsetEncoding: encodedOddsets.encoding,\n        offsets: encodedOddsets.data\n      }],\n      data: encodedData.data\n    };\n  }\n\n  ArrayEncoding.stringArray = stringArray;\n})(ArrayEncoding || (ArrayEncoding = {}));","map":{"version":3,"sources":["../../../../src/mol-io/common/binary-cif/array-encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Adapted from CIFTools.js (https://github.com/dsehnal/CIFTools.js; MIT) and MMTF (https://github.com/rcsb/mmtf-javascript/; MIT)\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { ChunkedArray } from '../../../mol-data/util';\r\nimport { Encoding } from './encoding';\r\nimport { classifyIntArray } from './classifier';\r\nvar ArrayEncoderImpl = /** @class */ (function () {\r\n    function ArrayEncoderImpl(providers) {\r\n        this.providers = providers;\r\n    }\r\n    ArrayEncoderImpl.prototype.and = function (f) {\r\n        return new ArrayEncoderImpl(this.providers.concat([f]));\r\n    };\r\n    ArrayEncoderImpl.prototype.encode = function (data) {\r\n        var encoding = [];\r\n        for (var _i = 0, _a = this.providers; _i < _a.length; _i++) {\r\n            var p = _a[_i];\r\n            var t = p(data);\r\n            if (!t.encodings.length) {\r\n                throw new Error('Encodings must be non-empty.');\r\n            }\r\n            data = t.data;\r\n            for (var _b = 0, _c = t.encodings; _b < _c.length; _b++) {\r\n                var e = _c[_b];\r\n                encoding.push(e);\r\n            }\r\n        }\r\n        if (!(data instanceof Uint8Array)) {\r\n            throw new Error('The encoding must result in a Uint8Array. Fix your encoding chain.');\r\n        }\r\n        return {\r\n            encoding: encoding,\r\n            data: data\r\n        };\r\n    };\r\n    return ArrayEncoderImpl;\r\n}());\r\nexport { ArrayEncoderImpl };\r\nexport var ArrayEncoder;\r\n(function (ArrayEncoder) {\r\n    function by(f) {\r\n        return new ArrayEncoderImpl([f]);\r\n    }\r\n    ArrayEncoder.by = by;\r\n    function fromEncoding(encoding) {\r\n        var e = by(getProvider(encoding[0]));\r\n        for (var i = 1; i < encoding.length; i++)\r\n            e = e.and(getProvider(encoding[i]));\r\n        return e;\r\n    }\r\n    ArrayEncoder.fromEncoding = fromEncoding;\r\n    function getProvider(e) {\r\n        switch (e.kind) {\r\n            case 'ByteArray': return ArrayEncoding.byteArray;\r\n            case 'FixedPoint': return ArrayEncoding.fixedPoint(e.factor);\r\n            case 'IntervalQuantization': return ArrayEncoding.intervalQuantizaiton(e.min, e.max, e.numSteps);\r\n            case 'RunLength': return ArrayEncoding.runLength;\r\n            case 'Delta': return ArrayEncoding.delta;\r\n            case 'IntegerPacking': return ArrayEncoding.integerPacking;\r\n            case 'StringArray': return ArrayEncoding.stringArray;\r\n        }\r\n    }\r\n})(ArrayEncoder || (ArrayEncoder = {}));\r\nexport var ArrayEncoding;\r\n(function (ArrayEncoding) {\r\n    var _a, _b;\r\n    function by(f) {\r\n        return new ArrayEncoderImpl([f]);\r\n    }\r\n    ArrayEncoding.by = by;\r\n    function uint8(data) {\r\n        return {\r\n            encodings: [{ kind: 'ByteArray', type: 4 /* Uint8 */ }],\r\n            data: data\r\n        };\r\n    }\r\n    function int8(data) {\r\n        return {\r\n            encodings: [{ kind: 'ByteArray', type: 1 /* Int8 */ }],\r\n            data: new Uint8Array(data.buffer, data.byteOffset)\r\n        };\r\n    }\r\n    var writers = (_a = {},\r\n        _a[2 /* Int16 */] = function (v, i, a) { v.setInt16(2 * i, a, true); },\r\n        _a[5 /* Uint16 */] = function (v, i, a) { v.setUint16(2 * i, a, true); },\r\n        _a[3 /* Int32 */] = function (v, i, a) { v.setInt32(4 * i, a, true); },\r\n        _a[6 /* Uint32 */] = function (v, i, a) { v.setUint32(4 * i, a, true); },\r\n        _a[32 /* Float32 */] = function (v, i, a) { v.setFloat32(4 * i, a, true); },\r\n        _a[33 /* Float64 */] = function (v, i, a) { v.setFloat64(8 * i, a, true); },\r\n        _a);\r\n    var byteSizes = (_b = {},\r\n        _b[2 /* Int16 */] = 2,\r\n        _b[5 /* Uint16 */] = 2,\r\n        _b[3 /* Int32 */] = 4,\r\n        _b[6 /* Uint32 */] = 4,\r\n        _b[32 /* Float32 */] = 4,\r\n        _b[33 /* Float64 */] = 8,\r\n        _b);\r\n    function byteArray(data) {\r\n        var type = Encoding.getDataType(data);\r\n        if (type === 1 /* Int8 */)\r\n            return int8(data);\r\n        else if (type === 4 /* Uint8 */)\r\n            return uint8(data);\r\n        var result = new Uint8Array(data.length * byteSizes[type]);\r\n        var w = writers[type];\r\n        var view = new DataView(result.buffer);\r\n        for (var i = 0, n = data.length; i < n; i++) {\r\n            w(view, i, data[i]);\r\n        }\r\n        return {\r\n            encodings: [{ kind: 'ByteArray', type: type }],\r\n            data: result\r\n        };\r\n    }\r\n    ArrayEncoding.byteArray = byteArray;\r\n    function _fixedPoint(data, factor) {\r\n        var srcType = Encoding.getDataType(data);\r\n        var result = new Int32Array(data.length);\r\n        for (var i = 0, n = data.length; i < n; i++) {\r\n            result[i] = Math.round(data[i] * factor);\r\n        }\r\n        return {\r\n            encodings: [{ kind: 'FixedPoint', factor: factor, srcType: srcType }],\r\n            data: result\r\n        };\r\n    }\r\n    function fixedPoint(factor) { return function (data) { return _fixedPoint(data, factor); }; }\r\n    ArrayEncoding.fixedPoint = fixedPoint;\r\n    function _intervalQuantizaiton(data, min, max, numSteps, arrayType) {\r\n        var srcType = Encoding.getDataType(data);\r\n        if (!data.length) {\r\n            return {\r\n                encodings: [{ kind: 'IntervalQuantization', min: min, max: max, numSteps: numSteps, srcType: srcType }],\r\n                data: new Int32Array(0)\r\n            };\r\n        }\r\n        if (max < min) {\r\n            var t = min;\r\n            min = max;\r\n            max = t;\r\n        }\r\n        var delta = (max - min) / (numSteps - 1);\r\n        var output = new arrayType(data.length);\r\n        for (var i = 0, n = data.length; i < n; i++) {\r\n            var v = data[i];\r\n            if (v <= min)\r\n                output[i] = 0;\r\n            else if (v >= max)\r\n                output[i] = numSteps - 1;\r\n            else\r\n                output[i] = (Math.round((v - min) / delta)) | 0;\r\n        }\r\n        return {\r\n            encodings: [{ kind: 'IntervalQuantization', min: min, max: max, numSteps: numSteps, srcType: srcType }],\r\n            data: output\r\n        };\r\n    }\r\n    function intervalQuantizaiton(min, max, numSteps, arrayType) {\r\n        if (arrayType === void 0) { arrayType = Int32Array; }\r\n        return function (data) { return _intervalQuantizaiton(data, min, max, numSteps, arrayType); };\r\n    }\r\n    ArrayEncoding.intervalQuantizaiton = intervalQuantizaiton;\r\n    function runLength(data) {\r\n        var srcType = Encoding.getDataType(data);\r\n        if (srcType === void 0) {\r\n            data = new Int32Array(data);\r\n            srcType = 3 /* Int32 */;\r\n        }\r\n        if (!data.length) {\r\n            return {\r\n                encodings: [{ kind: 'RunLength', srcType: srcType, srcSize: 0 }],\r\n                data: new Int32Array(0)\r\n            };\r\n        }\r\n        // calculate output size\r\n        var fullLength = 2;\r\n        for (var i = 1, il = data.length; i < il; i++) {\r\n            if (data[i - 1] !== data[i]) {\r\n                fullLength += 2;\r\n            }\r\n        }\r\n        var output = new Int32Array(fullLength);\r\n        var offset = 0;\r\n        var runLength = 1;\r\n        for (var i = 1, il = data.length; i < il; i++) {\r\n            if (data[i - 1] !== data[i]) {\r\n                output[offset] = data[i - 1];\r\n                output[offset + 1] = runLength;\r\n                runLength = 1;\r\n                offset += 2;\r\n            }\r\n            else {\r\n                ++runLength;\r\n            }\r\n        }\r\n        output[offset] = data[data.length - 1];\r\n        output[offset + 1] = runLength;\r\n        return {\r\n            encodings: [{ kind: 'RunLength', srcType: srcType, srcSize: data.length }],\r\n            data: output\r\n        };\r\n    }\r\n    ArrayEncoding.runLength = runLength;\r\n    function delta(data) {\r\n        if (!Encoding.isSignedIntegerDataType(data)) {\r\n            throw new Error('Only signed integer types can be encoded using delta encoding.');\r\n        }\r\n        var srcType = Encoding.getDataType(data);\r\n        if (srcType === void 0) {\r\n            data = new Int32Array(data);\r\n            srcType = 3 /* Int32 */;\r\n        }\r\n        if (!data.length) {\r\n            return {\r\n                encodings: [{ kind: 'Delta', origin: 0, srcType: srcType }],\r\n                data: new data.constructor(0)\r\n            };\r\n        }\r\n        var output = new data.constructor(data.length);\r\n        var origin = data[0];\r\n        output[0] = data[0];\r\n        for (var i = 1, n = data.length; i < n; i++) {\r\n            output[i] = data[i] - data[i - 1];\r\n        }\r\n        output[0] = 0;\r\n        return {\r\n            encodings: [{ kind: 'Delta', origin: origin, srcType: srcType }],\r\n            data: output\r\n        };\r\n    }\r\n    ArrayEncoding.delta = delta;\r\n    function isSigned(data) {\r\n        for (var i = 0, n = data.length; i < n; i++) {\r\n            if (data[i] < 0)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function packingSize(data, upperLimit) {\r\n        var lowerLimit = -upperLimit - 1;\r\n        var size = 0;\r\n        for (var i = 0, n = data.length; i < n; i++) {\r\n            var value = data[i];\r\n            if (value === 0) {\r\n                size += 1;\r\n            }\r\n            else if (value > 0) {\r\n                size += Math.ceil(value / upperLimit);\r\n                if (value % upperLimit === 0)\r\n                    size += 1;\r\n            }\r\n            else {\r\n                size += Math.ceil(value / lowerLimit);\r\n                if (value % lowerLimit === 0)\r\n                    size += 1;\r\n            }\r\n        }\r\n        return size;\r\n    }\r\n    function determinePacking(data) {\r\n        var signed = isSigned(data);\r\n        var size8 = signed ? packingSize(data, 0x7F) : packingSize(data, 0xFF);\r\n        var size16 = signed ? packingSize(data, 0x7FFF) : packingSize(data, 0xFFFF);\r\n        if (data.length * 4 < size16 * 2) {\r\n            // 4 byte packing is the most effective\r\n            return {\r\n                isSigned: signed,\r\n                size: data.length,\r\n                bytesPerElement: 4\r\n            };\r\n        }\r\n        else if (size16 * 2 < size8) {\r\n            // 2 byte packing is the most effective\r\n            return {\r\n                isSigned: signed,\r\n                size: size16,\r\n                bytesPerElement: 2\r\n            };\r\n        }\r\n        else {\r\n            // 1 byte packing is the most effective\r\n            return {\r\n                isSigned: signed,\r\n                size: size8,\r\n                bytesPerElement: 1\r\n            };\r\n        }\r\n        ;\r\n    }\r\n    function _integerPacking(data, packing) {\r\n        var upperLimit = packing.isSigned\r\n            ? (packing.bytesPerElement === 1 ? 0x7F : 0x7FFF)\r\n            : (packing.bytesPerElement === 1 ? 0xFF : 0xFFFF);\r\n        var lowerLimit = -upperLimit - 1;\r\n        var n = data.length;\r\n        var packed = packing.isSigned\r\n            ? packing.bytesPerElement === 1 ? new Int8Array(packing.size) : new Int16Array(packing.size)\r\n            : packing.bytesPerElement === 1 ? new Uint8Array(packing.size) : new Uint16Array(packing.size);\r\n        var j = 0;\r\n        for (var i = 0; i < n; i++) {\r\n            var value = data[i];\r\n            if (value >= 0) {\r\n                while (value >= upperLimit) {\r\n                    packed[j] = upperLimit;\r\n                    ++j;\r\n                    value -= upperLimit;\r\n                }\r\n            }\r\n            else {\r\n                while (value <= lowerLimit) {\r\n                    packed[j] = lowerLimit;\r\n                    ++j;\r\n                    value -= lowerLimit;\r\n                }\r\n            }\r\n            packed[j] = value;\r\n            ++j;\r\n        }\r\n        var result = byteArray(packed);\r\n        return {\r\n            encodings: [{\r\n                    kind: 'IntegerPacking',\r\n                    byteCount: packing.bytesPerElement,\r\n                    isUnsigned: !packing.isSigned,\r\n                    srcSize: n\r\n                },\r\n                result.encodings[0]\r\n            ],\r\n            data: result.data\r\n        };\r\n    }\r\n    /**\r\n     * Packs Int32 array. The packing level is determined automatically to either 1-, 2-, or 4-byte words.\r\n     */\r\n    function integerPacking(data) {\r\n        // if (!(data instanceof Int32Array)) {\r\n        //     throw new Error('Integer packing can only be applied to Int32 data.');\r\n        // }\r\n        var packing = determinePacking(data);\r\n        if (packing.bytesPerElement === 4) {\r\n            // no packing done, Int32 encoding will be used\r\n            return byteArray(data);\r\n        }\r\n        return _integerPacking(data, packing);\r\n    }\r\n    ArrayEncoding.integerPacking = integerPacking;\r\n    function stringArray(data) {\r\n        var map = Object.create(null);\r\n        var strings = [];\r\n        var output = new Int32Array(data.length);\r\n        var offsets = ChunkedArray.create(Int32Array, 1, Math.min(1024, data.length < 32 ? data.length + 1 : Math.round(data.length / 8) + 1));\r\n        ChunkedArray.add(offsets, 0);\r\n        var accLength = 0;\r\n        var i = 0;\r\n        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\r\n            var s = data_1[_i];\r\n            // handle null strings.\r\n            if (s === null || s === void 0) {\r\n                output[i++] = -1;\r\n                continue;\r\n            }\r\n            var index = map[s];\r\n            if (index === void 0) {\r\n                // increment the length\r\n                accLength += s.length;\r\n                // store the string and index\r\n                index = strings.length;\r\n                strings[index] = s;\r\n                map[s] = index;\r\n                // write the offset\r\n                ChunkedArray.add(offsets, accLength);\r\n            }\r\n            output[i++] = index;\r\n        }\r\n        var offsetArray = ChunkedArray.compact(offsets);\r\n        var offsetEncoding = classifyIntArray(offsetArray);\r\n        var encodedOddsets = offsetEncoding.encode(offsetArray);\r\n        var dataEncoding = classifyIntArray(output);\r\n        var encodedData = dataEncoding.encode(output);\r\n        return {\r\n            encodings: [{ kind: 'StringArray', dataEncoding: encodedData.encoding, stringData: strings.join(''), offsetEncoding: encodedOddsets.encoding, offsets: encodedOddsets.data }],\r\n            data: encodedData.data\r\n        };\r\n    }\r\n    ArrayEncoding.stringArray = stringArray;\r\n})(ArrayEncoding || (ArrayEncoding = {}));\r\n//# sourceMappingURL=array-encoder.js.map"]},"metadata":{},"sourceType":"module"}