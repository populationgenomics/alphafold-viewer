{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * from https://github.com/dsehnal/CIFTools.js\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nvar ChunkedArray;\n\n(function (ChunkedArray) {\n  function is(x) {\n    return x.creator && x.chunkSize;\n  }\n\n  ChunkedArray.is = is;\n\n  function allocateNext(array) {\n    var nextSize = array.growBy * array.elementSize;\n    array.currentSize = nextSize;\n    array.currentIndex = 0;\n    array.currentChunk = new array.ctor(nextSize);\n    array.allocatedSize += nextSize;\n    array.chunks[array.chunks.length] = array.currentChunk;\n  }\n\n  function add4(array, x, y, z, w) {\n    if (array.currentIndex >= array.currentSize) allocateNext(array);\n    var c = array.currentChunk;\n    var i = array.currentIndex;\n    c[i] = x;\n    c[i + 1] = y;\n    c[i + 2] = z;\n    c[i + 3] = w;\n    array.currentIndex += 4;\n    return array.elementCount++;\n  }\n\n  ChunkedArray.add4 = add4;\n\n  function add3(array, x, y, z) {\n    if (array.currentIndex >= array.currentSize) allocateNext(array);\n    var c = array.currentChunk;\n    var i = array.currentIndex;\n    c[i] = x;\n    c[i + 1] = y;\n    c[i + 2] = z;\n    array.currentIndex += 3;\n    return array.elementCount++;\n  }\n\n  ChunkedArray.add3 = add3;\n\n  function add2(array, x, y) {\n    if (array.currentIndex >= array.currentSize) allocateNext(array);\n    var c = array.currentChunk;\n    var i = array.currentIndex;\n    c[i] = x;\n    c[i + 1] = y;\n    array.currentIndex += 2;\n    return array.elementCount++;\n  }\n\n  ChunkedArray.add2 = add2;\n\n  function add(array, x) {\n    if (array.currentIndex >= array.currentSize) allocateNext(array);\n    array.currentChunk[array.currentIndex] = x;\n    array.currentIndex += 1;\n    return array.elementCount++;\n  }\n\n  ChunkedArray.add = add;\n\n  function addRepeat(array, n, x) {\n    for (var i = 0; i < n; i++) {\n      if (array.currentIndex >= array.currentSize) allocateNext(array);\n      array.currentChunk[array.currentIndex++] = x;\n      array.elementCount++;\n    }\n\n    return array.elementCount;\n  }\n\n  ChunkedArray.addRepeat = addRepeat;\n\n  function addMany(array, data) {\n    var elementSize = array.elementSize;\n\n    for (var i = 0, _i = data.length; i < _i; i += elementSize) {\n      if (array.currentIndex >= array.currentSize) allocateNext(array);\n      var currentChunk = array.currentChunk;\n\n      for (var j = 0; j < elementSize; j++) {\n        currentChunk[array.currentIndex++] = data[i + j];\n      }\n\n      array.elementCount++;\n    }\n\n    return array.elementCount;\n  }\n\n  ChunkedArray.addMany = addMany;\n  /** If doNotResizeSingleton = true and the data fit into a single chunk, do not resize it. */\n\n  function compact(array, doNotResizeSingleton) {\n    if (doNotResizeSingleton === void 0) {\n      doNotResizeSingleton = false;\n    }\n\n    return _compact(array, doNotResizeSingleton);\n  }\n\n  ChunkedArray.compact = compact;\n\n  function _compact(array, doNotResizeSingleton) {\n    var ctor = array.ctor,\n        chunks = array.chunks,\n        currentIndex = array.currentIndex;\n    if (!chunks.length) return new ctor(0);\n\n    if (chunks.length === 1) {\n      if (doNotResizeSingleton || currentIndex === array.allocatedSize) {\n        return chunks[0];\n      }\n    }\n\n    var size = 0;\n\n    for (var i = 0, _i = chunks.length - 1; i < _i; i++) size += chunks[i].length;\n\n    size += array.currentIndex;\n    var ret = new ctor(size);\n    var offset = 0;\n\n    if (ret.buffer) {\n      for (var i = 0, _i = chunks.length - 1; i < _i; i++) {\n        ret.set(chunks[i], offset);\n        offset += chunks[i].length;\n      }\n    } else {\n      for (var i = 0, _i = chunks.length - 1; i < _i; i++) {\n        var chunk = chunks[i];\n\n        for (var j = 0, _j = chunk.length; j < _j; j++) ret[offset + j] = chunk[j];\n\n        offset += chunk.length;\n      }\n    }\n\n    var lastChunk = chunks[chunks.length - 1];\n\n    if (ret.buffer && currentIndex >= array.currentSize) {\n      ret.set(lastChunk, offset);\n    } else {\n      for (var j = 0, _j = lastChunk.length; j < _j; j++) ret[offset + j] = lastChunk[j];\n    }\n\n    return ret;\n  }\n\n  ChunkedArray._compact = _compact;\n  /**\r\n   * The size of the initial chunk is elementSize * initialCount.\r\n   * Use the provided array as the initial chunk. The size of the array must be divisible by the elementSize.\r\n   */\n\n  function create(ctor, elementSize, chunkSize, initialChunkOrCount) {\n    var ret = {\n      ctor: ctor,\n      elementSize: elementSize,\n      growBy: Math.max(1, Math.ceil(chunkSize)),\n      allocatedSize: 0,\n      elementCount: 0,\n      currentSize: 0,\n      currentChunk: void 0,\n      currentIndex: 0,\n      chunks: []\n    };\n    if (typeof initialChunkOrCount === 'undefined') return ret;\n\n    if (typeof initialChunkOrCount === 'number') {\n      ret.currentChunk = new ctor(initialChunkOrCount * elementSize);\n      ret.allocatedSize = initialChunkOrCount * elementSize;\n      ret.currentSize = ret.currentChunk.length;\n      ret.chunks[0] = ret.currentChunk;\n      return ret;\n    }\n\n    var initialChunk = initialChunkOrCount;\n    if (initialChunk.length % elementSize !== 0) throw new Error('initialChunk length must be a multiple of the element size.');\n    ret.currentChunk = initialChunk;\n    ret.allocatedSize = initialChunk.length;\n    ret.currentSize = initialChunk.length;\n    ret.chunks[0] = initialChunk;\n    return ret;\n  }\n\n  ChunkedArray.create = create;\n})(ChunkedArray || (ChunkedArray = {}));\n\nexport { ChunkedArray };","map":{"version":3,"sources":["../../../src/mol-data/util/chunked-array.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;AAyBH,IAAU,YAAV;;AAAA,CAAA,UAAU,YAAV,EAAsB;AAGlB,WAAgB,EAAhB,CAAmB,CAAnB,EAAyB;AACrB,WAAO,CAAC,CAAC,OAAF,IAAa,CAAC,CAAC,SAAtB;AACH;;AAFe,EAAA,YAAA,CAAA,EAAA,GAAE,EAAF;;AAIhB,WAAS,YAAT,CAAsB,KAAtB,EAAmD;AAC/C,QAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,GAAe,KAAK,CAAC,WAAtC;AACA,IAAA,KAAK,CAAC,WAAN,GAAoB,QAApB;AACA,IAAA,KAAK,CAAC,YAAN,GAAqB,CAArB;AACA,IAAA,KAAK,CAAC,YAAN,GAAqB,IAAI,KAAK,CAAC,IAAV,CAAe,QAAf,CAArB;AACA,IAAA,KAAK,CAAC,aAAN,IAAuB,QAAvB;AACA,IAAA,KAAK,CAAC,MAAN,CAAa,KAAK,CAAC,MAAN,CAAa,MAA1B,IAAoC,KAAK,CAAC,YAA1C;AACH;;AAED,WAAgB,IAAhB,CAAwB,KAAxB,EAAmD,CAAnD,EAAyD,CAAzD,EAA+D,CAA/D,EAAqE,CAArE,EAAyE;AACrE,QAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AAC7C,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;AACA,WAAO,KAAK,CAAC,YAAN,EAAP;AACH;;AAVe,EAAA,YAAA,CAAA,IAAA,GAAI,IAAJ;;AAYhB,WAAgB,IAAhB,CAAwB,KAAxB,EAAmD,CAAnD,EAAyD,CAAzD,EAA+D,CAA/D,EAAmE;AAC/D,QAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AAC7C,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;AACA,WAAO,KAAK,CAAC,YAAN,EAAP;AACH;;AATe,EAAA,YAAA,CAAA,IAAA,GAAI,IAAJ;;AAWhB,WAAgB,IAAhB,CAAwB,KAAxB,EAAmD,CAAnD,EAAyD,CAAzD,EAA6D;AACzD,QAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AAC7C,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,YAAhB;AACA,IAAA,CAAC,CAAC,CAAD,CAAD,GAAO,CAAP;AACA,IAAA,CAAC,CAAC,CAAC,GAAG,CAAL,CAAD,GAAW,CAAX;AACA,IAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;AACA,WAAO,KAAK,CAAC,YAAN,EAAP;AACH;;AARe,EAAA,YAAA,CAAA,IAAA,GAAI,IAAJ;;AAUhB,WAAgB,GAAhB,CAAuB,KAAvB,EAAkD,CAAlD,EAAsD;AAClD,QAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AAC7C,IAAA,KAAK,CAAC,YAAN,CAAmB,KAAK,CAAC,YAAzB,IAAyC,CAAzC;AACA,IAAA,KAAK,CAAC,YAAN,IAAsB,CAAtB;AACA,WAAO,KAAK,CAAC,YAAN,EAAP;AACH;;AALe,EAAA,YAAA,CAAA,GAAA,GAAG,GAAH;;AAOhB,WAAgB,SAAhB,CAA6B,KAA7B,EAAwD,CAAxD,EAAmE,CAAnE,EAAuE;AACnE,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAApB,EAAuB,CAAC,EAAxB,EAA4B;AACxB,UAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AAC7C,MAAA,KAAK,CAAC,YAAN,CAAmB,KAAK,CAAC,YAAN,EAAnB,IAA2C,CAA3C;AACA,MAAA,KAAK,CAAC,YAAN;AACH;;AACD,WAAO,KAAK,CAAC,YAAb;AACH;;AAPe,EAAA,YAAA,CAAA,SAAA,GAAS,SAAT;;AAShB,WAAgB,OAAhB,CAA2B,KAA3B,EAAwD,IAAxD,EAA0E;AAC9D,QAAA,WAAW,GAAK,KAAK,CAAV,WAAX;;AACR,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,IAAI,CAAC,MAA1B,EAAkC,CAAC,GAAG,EAAtC,EAA0C,CAAC,IAAI,WAA/C,EAA4D;AACxD,UAAI,KAAK,CAAC,YAAN,IAAsB,KAAK,CAAC,WAAhC,EAA6C,YAAY,CAAC,KAAD,CAAZ;AACrC,UAAA,YAAY,GAAK,KAAK,CAAV,YAAZ;;AACR,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAApB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,QAAA,YAAY,CAAC,KAAK,CAAC,YAAN,EAAD,CAAZ,GAAqC,IAAI,CAAC,CAAC,GAAG,CAAL,CAAzC;AACH;;AACD,MAAA,KAAK,CAAC,YAAN;AACH;;AACD,WAAO,KAAK,CAAC,YAAb;AACH;;AAXe,EAAA,YAAA,CAAA,OAAA,GAAO,OAAP;AAahB;;AACA,WAAgB,OAAhB,CAA2B,KAA3B,EAAwD,oBAAxD,EAAoF;AAA5B,QAAA,oBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,oBAAA,GAAA,KAAA;AAA4B;;AAChF,WAAO,QAAQ,CAAC,KAAD,EAAQ,oBAAR,CAAf;AACH;;AAFe,EAAA,YAAA,CAAA,OAAA,GAAO,OAAP;;AAIhB,WAAgB,QAAhB,CAA4B,KAA5B,EAAyD,oBAAzD,EAAsF;AAC1E,QAAA,IAAI,GAA2B,KAAK,CAAhC,IAAJ;AAAA,QAAM,MAAM,GAAmB,KAAK,CAAxB,MAAZ;AAAA,QAAc,YAAY,GAAK,KAAK,CAAV,YAA1B;AAER,QAAI,CAAC,MAAM,CAAC,MAAZ,EAAoB,OAAO,IAAI,IAAJ,CAAS,CAAT,CAAP;;AACpB,QAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACrB,UAAI,oBAAoB,IAAI,YAAY,KAAK,KAAK,CAAC,aAAnD,EAAkE;AAC9D,eAAO,MAAM,CAAC,CAAD,CAAb;AACH;AACJ;;AAED,QAAI,IAAI,GAAG,CAAX;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAAP,GAAgB,CAArC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,CAAC,EAAjD,EAAqD,IAAI,IAAI,MAAM,CAAC,CAAD,CAAN,CAAU,MAAlB;;AACrD,IAAA,IAAI,IAAI,KAAK,CAAC,YAAd;AAEA,QAAM,GAAG,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAZ;AACA,QAAI,MAAM,GAAG,CAAb;;AAEA,QAAI,GAAG,CAAC,MAAR,EAAgB;AACZ,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAAP,GAAgB,CAArC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,CAAC,EAAjD,EAAqD;AACjD,QAAA,GAAG,CAAC,GAAJ,CAAQ,MAAM,CAAC,CAAD,CAAd,EAAmB,MAAnB;AACA,QAAA,MAAM,IAAI,MAAM,CAAC,CAAD,CAAN,CAAU,MAApB;AACH;AACJ,KALD,MAKO;AACH,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAAP,GAAgB,CAArC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,CAAC,EAAjD,EAAqD;AACjD,YAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD,GAAG,CAAC,MAAM,GAAG,CAAV,CAAH,GAAkB,KAAK,CAAC,CAAD,CAAvB;;AAChD,QAAA,MAAM,IAAI,KAAK,CAAC,MAAhB;AACH;AACJ;;AAED,QAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,MAAP,GAAgB,CAAjB,CAAxB;;AACA,QAAI,GAAG,CAAC,MAAJ,IAAc,YAAY,IAAI,KAAK,CAAC,WAAxC,EAAqD;AACjD,MAAA,GAAG,CAAC,GAAJ,CAAQ,SAAR,EAAmB,MAAnB;AACH,KAFD,MAEO;AACH,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,SAAS,CAAC,MAA/B,EAAuC,CAAC,GAAG,EAA3C,EAA+C,CAAC,EAAhD,EAAoD,GAAG,CAAC,MAAM,GAAG,CAAV,CAAH,GAAkB,SAAS,CAAC,CAAD,CAA3B;AACvD;;AAED,WAAO,GAAP;AACH;;AAtCe,EAAA,YAAA,CAAA,QAAA,GAAQ,QAAR;AAwChB;;;AAGG;;AACH,WAAgB,MAAhB,CAA+C,IAA/C,EAA2F,WAA3F,EAA2G,SAA3G,EAA8H,mBAA9H,EAAyK;AACrK,QAAM,GAAG,GAAuB;AAC5B,MAAA,IAAI,EAAA,IADwB;AAE5B,MAAA,WAAW,EAAA,WAFiB;AAI5B,MAAA,MAAM,EAAE,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,IAAL,CAAU,SAAV,CAAZ,CAJoB;AAK5B,MAAA,aAAa,EAAE,CALa;AAM5B,MAAA,YAAY,EAAE,CANc;AAQ5B,MAAA,WAAW,EAAE,CARe;AAS5B,MAAA,YAAY,EAAE,KAAK,CATS;AAU5B,MAAA,YAAY,EAAE,CAVc;AAY5B,MAAA,MAAM,EAAE;AAZoB,KAAhC;AAeA,QAAI,OAAO,mBAAP,KAA+B,WAAnC,EAAgD,OAAO,GAAP;;AAEhD,QAAI,OAAO,mBAAP,KAA+B,QAAnC,EAA6C;AACzC,MAAA,GAAG,CAAC,YAAJ,GAAmB,IAAI,IAAJ,CAAS,mBAAmB,GAAG,WAA/B,CAAnB;AACA,MAAA,GAAG,CAAC,aAAJ,GAAoB,mBAAmB,GAAG,WAA1C;AACA,MAAA,GAAG,CAAC,WAAJ,GAAkB,GAAG,CAAC,YAAJ,CAAiB,MAAnC;AACA,MAAA,GAAG,CAAC,MAAJ,CAAW,CAAX,IAAgB,GAAG,CAAC,YAApB;AACA,aAAO,GAAP;AACH;;AAED,QAAM,YAAY,GAAG,mBAArB;AACA,QAAI,YAAY,CAAC,MAAb,GAAsB,WAAtB,KAAsC,CAA1C,EAA6C,MAAM,IAAI,KAAJ,CAAU,6DAAV,CAAN;AAC7C,IAAA,GAAG,CAAC,YAAJ,GAAmB,YAAnB;AACA,IAAA,GAAG,CAAC,aAAJ,GAAoB,YAAY,CAAC,MAAjC;AACA,IAAA,GAAG,CAAC,WAAJ,GAAkB,YAAY,CAAC,MAA/B;AACA,IAAA,GAAG,CAAC,MAAJ,CAAW,CAAX,IAAgB,YAAhB;AAEA,WAAO,GAAP;AACH;;AAlCe,EAAA,YAAA,CAAA,MAAA,GAAM,MAAN;AAmCnB,CAlKD,EAAU,YAAY,KAAZ,YAAY,GAAA,EAAA,CAAtB;;AAoKA,SAAS,YAAT","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * from https://github.com/dsehnal/CIFTools.js\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nvar ChunkedArray;\r\n(function (ChunkedArray) {\r\n    function is(x) {\r\n        return x.creator && x.chunkSize;\r\n    }\r\n    ChunkedArray.is = is;\r\n    function allocateNext(array) {\r\n        var nextSize = array.growBy * array.elementSize;\r\n        array.currentSize = nextSize;\r\n        array.currentIndex = 0;\r\n        array.currentChunk = new array.ctor(nextSize);\r\n        array.allocatedSize += nextSize;\r\n        array.chunks[array.chunks.length] = array.currentChunk;\r\n    }\r\n    function add4(array, x, y, z, w) {\r\n        if (array.currentIndex >= array.currentSize)\r\n            allocateNext(array);\r\n        var c = array.currentChunk;\r\n        var i = array.currentIndex;\r\n        c[i] = x;\r\n        c[i + 1] = y;\r\n        c[i + 2] = z;\r\n        c[i + 3] = w;\r\n        array.currentIndex += 4;\r\n        return array.elementCount++;\r\n    }\r\n    ChunkedArray.add4 = add4;\r\n    function add3(array, x, y, z) {\r\n        if (array.currentIndex >= array.currentSize)\r\n            allocateNext(array);\r\n        var c = array.currentChunk;\r\n        var i = array.currentIndex;\r\n        c[i] = x;\r\n        c[i + 1] = y;\r\n        c[i + 2] = z;\r\n        array.currentIndex += 3;\r\n        return array.elementCount++;\r\n    }\r\n    ChunkedArray.add3 = add3;\r\n    function add2(array, x, y) {\r\n        if (array.currentIndex >= array.currentSize)\r\n            allocateNext(array);\r\n        var c = array.currentChunk;\r\n        var i = array.currentIndex;\r\n        c[i] = x;\r\n        c[i + 1] = y;\r\n        array.currentIndex += 2;\r\n        return array.elementCount++;\r\n    }\r\n    ChunkedArray.add2 = add2;\r\n    function add(array, x) {\r\n        if (array.currentIndex >= array.currentSize)\r\n            allocateNext(array);\r\n        array.currentChunk[array.currentIndex] = x;\r\n        array.currentIndex += 1;\r\n        return array.elementCount++;\r\n    }\r\n    ChunkedArray.add = add;\r\n    function addRepeat(array, n, x) {\r\n        for (var i = 0; i < n; i++) {\r\n            if (array.currentIndex >= array.currentSize)\r\n                allocateNext(array);\r\n            array.currentChunk[array.currentIndex++] = x;\r\n            array.elementCount++;\r\n        }\r\n        return array.elementCount;\r\n    }\r\n    ChunkedArray.addRepeat = addRepeat;\r\n    function addMany(array, data) {\r\n        var elementSize = array.elementSize;\r\n        for (var i = 0, _i = data.length; i < _i; i += elementSize) {\r\n            if (array.currentIndex >= array.currentSize)\r\n                allocateNext(array);\r\n            var currentChunk = array.currentChunk;\r\n            for (var j = 0; j < elementSize; j++) {\r\n                currentChunk[array.currentIndex++] = data[i + j];\r\n            }\r\n            array.elementCount++;\r\n        }\r\n        return array.elementCount;\r\n    }\r\n    ChunkedArray.addMany = addMany;\r\n    /** If doNotResizeSingleton = true and the data fit into a single chunk, do not resize it. */\r\n    function compact(array, doNotResizeSingleton) {\r\n        if (doNotResizeSingleton === void 0) { doNotResizeSingleton = false; }\r\n        return _compact(array, doNotResizeSingleton);\r\n    }\r\n    ChunkedArray.compact = compact;\r\n    function _compact(array, doNotResizeSingleton) {\r\n        var ctor = array.ctor, chunks = array.chunks, currentIndex = array.currentIndex;\r\n        if (!chunks.length)\r\n            return new ctor(0);\r\n        if (chunks.length === 1) {\r\n            if (doNotResizeSingleton || currentIndex === array.allocatedSize) {\r\n                return chunks[0];\r\n            }\r\n        }\r\n        var size = 0;\r\n        for (var i = 0, _i = chunks.length - 1; i < _i; i++)\r\n            size += chunks[i].length;\r\n        size += array.currentIndex;\r\n        var ret = new ctor(size);\r\n        var offset = 0;\r\n        if (ret.buffer) {\r\n            for (var i = 0, _i = chunks.length - 1; i < _i; i++) {\r\n                ret.set(chunks[i], offset);\r\n                offset += chunks[i].length;\r\n            }\r\n        }\r\n        else {\r\n            for (var i = 0, _i = chunks.length - 1; i < _i; i++) {\r\n                var chunk = chunks[i];\r\n                for (var j = 0, _j = chunk.length; j < _j; j++)\r\n                    ret[offset + j] = chunk[j];\r\n                offset += chunk.length;\r\n            }\r\n        }\r\n        var lastChunk = chunks[chunks.length - 1];\r\n        if (ret.buffer && currentIndex >= array.currentSize) {\r\n            ret.set(lastChunk, offset);\r\n        }\r\n        else {\r\n            for (var j = 0, _j = lastChunk.length; j < _j; j++)\r\n                ret[offset + j] = lastChunk[j];\r\n        }\r\n        return ret;\r\n    }\r\n    ChunkedArray._compact = _compact;\r\n    /**\r\n     * The size of the initial chunk is elementSize * initialCount.\r\n     * Use the provided array as the initial chunk. The size of the array must be divisible by the elementSize.\r\n     */\r\n    function create(ctor, elementSize, chunkSize, initialChunkOrCount) {\r\n        var ret = {\r\n            ctor: ctor,\r\n            elementSize: elementSize,\r\n            growBy: Math.max(1, Math.ceil(chunkSize)),\r\n            allocatedSize: 0,\r\n            elementCount: 0,\r\n            currentSize: 0,\r\n            currentChunk: void 0,\r\n            currentIndex: 0,\r\n            chunks: []\r\n        };\r\n        if (typeof initialChunkOrCount === 'undefined')\r\n            return ret;\r\n        if (typeof initialChunkOrCount === 'number') {\r\n            ret.currentChunk = new ctor(initialChunkOrCount * elementSize);\r\n            ret.allocatedSize = initialChunkOrCount * elementSize;\r\n            ret.currentSize = ret.currentChunk.length;\r\n            ret.chunks[0] = ret.currentChunk;\r\n            return ret;\r\n        }\r\n        var initialChunk = initialChunkOrCount;\r\n        if (initialChunk.length % elementSize !== 0)\r\n            throw new Error('initialChunk length must be a multiple of the element size.');\r\n        ret.currentChunk = initialChunk;\r\n        ret.allocatedSize = initialChunk.length;\r\n        ret.currentSize = initialChunk.length;\r\n        ret.chunks[0] = initialChunk;\r\n        return ret;\r\n    }\r\n    ChunkedArray.create = create;\r\n})(ChunkedArray || (ChunkedArray = {}));\r\nexport { ChunkedArray };\r\n//# sourceMappingURL=chunked-array.js.map"]},"metadata":{},"sourceType":"module"}