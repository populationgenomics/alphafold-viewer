{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { SortedArray } from '../../../mol-data/int';\nimport { EquivalenceClasses } from '../../../mol-data/util';\nimport { Spacegroup, SpacegroupCell, SymmetryOperator } from '../../../mol-math/geometry';\nimport { Vec3, Mat4 } from '../../../mol-math/linear-algebra';\nimport { Task } from '../../../mol-task';\nimport { Symmetry, Model } from '../model';\nimport { QueryContext, StructureSelection, Queries as Q } from '../query';\nimport { Structure } from './structure';\nimport { Unit } from './unit';\nimport { ModelSymmetry } from '../../../mol-model-formats/structure/property/symmetry';\nimport { StructureProperties } from './properties';\nvar StructureSymmetry;\n\n(function (StructureSymmetry) {\n  function buildAssembly(structure, asmName) {\n    var _this = this;\n\n    return Task.create('Build Assembly', function (ctx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var models, assembly, coordinateSystem, assembler, queryCtx, _i, _a, g, selection, units, _b, _c, oper, _d, units_1, unit;\n\n        return __generator(this, function (_e) {\n          models = structure.models;\n          if (models.length !== 1) throw new Error('Can only build assemblies from structures based on 1 model.');\n          assembly = Symmetry.findAssembly(models[0], asmName);\n          if (!assembly) throw new Error(\"Assembly '\" + asmName + \"' is not defined.\");\n          coordinateSystem = SymmetryOperator.create(assembly.id, Mat4.identity(), {\n            assembly: {\n              id: assembly.id,\n              operId: 0,\n              operList: []\n            }\n          });\n          assembler = Structure.Builder({\n            coordinateSystem: coordinateSystem,\n            label: structure.label,\n            dynamicBonds: structure.dynamicBonds\n          });\n          queryCtx = new QueryContext(structure);\n\n          for (_i = 0, _a = assembly.operatorGroups; _i < _a.length; _i++) {\n            g = _a[_i];\n            selection = g.selector(queryCtx);\n\n            if (StructureSelection.structureCount(selection) === 0) {\n              continue;\n            }\n\n            units = StructureSelection.unionStructure(selection).units;\n\n            for (_b = 0, _c = g.operators; _b < _c.length; _b++) {\n              oper = _c[_b];\n\n              for (_d = 0, units_1 = units; _d < units_1.length; _d++) {\n                unit = units_1[_d];\n                assembler.addWithOperator(unit, oper);\n              }\n            }\n          }\n\n          return [2\n          /*return*/\n          , assembler.getStructure()];\n        });\n      });\n    });\n  }\n\n  StructureSymmetry.buildAssembly = buildAssembly;\n\n  function buildSymmetryAssembly(structure, generators, symmetry) {\n    var _this = this;\n\n    return Task.create('Build Symmetry Assembly', function (ctx) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var models, modelCenter, assembler, queryCtx, _i, generators_1, g, selector, selection, units, _a, _b, _c, index, _d, i, j, k, operators, _e, units_2, unit, _f, operators_1, op;\n\n        return __generator(this, function (_g) {\n          models = structure.models;\n          if (models.length !== 1) throw new Error('Can only build symmetry assemblies from structures based on 1 model.');\n          modelCenter = Vec3();\n          assembler = Structure.Builder({\n            label: structure.label,\n            representativeModel: models[0],\n            dynamicBonds: structure.dynamicBonds\n          });\n          queryCtx = new QueryContext(structure);\n\n          for (_i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\n            g = generators_1[_i];\n            selector = getSelector(g.asymIds);\n            selection = selector(queryCtx);\n\n            if (StructureSelection.structureCount(selection) === 0) {\n              continue;\n            }\n\n            units = StructureSelection.unionStructure(selection).units;\n\n            for (_a = 0, _b = g.operators; _a < _b.length; _a++) {\n              _c = _b[_a], index = _c.index, _d = _c.shift, i = _d[0], j = _d[1], k = _d[2];\n              operators = getOperatorsForIndex(symmetry, index, i, j, k, modelCenter);\n\n              for (_e = 0, units_2 = units; _e < units_2.length; _e++) {\n                unit = units_2[_e];\n\n                for (_f = 0, operators_1 = operators; _f < operators_1.length; _f++) {\n                  op = operators_1[_f];\n                  assembler.addWithOperator(unit, op);\n                }\n              }\n            }\n          }\n\n          return [2\n          /*return*/\n          , assembler.getStructure()];\n        });\n      });\n    });\n  }\n\n  StructureSymmetry.buildSymmetryAssembly = buildSymmetryAssembly;\n\n  function builderSymmetryMates(structure, radius) {\n    return Task.create('Find Symmetry Mates', function (ctx) {\n      return findMatesRadius(ctx, structure, radius);\n    });\n  }\n\n  StructureSymmetry.builderSymmetryMates = builderSymmetryMates;\n\n  function buildSymmetryRange(structure, ijkMin, ijkMax) {\n    return Task.create('Build Symmetry', function (ctx) {\n      return findSymmetryRange(ctx, structure, ijkMin, ijkMax);\n    });\n  }\n\n  StructureSymmetry.buildSymmetryRange = buildSymmetryRange;\n  /** Builds NCS structure, returns the original if NCS operators are not present. */\n\n  function buildNcs(structure) {\n    return Task.create('Build NCS', function (ctx) {\n      return _buildNCS(ctx, structure);\n    });\n  }\n\n  StructureSymmetry.buildNcs = buildNcs;\n\n  function areUnitsEquivalent(a, b) {\n    return a.invariantId === b.invariantId && a.model.id === b.model.id && SortedArray.areEqual(a.elements, b.elements);\n  }\n\n  StructureSymmetry.areUnitsEquivalent = areUnitsEquivalent;\n\n  function UnitEquivalenceBuilder() {\n    return EquivalenceClasses(Unit.hashUnit, areUnitsEquivalent);\n  }\n\n  StructureSymmetry.UnitEquivalenceBuilder = UnitEquivalenceBuilder;\n\n  function computeTransformGroups(s) {\n    var groups = UnitEquivalenceBuilder();\n\n    for (var _i = 0, _a = s.units; _i < _a.length; _i++) {\n      var u = _a[_i];\n      groups.add(u.id, u);\n    }\n\n    var ret = [];\n\n    for (var _b = 0, _c = groups.groups; _b < _c.length; _b++) {\n      var eqUnits = _c[_b];\n      ret.push(Unit.SymmetryGroup(eqUnits.map(function (id) {\n        return s.unitMap.get(id);\n      })));\n    }\n\n    return ret;\n  }\n\n  StructureSymmetry.computeTransformGroups = computeTransformGroups;\n  /** Checks if transform groups are equal up to their unit's transformations */\n\n  function areTransformGroupsEquivalent(a, b) {\n    if (a.length !== b.length) return false;\n\n    for (var i = 0, il = a.length; i < il; ++i) {\n      var au = a[i].units,\n          bu = b[i].units;\n      if (au.length !== bu.length) return false;\n      if (a[i].hashCode !== b[i].hashCode) return false;\n\n      for (var j = 0, _j = au.length; j < _j; j++) {\n        if (au[j].conformation !== bu[j].conformation) return false;\n      }\n    }\n\n    return true;\n  }\n\n  StructureSymmetry.areTransformGroupsEquivalent = areTransformGroupsEquivalent;\n})(StructureSymmetry || (StructureSymmetry = {}));\n\nfunction getSelector(asymIds) {\n  return Q.generators.atoms({\n    chainTest: Q.pred.and(Q.pred.eq(function (ctx) {\n      return StructureProperties.unit.operator_name(ctx.element);\n    }, SymmetryOperator.DefaultName), Q.pred.inSet(function (ctx) {\n      return StructureProperties.chain.label_asym_id(ctx.element);\n    }, asymIds))\n  });\n}\n\nfunction getOperatorsForIndex(symmetry, index, i, j, k, modelCenter) {\n  var spacegroup = symmetry.spacegroup,\n      ncsOperators = symmetry.ncsOperators;\n  var operators = [];\n  var toFractional = spacegroup.cell.toFractional;\n  var ref = Vec3.transformMat4(Vec3(), modelCenter, toFractional);\n  var symOp = Spacegroup.getSymmetryOperatorRef(spacegroup, index, i, j, k, ref);\n\n  if (ncsOperators && ncsOperators.length) {\n    for (var u = 0, ul = ncsOperators.length; u < ul; ++u) {\n      var ncsOp = ncsOperators[u];\n      var matrix = Mat4.mul(Mat4(), symOp.matrix, ncsOp.matrix);\n      var operator = SymmetryOperator.create(symOp.name + \" \" + ncsOp.name, matrix, {\n        assembly: symOp.assembly,\n        ncsId: ncsOp.ncsId,\n        hkl: symOp.hkl,\n        spgrOp: symOp.spgrOp\n      });\n      operators.push(operator);\n    }\n  } else {\n    operators.push(symOp);\n  }\n\n  return operators;\n}\n\nfunction getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter) {\n  var spacegroup = symmetry.spacegroup,\n      ncsOperators = symmetry.ncsOperators;\n  var ncsCount = ncsOperators && ncsOperators.length || 0;\n  var operators = [];\n\n  if (!ncsCount && ijkMin[0] <= 0 && ijkMax[0] >= 0 && ijkMin[1] <= 0 && ijkMax[1] >= 0 && ijkMin[2] <= 0 && ijkMax[2] >= 0) {\n    operators[0] = Spacegroup.getSymmetryOperator(spacegroup, 0, 0, 0, 0);\n  }\n\n  var toFractional = spacegroup.cell.toFractional;\n  var ref = Vec3.transformMat4(Vec3(), modelCenter, toFractional);\n\n  for (var op = 0; op < spacegroup.operators.length; op++) {\n    for (var i = ijkMin[0]; i <= ijkMax[0]; i++) {\n      for (var j = ijkMin[1]; j <= ijkMax[1]; j++) {\n        for (var k = ijkMin[2]; k <= ijkMax[2]; k++) {\n          // check if we have added identity as the 1st operator.\n          if (!ncsCount && op === 0 && i === 0 && j === 0 && k === 0) continue;\n          operators.push.apply(operators, getOperatorsForIndex(symmetry, op, i, j, k, ref));\n        }\n      }\n    }\n  }\n\n  return operators;\n}\n\nfunction getOperatorsCached333(symmetry, ref) {\n  if (symmetry._operators_333 && Vec3.equals(ref, symmetry._operators_333.ref)) {\n    return symmetry._operators_333.operators;\n  }\n\n  symmetry._operators_333 = {\n    ref: Vec3.clone(ref),\n    operators: getOperatorsForRange(symmetry, Vec3.create(-3, -3, -3), Vec3.create(3, 3, 3), ref)\n  };\n  return symmetry._operators_333.operators;\n}\n\nfunction assembleOperators(structure, operators) {\n  var assembler = Structure.Builder({\n    label: structure.label,\n    dynamicBonds: structure.dynamicBonds\n  });\n  var units = structure.units;\n\n  for (var _i = 0, operators_2 = operators; _i < operators_2.length; _i++) {\n    var oper = operators_2[_i];\n\n    for (var _a = 0, units_3 = units; _a < units_3.length; _a++) {\n      var unit = units_3[_a];\n      assembler.addWithOperator(unit, oper);\n    }\n  }\n\n  return assembler.getStructure();\n}\n\nfunction _buildNCS(ctx, structure) {\n  return __awaiter(this, void 0, void 0, function () {\n    var models, symmetry, operators;\n    return __generator(this, function (_a) {\n      models = structure.models;\n      if (models.length !== 1) throw new Error('Can only build NCS from structures based on 1 model.');\n      symmetry = ModelSymmetry.Provider.get(models[0]);\n      if (!symmetry) return [2\n      /*return*/\n      , structure];\n      operators = symmetry.ncsOperators;\n      if (!operators || !operators.length) return [2\n      /*return*/\n      , structure];\n      return [2\n      /*return*/\n      , assembleOperators(structure, operators)];\n    });\n  });\n}\n\nfunction findSymmetryRange(ctx, structure, ijkMin, ijkMax) {\n  return __awaiter(this, void 0, void 0, function () {\n    var models, symmetry, spacegroup, modelCenter, operators;\n    return __generator(this, function (_a) {\n      models = structure.models;\n      if (models.length !== 1) throw new Error('Can only build symmetries from structures based on 1 model.');\n      symmetry = ModelSymmetry.Provider.get(models[0]);\n      if (!symmetry) return [2\n      /*return*/\n      , structure];\n      spacegroup = symmetry.spacegroup;\n      if (SpacegroupCell.isZero(spacegroup.cell)) return [2\n      /*return*/\n      , structure];\n      modelCenter = Model.getCenter(models[0]);\n      operators = getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter);\n      return [2\n      /*return*/\n      , assembleOperators(structure, operators)];\n    });\n  });\n}\n\nfunction findMatesRadius(ctx, structure, radius) {\n  return __awaiter(this, void 0, void 0, function () {\n    function hash(unit, oper) {\n      return unit.invariantId + \"|\" + oper.name;\n    }\n\n    var models, symmetry, spacegroup, modelCenter, operators, lookup, added, assembler, units, center, _i, operators_3, oper, _a, units_4, unit, boundingSphere, closeUnits, uI, _uI, closeUnit, h;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          models = structure.models;\n          if (models.length !== 1) throw new Error('Can only build symmetries from structures based on 1 model.');\n          symmetry = ModelSymmetry.Provider.get(models[0]);\n          if (!symmetry) return [2\n          /*return*/\n          , structure];\n          spacegroup = symmetry.spacegroup;\n          if (SpacegroupCell.isZero(spacegroup.cell)) return [2\n          /*return*/\n          , structure];\n          if (!ctx.shouldUpdate) return [3\n          /*break*/\n          , 2];\n          return [4\n          /*yield*/\n          , ctx.update('Initialing...')];\n\n        case 1:\n          _b.sent();\n\n          _b.label = 2;\n\n        case 2:\n          modelCenter = Model.getCenter(models[0]);\n          operators = getOperatorsCached333(symmetry, modelCenter);\n          lookup = structure.lookup3d;\n          added = new Set();\n          assembler = Structure.Builder({\n            label: structure.label,\n            dynamicBonds: structure.dynamicBonds\n          });\n          units = structure.units;\n          center = Vec3.zero();\n          _i = 0, operators_3 = operators;\n          _b.label = 3;\n\n        case 3:\n          if (!(_i < operators_3.length)) return [3\n          /*break*/\n          , 6];\n          oper = operators_3[_i];\n\n          for (_a = 0, units_4 = units; _a < units_4.length; _a++) {\n            unit = units_4[_a];\n            boundingSphere = unit.lookup3d.boundary.sphere;\n            Vec3.transformMat4(center, boundingSphere.center, oper.matrix);\n            closeUnits = lookup.findUnitIndices(center[0], center[1], center[2], boundingSphere.radius + radius);\n\n            for (uI = 0, _uI = closeUnits.count; uI < _uI; uI++) {\n              closeUnit = units[closeUnits.indices[uI]];\n              if (!closeUnit.lookup3d.check(center[0], center[1], center[2], boundingSphere.radius + radius)) continue;\n              h = hash(unit, oper);\n\n              if (!added.has(h)) {\n                assembler.addWithOperator(unit, oper);\n                added.add(h);\n              }\n            }\n          }\n\n          if (!ctx.shouldUpdate) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , ctx.update('Building symmetry...')];\n\n        case 4:\n          _b.sent();\n\n          _b.label = 5;\n\n        case 5:\n          _i++;\n          return [3\n          /*break*/\n          , 3];\n\n        case 6:\n          return [2\n          /*return*/\n          , assembler.getStructure()];\n      }\n    });\n  });\n}\n\nexport { StructureSymmetry };","map":{"version":3,"sources":["../../../../src/mol-model/structure/structure/symmetry.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { SortedArray } from '../../../mol-data/int';\r\nimport { EquivalenceClasses } from '../../../mol-data/util';\r\nimport { Spacegroup, SpacegroupCell, SymmetryOperator } from '../../../mol-math/geometry';\r\nimport { Vec3, Mat4 } from '../../../mol-math/linear-algebra';\r\nimport { Task } from '../../../mol-task';\r\nimport { Symmetry, Model } from '../model';\r\nimport { QueryContext, StructureSelection, Queries as Q } from '../query';\r\nimport { Structure } from './structure';\r\nimport { Unit } from './unit';\r\nimport { ModelSymmetry } from '../../../mol-model-formats/structure/property/symmetry';\r\nimport { StructureProperties } from './properties';\r\nvar StructureSymmetry;\r\n(function (StructureSymmetry) {\r\n    function buildAssembly(structure, asmName) {\r\n        var _this = this;\r\n        return Task.create('Build Assembly', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n            var models, assembly, coordinateSystem, assembler, queryCtx, _i, _a, g, selection, units, _b, _c, oper, _d, units_1, unit;\r\n            return __generator(this, function (_e) {\r\n                models = structure.models;\r\n                if (models.length !== 1)\r\n                    throw new Error('Can only build assemblies from structures based on 1 model.');\r\n                assembly = Symmetry.findAssembly(models[0], asmName);\r\n                if (!assembly)\r\n                    throw new Error(\"Assembly '\" + asmName + \"' is not defined.\");\r\n                coordinateSystem = SymmetryOperator.create(assembly.id, Mat4.identity(), { assembly: { id: assembly.id, operId: 0, operList: [] } });\r\n                assembler = Structure.Builder({\r\n                    coordinateSystem: coordinateSystem,\r\n                    label: structure.label,\r\n                    dynamicBonds: structure.dynamicBonds\r\n                });\r\n                queryCtx = new QueryContext(structure);\r\n                for (_i = 0, _a = assembly.operatorGroups; _i < _a.length; _i++) {\r\n                    g = _a[_i];\r\n                    selection = g.selector(queryCtx);\r\n                    if (StructureSelection.structureCount(selection) === 0) {\r\n                        continue;\r\n                    }\r\n                    units = StructureSelection.unionStructure(selection).units;\r\n                    for (_b = 0, _c = g.operators; _b < _c.length; _b++) {\r\n                        oper = _c[_b];\r\n                        for (_d = 0, units_1 = units; _d < units_1.length; _d++) {\r\n                            unit = units_1[_d];\r\n                            assembler.addWithOperator(unit, oper);\r\n                        }\r\n                    }\r\n                }\r\n                return [2 /*return*/, assembler.getStructure()];\r\n            });\r\n        }); });\r\n    }\r\n    StructureSymmetry.buildAssembly = buildAssembly;\r\n    function buildSymmetryAssembly(structure, generators, symmetry) {\r\n        var _this = this;\r\n        return Task.create('Build Symmetry Assembly', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n            var models, modelCenter, assembler, queryCtx, _i, generators_1, g, selector, selection, units, _a, _b, _c, index, _d, i, j, k, operators, _e, units_2, unit, _f, operators_1, op;\r\n            return __generator(this, function (_g) {\r\n                models = structure.models;\r\n                if (models.length !== 1)\r\n                    throw new Error('Can only build symmetry assemblies from structures based on 1 model.');\r\n                modelCenter = Vec3();\r\n                assembler = Structure.Builder({\r\n                    label: structure.label,\r\n                    representativeModel: models[0],\r\n                    dynamicBonds: structure.dynamicBonds\r\n                });\r\n                queryCtx = new QueryContext(structure);\r\n                for (_i = 0, generators_1 = generators; _i < generators_1.length; _i++) {\r\n                    g = generators_1[_i];\r\n                    selector = getSelector(g.asymIds);\r\n                    selection = selector(queryCtx);\r\n                    if (StructureSelection.structureCount(selection) === 0) {\r\n                        continue;\r\n                    }\r\n                    units = StructureSelection.unionStructure(selection).units;\r\n                    for (_a = 0, _b = g.operators; _a < _b.length; _a++) {\r\n                        _c = _b[_a], index = _c.index, _d = _c.shift, i = _d[0], j = _d[1], k = _d[2];\r\n                        operators = getOperatorsForIndex(symmetry, index, i, j, k, modelCenter);\r\n                        for (_e = 0, units_2 = units; _e < units_2.length; _e++) {\r\n                            unit = units_2[_e];\r\n                            for (_f = 0, operators_1 = operators; _f < operators_1.length; _f++) {\r\n                                op = operators_1[_f];\r\n                                assembler.addWithOperator(unit, op);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return [2 /*return*/, assembler.getStructure()];\r\n            });\r\n        }); });\r\n    }\r\n    StructureSymmetry.buildSymmetryAssembly = buildSymmetryAssembly;\r\n    function builderSymmetryMates(structure, radius) {\r\n        return Task.create('Find Symmetry Mates', function (ctx) { return findMatesRadius(ctx, structure, radius); });\r\n    }\r\n    StructureSymmetry.builderSymmetryMates = builderSymmetryMates;\r\n    function buildSymmetryRange(structure, ijkMin, ijkMax) {\r\n        return Task.create('Build Symmetry', function (ctx) { return findSymmetryRange(ctx, structure, ijkMin, ijkMax); });\r\n    }\r\n    StructureSymmetry.buildSymmetryRange = buildSymmetryRange;\r\n    /** Builds NCS structure, returns the original if NCS operators are not present. */\r\n    function buildNcs(structure) {\r\n        return Task.create('Build NCS', function (ctx) { return _buildNCS(ctx, structure); });\r\n    }\r\n    StructureSymmetry.buildNcs = buildNcs;\r\n    function areUnitsEquivalent(a, b) {\r\n        return a.invariantId === b.invariantId && a.model.id === b.model.id && SortedArray.areEqual(a.elements, b.elements);\r\n    }\r\n    StructureSymmetry.areUnitsEquivalent = areUnitsEquivalent;\r\n    function UnitEquivalenceBuilder() {\r\n        return EquivalenceClasses(Unit.hashUnit, areUnitsEquivalent);\r\n    }\r\n    StructureSymmetry.UnitEquivalenceBuilder = UnitEquivalenceBuilder;\r\n    function computeTransformGroups(s) {\r\n        var groups = UnitEquivalenceBuilder();\r\n        for (var _i = 0, _a = s.units; _i < _a.length; _i++) {\r\n            var u = _a[_i];\r\n            groups.add(u.id, u);\r\n        }\r\n        var ret = [];\r\n        for (var _b = 0, _c = groups.groups; _b < _c.length; _b++) {\r\n            var eqUnits = _c[_b];\r\n            ret.push(Unit.SymmetryGroup(eqUnits.map(function (id) { return s.unitMap.get(id); })));\r\n        }\r\n        return ret;\r\n    }\r\n    StructureSymmetry.computeTransformGroups = computeTransformGroups;\r\n    /** Checks if transform groups are equal up to their unit's transformations */\r\n    function areTransformGroupsEquivalent(a, b) {\r\n        if (a.length !== b.length)\r\n            return false;\r\n        for (var i = 0, il = a.length; i < il; ++i) {\r\n            var au = a[i].units, bu = b[i].units;\r\n            if (au.length !== bu.length)\r\n                return false;\r\n            if (a[i].hashCode !== b[i].hashCode)\r\n                return false;\r\n            for (var j = 0, _j = au.length; j < _j; j++) {\r\n                if (au[j].conformation !== bu[j].conformation)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    StructureSymmetry.areTransformGroupsEquivalent = areTransformGroupsEquivalent;\r\n})(StructureSymmetry || (StructureSymmetry = {}));\r\nfunction getSelector(asymIds) {\r\n    return Q.generators.atoms({ chainTest: Q.pred.and(Q.pred.eq(function (ctx) { return StructureProperties.unit.operator_name(ctx.element); }, SymmetryOperator.DefaultName), Q.pred.inSet(function (ctx) { return StructureProperties.chain.label_asym_id(ctx.element); }, asymIds)) });\r\n}\r\nfunction getOperatorsForIndex(symmetry, index, i, j, k, modelCenter) {\r\n    var spacegroup = symmetry.spacegroup, ncsOperators = symmetry.ncsOperators;\r\n    var operators = [];\r\n    var toFractional = spacegroup.cell.toFractional;\r\n    var ref = Vec3.transformMat4(Vec3(), modelCenter, toFractional);\r\n    var symOp = Spacegroup.getSymmetryOperatorRef(spacegroup, index, i, j, k, ref);\r\n    if (ncsOperators && ncsOperators.length) {\r\n        for (var u = 0, ul = ncsOperators.length; u < ul; ++u) {\r\n            var ncsOp = ncsOperators[u];\r\n            var matrix = Mat4.mul(Mat4(), symOp.matrix, ncsOp.matrix);\r\n            var operator = SymmetryOperator.create(symOp.name + \" \" + ncsOp.name, matrix, {\r\n                assembly: symOp.assembly,\r\n                ncsId: ncsOp.ncsId,\r\n                hkl: symOp.hkl,\r\n                spgrOp: symOp.spgrOp\r\n            });\r\n            operators.push(operator);\r\n        }\r\n    }\r\n    else {\r\n        operators.push(symOp);\r\n    }\r\n    return operators;\r\n}\r\nfunction getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter) {\r\n    var spacegroup = symmetry.spacegroup, ncsOperators = symmetry.ncsOperators;\r\n    var ncsCount = (ncsOperators && ncsOperators.length) || 0;\r\n    var operators = [];\r\n    if (!ncsCount &&\r\n        ijkMin[0] <= 0 && ijkMax[0] >= 0 &&\r\n        ijkMin[1] <= 0 && ijkMax[1] >= 0 &&\r\n        ijkMin[2] <= 0 && ijkMax[2] >= 0) {\r\n        operators[0] = Spacegroup.getSymmetryOperator(spacegroup, 0, 0, 0, 0);\r\n    }\r\n    var toFractional = spacegroup.cell.toFractional;\r\n    var ref = Vec3.transformMat4(Vec3(), modelCenter, toFractional);\r\n    for (var op = 0; op < spacegroup.operators.length; op++) {\r\n        for (var i = ijkMin[0]; i <= ijkMax[0]; i++) {\r\n            for (var j = ijkMin[1]; j <= ijkMax[1]; j++) {\r\n                for (var k = ijkMin[2]; k <= ijkMax[2]; k++) {\r\n                    // check if we have added identity as the 1st operator.\r\n                    if (!ncsCount && op === 0 && i === 0 && j === 0 && k === 0)\r\n                        continue;\r\n                    operators.push.apply(operators, getOperatorsForIndex(symmetry, op, i, j, k, ref));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return operators;\r\n}\r\nfunction getOperatorsCached333(symmetry, ref) {\r\n    if (symmetry._operators_333 && Vec3.equals(ref, symmetry._operators_333.ref)) {\r\n        return symmetry._operators_333.operators;\r\n    }\r\n    symmetry._operators_333 = {\r\n        ref: Vec3.clone(ref),\r\n        operators: getOperatorsForRange(symmetry, Vec3.create(-3, -3, -3), Vec3.create(3, 3, 3), ref)\r\n    };\r\n    return symmetry._operators_333.operators;\r\n}\r\nfunction assembleOperators(structure, operators) {\r\n    var assembler = Structure.Builder({\r\n        label: structure.label,\r\n        dynamicBonds: structure.dynamicBonds\r\n    });\r\n    var units = structure.units;\r\n    for (var _i = 0, operators_2 = operators; _i < operators_2.length; _i++) {\r\n        var oper = operators_2[_i];\r\n        for (var _a = 0, units_3 = units; _a < units_3.length; _a++) {\r\n            var unit = units_3[_a];\r\n            assembler.addWithOperator(unit, oper);\r\n        }\r\n    }\r\n    return assembler.getStructure();\r\n}\r\nfunction _buildNCS(ctx, structure) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var models, symmetry, operators;\r\n        return __generator(this, function (_a) {\r\n            models = structure.models;\r\n            if (models.length !== 1)\r\n                throw new Error('Can only build NCS from structures based on 1 model.');\r\n            symmetry = ModelSymmetry.Provider.get(models[0]);\r\n            if (!symmetry)\r\n                return [2 /*return*/, structure];\r\n            operators = symmetry.ncsOperators;\r\n            if (!operators || !operators.length)\r\n                return [2 /*return*/, structure];\r\n            return [2 /*return*/, assembleOperators(structure, operators)];\r\n        });\r\n    });\r\n}\r\nfunction findSymmetryRange(ctx, structure, ijkMin, ijkMax) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var models, symmetry, spacegroup, modelCenter, operators;\r\n        return __generator(this, function (_a) {\r\n            models = structure.models;\r\n            if (models.length !== 1)\r\n                throw new Error('Can only build symmetries from structures based on 1 model.');\r\n            symmetry = ModelSymmetry.Provider.get(models[0]);\r\n            if (!symmetry)\r\n                return [2 /*return*/, structure];\r\n            spacegroup = symmetry.spacegroup;\r\n            if (SpacegroupCell.isZero(spacegroup.cell))\r\n                return [2 /*return*/, structure];\r\n            modelCenter = Model.getCenter(models[0]);\r\n            operators = getOperatorsForRange(symmetry, ijkMin, ijkMax, modelCenter);\r\n            return [2 /*return*/, assembleOperators(structure, operators)];\r\n        });\r\n    });\r\n}\r\nfunction findMatesRadius(ctx, structure, radius) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        function hash(unit, oper) {\r\n            return unit.invariantId + \"|\" + oper.name;\r\n        }\r\n        var models, symmetry, spacegroup, modelCenter, operators, lookup, added, assembler, units, center, _i, operators_3, oper, _a, units_4, unit, boundingSphere, closeUnits, uI, _uI, closeUnit, h;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    models = structure.models;\r\n                    if (models.length !== 1)\r\n                        throw new Error('Can only build symmetries from structures based on 1 model.');\r\n                    symmetry = ModelSymmetry.Provider.get(models[0]);\r\n                    if (!symmetry)\r\n                        return [2 /*return*/, structure];\r\n                    spacegroup = symmetry.spacegroup;\r\n                    if (SpacegroupCell.isZero(spacegroup.cell))\r\n                        return [2 /*return*/, structure];\r\n                    if (!ctx.shouldUpdate) return [3 /*break*/, 2];\r\n                    return [4 /*yield*/, ctx.update('Initialing...')];\r\n                case 1:\r\n                    _b.sent();\r\n                    _b.label = 2;\r\n                case 2:\r\n                    modelCenter = Model.getCenter(models[0]);\r\n                    operators = getOperatorsCached333(symmetry, modelCenter);\r\n                    lookup = structure.lookup3d;\r\n                    added = new Set();\r\n                    assembler = Structure.Builder({\r\n                        label: structure.label,\r\n                        dynamicBonds: structure.dynamicBonds\r\n                    });\r\n                    units = structure.units;\r\n                    center = Vec3.zero();\r\n                    _i = 0, operators_3 = operators;\r\n                    _b.label = 3;\r\n                case 3:\r\n                    if (!(_i < operators_3.length)) return [3 /*break*/, 6];\r\n                    oper = operators_3[_i];\r\n                    for (_a = 0, units_4 = units; _a < units_4.length; _a++) {\r\n                        unit = units_4[_a];\r\n                        boundingSphere = unit.lookup3d.boundary.sphere;\r\n                        Vec3.transformMat4(center, boundingSphere.center, oper.matrix);\r\n                        closeUnits = lookup.findUnitIndices(center[0], center[1], center[2], boundingSphere.radius + radius);\r\n                        for (uI = 0, _uI = closeUnits.count; uI < _uI; uI++) {\r\n                            closeUnit = units[closeUnits.indices[uI]];\r\n                            if (!closeUnit.lookup3d.check(center[0], center[1], center[2], boundingSphere.radius + radius))\r\n                                continue;\r\n                            h = hash(unit, oper);\r\n                            if (!added.has(h)) {\r\n                                assembler.addWithOperator(unit, oper);\r\n                                added.add(h);\r\n                            }\r\n                        }\r\n                    }\r\n                    if (!ctx.shouldUpdate) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, ctx.update('Building symmetry...')];\r\n                case 4:\r\n                    _b.sent();\r\n                    _b.label = 5;\r\n                case 5:\r\n                    _i++;\r\n                    return [3 /*break*/, 3];\r\n                case 6: return [2 /*return*/, assembler.getStructure()];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport { StructureSymmetry };\r\n//# sourceMappingURL=symmetry.js.map"]},"metadata":{},"sourceType":"module"}