{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Segmentation, Interval } from '../../../../../mol-data/int';\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges'; // TODO assumes all coarse elements are part of a polymer\n// TODO add gaps at the ends of the chains by comparing to the polymer sequence data\n\nexport function getCoarseRanges(data, chemicalComponentMap) {\n  var polymerRanges = [];\n  var gapRanges = [];\n  var chainIt = Segmentation.transientSegments(data.chainElementSegments, Interval.ofBounds(0, data.count));\n  var seq_id_begin = data.seq_id_begin,\n      seq_id_end = data.seq_id_end;\n\n  while (chainIt.hasNext) {\n    var _a = chainIt.move(),\n        start = _a.start,\n        end = _a.end;\n\n    var startIndex = -1;\n    var prevSeqEnd = -1;\n\n    for (var i = start; i < end; ++i) {\n      var seqEnd = seq_id_end.value(i);\n\n      if (i === start) {\n        startIndex = i;\n        prevSeqEnd = seq_id_end.value(i);\n      } else {\n        if (seq_id_begin.value(i) - prevSeqEnd > 1) {\n          polymerRanges.push(startIndex, i - 1);\n          gapRanges.push(i - 1, i);\n          startIndex = i;\n        }\n      }\n\n      if (i === end - 1) {\n        polymerRanges.push(startIndex, i);\n      }\n\n      prevSeqEnd = seqEnd;\n    }\n  }\n\n  return {\n    polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),\n    gapRanges: SortedRanges.ofSortedRanges(gapRanges)\n  };\n}","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/model/properties/utils/coarse-ranges.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAGH,SAAS,YAAT,EAAuB,QAAvB,QAAuC,6BAAvC;AACA,SAAS,YAAT,QAA6B,2CAA7B,C,CAIA;AACA;;AAEA,OAAM,SAAU,eAAV,CAA0B,IAA1B,EAAmD,oBAAnD,EAA+G;AACjH,MAAM,aAAa,GAAa,EAAhC;AACA,MAAM,SAAS,GAAa,EAA5B;AACA,MAAM,OAAO,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,oBAApC,EAA0D,QAAQ,CAAC,QAAT,CAAkB,CAAlB,EAAqB,IAAI,CAAC,KAA1B,CAA1D,CAAhB;AAEQ,MAAA,YAAY,GAAiB,IAAI,CAArB,YAAZ;AAAA,MAAc,UAAU,GAAK,IAAI,CAAT,UAAxB;;AAER,SAAO,OAAO,CAAC,OAAf,EAAwB;AACd,QAAA,EAAA,GAAiB,OAAO,CAAC,IAAR,EAAjB;AAAA,QAAE,KAAK,GAAA,EAAA,CAAA,KAAP;AAAA,QAAS,GAAG,GAAA,EAAA,CAAA,GAAZ;;AAEN,QAAI,UAAU,GAAG,CAAC,CAAlB;AACA,QAAI,UAAU,GAAG,CAAC,CAAlB;;AACA,SAAK,IAAI,CAAC,GAAG,KAAb,EAAoB,CAAC,GAAG,GAAxB,EAA6B,EAAE,CAA/B,EAAkC;AAC9B,UAAM,MAAM,GAAG,UAAU,CAAC,KAAX,CAAiB,CAAjB,CAAf;;AACA,UAAI,CAAC,KAAK,KAAV,EAAiB;AACb,QAAA,UAAU,GAAG,CAAb;AACA,QAAA,UAAU,GAAG,UAAU,CAAC,KAAX,CAAiB,CAAjB,CAAb;AACH,OAHD,MAGO;AACH,YAAI,YAAY,CAAC,KAAb,CAAmB,CAAnB,IAAwB,UAAxB,GAAqC,CAAzC,EAA4C;AACxC,UAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,CAAC,GAAG,CAAnC;AACA,UAAA,SAAS,CAAC,IAAV,CAAe,CAAC,GAAG,CAAnB,EAAsB,CAAtB;AACA,UAAA,UAAU,GAAG,CAAb;AACH;AACJ;;AACD,UAAI,CAAC,KAAK,GAAG,GAAG,CAAhB,EAAmB;AACf,QAAA,aAAa,CAAC,IAAd,CAAmB,UAAnB,EAA+B,CAA/B;AACH;;AACD,MAAA,UAAU,GAAG,MAAb;AACH;AACJ;;AAED,SAAO;AACH,IAAA,aAAa,EAAE,YAAY,CAAC,cAAb,CAA4B,aAA5B,CADZ;AAEH,IAAA,SAAS,EAAE,YAAY,CAAC,cAAb,CAA4B,SAA5B;AAFR,GAAP;AAIH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Segmentation, Interval } from '../../../../../mol-data/int';\r\nimport { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';\r\n// TODO assumes all coarse elements are part of a polymer\r\n// TODO add gaps at the ends of the chains by comparing to the polymer sequence data\r\nexport function getCoarseRanges(data, chemicalComponentMap) {\r\n    var polymerRanges = [];\r\n    var gapRanges = [];\r\n    var chainIt = Segmentation.transientSegments(data.chainElementSegments, Interval.ofBounds(0, data.count));\r\n    var seq_id_begin = data.seq_id_begin, seq_id_end = data.seq_id_end;\r\n    while (chainIt.hasNext) {\r\n        var _a = chainIt.move(), start = _a.start, end = _a.end;\r\n        var startIndex = -1;\r\n        var prevSeqEnd = -1;\r\n        for (var i = start; i < end; ++i) {\r\n            var seqEnd = seq_id_end.value(i);\r\n            if (i === start) {\r\n                startIndex = i;\r\n                prevSeqEnd = seq_id_end.value(i);\r\n            }\r\n            else {\r\n                if (seq_id_begin.value(i) - prevSeqEnd > 1) {\r\n                    polymerRanges.push(startIndex, i - 1);\r\n                    gapRanges.push(i - 1, i);\r\n                    startIndex = i;\r\n                }\r\n            }\r\n            if (i === end - 1) {\r\n                polymerRanges.push(startIndex, i);\r\n            }\r\n            prevSeqEnd = seqEnd;\r\n        }\r\n    }\r\n    return {\r\n        polymerRanges: SortedRanges.ofSortedRanges(polymerRanges),\r\n        gapRanges: SortedRanges.ofSortedRanges(gapRanges)\r\n    };\r\n}\r\n//# sourceMappingURL=coarse-ranges.js.map"]},"metadata":{},"sourceType":"module"}