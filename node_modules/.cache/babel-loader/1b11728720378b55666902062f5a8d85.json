{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nvar Spec = {\n  'MOL_ID': '',\n  'MOLECULE': '',\n  'CHAIN': '',\n  'FRAGMENT': '',\n  'SYNONYM': '',\n  'EC': '',\n  'ENGINEERED': '',\n  'MUTATION': '',\n  'OTHER_DETAILS': ''\n};\nexport function parseCmpnd(lines, lineStart, lineEnd) {\n  var getLine = function (n) {\n    return lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);\n  };\n\n  var currentSpec;\n  var currentCompound = {\n    chains: [],\n    description: ''\n  };\n  var compounds = [];\n\n  for (var i = lineStart; i < lineEnd; i++) {\n    var line = getLine(i); // COLUMNS       DATA TYPE       FIELD         DEFINITION\n    // ----------------------------------------------------------------------------------\n    //  1 -  6       Record name     \"COMPND\"\n    //  8 - 10       Continuation    continuation  Allows concatenation of multiple records.\n    // 11 - 80       Specification   compound      Description of the molecular components.\n    //               list\n\n    var cmpnd = line.substr(10, 70).trim();\n    var cmpndSpecEnd = cmpnd.indexOf(':');\n    var cmpndSpec = cmpnd.substring(0, cmpndSpecEnd);\n    var value = void 0;\n\n    if (cmpndSpec in Spec) {\n      currentSpec = cmpndSpec;\n      value = cmpnd.substring(cmpndSpecEnd + 2);\n    } else {\n      value = cmpnd;\n    }\n\n    value = value.replace(/;$/, '');\n\n    if (currentSpec === 'MOL_ID') {\n      currentCompound = {\n        chains: [],\n        description: ''\n      };\n      compounds.push(currentCompound);\n    } else if (currentSpec === 'MOLECULE') {\n      if (currentCompound.description) currentCompound.description += ' ';\n      currentCompound.description += value;\n    } else if (currentSpec === 'CHAIN') {\n      Array.prototype.push.apply(currentCompound.chains, value.split(/\\s*,\\s*/));\n    }\n  } // Define a seprate entity for each chain\n  // --------------------------------------\n  //\n  // This is a workaround for how sequences are currently determined for PDB files.\n  //\n  // The current approach infers the \"observed sequence\" from the atomic hierarchy.\n  // However, for example for PDB ID 3HHR, this approach fails, since chains B and C\n  // belong to the same entity but contain different observed sequence, which causes display\n  // errors in the sequence viewer (since the sequences are determined \"per entity\").\n  //\n  // A better approach could be to parse SEQRES categories and use it to construct\n  // entity_poly_seq category. However, this would require constructing label_seq_id (with gaps)\n  // from RES ID pdb column (auth_seq_id), which isn't a trivial exercise.\n  //\n  // (properly formatted) mmCIF structures do not exhibit this issue.\n\n\n  var singletons = [];\n\n  for (var _i = 0, compounds_1 = compounds; _i < compounds_1.length; _i++) {\n    var comp = compounds_1[_i];\n\n    for (var _a = 0, _b = comp.chains; _a < _b.length; _a++) {\n      var chain = _b[_a];\n      singletons.push({\n        description: comp.description,\n        chains: [chain]\n      });\n    }\n  }\n\n  return singletons;\n}\nexport function parseHetnam(lines, lineStart, lineEnd) {\n  var getLine = function (n) {\n    return lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]);\n  };\n\n  var hetnams = new Map();\n\n  for (var i = lineStart; i < lineEnd; i++) {\n    var line = getLine(i); // COLUMNS       DATA  TYPE    FIELD           DEFINITION\n    // ----------------------------------------------------------------------------\n    //  1 -  6       Record name   \"HETNAM\"\n    //  9 - 10       Continuation  continuation    Allows concatenation of multiple records.\n    // 12 - 14       LString(3)    hetID           Het identifier, right-justified.\n    // 16 - 70       String        text            Chemical name.\n\n    var het = line.substr(11, 3).trim();\n    var name_1 = line.substr(15).trim();\n\n    if (hetnams.has(het)) {\n      hetnams.set(het, hetnams.get(het) + \" \" + name_1);\n    } else {\n      hetnams.set(het, name_1);\n    }\n  }\n\n  return hetnams;\n}","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/pdb/entity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nvar Spec = {\r\n    'MOL_ID': '',\r\n    'MOLECULE': '',\r\n    'CHAIN': '',\r\n    'FRAGMENT': '',\r\n    'SYNONYM': '',\r\n    'EC': '',\r\n    'ENGINEERED': '',\r\n    'MUTATION': '',\r\n    'OTHER_DETAILS': ''\r\n};\r\nexport function parseCmpnd(lines, lineStart, lineEnd) {\r\n    var getLine = function (n) { return lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]); };\r\n    var currentSpec;\r\n    var currentCompound = { chains: [], description: '' };\r\n    var compounds = [];\r\n    for (var i = lineStart; i < lineEnd; i++) {\r\n        var line = getLine(i);\r\n        // COLUMNS       DATA TYPE       FIELD         DEFINITION\r\n        // ----------------------------------------------------------------------------------\r\n        //  1 -  6       Record name     \"COMPND\"\r\n        //  8 - 10       Continuation    continuation  Allows concatenation of multiple records.\r\n        // 11 - 80       Specification   compound      Description of the molecular components.\r\n        //               list\r\n        var cmpnd = line.substr(10, 70).trim();\r\n        var cmpndSpecEnd = cmpnd.indexOf(':');\r\n        var cmpndSpec = cmpnd.substring(0, cmpndSpecEnd);\r\n        var value = void 0;\r\n        if (cmpndSpec in Spec) {\r\n            currentSpec = cmpndSpec;\r\n            value = cmpnd.substring(cmpndSpecEnd + 2);\r\n        }\r\n        else {\r\n            value = cmpnd;\r\n        }\r\n        value = value.replace(/;$/, '');\r\n        if (currentSpec === 'MOL_ID') {\r\n            currentCompound = {\r\n                chains: [],\r\n                description: ''\r\n            };\r\n            compounds.push(currentCompound);\r\n        }\r\n        else if (currentSpec === 'MOLECULE') {\r\n            if (currentCompound.description)\r\n                currentCompound.description += ' ';\r\n            currentCompound.description += value;\r\n        }\r\n        else if (currentSpec === 'CHAIN') {\r\n            Array.prototype.push.apply(currentCompound.chains, value.split(/\\s*,\\s*/));\r\n        }\r\n    }\r\n    // Define a seprate entity for each chain\r\n    // --------------------------------------\r\n    //\r\n    // This is a workaround for how sequences are currently determined for PDB files.\r\n    //\r\n    // The current approach infers the \"observed sequence\" from the atomic hierarchy.\r\n    // However, for example for PDB ID 3HHR, this approach fails, since chains B and C\r\n    // belong to the same entity but contain different observed sequence, which causes display\r\n    // errors in the sequence viewer (since the sequences are determined \"per entity\").\r\n    //\r\n    // A better approach could be to parse SEQRES categories and use it to construct\r\n    // entity_poly_seq category. However, this would require constructing label_seq_id (with gaps)\r\n    // from RES ID pdb column (auth_seq_id), which isn't a trivial exercise.\r\n    //\r\n    // (properly formatted) mmCIF structures do not exhibit this issue.\r\n    var singletons = [];\r\n    for (var _i = 0, compounds_1 = compounds; _i < compounds_1.length; _i++) {\r\n        var comp = compounds_1[_i];\r\n        for (var _a = 0, _b = comp.chains; _a < _b.length; _a++) {\r\n            var chain = _b[_a];\r\n            singletons.push({\r\n                description: comp.description,\r\n                chains: [chain]\r\n            });\r\n        }\r\n    }\r\n    return singletons;\r\n}\r\nexport function parseHetnam(lines, lineStart, lineEnd) {\r\n    var getLine = function (n) { return lines.data.substring(lines.indices[2 * n], lines.indices[2 * n + 1]); };\r\n    var hetnams = new Map();\r\n    for (var i = lineStart; i < lineEnd; i++) {\r\n        var line = getLine(i);\r\n        // COLUMNS       DATA  TYPE    FIELD           DEFINITION\r\n        // ----------------------------------------------------------------------------\r\n        //  1 -  6       Record name   \"HETNAM\"\r\n        //  9 - 10       Continuation  continuation    Allows concatenation of multiple records.\r\n        // 12 - 14       LString(3)    hetID           Het identifier, right-justified.\r\n        // 16 - 70       String        text            Chemical name.\r\n        var het = line.substr(11, 3).trim();\r\n        var name_1 = line.substr(15).trim();\r\n        if (hetnams.has(het)) {\r\n            hetnams.set(het, hetnams.get(het) + \" \" + name_1);\r\n        }\r\n        else {\r\n            hetnams.set(het, name_1);\r\n        }\r\n    }\r\n    return hetnams;\r\n}\r\n//# sourceMappingURL=entity.js.map"]},"metadata":{},"sourceType":"module"}