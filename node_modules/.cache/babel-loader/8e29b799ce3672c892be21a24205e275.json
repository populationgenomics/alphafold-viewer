{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Taken/adapted from DensityServer (https://github.com/dsehnal/DensityServer)\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { SimpleBuffer } from '../../mol-io/common/simple-buffer';\nexport var TypedArrayValueType;\n\n(function (TypedArrayValueType) {\n  TypedArrayValueType.Float32 = 'float32';\n  TypedArrayValueType.Int8 = 'int8';\n  TypedArrayValueType.Int16 = 'int16';\n  TypedArrayValueType.Uint16 = 'uint16';\n})(TypedArrayValueType || (TypedArrayValueType = {}));\n\nexport function getElementByteSize(type) {\n  if (type === TypedArrayValueType.Float32) return 4;\n  if (type === TypedArrayValueType.Int16) return 2;\n  if (type === TypedArrayValueType.Uint16) return 2;\n  return 1;\n}\nexport function makeTypedArray(type, buffer, byteOffset, length) {\n  if (byteOffset === void 0) {\n    byteOffset = 0;\n  }\n\n  if (type === TypedArrayValueType.Float32) return new Float32Array(buffer, byteOffset, length);\n  if (type === TypedArrayValueType.Int16) return new Int16Array(buffer, byteOffset, length);\n  if (type === TypedArrayValueType.Uint16) return new Uint16Array(buffer, byteOffset, length);\n  return new Int8Array(buffer, byteOffset, length);\n}\nexport function createTypedArray(type, size) {\n  switch (type) {\n    case TypedArrayValueType.Float32:\n      return new Float32Array(new ArrayBuffer(4 * size));\n\n    case TypedArrayValueType.Int8:\n      return new Int8Array(new ArrayBuffer(1 * size));\n\n    case TypedArrayValueType.Int16:\n      return new Int16Array(new ArrayBuffer(2 * size));\n\n    case TypedArrayValueType.Uint16:\n      return new Uint16Array(new ArrayBuffer(2 * size));\n  }\n\n  throw Error(type + \" is not a supported value format.\");\n}\nexport function createTypedArrayBufferContext(size, type) {\n  var elementByteSize = getElementByteSize(type);\n  var arrayBuffer = new ArrayBuffer(elementByteSize * size);\n  var readBuffer = SimpleBuffer.fromArrayBuffer(arrayBuffer);\n  var valuesBuffer = SimpleBuffer.IsNativeEndianLittle ? arrayBuffer : new ArrayBuffer(elementByteSize * size);\n  return {\n    type: type,\n    elementByteSize: elementByteSize,\n    readBuffer: readBuffer,\n    valuesBuffer: new Uint8Array(valuesBuffer),\n    values: makeTypedArray(type, valuesBuffer)\n  };\n}\nexport function readTypedArray(ctx, file, position, byteCount, valueByteOffset, littleEndian) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , file.readBuffer(position, ctx.readBuffer, byteCount, valueByteOffset)];\n\n        case 1:\n          _a.sent();\n\n          if (ctx.elementByteSize > 1 && (littleEndian !== void 0 && littleEndian !== SimpleBuffer.IsNativeEndianLittle || !SimpleBuffer.IsNativeEndianLittle)) {\n            // fix the endian\n            SimpleBuffer.flipByteOrder(ctx.readBuffer, ctx.valuesBuffer, byteCount, ctx.elementByteSize, valueByteOffset);\n          }\n\n          return [2\n          /*return*/\n          , ctx.values];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../src/mol-io/common/typed-array.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * Taken/adapted from DensityServer (https://github.com/dsehnal/DensityServer)\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { SimpleBuffer } from '../../mol-io/common/simple-buffer';\r\nexport var TypedArrayValueType;\r\n(function (TypedArrayValueType) {\r\n    TypedArrayValueType.Float32 = 'float32';\r\n    TypedArrayValueType.Int8 = 'int8';\r\n    TypedArrayValueType.Int16 = 'int16';\r\n    TypedArrayValueType.Uint16 = 'uint16';\r\n})(TypedArrayValueType || (TypedArrayValueType = {}));\r\nexport function getElementByteSize(type) {\r\n    if (type === TypedArrayValueType.Float32)\r\n        return 4;\r\n    if (type === TypedArrayValueType.Int16)\r\n        return 2;\r\n    if (type === TypedArrayValueType.Uint16)\r\n        return 2;\r\n    return 1;\r\n}\r\nexport function makeTypedArray(type, buffer, byteOffset, length) {\r\n    if (byteOffset === void 0) { byteOffset = 0; }\r\n    if (type === TypedArrayValueType.Float32)\r\n        return new Float32Array(buffer, byteOffset, length);\r\n    if (type === TypedArrayValueType.Int16)\r\n        return new Int16Array(buffer, byteOffset, length);\r\n    if (type === TypedArrayValueType.Uint16)\r\n        return new Uint16Array(buffer, byteOffset, length);\r\n    return new Int8Array(buffer, byteOffset, length);\r\n}\r\nexport function createTypedArray(type, size) {\r\n    switch (type) {\r\n        case TypedArrayValueType.Float32: return new Float32Array(new ArrayBuffer(4 * size));\r\n        case TypedArrayValueType.Int8: return new Int8Array(new ArrayBuffer(1 * size));\r\n        case TypedArrayValueType.Int16: return new Int16Array(new ArrayBuffer(2 * size));\r\n        case TypedArrayValueType.Uint16: return new Uint16Array(new ArrayBuffer(2 * size));\r\n    }\r\n    throw Error(type + \" is not a supported value format.\");\r\n}\r\nexport function createTypedArrayBufferContext(size, type) {\r\n    var elementByteSize = getElementByteSize(type);\r\n    var arrayBuffer = new ArrayBuffer(elementByteSize * size);\r\n    var readBuffer = SimpleBuffer.fromArrayBuffer(arrayBuffer);\r\n    var valuesBuffer = SimpleBuffer.IsNativeEndianLittle ? arrayBuffer : new ArrayBuffer(elementByteSize * size);\r\n    return {\r\n        type: type,\r\n        elementByteSize: elementByteSize,\r\n        readBuffer: readBuffer,\r\n        valuesBuffer: new Uint8Array(valuesBuffer),\r\n        values: makeTypedArray(type, valuesBuffer)\r\n    };\r\n}\r\nexport function readTypedArray(ctx, file, position, byteCount, valueByteOffset, littleEndian) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, file.readBuffer(position, ctx.readBuffer, byteCount, valueByteOffset)];\r\n                case 1:\r\n                    _a.sent();\r\n                    if (ctx.elementByteSize > 1 && ((littleEndian !== void 0 && littleEndian !== SimpleBuffer.IsNativeEndianLittle) || !SimpleBuffer.IsNativeEndianLittle)) {\r\n                        // fix the endian\r\n                        SimpleBuffer.flipByteOrder(ctx.readBuffer, ctx.valuesBuffer, byteCount, ctx.elementByteSize, valueByteOffset);\r\n                    }\r\n                    return [2 /*return*/, ctx.values];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=typed-array.js.map"]},"metadata":{},"sourceType":"module"}