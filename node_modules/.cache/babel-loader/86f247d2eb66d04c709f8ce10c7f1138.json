{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { BondType } from '../../../../mol-model/structure/model/types';\nimport { Unit, StructureElement, Structure, Bond } from '../../../../mol-model/structure';\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\nimport { LinkCylinderParams, LinkLineParams } from './link';\nimport { ObjectKeys } from '../../../../mol-util/type-helpers';\nimport { EmptyLoci } from '../../../../mol-model/loci';\nimport { Interval, OrderedSet, SortedArray } from '../../../../mol-data/int';\nimport { isH, isHydrogen } from './common';\nexport var BondParams = {\n  includeTypes: PD.MultiSelect(ObjectKeys(BondType.Names), PD.objectToOptions(BondType.Names)),\n  excludeTypes: PD.MultiSelect([], PD.objectToOptions(BondType.Names)),\n  ignoreHydrogens: PD.Boolean(false),\n  aromaticBonds: PD.Boolean(false, {\n    description: 'Display aromatic bonds with dashes'\n  }),\n  multipleBonds: PD.Select('symmetric', PD.arrayToOptions(['off', 'symmetric', 'offset']))\n};\nexport var DefaultBondProps = PD.getDefaultValues(BondParams);\nexport var BondCylinderParams = __assign(__assign(__assign({}, LinkCylinderParams), BondParams), {\n  adjustCylinderLength: PD.Boolean(true, {\n    description: 'Shorten cylinders to reduce overlap with spheres.'\n  })\n});\nexport var DefaultBondCylinderProps = PD.getDefaultValues(BondCylinderParams);\nexport var BondLineParams = __assign(__assign({}, LinkLineParams), BondParams);\nexport var DefaultBondLineProps = PD.getDefaultValues(BondLineParams);\nexport function ignoreBondType(include, exclude, f) {\n  return !BondType.is(include, f) || BondType.is(exclude, f);\n}\nexport function makeIntraBondIgnoreTest(structure, unit, props) {\n  var elements = unit.elements;\n  var atomicNumber = unit.model.atomicHierarchy.derived.atom.atomicNumber;\n  var bonds = unit.bonds;\n  var a = bonds.a,\n      b = bonds.b,\n      edgeProps = bonds.edgeProps;\n  var _flags = edgeProps.flags;\n  var ignoreHydrogens = props.ignoreHydrogens,\n      includeTypes = props.includeTypes,\n      excludeTypes = props.excludeTypes;\n  var include = BondType.fromNames(includeTypes);\n  var exclude = BondType.fromNames(excludeTypes);\n  var allBondTypes = BondType.isAll(include) && 0\n  /* None */\n  === exclude;\n  var child = structure.child;\n  var childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n  if (child && !childUnit) throw new Error('expected childUnit to exist if child exists');\n  if (allBondTypes && !ignoreHydrogens && !child) return;\n  return function (edgeIndex) {\n    return !!childUnit && !SortedArray.has(childUnit.elements, elements[a[edgeIndex]]) || ignoreHydrogens && (isH(atomicNumber, elements[a[edgeIndex]]) || isH(atomicNumber, elements[b[edgeIndex]])) || !allBondTypes && ignoreBondType(include, exclude, _flags[edgeIndex]);\n  };\n}\nexport function makeInterBondIgnoreTest(structure, props) {\n  var bonds = structure.interUnitBonds;\n  var edges = bonds.edges;\n  var ignoreHydrogens = props.ignoreHydrogens,\n      includeTypes = props.includeTypes,\n      excludeTypes = props.excludeTypes;\n  var include = BondType.fromNames(includeTypes);\n  var exclude = BondType.fromNames(excludeTypes);\n  var allBondTypes = BondType.isAll(include) && 0\n  /* None */\n  === exclude;\n  var child = structure.child;\n  if (allBondTypes && !ignoreHydrogens && !child) return;\n  return function (edgeIndex) {\n    if (child) {\n      var b = edges[edgeIndex];\n      var childUnitA = child.unitMap.get(b.unitA);\n      if (!childUnitA) return true;\n      var unitA = structure.unitMap.get(b.unitA);\n      var eA = unitA.elements[b.indexA];\n      if (!SortedArray.has(childUnitA.elements, eA)) return true;\n    }\n\n    if (ignoreHydrogens) {\n      var b = edges[edgeIndex];\n      var uA = structure.unitMap.get(b.unitA);\n      var uB = structure.unitMap.get(b.unitB);\n      if (isHydrogen(uA, uA.elements[b.indexA]) || isHydrogen(uB, uB.elements[b.indexB])) return true;\n    }\n\n    if (!allBondTypes) {\n      if (ignoreBondType(include, exclude, edges[edgeIndex].props.flag)) return true;\n    }\n\n    return false;\n  };\n}\nexport var BondIterator;\n\n(function (BondIterator) {\n  function fromGroup(structureGroup) {\n    var group = structureGroup.group,\n        structure = structureGroup.structure;\n    var unit = group.units[0];\n    var groupCount = Unit.isAtomic(unit) ? unit.bonds.edgeCount * 2 : 0;\n    var instanceCount = group.units.length;\n    var location = Bond.Location(structure, undefined, undefined, structure, undefined, undefined);\n\n    var getLocation = function (groupIndex, instanceIndex) {\n      var unit = group.units[instanceIndex];\n      location.aUnit = unit;\n      location.bUnit = unit;\n      location.aIndex = unit.bonds.a[groupIndex];\n      location.bIndex = unit.bonds.b[groupIndex];\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation);\n  }\n\n  BondIterator.fromGroup = fromGroup;\n\n  function fromStructure(structure) {\n    var groupCount = structure.interUnitBonds.edgeCount;\n    var instanceCount = 1;\n    var location = Bond.Location(structure, undefined, undefined, structure, undefined, undefined);\n\n    var getLocation = function (groupIndex) {\n      var bond = structure.interUnitBonds.edges[groupIndex];\n      location.aUnit = structure.unitMap.get(bond.unitA);\n      location.aIndex = bond.indexA;\n      location.bUnit = structure.unitMap.get(bond.unitB);\n      location.bIndex = bond.indexB;\n      return location;\n    };\n\n    return LocationIterator(groupCount, instanceCount, 1, getLocation, true);\n  }\n\n  BondIterator.fromStructure = fromStructure;\n})(BondIterator || (BondIterator = {})); //\n\n\nexport function getIntraBondLoci(pickingId, structureGroup, id) {\n  var objectId = pickingId.objectId,\n      instanceId = pickingId.instanceId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    var unit = group.units[instanceId];\n\n    if (Unit.isAtomic(unit)) {\n      var target = structure.target;\n      var iA = unit.bonds.a[groupId];\n      var iB = unit.bonds.b[groupId];\n      return Bond.Loci(target, [Bond.Location(target, unit, iA, target, unit, iB), Bond.Location(target, unit, iB, target, unit, iA)]);\n    }\n  }\n\n  return EmptyLoci;\n}\nexport function eachIntraBond(loci, structureGroup, apply, isMarking) {\n  var changed = false;\n\n  if (Bond.isLoci(loci)) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    if (!Structure.areEquivalent(loci.structure, structure)) return false;\n    var unit = group.units[0];\n    if (!Unit.isAtomic(unit)) return false;\n    var groupCount = unit.bonds.edgeCount * 2;\n\n    for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {\n      var b = _a[_i];\n      if (b.aUnit !== b.bUnit) continue;\n      var unitIdx = group.unitIndexMap.get(b.aUnit.id);\n\n      if (unitIdx !== undefined) {\n        var idx = unit.bonds.getDirectedEdgeIndex(b.aIndex, b.bIndex);\n\n        if (idx !== -1) {\n          if (apply(Interval.ofSingleton(unitIdx * groupCount + idx))) changed = true;\n        }\n      }\n    }\n  } else if (StructureElement.Loci.is(loci)) {\n    var structure = structureGroup.structure,\n        group = structureGroup.group;\n    if (!Structure.areEquivalent(loci.structure, structure)) return false;\n    var unit = group.units[0];\n    if (!Unit.isAtomic(unit)) return false;\n    var groupCount_1 = unit.bonds.edgeCount * 2;\n\n    var _loop_1 = function (e) {\n      var unitIdx = group.unitIndexMap.get(e.unit.id);\n\n      if (unitIdx !== undefined) {\n        var _d = unit.bonds,\n            offset_1 = _d.offset,\n            b_1 = _d.b;\n        OrderedSet.forEach(e.indices, function (v) {\n          for (var t = offset_1[v], _t = offset_1[v + 1]; t < _t; t++) {\n            if (!isMarking || OrderedSet.has(e.indices, b_1[t])) {\n              if (apply(Interval.ofSingleton(unitIdx * groupCount_1 + t))) changed = true;\n            }\n          }\n        });\n      }\n    };\n\n    for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\n      var e = _c[_b];\n\n      _loop_1(e);\n    }\n  }\n\n  return changed;\n} //\n\nexport function getInterBondLoci(pickingId, structure, id) {\n  var objectId = pickingId.objectId,\n      groupId = pickingId.groupId;\n\n  if (id === objectId) {\n    var target = structure.target;\n    var b = structure.interUnitBonds.edges[groupId];\n    var uA = structure.unitMap.get(b.unitA);\n    var uB = structure.unitMap.get(b.unitB);\n    return Bond.Loci(target, [Bond.Location(target, uA, b.indexA, target, uB, b.indexB), Bond.Location(target, uB, b.indexB, target, uA, b.indexA)]);\n  }\n\n  return EmptyLoci;\n}\nexport function eachInterBond(loci, structure, apply, isMarking) {\n  var changed = false;\n\n  if (Bond.isLoci(loci)) {\n    if (!Structure.areEquivalent(loci.structure, structure)) return false;\n\n    for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {\n      var b = _a[_i];\n      var idx = structure.interUnitBonds.getBondIndexFromLocation(b);\n\n      if (idx !== -1) {\n        if (apply(Interval.ofSingleton(idx))) changed = true;\n      }\n    }\n  } else if (StructureElement.Loci.is(loci)) {\n    if (!Structure.areEquivalent(loci.structure, structure)) return false;\n    if (isMarking && loci.elements.length === 1) return false; // only a single unit\n\n    var map_1 = new Map();\n\n    for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\n      var e = _c[_b];\n      map_1.set(e.unit.id, e.indices);\n    }\n\n    var _loop_2 = function (e) {\n      var unit = e.unit;\n      if (!Unit.isAtomic(unit)) return \"continue\";\n      structure.interUnitBonds.getConnectedUnits(unit.id).forEach(function (b) {\n        var otherLociIndices = map_1.get(b.unitB);\n\n        if (!isMarking || otherLociIndices) {\n          OrderedSet.forEach(e.indices, function (v) {\n            if (!b.connectedIndices.includes(v)) return;\n            b.getEdges(v).forEach(function (bi) {\n              if (!isMarking || otherLociIndices && OrderedSet.has(otherLociIndices, bi.indexB)) {\n                var idx = structure.interUnitBonds.getEdgeIndex(v, unit.id, bi.indexB, b.unitB);\n                if (apply(Interval.ofSingleton(idx))) changed = true;\n              }\n            });\n          });\n        }\n      });\n    };\n\n    for (var _d = 0, _e = loci.elements; _d < _e.length; _d++) {\n      var e = _e[_d];\n\n      _loop_2(e);\n    }\n  }\n\n  return changed;\n}","map":{"version":3,"sources":["../../../../../src/mol-repr/structure/visual/util/bond.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { BondType } from '../../../../mol-model/structure/model/types';\r\nimport { Unit, StructureElement, Structure, Bond } from '../../../../mol-model/structure';\r\nimport { ParamDefinition as PD } from '../../../../mol-util/param-definition';\r\nimport { LocationIterator } from '../../../../mol-geo/util/location-iterator';\r\nimport { LinkCylinderParams, LinkLineParams } from './link';\r\nimport { ObjectKeys } from '../../../../mol-util/type-helpers';\r\nimport { EmptyLoci } from '../../../../mol-model/loci';\r\nimport { Interval, OrderedSet, SortedArray } from '../../../../mol-data/int';\r\nimport { isH, isHydrogen } from './common';\r\nexport var BondParams = {\r\n    includeTypes: PD.MultiSelect(ObjectKeys(BondType.Names), PD.objectToOptions(BondType.Names)),\r\n    excludeTypes: PD.MultiSelect([], PD.objectToOptions(BondType.Names)),\r\n    ignoreHydrogens: PD.Boolean(false),\r\n    aromaticBonds: PD.Boolean(false, { description: 'Display aromatic bonds with dashes' }),\r\n    multipleBonds: PD.Select('symmetric', PD.arrayToOptions(['off', 'symmetric', 'offset'])),\r\n};\r\nexport var DefaultBondProps = PD.getDefaultValues(BondParams);\r\nexport var BondCylinderParams = __assign(__assign(__assign({}, LinkCylinderParams), BondParams), { adjustCylinderLength: PD.Boolean(true, { description: 'Shorten cylinders to reduce overlap with spheres.' }) });\r\nexport var DefaultBondCylinderProps = PD.getDefaultValues(BondCylinderParams);\r\nexport var BondLineParams = __assign(__assign({}, LinkLineParams), BondParams);\r\nexport var DefaultBondLineProps = PD.getDefaultValues(BondLineParams);\r\nexport function ignoreBondType(include, exclude, f) {\r\n    return !BondType.is(include, f) || BondType.is(exclude, f);\r\n}\r\nexport function makeIntraBondIgnoreTest(structure, unit, props) {\r\n    var elements = unit.elements;\r\n    var atomicNumber = unit.model.atomicHierarchy.derived.atom.atomicNumber;\r\n    var bonds = unit.bonds;\r\n    var a = bonds.a, b = bonds.b, edgeProps = bonds.edgeProps;\r\n    var _flags = edgeProps.flags;\r\n    var ignoreHydrogens = props.ignoreHydrogens, includeTypes = props.includeTypes, excludeTypes = props.excludeTypes;\r\n    var include = BondType.fromNames(includeTypes);\r\n    var exclude = BondType.fromNames(excludeTypes);\r\n    var allBondTypes = BondType.isAll(include) && 0 /* None */ === exclude;\r\n    var child = structure.child;\r\n    var childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\r\n    if (child && !childUnit)\r\n        throw new Error('expected childUnit to exist if child exists');\r\n    if (allBondTypes && !ignoreHydrogens && !child)\r\n        return;\r\n    return function (edgeIndex) {\r\n        return ((!!childUnit && !SortedArray.has(childUnit.elements, elements[a[edgeIndex]])) ||\r\n            (ignoreHydrogens && (isH(atomicNumber, elements[a[edgeIndex]]) || isH(atomicNumber, elements[b[edgeIndex]]))) ||\r\n            (!allBondTypes && ignoreBondType(include, exclude, _flags[edgeIndex])));\r\n    };\r\n}\r\nexport function makeInterBondIgnoreTest(structure, props) {\r\n    var bonds = structure.interUnitBonds;\r\n    var edges = bonds.edges;\r\n    var ignoreHydrogens = props.ignoreHydrogens, includeTypes = props.includeTypes, excludeTypes = props.excludeTypes;\r\n    var include = BondType.fromNames(includeTypes);\r\n    var exclude = BondType.fromNames(excludeTypes);\r\n    var allBondTypes = BondType.isAll(include) && 0 /* None */ === exclude;\r\n    var child = structure.child;\r\n    if (allBondTypes && !ignoreHydrogens && !child)\r\n        return;\r\n    return function (edgeIndex) {\r\n        if (child) {\r\n            var b = edges[edgeIndex];\r\n            var childUnitA = child.unitMap.get(b.unitA);\r\n            if (!childUnitA)\r\n                return true;\r\n            var unitA = structure.unitMap.get(b.unitA);\r\n            var eA = unitA.elements[b.indexA];\r\n            if (!SortedArray.has(childUnitA.elements, eA))\r\n                return true;\r\n        }\r\n        if (ignoreHydrogens) {\r\n            var b = edges[edgeIndex];\r\n            var uA = structure.unitMap.get(b.unitA);\r\n            var uB = structure.unitMap.get(b.unitB);\r\n            if (isHydrogen(uA, uA.elements[b.indexA]) || isHydrogen(uB, uB.elements[b.indexB]))\r\n                return true;\r\n        }\r\n        if (!allBondTypes) {\r\n            if (ignoreBondType(include, exclude, edges[edgeIndex].props.flag))\r\n                return true;\r\n        }\r\n        return false;\r\n    };\r\n}\r\nexport var BondIterator;\r\n(function (BondIterator) {\r\n    function fromGroup(structureGroup) {\r\n        var group = structureGroup.group, structure = structureGroup.structure;\r\n        var unit = group.units[0];\r\n        var groupCount = Unit.isAtomic(unit) ? unit.bonds.edgeCount * 2 : 0;\r\n        var instanceCount = group.units.length;\r\n        var location = Bond.Location(structure, undefined, undefined, structure, undefined, undefined);\r\n        var getLocation = function (groupIndex, instanceIndex) {\r\n            var unit = group.units[instanceIndex];\r\n            location.aUnit = unit;\r\n            location.bUnit = unit;\r\n            location.aIndex = unit.bonds.a[groupIndex];\r\n            location.bIndex = unit.bonds.b[groupIndex];\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation);\r\n    }\r\n    BondIterator.fromGroup = fromGroup;\r\n    function fromStructure(structure) {\r\n        var groupCount = structure.interUnitBonds.edgeCount;\r\n        var instanceCount = 1;\r\n        var location = Bond.Location(structure, undefined, undefined, structure, undefined, undefined);\r\n        var getLocation = function (groupIndex) {\r\n            var bond = structure.interUnitBonds.edges[groupIndex];\r\n            location.aUnit = structure.unitMap.get(bond.unitA);\r\n            location.aIndex = bond.indexA;\r\n            location.bUnit = structure.unitMap.get(bond.unitB);\r\n            location.bIndex = bond.indexB;\r\n            return location;\r\n        };\r\n        return LocationIterator(groupCount, instanceCount, 1, getLocation, true);\r\n    }\r\n    BondIterator.fromStructure = fromStructure;\r\n})(BondIterator || (BondIterator = {}));\r\n//\r\nexport function getIntraBondLoci(pickingId, structureGroup, id) {\r\n    var objectId = pickingId.objectId, instanceId = pickingId.instanceId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        var unit = group.units[instanceId];\r\n        if (Unit.isAtomic(unit)) {\r\n            var target = structure.target;\r\n            var iA = unit.bonds.a[groupId];\r\n            var iB = unit.bonds.b[groupId];\r\n            return Bond.Loci(target, [\r\n                Bond.Location(target, unit, iA, target, unit, iB),\r\n                Bond.Location(target, unit, iB, target, unit, iA)\r\n            ]);\r\n        }\r\n    }\r\n    return EmptyLoci;\r\n}\r\nexport function eachIntraBond(loci, structureGroup, apply, isMarking) {\r\n    var changed = false;\r\n    if (Bond.isLoci(loci)) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        if (!Structure.areEquivalent(loci.structure, structure))\r\n            return false;\r\n        var unit = group.units[0];\r\n        if (!Unit.isAtomic(unit))\r\n            return false;\r\n        var groupCount = unit.bonds.edgeCount * 2;\r\n        for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {\r\n            var b = _a[_i];\r\n            if (b.aUnit !== b.bUnit)\r\n                continue;\r\n            var unitIdx = group.unitIndexMap.get(b.aUnit.id);\r\n            if (unitIdx !== undefined) {\r\n                var idx = unit.bonds.getDirectedEdgeIndex(b.aIndex, b.bIndex);\r\n                if (idx !== -1) {\r\n                    if (apply(Interval.ofSingleton(unitIdx * groupCount + idx)))\r\n                        changed = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (StructureElement.Loci.is(loci)) {\r\n        var structure = structureGroup.structure, group = structureGroup.group;\r\n        if (!Structure.areEquivalent(loci.structure, structure))\r\n            return false;\r\n        var unit = group.units[0];\r\n        if (!Unit.isAtomic(unit))\r\n            return false;\r\n        var groupCount_1 = unit.bonds.edgeCount * 2;\r\n        var _loop_1 = function (e) {\r\n            var unitIdx = group.unitIndexMap.get(e.unit.id);\r\n            if (unitIdx !== undefined) {\r\n                var _d = unit.bonds, offset_1 = _d.offset, b_1 = _d.b;\r\n                OrderedSet.forEach(e.indices, function (v) {\r\n                    for (var t = offset_1[v], _t = offset_1[v + 1]; t < _t; t++) {\r\n                        if (!isMarking || OrderedSet.has(e.indices, b_1[t])) {\r\n                            if (apply(Interval.ofSingleton(unitIdx * groupCount_1 + t)))\r\n                                changed = true;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        };\r\n        for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\r\n            var e = _c[_b];\r\n            _loop_1(e);\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n//\r\nexport function getInterBondLoci(pickingId, structure, id) {\r\n    var objectId = pickingId.objectId, groupId = pickingId.groupId;\r\n    if (id === objectId) {\r\n        var target = structure.target;\r\n        var b = structure.interUnitBonds.edges[groupId];\r\n        var uA = structure.unitMap.get(b.unitA);\r\n        var uB = structure.unitMap.get(b.unitB);\r\n        return Bond.Loci(target, [\r\n            Bond.Location(target, uA, b.indexA, target, uB, b.indexB),\r\n            Bond.Location(target, uB, b.indexB, target, uA, b.indexA)\r\n        ]);\r\n    }\r\n    return EmptyLoci;\r\n}\r\nexport function eachInterBond(loci, structure, apply, isMarking) {\r\n    var changed = false;\r\n    if (Bond.isLoci(loci)) {\r\n        if (!Structure.areEquivalent(loci.structure, structure))\r\n            return false;\r\n        for (var _i = 0, _a = loci.bonds; _i < _a.length; _i++) {\r\n            var b = _a[_i];\r\n            var idx = structure.interUnitBonds.getBondIndexFromLocation(b);\r\n            if (idx !== -1) {\r\n                if (apply(Interval.ofSingleton(idx)))\r\n                    changed = true;\r\n            }\r\n        }\r\n    }\r\n    else if (StructureElement.Loci.is(loci)) {\r\n        if (!Structure.areEquivalent(loci.structure, structure))\r\n            return false;\r\n        if (isMarking && loci.elements.length === 1)\r\n            return false; // only a single unit\r\n        var map_1 = new Map();\r\n        for (var _b = 0, _c = loci.elements; _b < _c.length; _b++) {\r\n            var e = _c[_b];\r\n            map_1.set(e.unit.id, e.indices);\r\n        }\r\n        var _loop_2 = function (e) {\r\n            var unit = e.unit;\r\n            if (!Unit.isAtomic(unit))\r\n                return \"continue\";\r\n            structure.interUnitBonds.getConnectedUnits(unit.id).forEach(function (b) {\r\n                var otherLociIndices = map_1.get(b.unitB);\r\n                if (!isMarking || otherLociIndices) {\r\n                    OrderedSet.forEach(e.indices, function (v) {\r\n                        if (!b.connectedIndices.includes(v))\r\n                            return;\r\n                        b.getEdges(v).forEach(function (bi) {\r\n                            if (!isMarking || (otherLociIndices && OrderedSet.has(otherLociIndices, bi.indexB))) {\r\n                                var idx = structure.interUnitBonds.getEdgeIndex(v, unit.id, bi.indexB, b.unitB);\r\n                                if (apply(Interval.ofSingleton(idx)))\r\n                                    changed = true;\r\n                            }\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n        };\r\n        for (var _d = 0, _e = loci.elements; _d < _e.length; _d++) {\r\n            var e = _e[_d];\r\n            _loop_2(e);\r\n        }\r\n    }\r\n    return changed;\r\n}\r\n//# sourceMappingURL=bond.js.map"]},"metadata":{},"sourceType":"module"}