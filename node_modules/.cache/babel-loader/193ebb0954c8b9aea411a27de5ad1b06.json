{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * based in part on https://github.com/dsehnal/CIFTools.js\r\n */\n\n/**\r\n * Efficient integer and float parsers.\r\n *\r\n * For the purposes of parsing numbers from the mmCIF data representations,\r\n * up to 4 times faster than JS parseInt/parseFloat.\r\n */\nexport function parseIntSkipLeadingWhitespace(str, start, end) {\n  while (start < end && str.charCodeAt(start) === 32) start++;\n\n  return parseInt(str, start, end);\n}\nexport function parseInt(str, start, end) {\n  var _start = start,\n      ret = 0,\n      neg = 1;\n\n  if (str.charCodeAt(_start) === 45\n  /* - */\n  ) {\n    neg = -1;\n    ++_start;\n  } else if (str.charCodeAt(_start) === 43\n  /* + */\n  ) {\n    ++_start;\n  }\n\n  for (; _start < end; _start++) {\n    var c = str.charCodeAt(_start) - 48;\n    if (c > 9 || c < 0) return neg * ret | 0;else ret = 10 * ret + c | 0;\n  }\n\n  return neg * ret;\n}\n\nfunction parseScientific(main, str, start, end) {\n  // handle + in '1e+1' separately.\n  if (str.charCodeAt(start) === 43\n  /* + */\n  ) start++;\n  return main * Math.pow(10.0, parseInt(str, start, end));\n}\n\nexport function parseFloatSkipLeadingWhitespace(str, start, end) {\n  while (start < end && str.charCodeAt(start) === 32) start++;\n\n  return parseFloat(str, start, end);\n}\nexport function parseFloat(str, start, end) {\n  var _start = start,\n      neg = 1.0,\n      ret = 0.0,\n      point = 0.0,\n      div = 1.0;\n\n  if (str.charCodeAt(_start) === 45\n  /* - */\n  ) {\n    neg = -1;\n    ++_start;\n  } else if (str.charCodeAt(_start) === 43\n  /* + */\n  ) {\n    ++_start;\n  }\n\n  while (_start < end) {\n    var c = str.charCodeAt(_start) - 48;\n\n    if (c >= 0 && c < 10) {\n      ret = ret * 10 + c;\n      ++_start;\n    } else if (c === -2) {\n      // .\n      ++_start;\n\n      while (_start < end) {\n        c = str.charCodeAt(_start) - 48;\n\n        if (c >= 0 && c < 10) {\n          point = 10.0 * point + c;\n          div = 10.0 * div;\n          ++_start;\n        } else if (c === 53 || c === 21) {\n          // 'e'/'E'\n          return parseScientific(neg * (ret + point / div), str, _start + 1, end);\n        } else {\n          return neg * (ret + point / div);\n        }\n      }\n\n      return neg * (ret + point / div);\n    } else if (c === 53 || c === 21) {\n      // 'e'/'E'\n      return parseScientific(neg * ret, str, _start + 1, end);\n    } else {\n      break;\n    }\n  }\n\n  return neg * ret;\n}\n\nfunction isInt(str, start, end) {\n  if (str.charCodeAt(start) === 45\n  /* - */\n  ) {\n    start++;\n  }\n\n  for (; start < end; start++) {\n    var c = str.charCodeAt(start) - 48;\n    if (c > 9 || c < 0) return false;\n  }\n\n  return true;\n} // TODO: check for \"scientific integers?\"\n\n\nfunction getNumberTypeScientific(str, start, end) {\n  // handle + in '1e+1' separately.\n  if (str.charCodeAt(start) === 43\n  /* + */\n  ) start++;\n  return isInt(str, start, end) ? 2\n  /* Scientific */\n  : 3\n  /* NaN */\n  ;\n}\n/** The whole range must match, otherwise returns NaN */\n\n\nexport function getNumberType(str) {\n  var start = 0;\n  var end = str.length;\n\n  if (str.charCodeAt(start) === 45) {\n    // -\n    ++start;\n  } // string is . or -.\n\n\n  if (str.charCodeAt(start) === 46 && end - start === 1) {\n    return 3\n    /* NaN */\n    ;\n  }\n\n  while (start < end) {\n    var c = str.charCodeAt(start) - 48;\n\n    if (c >= 0 && c < 10) {\n      ++start;\n    } else if (c === -2) {\n      // .\n      ++start;\n      var hasDigit = false;\n\n      while (start < end) {\n        c = str.charCodeAt(start) - 48;\n\n        if (c >= 0 && c < 10) {\n          hasDigit = true;\n          ++start;\n        } else if (c === 53 || c === 21) {\n          // 'e'/'E'\n          return getNumberTypeScientific(str, start + 1, end);\n        } else {\n          return 3\n          /* NaN */\n          ;\n        }\n      }\n\n      return hasDigit ? 1\n      /* Float */\n      : 0\n      /* Int */\n      ;\n    } else if (c === 53 || c === 21) {\n      // 'e'/'E'\n      if (start === 0 || start === 1 && str.charCodeAt(0) === 45) {\n        return 3\n        /* NaN */\n        ; // string starts with e/E or -e/-E\n      }\n\n      return getNumberTypeScientific(str, start + 1, end);\n    } else {\n      break;\n    }\n  }\n\n  return start === end ? 0\n  /* Int */\n  : 3\n  /* NaN */\n  ;\n}","map":{"version":3,"sources":["../../../../../src/mol-io/reader/common/text/number-parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * based in part on https://github.com/dsehnal/CIFTools.js\r\n */\r\n/**\r\n * Efficient integer and float parsers.\r\n *\r\n * For the purposes of parsing numbers from the mmCIF data representations,\r\n * up to 4 times faster than JS parseInt/parseFloat.\r\n */\r\nexport function parseIntSkipLeadingWhitespace(str, start, end) {\r\n    while (start < end && str.charCodeAt(start) === 32)\r\n        start++;\r\n    return parseInt(str, start, end);\r\n}\r\nexport function parseInt(str, start, end) {\r\n    var _start = start, ret = 0, neg = 1;\r\n    if (str.charCodeAt(_start) === 45 /* - */) {\r\n        neg = -1;\r\n        ++_start;\r\n    }\r\n    else if (str.charCodeAt(_start) === 43 /* + */) {\r\n        ++_start;\r\n    }\r\n    for (; _start < end; _start++) {\r\n        var c = str.charCodeAt(_start) - 48;\r\n        if (c > 9 || c < 0)\r\n            return (neg * ret) | 0;\r\n        else\r\n            ret = (10 * ret + c) | 0;\r\n    }\r\n    return neg * ret;\r\n}\r\nfunction parseScientific(main, str, start, end) {\r\n    // handle + in '1e+1' separately.\r\n    if (str.charCodeAt(start) === 43 /* + */)\r\n        start++;\r\n    return main * Math.pow(10.0, parseInt(str, start, end));\r\n}\r\nexport function parseFloatSkipLeadingWhitespace(str, start, end) {\r\n    while (start < end && str.charCodeAt(start) === 32)\r\n        start++;\r\n    return parseFloat(str, start, end);\r\n}\r\nexport function parseFloat(str, start, end) {\r\n    var _start = start, neg = 1.0, ret = 0.0, point = 0.0, div = 1.0;\r\n    if (str.charCodeAt(_start) === 45 /* - */) {\r\n        neg = -1;\r\n        ++_start;\r\n    }\r\n    else if (str.charCodeAt(_start) === 43 /* + */) {\r\n        ++_start;\r\n    }\r\n    while (_start < end) {\r\n        var c = str.charCodeAt(_start) - 48;\r\n        if (c >= 0 && c < 10) {\r\n            ret = ret * 10 + c;\r\n            ++_start;\r\n        }\r\n        else if (c === -2) { // .\r\n            ++_start;\r\n            while (_start < end) {\r\n                c = str.charCodeAt(_start) - 48;\r\n                if (c >= 0 && c < 10) {\r\n                    point = 10.0 * point + c;\r\n                    div = 10.0 * div;\r\n                    ++_start;\r\n                }\r\n                else if (c === 53 || c === 21) { // 'e'/'E'\r\n                    return parseScientific(neg * (ret + point / div), str, _start + 1, end);\r\n                }\r\n                else {\r\n                    return neg * (ret + point / div);\r\n                }\r\n            }\r\n            return neg * (ret + point / div);\r\n        }\r\n        else if (c === 53 || c === 21) { // 'e'/'E'\r\n            return parseScientific(neg * ret, str, _start + 1, end);\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return neg * ret;\r\n}\r\nfunction isInt(str, start, end) {\r\n    if (str.charCodeAt(start) === 45 /* - */) {\r\n        start++;\r\n    }\r\n    for (; start < end; start++) {\r\n        var c = str.charCodeAt(start) - 48;\r\n        if (c > 9 || c < 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n// TODO: check for \"scientific integers?\"\r\nfunction getNumberTypeScientific(str, start, end) {\r\n    // handle + in '1e+1' separately.\r\n    if (str.charCodeAt(start) === 43 /* + */)\r\n        start++;\r\n    return isInt(str, start, end) ? 2 /* Scientific */ : 3 /* NaN */;\r\n}\r\n/** The whole range must match, otherwise returns NaN */\r\nexport function getNumberType(str) {\r\n    var start = 0;\r\n    var end = str.length;\r\n    if (str.charCodeAt(start) === 45) { // -\r\n        ++start;\r\n    }\r\n    // string is . or -.\r\n    if (str.charCodeAt(start) === 46 && end - start === 1) {\r\n        return 3 /* NaN */;\r\n    }\r\n    while (start < end) {\r\n        var c = str.charCodeAt(start) - 48;\r\n        if (c >= 0 && c < 10) {\r\n            ++start;\r\n        }\r\n        else if (c === -2) { // .\r\n            ++start;\r\n            var hasDigit = false;\r\n            while (start < end) {\r\n                c = str.charCodeAt(start) - 48;\r\n                if (c >= 0 && c < 10) {\r\n                    hasDigit = true;\r\n                    ++start;\r\n                }\r\n                else if (c === 53 || c === 21) { // 'e'/'E'\r\n                    return getNumberTypeScientific(str, start + 1, end);\r\n                }\r\n                else {\r\n                    return 3 /* NaN */;\r\n                }\r\n            }\r\n            return hasDigit ? 1 /* Float */ : 0 /* Int */;\r\n        }\r\n        else if (c === 53 || c === 21) { // 'e'/'E'\r\n            if (start === 0 || start === 1 && str.charCodeAt(0) === 45) {\r\n                return 3 /* NaN */; // string starts with e/E or -e/-E\r\n            }\r\n            return getNumberTypeScientific(str, start + 1, end);\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return start === end ? 0 /* Int */ : 3 /* NaN */;\r\n}\r\n//# sourceMappingURL=number-parser.js.map"]},"metadata":{},"sourceType":"module"}