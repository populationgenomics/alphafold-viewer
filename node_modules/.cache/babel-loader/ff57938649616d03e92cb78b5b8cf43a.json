{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { OrderedSet } from '../../../mol-data/int';\nimport { Mat4, Vec3 } from '../../../mol-math/linear-algebra';\nimport { Unit } from '../../../mol-model/structure';\nimport { VdwRadius } from '../../../mol-model/structure/model/properties/atomic';\nimport { StructureLookup3DResultContext } from '../../../mol-model/structure/structure/util/lookup3d';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { altLoc, connectedTo, typeSymbol } from '../chemistry/util';\nimport { Features } from './features';\nexport var ContactsParams = {\n  lineOfSightDistFactor: PD.Numeric(1.0, {\n    min: 0,\n    max: 3,\n    step: 0.1\n  })\n};\nvar MAX_LINE_OF_SIGHT_DISTANCE = 3;\n\nfunction validPair(structure, infoA, infoB) {\n  var indexA = infoA.members[infoA.offsets[infoA.feature]];\n  var indexB = infoB.members[infoB.offsets[infoB.feature]];\n  if (indexA === indexB && infoA.unit === infoB.unit) return false; // no self interaction\n\n  var altA = altLoc(infoA.unit, indexA);\n  var altB = altLoc(infoB.unit, indexB);\n  if (altA && altB && altA !== altB) return false; // incompatible alternate location id\n\n  if (infoA.unit.residueIndex[infoA.unit.elements[indexA]] === infoB.unit.residueIndex[infoB.unit.elements[indexB]] && infoA.unit === infoB.unit) return false; // same residue\n  // e.g. no hbond if donor and acceptor are bonded\n\n  if (connectedTo(structure, infoA.unit, indexA, infoB.unit, indexB)) return false;\n  return true;\n} //\n\n\nfunction invalidAltLoc(unitA, indexA, unitB, indexB) {\n  var altA = altLoc(unitA, indexA);\n  var altB = altLoc(unitB, indexB);\n  return altA && altB && altA !== altB;\n}\n\nfunction isMember(element, info) {\n  var feature = info.feature,\n      offsets = info.offsets,\n      members = info.members;\n\n  for (var i = offsets[feature], il = offsets[feature + 1]; i < il; ++i) {\n    if (members[i] === element) return true;\n  }\n\n  return false;\n}\n\nvar tmpVec = Vec3();\nvar tmpVecA = Vec3();\nvar tmpVecB = Vec3(); // need to use a separate context for structure.lookup3d.find because of nested queries\n\nvar lineOfSightLookupCtx = StructureLookup3DResultContext();\n\nfunction checkLineOfSight(structure, infoA, infoB, distFactor) {\n  var featureA = infoA.feature;\n  var featureB = infoB.feature;\n  var indexA = infoA.members[infoA.offsets[featureA]];\n  var indexB = infoB.members[infoB.offsets[featureB]];\n  Features.position(tmpVecA, infoA);\n  Features.position(tmpVecB, infoB);\n  Vec3.scale(tmpVec, Vec3.add(tmpVec, tmpVecA, tmpVecB), 0.5);\n  var distMax = distFactor * MAX_LINE_OF_SIGHT_DISTANCE;\n\n  var _a = structure.lookup3d.find(tmpVec[0], tmpVec[1], tmpVec[2], distMax, lineOfSightLookupCtx),\n      count = _a.count,\n      indices = _a.indices,\n      units = _a.units,\n      squaredDistances = _a.squaredDistances;\n\n  if (count === 0) return true;\n\n  for (var r = 0; r < count; ++r) {\n    var i = indices[r];\n    var unit = units[r];\n    if (!Unit.isAtomic(unit)) continue;\n    var element = typeSymbol(unit, i); // allow hydrogens\n\n    if (element === \"H\"\n    /* H */\n    ) continue;\n    var vdw = VdwRadius(element); // check distance\n\n    if (vdw * vdw * distFactor * distFactor <= squaredDistances[r]) continue; // allow different altlocs\n\n    if (invalidAltLoc(unit, i, infoA.unit, indexA) || invalidAltLoc(unit, i, infoB.unit, indexB)) continue; // allow member atoms\n\n    if (infoA.unit === unit && isMember(i, infoA) || infoB.unit === unit && isMember(i, infoB)) continue;\n    unit.conformation.position(unit.elements[i], tmpVec); // allow atoms at the center of functional groups\n\n    if (Vec3.squaredDistance(tmpVec, tmpVecA) < 1 || Vec3.squaredDistance(tmpVec, tmpVecB) < 1) continue;\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Add all intra-unit contacts, i.e. pairs of features\r\n */\n\n\nexport function addUnitContacts(structure, unit, features, builder, testers, props) {\n  for (var _i = 0, testers_1 = testers; _i < testers_1.length; _i++) {\n    var tester = testers_1[_i];\n\n    _addUnitContacts(structure, unit, features, builder, tester, props);\n  }\n}\n\nfunction _addUnitContacts(structure, unit, features, builder, tester, props) {\n  var x = features.x,\n      y = features.y,\n      z = features.z;\n\n  var _a = features.subset(tester.requiredFeatures),\n      lookup3d = _a.lookup3d,\n      subsetIndices = _a.indices;\n\n  var infoA = Features.Info(structure, unit, features);\n\n  var infoB = __assign({}, infoA);\n\n  var distFactor = props.lineOfSightDistFactor;\n\n  for (var t = 0, tl = OrderedSet.size(subsetIndices); t < tl; ++t) {\n    var i = OrderedSet.getAt(subsetIndices, t);\n\n    var _b = lookup3d.find(x[i], y[i], z[i], tester.maxDistance),\n        count = _b.count,\n        indices = _b.indices,\n        squaredDistances = _b.squaredDistances;\n\n    if (count === 0) continue;\n    infoA.feature = i;\n\n    for (var r = 0; r < count; ++r) {\n      var j = OrderedSet.getAt(subsetIndices, indices[r]);\n      if (j <= i) continue;\n      infoB.feature = j;\n      if (!validPair(structure, infoA, infoB)) continue;\n      var type = tester.getType(structure, infoA, infoB, squaredDistances[r]);\n\n      if (type && checkLineOfSight(structure, infoA, infoB, distFactor)) {\n        builder.add(i, j, type);\n      }\n    }\n  }\n}\n\nvar _imageTransform = Mat4();\n/**\r\n * Add all inter-unit contacts, i.e. pairs of features\r\n */\n\n\nexport function addStructureContacts(structure, unitA, featuresA, unitB, featuresB, builder, testers, props) {\n  var countA = featuresA.count,\n      xA = featuresA.x,\n      yA = featuresA.y,\n      zA = featuresA.z;\n  var lookup3d = featuresB.lookup3d; // the lookup queries need to happen in the \"unitB space\".\n  // that means imageA = inverseOperB(operA(i))\n\n  var imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);\n  var isNotIdentity = !Mat4.isIdentity(imageTransform);\n  var imageA = Vec3();\n  var maxDistance = Math.max.apply(Math, testers.map(function (t) {\n    return t.maxDistance;\n  }));\n  var _a = lookup3d.boundary.sphere,\n      center = _a.center,\n      radius = _a.radius;\n  var testDistanceSq = (radius + maxDistance) * (radius + maxDistance);\n  var distFactor = props.lineOfSightDistFactor;\n  var infoA = Features.Info(structure, unitA, featuresA);\n  var infoB = Features.Info(structure, unitB, featuresB);\n  builder.startUnitPair(unitA, unitB);\n\n  for (var i = 0; i < countA; ++i) {\n    Vec3.set(imageA, xA[i], yA[i], zA[i]);\n    if (isNotIdentity) Vec3.transformMat4(imageA, imageA, imageTransform);\n    if (Vec3.squaredDistance(imageA, center) > testDistanceSq) continue;\n\n    var _b = lookup3d.find(imageA[0], imageA[1], imageA[2], maxDistance),\n        indices = _b.indices,\n        count = _b.count,\n        squaredDistances = _b.squaredDistances;\n\n    if (count === 0) continue;\n    infoA.feature = i;\n\n    for (var r = 0; r < count; ++r) {\n      var j = indices[r];\n      infoB.feature = j;\n      if (!validPair(structure, infoA, infoB)) continue;\n      var distanceSq = squaredDistances[r];\n\n      for (var _i = 0, testers_2 = testers; _i < testers_2.length; _i++) {\n        var tester = testers_2[_i];\n\n        if (distanceSq < tester.maxDistance * tester.maxDistance) {\n          var type = tester.getType(structure, infoA, infoB, distanceSq);\n\n          if (type && checkLineOfSight(structure, infoA, infoB, distFactor)) {\n            builder.add(i, j, type);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  builder.finishUnitPair();\n}","map":{"version":3,"sources":["../../../../src/mol-model-props/computed/interactions/contacts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { OrderedSet } from '../../../mol-data/int';\r\nimport { Mat4, Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { Unit } from '../../../mol-model/structure';\r\nimport { VdwRadius } from '../../../mol-model/structure/model/properties/atomic';\r\nimport { StructureLookup3DResultContext } from '../../../mol-model/structure/structure/util/lookup3d';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { altLoc, connectedTo, typeSymbol } from '../chemistry/util';\r\nimport { Features } from './features';\r\nexport var ContactsParams = {\r\n    lineOfSightDistFactor: PD.Numeric(1.0, { min: 0, max: 3, step: 0.1 }),\r\n};\r\nvar MAX_LINE_OF_SIGHT_DISTANCE = 3;\r\nfunction validPair(structure, infoA, infoB) {\r\n    var indexA = infoA.members[infoA.offsets[infoA.feature]];\r\n    var indexB = infoB.members[infoB.offsets[infoB.feature]];\r\n    if (indexA === indexB && infoA.unit === infoB.unit)\r\n        return false; // no self interaction\r\n    var altA = altLoc(infoA.unit, indexA);\r\n    var altB = altLoc(infoB.unit, indexB);\r\n    if (altA && altB && altA !== altB)\r\n        return false; // incompatible alternate location id\r\n    if (infoA.unit.residueIndex[infoA.unit.elements[indexA]] === infoB.unit.residueIndex[infoB.unit.elements[indexB]] && infoA.unit === infoB.unit)\r\n        return false; // same residue\r\n    // e.g. no hbond if donor and acceptor are bonded\r\n    if (connectedTo(structure, infoA.unit, indexA, infoB.unit, indexB))\r\n        return false;\r\n    return true;\r\n}\r\n//\r\nfunction invalidAltLoc(unitA, indexA, unitB, indexB) {\r\n    var altA = altLoc(unitA, indexA);\r\n    var altB = altLoc(unitB, indexB);\r\n    return altA && altB && altA !== altB;\r\n}\r\nfunction isMember(element, info) {\r\n    var feature = info.feature, offsets = info.offsets, members = info.members;\r\n    for (var i = offsets[feature], il = offsets[feature + 1]; i < il; ++i) {\r\n        if (members[i] === element)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nvar tmpVec = Vec3();\r\nvar tmpVecA = Vec3();\r\nvar tmpVecB = Vec3();\r\n// need to use a separate context for structure.lookup3d.find because of nested queries\r\nvar lineOfSightLookupCtx = StructureLookup3DResultContext();\r\nfunction checkLineOfSight(structure, infoA, infoB, distFactor) {\r\n    var featureA = infoA.feature;\r\n    var featureB = infoB.feature;\r\n    var indexA = infoA.members[infoA.offsets[featureA]];\r\n    var indexB = infoB.members[infoB.offsets[featureB]];\r\n    Features.position(tmpVecA, infoA);\r\n    Features.position(tmpVecB, infoB);\r\n    Vec3.scale(tmpVec, Vec3.add(tmpVec, tmpVecA, tmpVecB), 0.5);\r\n    var distMax = distFactor * MAX_LINE_OF_SIGHT_DISTANCE;\r\n    var _a = structure.lookup3d.find(tmpVec[0], tmpVec[1], tmpVec[2], distMax, lineOfSightLookupCtx), count = _a.count, indices = _a.indices, units = _a.units, squaredDistances = _a.squaredDistances;\r\n    if (count === 0)\r\n        return true;\r\n    for (var r = 0; r < count; ++r) {\r\n        var i = indices[r];\r\n        var unit = units[r];\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        var element = typeSymbol(unit, i);\r\n        // allow hydrogens\r\n        if (element === \"H\" /* H */)\r\n            continue;\r\n        var vdw = VdwRadius(element);\r\n        // check distance\r\n        if (vdw * vdw * distFactor * distFactor <= squaredDistances[r])\r\n            continue;\r\n        // allow different altlocs\r\n        if (invalidAltLoc(unit, i, infoA.unit, indexA) || invalidAltLoc(unit, i, infoB.unit, indexB))\r\n            continue;\r\n        // allow member atoms\r\n        if ((infoA.unit === unit && isMember(i, infoA)) || (infoB.unit === unit && isMember(i, infoB)))\r\n            continue;\r\n        unit.conformation.position(unit.elements[i], tmpVec);\r\n        // allow atoms at the center of functional groups\r\n        if (Vec3.squaredDistance(tmpVec, tmpVecA) < 1 || Vec3.squaredDistance(tmpVec, tmpVecB) < 1)\r\n            continue;\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Add all intra-unit contacts, i.e. pairs of features\r\n */\r\nexport function addUnitContacts(structure, unit, features, builder, testers, props) {\r\n    for (var _i = 0, testers_1 = testers; _i < testers_1.length; _i++) {\r\n        var tester = testers_1[_i];\r\n        _addUnitContacts(structure, unit, features, builder, tester, props);\r\n    }\r\n}\r\nfunction _addUnitContacts(structure, unit, features, builder, tester, props) {\r\n    var x = features.x, y = features.y, z = features.z;\r\n    var _a = features.subset(tester.requiredFeatures), lookup3d = _a.lookup3d, subsetIndices = _a.indices;\r\n    var infoA = Features.Info(structure, unit, features);\r\n    var infoB = __assign({}, infoA);\r\n    var distFactor = props.lineOfSightDistFactor;\r\n    for (var t = 0, tl = OrderedSet.size(subsetIndices); t < tl; ++t) {\r\n        var i = OrderedSet.getAt(subsetIndices, t);\r\n        var _b = lookup3d.find(x[i], y[i], z[i], tester.maxDistance), count = _b.count, indices = _b.indices, squaredDistances = _b.squaredDistances;\r\n        if (count === 0)\r\n            continue;\r\n        infoA.feature = i;\r\n        for (var r = 0; r < count; ++r) {\r\n            var j = OrderedSet.getAt(subsetIndices, indices[r]);\r\n            if (j <= i)\r\n                continue;\r\n            infoB.feature = j;\r\n            if (!validPair(structure, infoA, infoB))\r\n                continue;\r\n            var type = tester.getType(structure, infoA, infoB, squaredDistances[r]);\r\n            if (type && checkLineOfSight(structure, infoA, infoB, distFactor)) {\r\n                builder.add(i, j, type);\r\n            }\r\n        }\r\n    }\r\n}\r\nvar _imageTransform = Mat4();\r\n/**\r\n * Add all inter-unit contacts, i.e. pairs of features\r\n */\r\nexport function addStructureContacts(structure, unitA, featuresA, unitB, featuresB, builder, testers, props) {\r\n    var countA = featuresA.count, xA = featuresA.x, yA = featuresA.y, zA = featuresA.z;\r\n    var lookup3d = featuresB.lookup3d;\r\n    // the lookup queries need to happen in the \"unitB space\".\r\n    // that means imageA = inverseOperB(operA(i))\r\n    var imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);\r\n    var isNotIdentity = !Mat4.isIdentity(imageTransform);\r\n    var imageA = Vec3();\r\n    var maxDistance = Math.max.apply(Math, testers.map(function (t) { return t.maxDistance; }));\r\n    var _a = lookup3d.boundary.sphere, center = _a.center, radius = _a.radius;\r\n    var testDistanceSq = (radius + maxDistance) * (radius + maxDistance);\r\n    var distFactor = props.lineOfSightDistFactor;\r\n    var infoA = Features.Info(structure, unitA, featuresA);\r\n    var infoB = Features.Info(structure, unitB, featuresB);\r\n    builder.startUnitPair(unitA, unitB);\r\n    for (var i = 0; i < countA; ++i) {\r\n        Vec3.set(imageA, xA[i], yA[i], zA[i]);\r\n        if (isNotIdentity)\r\n            Vec3.transformMat4(imageA, imageA, imageTransform);\r\n        if (Vec3.squaredDistance(imageA, center) > testDistanceSq)\r\n            continue;\r\n        var _b = lookup3d.find(imageA[0], imageA[1], imageA[2], maxDistance), indices = _b.indices, count = _b.count, squaredDistances = _b.squaredDistances;\r\n        if (count === 0)\r\n            continue;\r\n        infoA.feature = i;\r\n        for (var r = 0; r < count; ++r) {\r\n            var j = indices[r];\r\n            infoB.feature = j;\r\n            if (!validPair(structure, infoA, infoB))\r\n                continue;\r\n            var distanceSq = squaredDistances[r];\r\n            for (var _i = 0, testers_2 = testers; _i < testers_2.length; _i++) {\r\n                var tester = testers_2[_i];\r\n                if (distanceSq < tester.maxDistance * tester.maxDistance) {\r\n                    var type = tester.getType(structure, infoA, infoB, distanceSq);\r\n                    if (type && checkLineOfSight(structure, infoA, infoB, distFactor)) {\r\n                        builder.add(i, j, type);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    builder.finishUnitPair();\r\n}\r\n//# sourceMappingURL=contacts.js.map"]},"metadata":{},"sourceType":"module"}