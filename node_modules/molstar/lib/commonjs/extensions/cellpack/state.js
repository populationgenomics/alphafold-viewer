"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructureFromAssemblies = exports.StructureFromCellpack = exports.ParseCellPack = exports.CellPack = exports.DefaultCellPackBaseUrl = void 0;
var tslib_1 = require("tslib");
var objects_1 = require("../../mol-plugin-state/objects");
var param_definition_1 = require("../../mol-util/param-definition");
var mol_task_1 = require("../../mol-task");
var model_1 = require("./model");
var property_1 = require("./property");
var structure_1 = require("../../mol-model/structure");
var symmetry_1 = require("../../mol-model-formats/structure/property/symmetry");
exports.DefaultCellPackBaseUrl = 'https://mesoscope.scripps.edu/data/cellPACK_data/cellPACK_database_1.1.0/';
var CellPack = /** @class */ (function (_super) {
    (0, tslib_1.__extends)(CellPack, _super);
    function CellPack() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CellPack;
}(objects_1.PluginStateObject.Create({ name: 'CellPack', typeClass: 'Object' })));
exports.CellPack = CellPack;
var ParseCellPack = objects_1.PluginStateTransform.BuiltIn({
    name: 'parse-cellpack',
    display: { name: 'Parse CellPack', description: 'Parse CellPack from JSON data' },
    from: objects_1.PluginStateObject.Format.Json,
    to: CellPack
})({
    apply: function (_a) {
        var _this = this;
        var a = _a.a;
        return mol_task_1.Task.create('Parse CellPack', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var cell, packings, compartments, cytoplasme, name_1, _a, surface, interior;
            return (0, tslib_1.__generator)(this, function (_b) {
                cell = a.data;
                packings = [];
                compartments = cell.compartments, cytoplasme = cell.cytoplasme;
                if (compartments) {
                    for (name_1 in compartments) {
                        _a = compartments[name_1], surface = _a.surface, interior = _a.interior;
                        if (surface)
                            packings.push({ name: name_1, location: 'surface', ingredients: surface.ingredients });
                        if (interior)
                            packings.push({ name: name_1, location: 'interior', ingredients: interior.ingredients });
                    }
                }
                if (cytoplasme)
                    packings.push({ name: 'Cytoplasme', location: 'cytoplasme', ingredients: cytoplasme.ingredients });
                return [2 /*return*/, new CellPack({ cell: cell, packings: packings })];
            });
        }); });
    }
});
exports.ParseCellPack = ParseCellPack;
var StructureFromCellpack = objects_1.PluginStateTransform.BuiltIn({
    name: 'structure-from-cellpack',
    display: { name: 'Structure from CellPack', description: 'Create Structure from CellPack Packing' },
    from: CellPack,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: function (a) {
        var options = a ? a.data.packings.map(function (d, i) { return [i, d.name]; }) : [];
        return {
            packing: param_definition_1.ParamDefinition.Select(0, options),
            baseUrl: param_definition_1.ParamDefinition.Text(exports.DefaultCellPackBaseUrl),
            ingredientFiles: param_definition_1.ParamDefinition.FileList({ accept: '.cif,.bcif,.pdb' })
        };
    }
})({
    apply: function (_a, plugin) {
        var _this = this;
        var a = _a.a, params = _a.params, cache = _a.cache;
        return mol_task_1.Task.create('Structure from CellPack', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var packing, ingredientFiles, _i, _a, file, _b, structure, assets, colors;
            return (0, tslib_1.__generator)(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        packing = a.data.packings[params.packing];
                        ingredientFiles = {};
                        if (params.ingredientFiles !== null) {
                            for (_i = 0, _a = params.ingredientFiles; _i < _a.length; _i++) {
                                file = _a[_i];
                                ingredientFiles[file.name] = file;
                            }
                        }
                        return [4 /*yield*/, (0, model_1.createStructureFromCellPack)(plugin, packing, params.baseUrl, ingredientFiles).runInContext(ctx)];
                    case 1:
                        _b = _c.sent(), structure = _b.structure, assets = _b.assets, colors = _b.colors;
                        return [4 /*yield*/, property_1.CellPackInfoProvider.attach({ runtime: ctx, assetManager: plugin.managers.asset }, structure, {
                                info: { packingsCount: a.data.packings.length, packingIndex: params.packing, colors: colors }
                            })];
                    case 2:
                        _c.sent();
                        cache.assets = assets;
                        return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(structure, { label: packing.name })];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b, cache = _a.cache;
        var assets = cache.assets;
        if (assets) {
            for (var _i = 0, assets_1 = assets; _i < assets_1.length; _i++) {
                var a = assets_1[_i];
                a.dispose();
            }
        }
        if (b) {
            b.data.customPropertyDescriptors.dispose();
            for (var _b = 0, _c = b.data.models; _b < _c.length; _b++) {
                var m = _c[_b];
                m.customProperties.dispose();
            }
        }
    }
});
exports.StructureFromCellpack = StructureFromCellpack;
var StructureFromAssemblies = objects_1.PluginStateTransform.BuiltIn({
    name: 'Structure from all assemblies',
    display: { name: 'Structure from all assemblies' },
    from: objects_1.PluginStateObject.Molecule.Model,
    to: objects_1.PluginStateObject.Molecule.Structure,
    params: {}
})({
    canAutoUpdate: function (_a) {
        var newParams = _a.newParams;
        return true;
    },
    apply: function (_a) {
        var _this = this;
        var a = _a.a, params = _a.params;
        return mol_task_1.Task.create('Build Structure', function (ctx) { return (0, tslib_1.__awaiter)(_this, void 0, void 0, function () {
            var model, initial_structure, structures, structure, symmetry, _i, _a, a_1, s, builder, offsetInvariantId, _b, structures_1, s, maxInvariantId, _c, _d, u, invariantId, i, il;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        model = a.data;
                        initial_structure = structure_1.Structure.ofModel(model);
                        structures = [];
                        structure = initial_structure;
                        symmetry = symmetry_1.ModelSymmetry.Provider.get(model);
                        if (!(symmetry && symmetry.assemblies.length !== 0)) return [3 /*break*/, 5];
                        _i = 0, _a = symmetry.assemblies;
                        _e.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        a_1 = _a[_i];
                        return [4 /*yield*/, structure_1.StructureSymmetry.buildAssembly(initial_structure, a_1.id).runInContext(ctx)];
                    case 2:
                        s = _e.sent();
                        structures.push(s);
                        _e.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        builder = structure_1.Structure.Builder();
                        offsetInvariantId = 0;
                        for (_b = 0, structures_1 = structures; _b < structures_1.length; _b++) {
                            s = structures_1[_b];
                            maxInvariantId = 0;
                            for (_c = 0, _d = s.units; _c < _d.length; _c++) {
                                u = _d[_c];
                                invariantId = u.invariantId + offsetInvariantId;
                                if (u.invariantId > maxInvariantId)
                                    maxInvariantId = u.invariantId;
                                builder.addUnit(u.kind, u.model, u.conformation.operator, u.elements, 0 /* None */, invariantId);
                            }
                            offsetInvariantId += maxInvariantId + 1;
                        }
                        structure = builder.getStructure();
                        for (i = 0, il = structure.models.length; i < il; ++i) {
                            structure_1.Model.TrajectoryInfo.set(structure.models[i], { size: il, index: i });
                        }
                        _e.label = 5;
                    case 5: return [2 /*return*/, new objects_1.PluginStateObject.Molecule.Structure(structure, { label: a.label, description: "" + a.description })];
                }
            });
        }); });
    },
    dispose: function (_a) {
        var b = _a.b;
        b === null || b === void 0 ? void 0 : b.data.customPropertyDescriptors.dispose();
    }
});
exports.StructureFromAssemblies = StructureFromAssemblies;
//# sourceMappingURL=state.js.map