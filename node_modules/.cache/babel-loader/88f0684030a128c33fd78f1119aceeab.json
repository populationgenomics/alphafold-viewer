{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * Adapted from LiteMol\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task } from '../mol-task';\nimport { unzip, ungzip } from './zip/zip';\nimport { utf8Read } from '../mol-io/common/utf8';\nimport { Asset } from './assets'; // polyfill XMLHttpRequest in node.js\n\nvar XHR = typeof document === 'undefined' ? require('xhr2') : XMLHttpRequest;\nexport var DataCompressionMethod;\n\n(function (DataCompressionMethod) {\n  DataCompressionMethod[DataCompressionMethod[\"None\"] = 0] = \"None\";\n  DataCompressionMethod[DataCompressionMethod[\"Gzip\"] = 1] = \"Gzip\";\n  DataCompressionMethod[DataCompressionMethod[\"Zip\"] = 2] = \"Zip\";\n})(DataCompressionMethod || (DataCompressionMethod = {}));\n\nexport function readStringFromFile(file) {\n  return readFromFileInternal(file, 'string');\n}\nexport function readUint8ArrayFromFile(file) {\n  return readFromFileInternal(file, 'binary');\n}\nexport function readFromFile(file, type) {\n  return readFromFileInternal(file, type);\n}\nexport function ajaxGet(params) {\n  if (typeof params === 'string') return ajaxGetInternal(params, params, 'string');\n  return ajaxGetInternal(params.title, params.url, params.type || 'string', params.body, params.headers);\n}\n\nfunction isDone(data) {\n  if (data instanceof FileReader) {\n    return data.readyState === FileReader.DONE;\n  } else if (data instanceof XMLHttpRequest) {\n    return data.readyState === XMLHttpRequest.DONE;\n  }\n\n  throw new Error('unknown data type');\n}\n\nfunction genericError(isDownload) {\n  if (isDownload) return 'Failed to download data. Possible reasons: Resource is not available, or CORS is not allowed on the server.';\n  return 'Failed to open file.';\n}\n\nfunction readData(ctx, action, data) {\n  return new Promise(function (resolve, reject) {\n    // first check if data reading is already done\n    if (isDone(data)) {\n      var error = data.error;\n\n      if (error !== null && error !== undefined) {\n        reject(error !== null && error !== void 0 ? error : genericError(data instanceof XMLHttpRequest));\n      } else {\n        resolve(data);\n      }\n\n      return;\n    }\n\n    var hasError = false;\n\n    data.onerror = function (e) {\n      if (hasError) return;\n      var error = e.target.error;\n      reject(error !== null && error !== void 0 ? error : genericError(data instanceof XMLHttpRequest));\n    };\n\n    data.onprogress = function (e) {\n      if (!ctx.shouldUpdate || hasError) return;\n\n      try {\n        if (e.lengthComputable) {\n          ctx.update({\n            message: action,\n            isIndeterminate: false,\n            current: e.loaded,\n            max: e.total\n          });\n        } else {\n          ctx.update({\n            message: action + \" \" + (e.loaded / 1024 / 1024).toFixed(2) + \" MB\",\n            isIndeterminate: true\n          });\n        }\n      } catch (e) {\n        hasError = true;\n        reject(e);\n      }\n    };\n\n    data.onload = function (e) {\n      resolve(data);\n    };\n  });\n}\n\nfunction getCompression(name) {\n  return /\\.gz$/i.test(name) ? DataCompressionMethod.Gzip : /\\.zip$/i.test(name) ? DataCompressionMethod.Zip : DataCompressionMethod.None;\n}\n\nfunction decompress(ctx, data, compression) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, parsed, names;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          _a = compression;\n\n          switch (_a) {\n            case DataCompressionMethod.None:\n              return [3\n              /*break*/\n              , 1];\n\n            case DataCompressionMethod.Gzip:\n              return [3\n              /*break*/\n              , 2];\n\n            case DataCompressionMethod.Zip:\n              return [3\n              /*break*/\n              , 3];\n          }\n\n          return [3\n          /*break*/\n          , 5];\n\n        case 1:\n          return [2\n          /*return*/\n          , data];\n\n        case 2:\n          return [2\n          /*return*/\n          , ungzip(ctx, data)];\n\n        case 3:\n          return [4\n          /*yield*/\n          , unzip(ctx, data.buffer)];\n\n        case 4:\n          parsed = _b.sent();\n          names = Object.keys(parsed);\n          if (names.length !== 1) throw new Error('can only decompress zip files with a single entry');\n          return [2\n          /*return*/\n          , parsed[names[0]]];\n\n        case 5:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction processFile(ctx, reader, type, compression) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, data, decompressed, parser;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          result = reader.result;\n          data = result instanceof ArrayBuffer ? new Uint8Array(result) : result;\n          if (data === null) throw new Error('no data given');\n          if (!(compression !== DataCompressionMethod.None)) return [3\n          /*break*/\n          , 4];\n          if (!(data instanceof Uint8Array)) throw new Error('need Uint8Array for decompression');\n          return [4\n          /*yield*/\n          , decompress(ctx, data, compression)];\n\n        case 1:\n          decompressed = _a.sent();\n          if (!(type === 'string')) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , ctx.update({\n            message: 'Decoding text...'\n          })];\n\n        case 2:\n          _a.sent();\n\n          data = utf8Read(decompressed, 0, decompressed.length);\n          return [3\n          /*break*/\n          , 4];\n\n        case 3:\n          data = decompressed;\n          _a.label = 4;\n\n        case 4:\n          if (!(type === 'binary' && data instanceof Uint8Array)) return [3\n          /*break*/\n          , 5];\n          return [2\n          /*return*/\n          , data];\n\n        case 5:\n          if (!(type === 'zip' && data instanceof Uint8Array)) return [3\n          /*break*/\n          , 7];\n          return [4\n          /*yield*/\n          , unzip(ctx, data.buffer)];\n\n        case 6:\n          return [2\n          /*return*/\n          , _a.sent()];\n\n        case 7:\n          if (type === 'string' && typeof data === 'string') {\n            return [2\n            /*return*/\n            , data];\n          } else if (type === 'xml' && typeof data === 'string') {\n            parser = new DOMParser();\n            return [2\n            /*return*/\n            , parser.parseFromString(data, 'application/xml')];\n          } else if (type === 'json' && typeof data === 'string') {\n            return [2\n            /*return*/\n            , JSON.parse(data)];\n          }\n\n          _a.label = 8;\n\n        case 8:\n          throw new Error(\"could not get requested response data '\" + type + \"'\");\n      }\n    });\n  });\n}\n\nfunction readFromFileInternal(file, type) {\n  var _this = this;\n\n  var reader = void 0;\n  return Task.create('Read File', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var compression, fileReader;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0,, 5, 6]);\n\n            reader = new FileReader();\n            compression = type === 'zip' ? DataCompressionMethod.None : getCompression(file.name);\n\n            if (type === 'binary' || type === 'zip' || compression !== DataCompressionMethod.None) {\n              reader.readAsArrayBuffer(file);\n            } else {\n              reader.readAsText(file);\n            }\n\n            return [4\n            /*yield*/\n            , ctx.update({\n              message: 'Opening file...',\n              canAbort: true\n            })];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , readData(ctx, 'Reading...', reader)];\n\n          case 2:\n            fileReader = _a.sent();\n            return [4\n            /*yield*/\n            , ctx.update({\n              message: 'Processing file...',\n              canAbort: false\n            })];\n\n          case 3:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , processFile(ctx, fileReader, type, compression)];\n\n          case 4:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 5:\n            reader = void 0;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }, function () {\n    if (reader) reader.abort();\n  });\n}\n\nvar RequestPool =\n/** @class */\nfunction () {\n  function RequestPool() {}\n\n  RequestPool.get = function () {\n    if (this.pool.length) {\n      return this.pool.pop();\n    }\n\n    return new XHR();\n  };\n\n  RequestPool.emptyFunc = function () {};\n\n  RequestPool.deposit = function (req) {\n    if (this.pool.length < this.poolSize) {\n      req.onabort = RequestPool.emptyFunc;\n      req.onerror = RequestPool.emptyFunc;\n      req.onload = RequestPool.emptyFunc;\n      req.onprogress = RequestPool.emptyFunc;\n      this.pool.push(req);\n    }\n  };\n\n  RequestPool.pool = [];\n  RequestPool.poolSize = 15;\n  return RequestPool;\n}();\n\nfunction processAjax(req, type) {\n  if (req.status >= 200 && req.status < 400) {\n    var response = req.response;\n    RequestPool.deposit(req);\n\n    if ((type === 'binary' || type === 'zip') && response instanceof ArrayBuffer) {\n      return new Uint8Array(response);\n    } else if (type === 'string' && typeof response === 'string') {\n      return response;\n    } else if (type === 'xml' && response instanceof XMLDocument) {\n      return response;\n    } else if (type === 'json' && typeof response === 'object') {\n      return response;\n    }\n\n    throw new Error(\"could not get requested response data '\" + type + \"'\");\n  } else {\n    RequestPool.deposit(req);\n    throw new Error(\"Download failed with status code \" + req.status);\n  }\n}\n\nfunction getRequestResponseType(type) {\n  switch (type) {\n    case 'json':\n      return 'json';\n\n    case 'xml':\n      return 'document';\n\n    case 'string':\n      return 'text';\n\n    case 'binary':\n      return 'arraybuffer';\n\n    case 'zip':\n      return 'arraybuffer';\n  }\n}\n\nfunction ajaxGetInternal(title, url, type, body, headers) {\n  var _this = this;\n\n  var xhttp = void 0;\n  return Task.create(title ? title : 'Download', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var _a, headers_1, _b, name_1, value, req, result;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            xhttp = RequestPool.get();\n            xhttp.open(body ? 'post' : 'get', url, true);\n\n            if (headers) {\n              for (_a = 0, headers_1 = headers; _a < headers_1.length; _a++) {\n                _b = headers_1[_a], name_1 = _b[0], value = _b[1];\n                xhttp.setRequestHeader(name_1, value);\n              }\n            }\n\n            xhttp.responseType = getRequestResponseType(type);\n            xhttp.send(body);\n            return [4\n            /*yield*/\n            , ctx.update({\n              message: 'Waiting for server...',\n              canAbort: true\n            })];\n\n          case 1:\n            _c.sent();\n\n            return [4\n            /*yield*/\n            , readData(ctx, 'Downloading...', xhttp)];\n\n          case 2:\n            req = _c.sent();\n            xhttp = void 0; // guard against reuse, help garbage collector\n\n            return [4\n            /*yield*/\n            , ctx.update({\n              message: 'Parsing response...',\n              canAbort: false\n            })];\n\n          case 3:\n            _c.sent();\n\n            result = processAjax(req, type);\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  }, function () {\n    if (xhttp) {\n      xhttp.abort();\n      xhttp = void 0; // guard against reuse, help garbage collector\n    }\n  });\n}\n\nexport function ajaxGetMany(ctx, assetManager, sources, maxConcurrency) {\n  return __awaiter(this, void 0, void 0, function () {\n    var len, slots, promises, promiseKeys, currentSrc, _i, current, done, r, src, idx, current, asset;\n\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          len = sources.length;\n          slots = new Array(sources.length);\n          return [4\n          /*yield*/\n          , ctx.update({\n            message: 'Downloading...',\n            current: 0,\n            max: len\n          })];\n\n        case 1:\n          _a.sent();\n\n          promises = [], promiseKeys = [];\n          currentSrc = 0;\n\n          for (_i = Math.min(len, maxConcurrency); currentSrc < _i; currentSrc++) {\n            current = sources[currentSrc];\n            promises.push(wrapPromise(currentSrc, current.id, assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? 'binary' : 'string').runAsChild(ctx)));\n            promiseKeys.push(currentSrc);\n          }\n\n          done = 0;\n          _a.label = 2;\n\n        case 2:\n          if (!(promises.length > 0)) return [3\n          /*break*/\n          , 6];\n          return [4\n          /*yield*/\n          , Promise.race(promises)];\n\n        case 3:\n          r = _a.sent();\n          src = sources[r.index];\n          idx = promiseKeys.indexOf(r.index);\n          done++;\n\n          if (r.kind === 'error' && !src.canFail) {\n            // TODO: cancel other downloads\n            throw new Error(src.url + \": \" + r.error);\n          }\n\n          if (!ctx.shouldUpdate) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , ctx.update({\n            message: 'Downloading...',\n            current: done,\n            max: len\n          })];\n\n        case 4:\n          _a.sent();\n\n          _a.label = 5;\n\n        case 5:\n          slots[r.index] = r;\n          promises = promises.filter(_filterRemoveIndex, idx);\n          promiseKeys = promiseKeys.filter(_filterRemoveIndex, idx);\n\n          if (currentSrc < len) {\n            current = sources[currentSrc];\n            asset = assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? 'binary' : 'string').runAsChild(ctx);\n            promises.push(wrapPromise(currentSrc, current.id, asset));\n            promiseKeys.push(currentSrc);\n            currentSrc++;\n          }\n\n          return [3\n          /*break*/\n          , 2];\n\n        case 6:\n          return [2\n          /*return*/\n          , slots];\n      }\n    });\n  });\n}\n\nfunction _filterRemoveIndex(_, i) {\n  return this !== i;\n}\n\nfunction wrapPromise(index, id, p) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, error_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 2,, 3]);\n\n          return [4\n          /*yield*/\n          , p];\n\n        case 1:\n          result = _a.sent();\n          return [2\n          /*return*/\n          , {\n            kind: 'ok',\n            result: result,\n            index: index,\n            id: id\n          }];\n\n        case 2:\n          error_1 = _a.sent();\n          return [2\n          /*return*/\n          , {\n            kind: 'error',\n            error: error_1,\n            index: index,\n            id: id\n          }];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../src/mol-util/data-source.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n *\r\n * Adapted from LiteMol\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../mol-task';\r\nimport { unzip, ungzip } from './zip/zip';\r\nimport { utf8Read } from '../mol-io/common/utf8';\r\nimport { Asset } from './assets';\r\n// polyfill XMLHttpRequest in node.js\r\nvar XHR = typeof document === 'undefined' ? require('xhr2') : XMLHttpRequest;\r\nexport var DataCompressionMethod;\r\n(function (DataCompressionMethod) {\r\n    DataCompressionMethod[DataCompressionMethod[\"None\"] = 0] = \"None\";\r\n    DataCompressionMethod[DataCompressionMethod[\"Gzip\"] = 1] = \"Gzip\";\r\n    DataCompressionMethod[DataCompressionMethod[\"Zip\"] = 2] = \"Zip\";\r\n})(DataCompressionMethod || (DataCompressionMethod = {}));\r\nexport function readStringFromFile(file) {\r\n    return readFromFileInternal(file, 'string');\r\n}\r\nexport function readUint8ArrayFromFile(file) {\r\n    return readFromFileInternal(file, 'binary');\r\n}\r\nexport function readFromFile(file, type) {\r\n    return readFromFileInternal(file, type);\r\n}\r\nexport function ajaxGet(params) {\r\n    if (typeof params === 'string')\r\n        return ajaxGetInternal(params, params, 'string');\r\n    return ajaxGetInternal(params.title, params.url, params.type || 'string', params.body, params.headers);\r\n}\r\nfunction isDone(data) {\r\n    if (data instanceof FileReader) {\r\n        return data.readyState === FileReader.DONE;\r\n    }\r\n    else if (data instanceof XMLHttpRequest) {\r\n        return data.readyState === XMLHttpRequest.DONE;\r\n    }\r\n    throw new Error('unknown data type');\r\n}\r\nfunction genericError(isDownload) {\r\n    if (isDownload)\r\n        return 'Failed to download data. Possible reasons: Resource is not available, or CORS is not allowed on the server.';\r\n    return 'Failed to open file.';\r\n}\r\nfunction readData(ctx, action, data) {\r\n    return new Promise(function (resolve, reject) {\r\n        // first check if data reading is already done\r\n        if (isDone(data)) {\r\n            var error = data.error;\r\n            if (error !== null && error !== undefined) {\r\n                reject(error !== null && error !== void 0 ? error : genericError(data instanceof XMLHttpRequest));\r\n            }\r\n            else {\r\n                resolve(data);\r\n            }\r\n            return;\r\n        }\r\n        var hasError = false;\r\n        data.onerror = function (e) {\r\n            if (hasError)\r\n                return;\r\n            var error = e.target.error;\r\n            reject(error !== null && error !== void 0 ? error : genericError(data instanceof XMLHttpRequest));\r\n        };\r\n        data.onprogress = function (e) {\r\n            if (!ctx.shouldUpdate || hasError)\r\n                return;\r\n            try {\r\n                if (e.lengthComputable) {\r\n                    ctx.update({ message: action, isIndeterminate: false, current: e.loaded, max: e.total });\r\n                }\r\n                else {\r\n                    ctx.update({ message: action + \" \" + (e.loaded / 1024 / 1024).toFixed(2) + \" MB\", isIndeterminate: true });\r\n                }\r\n            }\r\n            catch (e) {\r\n                hasError = true;\r\n                reject(e);\r\n            }\r\n        };\r\n        data.onload = function (e) {\r\n            resolve(data);\r\n        };\r\n    });\r\n}\r\nfunction getCompression(name) {\r\n    return /\\.gz$/i.test(name) ? DataCompressionMethod.Gzip :\r\n        /\\.zip$/i.test(name) ? DataCompressionMethod.Zip :\r\n            DataCompressionMethod.None;\r\n}\r\nfunction decompress(ctx, data, compression) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, parsed, names;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0:\r\n                    _a = compression;\r\n                    switch (_a) {\r\n                        case DataCompressionMethod.None: return [3 /*break*/, 1];\r\n                        case DataCompressionMethod.Gzip: return [3 /*break*/, 2];\r\n                        case DataCompressionMethod.Zip: return [3 /*break*/, 3];\r\n                    }\r\n                    return [3 /*break*/, 5];\r\n                case 1: return [2 /*return*/, data];\r\n                case 2: return [2 /*return*/, ungzip(ctx, data)];\r\n                case 3: return [4 /*yield*/, unzip(ctx, data.buffer)];\r\n                case 4:\r\n                    parsed = _b.sent();\r\n                    names = Object.keys(parsed);\r\n                    if (names.length !== 1)\r\n                        throw new Error('can only decompress zip files with a single entry');\r\n                    return [2 /*return*/, parsed[names[0]]];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction processFile(ctx, reader, type, compression) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var result, data, decompressed, parser;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    result = reader.result;\r\n                    data = result instanceof ArrayBuffer ? new Uint8Array(result) : result;\r\n                    if (data === null)\r\n                        throw new Error('no data given');\r\n                    if (!(compression !== DataCompressionMethod.None)) return [3 /*break*/, 4];\r\n                    if (!(data instanceof Uint8Array))\r\n                        throw new Error('need Uint8Array for decompression');\r\n                    return [4 /*yield*/, decompress(ctx, data, compression)];\r\n                case 1:\r\n                    decompressed = _a.sent();\r\n                    if (!(type === 'string')) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, ctx.update({ message: 'Decoding text...' })];\r\n                case 2:\r\n                    _a.sent();\r\n                    data = utf8Read(decompressed, 0, decompressed.length);\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    data = decompressed;\r\n                    _a.label = 4;\r\n                case 4:\r\n                    if (!(type === 'binary' && data instanceof Uint8Array)) return [3 /*break*/, 5];\r\n                    return [2 /*return*/, data];\r\n                case 5:\r\n                    if (!(type === 'zip' && data instanceof Uint8Array)) return [3 /*break*/, 7];\r\n                    return [4 /*yield*/, unzip(ctx, data.buffer)];\r\n                case 6: return [2 /*return*/, _a.sent()];\r\n                case 7:\r\n                    if (type === 'string' && typeof data === 'string') {\r\n                        return [2 /*return*/, data];\r\n                    }\r\n                    else if (type === 'xml' && typeof data === 'string') {\r\n                        parser = new DOMParser();\r\n                        return [2 /*return*/, parser.parseFromString(data, 'application/xml')];\r\n                    }\r\n                    else if (type === 'json' && typeof data === 'string') {\r\n                        return [2 /*return*/, JSON.parse(data)];\r\n                    }\r\n                    _a.label = 8;\r\n                case 8: throw new Error(\"could not get requested response data '\" + type + \"'\");\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction readFromFileInternal(file, type) {\r\n    var _this = this;\r\n    var reader = void 0;\r\n    return Task.create('Read File', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var compression, fileReader;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, , 5, 6]);\r\n                    reader = new FileReader();\r\n                    compression = type === 'zip' ? DataCompressionMethod.None : getCompression(file.name);\r\n                    if (type === 'binary' || type === 'zip' || compression !== DataCompressionMethod.None) {\r\n                        reader.readAsArrayBuffer(file);\r\n                    }\r\n                    else {\r\n                        reader.readAsText(file);\r\n                    }\r\n                    return [4 /*yield*/, ctx.update({ message: 'Opening file...', canAbort: true })];\r\n                case 1:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, readData(ctx, 'Reading...', reader)];\r\n                case 2:\r\n                    fileReader = _a.sent();\r\n                    return [4 /*yield*/, ctx.update({ message: 'Processing file...', canAbort: false })];\r\n                case 3:\r\n                    _a.sent();\r\n                    return [4 /*yield*/, processFile(ctx, fileReader, type, compression)];\r\n                case 4: return [2 /*return*/, _a.sent()];\r\n                case 5:\r\n                    reader = void 0;\r\n                    return [7 /*endfinally*/];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); }, function () {\r\n        if (reader)\r\n            reader.abort();\r\n    });\r\n}\r\nvar RequestPool = /** @class */ (function () {\r\n    function RequestPool() {\r\n    }\r\n    RequestPool.get = function () {\r\n        if (this.pool.length) {\r\n            return this.pool.pop();\r\n        }\r\n        return new XHR();\r\n    };\r\n    RequestPool.emptyFunc = function () { };\r\n    RequestPool.deposit = function (req) {\r\n        if (this.pool.length < this.poolSize) {\r\n            req.onabort = RequestPool.emptyFunc;\r\n            req.onerror = RequestPool.emptyFunc;\r\n            req.onload = RequestPool.emptyFunc;\r\n            req.onprogress = RequestPool.emptyFunc;\r\n            this.pool.push(req);\r\n        }\r\n    };\r\n    RequestPool.pool = [];\r\n    RequestPool.poolSize = 15;\r\n    return RequestPool;\r\n}());\r\nfunction processAjax(req, type) {\r\n    if (req.status >= 200 && req.status < 400) {\r\n        var response = req.response;\r\n        RequestPool.deposit(req);\r\n        if ((type === 'binary' || type === 'zip') && response instanceof ArrayBuffer) {\r\n            return new Uint8Array(response);\r\n        }\r\n        else if (type === 'string' && typeof response === 'string') {\r\n            return response;\r\n        }\r\n        else if (type === 'xml' && response instanceof XMLDocument) {\r\n            return response;\r\n        }\r\n        else if (type === 'json' && typeof response === 'object') {\r\n            return response;\r\n        }\r\n        throw new Error(\"could not get requested response data '\" + type + \"'\");\r\n    }\r\n    else {\r\n        RequestPool.deposit(req);\r\n        throw new Error(\"Download failed with status code \" + req.status);\r\n    }\r\n}\r\nfunction getRequestResponseType(type) {\r\n    switch (type) {\r\n        case 'json': return 'json';\r\n        case 'xml': return 'document';\r\n        case 'string': return 'text';\r\n        case 'binary': return 'arraybuffer';\r\n        case 'zip': return 'arraybuffer';\r\n    }\r\n}\r\nfunction ajaxGetInternal(title, url, type, body, headers) {\r\n    var _this = this;\r\n    var xhttp = void 0;\r\n    return Task.create(title ? title : 'Download', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var _a, headers_1, _b, name_1, value, req, result;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    xhttp = RequestPool.get();\r\n                    xhttp.open(body ? 'post' : 'get', url, true);\r\n                    if (headers) {\r\n                        for (_a = 0, headers_1 = headers; _a < headers_1.length; _a++) {\r\n                            _b = headers_1[_a], name_1 = _b[0], value = _b[1];\r\n                            xhttp.setRequestHeader(name_1, value);\r\n                        }\r\n                    }\r\n                    xhttp.responseType = getRequestResponseType(type);\r\n                    xhttp.send(body);\r\n                    return [4 /*yield*/, ctx.update({ message: 'Waiting for server...', canAbort: true })];\r\n                case 1:\r\n                    _c.sent();\r\n                    return [4 /*yield*/, readData(ctx, 'Downloading...', xhttp)];\r\n                case 2:\r\n                    req = _c.sent();\r\n                    xhttp = void 0; // guard against reuse, help garbage collector\r\n                    return [4 /*yield*/, ctx.update({ message: 'Parsing response...', canAbort: false })];\r\n                case 3:\r\n                    _c.sent();\r\n                    result = processAjax(req, type);\r\n                    return [2 /*return*/, result];\r\n            }\r\n        });\r\n    }); }, function () {\r\n        if (xhttp) {\r\n            xhttp.abort();\r\n            xhttp = void 0; // guard against reuse, help garbage collector\r\n        }\r\n    });\r\n}\r\nexport function ajaxGetMany(ctx, assetManager, sources, maxConcurrency) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var len, slots, promises, promiseKeys, currentSrc, _i, current, done, r, src, idx, current, asset;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    len = sources.length;\r\n                    slots = new Array(sources.length);\r\n                    return [4 /*yield*/, ctx.update({ message: 'Downloading...', current: 0, max: len })];\r\n                case 1:\r\n                    _a.sent();\r\n                    promises = [], promiseKeys = [];\r\n                    currentSrc = 0;\r\n                    for (_i = Math.min(len, maxConcurrency); currentSrc < _i; currentSrc++) {\r\n                        current = sources[currentSrc];\r\n                        promises.push(wrapPromise(currentSrc, current.id, assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? 'binary' : 'string').runAsChild(ctx)));\r\n                        promiseKeys.push(currentSrc);\r\n                    }\r\n                    done = 0;\r\n                    _a.label = 2;\r\n                case 2:\r\n                    if (!(promises.length > 0)) return [3 /*break*/, 6];\r\n                    return [4 /*yield*/, Promise.race(promises)];\r\n                case 3:\r\n                    r = _a.sent();\r\n                    src = sources[r.index];\r\n                    idx = promiseKeys.indexOf(r.index);\r\n                    done++;\r\n                    if (r.kind === 'error' && !src.canFail) {\r\n                        // TODO: cancel other downloads\r\n                        throw new Error(src.url + \": \" + r.error);\r\n                    }\r\n                    if (!ctx.shouldUpdate) return [3 /*break*/, 5];\r\n                    return [4 /*yield*/, ctx.update({ message: 'Downloading...', current: done, max: len })];\r\n                case 4:\r\n                    _a.sent();\r\n                    _a.label = 5;\r\n                case 5:\r\n                    slots[r.index] = r;\r\n                    promises = promises.filter(_filterRemoveIndex, idx);\r\n                    promiseKeys = promiseKeys.filter(_filterRemoveIndex, idx);\r\n                    if (currentSrc < len) {\r\n                        current = sources[currentSrc];\r\n                        asset = assetManager.resolve(Asset.getUrlAsset(assetManager, current.url), current.isBinary ? 'binary' : 'string').runAsChild(ctx);\r\n                        promises.push(wrapPromise(currentSrc, current.id, asset));\r\n                        promiseKeys.push(currentSrc);\r\n                        currentSrc++;\r\n                    }\r\n                    return [3 /*break*/, 2];\r\n                case 6: return [2 /*return*/, slots];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction _filterRemoveIndex(_, i) {\r\n    return this !== i;\r\n}\r\nfunction wrapPromise(index, id, p) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var result, error_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    _a.trys.push([0, 2, , 3]);\r\n                    return [4 /*yield*/, p];\r\n                case 1:\r\n                    result = _a.sent();\r\n                    return [2 /*return*/, { kind: 'ok', result: result, index: index, id: id }];\r\n                case 2:\r\n                    error_1 = _a.sent();\r\n                    return [2 /*return*/, { kind: 'error', error: error_1, index: index, id: id }];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=data-source.js.map"]},"metadata":{},"sourceType":"module"}