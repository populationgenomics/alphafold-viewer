/**
 * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __assign, __awaiter, __generator } from "tslib";
import { createGl } from './gl.shim';
import { Camera } from '../../mol-canvas3d/camera';
import { Vec3, Mat4, Vec4 } from '../../mol-math/linear-algebra';
import { ValueCell } from '../../mol-util';
import { Renderer } from '../renderer';
import { createValueColor } from '../../mol-geo/geometry/color-data';
import { createValueSize } from '../../mol-geo/geometry/size-data';
import { createContext } from '../webgl/context';
import { createRenderObject } from '../render-object';
import { Scene } from '../scene';
import { createEmptyMarkers } from '../../mol-geo/geometry/marker-data';
import { fillSerial } from '../../mol-util/array';
import { Color } from '../../mol-util/color';
import { Sphere3D } from '../../mol-math/geometry';
import { createEmptyOverpaint } from '../../mol-geo/geometry/overpaint-data';
import { createEmptyTransparency } from '../../mol-geo/geometry/transparency-data';
import { createEmptyClipping } from '../../mol-geo/geometry/clipping-data';
function createRenderer(gl) {
    var ctx = createContext(gl);
    var camera = new Camera({
        position: Vec3.create(0, 0, 50)
    });
    var renderer = Renderer.create(ctx);
    return { ctx: ctx, camera: camera, renderer: renderer };
}
function createPoints() {
    var aPosition = ValueCell.create(new Float32Array([0, -1, 0, -1, 0, 0, 1, 1, 0]));
    var aGroup = ValueCell.create(fillSerial(new Float32Array(3)));
    var aInstance = ValueCell.create(fillSerial(new Float32Array(1)));
    var color = createValueColor(Color(0xFF0000));
    var size = createValueSize(1);
    var marker = createEmptyMarkers();
    var overpaint = createEmptyOverpaint();
    var transparency = createEmptyTransparency();
    var clipping = createEmptyClipping();
    var aTransform = ValueCell.create(new Float32Array(16));
    var m4 = Mat4.identity();
    Mat4.toArray(m4, aTransform.ref.value, 0);
    var transform = ValueCell.create(new Float32Array(aTransform.ref.value));
    var extraTransform = ValueCell.create(new Float32Array(aTransform.ref.value));
    var boundingSphere = ValueCell.create(Sphere3D.create(Vec3.zero(), 2));
    var invariantBoundingSphere = ValueCell.create(Sphere3D.create(Vec3.zero(), 2));
    var values = __assign(__assign(__assign(__assign(__assign(__assign(__assign({ aPosition: aPosition, aGroup: aGroup, aTransform: aTransform, aInstance: aInstance }, color), marker), size), overpaint), transparency), clipping), { uAlpha: ValueCell.create(1.0), uVertexCount: ValueCell.create(3), uInstanceCount: ValueCell.create(1), uGroupCount: ValueCell.create(3), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere.ref.value)), alpha: ValueCell.create(1.0), drawCount: ValueCell.create(3), instanceCount: ValueCell.create(1), matrix: ValueCell.create(m4), transform: transform, extraTransform: extraTransform, hasReflection: ValueCell.create(false), boundingSphere: boundingSphere, invariantBoundingSphere: invariantBoundingSphere, uSizeFactor: ValueCell.create(1), dPointSizeAttenuation: ValueCell.create(true), dPointStyle: ValueCell.create('square') });
    var state = {
        disposed: false,
        visible: true,
        alphaFactor: 1,
        pickable: true,
        colorOnly: false,
        opaque: true,
        writeDepth: true,
        noClip: false,
    };
    return createRenderObject('points', values, state, -1);
}
describe('renderer', function () {
    it('basic', function () {
        var _a = [32, 32], width = _a[0], height = _a[1];
        var gl = createGl(width, height, { preserveDrawingBuffer: true });
        var _b = createRenderer(gl), ctx = _b.ctx, renderer = _b.renderer;
        expect(ctx.gl.canvas.width).toBe(32);
        expect(ctx.gl.canvas.height).toBe(32);
        expect(ctx.stats.resourceCounts.attribute).toBe(0);
        expect(ctx.stats.resourceCounts.texture).toBe(0);
        expect(ctx.stats.resourceCounts.vertexArray).toBe(0);
        expect(ctx.stats.resourceCounts.program).toBe(0);
        expect(ctx.stats.resourceCounts.shader).toBe(0);
        renderer.setViewport(0, 0, 64, 48);
        expect(ctx.gl.getParameter(ctx.gl.VIEWPORT)[2]).toBe(64);
        expect(ctx.gl.getParameter(ctx.gl.VIEWPORT)[3]).toBe(48);
    });
    it('points', function () { return __awaiter(void 0, void 0, void 0, function () {
        var _a, width, height, gl, ctx, scene, points;
        return __generator(this, function (_b) {
            _a = [32, 32], width = _a[0], height = _a[1];
            gl = createGl(width, height, { preserveDrawingBuffer: true });
            ctx = createRenderer(gl).ctx;
            scene = Scene.create(ctx);
            points = createPoints();
            scene.add(points);
            scene.commit();
            expect(ctx.stats.resourceCounts.attribute).toBe(ctx.isWebGL2 ? 4 : 5);
            expect(ctx.stats.resourceCounts.texture).toBe(7);
            expect(ctx.stats.resourceCounts.vertexArray).toBe(8);
            expect(ctx.stats.resourceCounts.program).toBe(8);
            expect(ctx.stats.resourceCounts.shader).toBe(16);
            scene.remove(points);
            scene.commit();
            expect(ctx.stats.resourceCounts.attribute).toBe(0);
            expect(ctx.stats.resourceCounts.texture).toBe(0);
            expect(ctx.stats.resourceCounts.vertexArray).toBe(0);
            expect(ctx.stats.resourceCounts.program).toBe(8);
            expect(ctx.stats.resourceCounts.shader).toBe(16);
            ctx.resources.destroy();
            expect(ctx.stats.resourceCounts.program).toBe(0);
            expect(ctx.stats.resourceCounts.shader).toBe(0);
            return [2 /*return*/];
        });
    }); });
});
//# sourceMappingURL=renderer.spec.js.map