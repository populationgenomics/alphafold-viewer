{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { mmCIF_Schema } from '../../../mol-io/reader/cif/schema/mmcif';\nimport { CifWriter } from '../../../mol-io/writer/cif';\nimport { FormatPropertyProvider } from '../common/property';\nimport { MmcifFormat } from '../mmcif';\nexport { AtomSiteAnisotrop };\nvar Anisotrop = {\n  U: mmCIF_Schema.atom_site_anisotrop.U,\n  U_esd: mmCIF_Schema.atom_site_anisotrop.U_esd\n};\nvar AtomSiteAnisotrop;\n\n(function (AtomSiteAnisotrop) {\n  AtomSiteAnisotrop.Schema = Anisotrop;\n  AtomSiteAnisotrop.Descriptor = {\n    name: 'atom_site_anisotrop',\n    cifExport: {\n      prefix: '',\n      categories: [{\n        name: 'atom_site_anisotrop',\n        instance: function (ctx) {\n          var p = AtomSiteAnisotrop.Provider.get(ctx.firstModel);\n          if (!p) return CifWriter.Category.Empty;\n          if (!MmcifFormat.is(ctx.firstModel.sourceData)) return CifWriter.Category.Empty; // TODO filter to write only data for elements that exist in model\n\n          return CifWriter.Category.ofTable(ctx.firstModel.sourceData.data.db.atom_site_anisotrop);\n        }\n      }]\n    }\n  };\n  AtomSiteAnisotrop.Provider = FormatPropertyProvider.create(AtomSiteAnisotrop.Descriptor);\n\n  function getElementToAnsiotrop(atomId, ansioId) {\n    var atomIdToElement = new Int32Array(atomId.rowCount);\n    atomIdToElement.fill(-1);\n\n    for (var i = 0, il = atomId.rowCount; i < il; i++) {\n      atomIdToElement[atomId.value(i)] = i;\n    }\n\n    var elementToAnsiotrop = new Int32Array(atomId.rowCount);\n    elementToAnsiotrop.fill(-1);\n\n    for (var i = 0, il = ansioId.rowCount; i < il; ++i) {\n      var ei = atomIdToElement[ansioId.value(i)];\n      if (ei !== -1) elementToAnsiotrop[ei] = i;\n    }\n\n    return elementToAnsiotrop;\n  }\n\n  AtomSiteAnisotrop.getElementToAnsiotrop = getElementToAnsiotrop;\n\n  function getElementToAnsiotropFromLabel(atomLabel, ansioLabel) {\n    var atomLabelToElement = {};\n\n    for (var i = 0, il = atomLabel.rowCount; i < il; i++) {\n      atomLabelToElement[atomLabel.value(i)] = i;\n    }\n\n    var elementToAnsiotrop = new Int32Array(atomLabel.rowCount);\n    elementToAnsiotrop.fill(-1);\n\n    for (var i = 0, il = ansioLabel.rowCount; i < il; ++i) {\n      var ei = atomLabelToElement[ansioLabel.value(i)];\n      if (ei !== undefined) elementToAnsiotrop[ei] = i;\n    }\n\n    return elementToAnsiotrop;\n  }\n\n  AtomSiteAnisotrop.getElementToAnsiotropFromLabel = getElementToAnsiotropFromLabel;\n})(AtomSiteAnisotrop || (AtomSiteAnisotrop = {}));","map":{"version":3,"sources":["../../../../src/mol-model-formats/structure/property/anisotropic.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { mmCIF_Schema } from '../../../mol-io/reader/cif/schema/mmcif';\r\nimport { CifWriter } from '../../../mol-io/writer/cif';\r\nimport { FormatPropertyProvider } from '../common/property';\r\nimport { MmcifFormat } from '../mmcif';\r\nexport { AtomSiteAnisotrop };\r\nvar Anisotrop = {\r\n    U: mmCIF_Schema.atom_site_anisotrop.U,\r\n    U_esd: mmCIF_Schema.atom_site_anisotrop.U_esd\r\n};\r\nvar AtomSiteAnisotrop;\r\n(function (AtomSiteAnisotrop) {\r\n    AtomSiteAnisotrop.Schema = Anisotrop;\r\n    AtomSiteAnisotrop.Descriptor = {\r\n        name: 'atom_site_anisotrop',\r\n        cifExport: {\r\n            prefix: '',\r\n            categories: [{\r\n                    name: 'atom_site_anisotrop',\r\n                    instance: function (ctx) {\r\n                        var p = AtomSiteAnisotrop.Provider.get(ctx.firstModel);\r\n                        if (!p)\r\n                            return CifWriter.Category.Empty;\r\n                        if (!MmcifFormat.is(ctx.firstModel.sourceData))\r\n                            return CifWriter.Category.Empty;\r\n                        // TODO filter to write only data for elements that exist in model\r\n                        return CifWriter.Category.ofTable(ctx.firstModel.sourceData.data.db.atom_site_anisotrop);\r\n                    }\r\n                }]\r\n        }\r\n    };\r\n    AtomSiteAnisotrop.Provider = FormatPropertyProvider.create(AtomSiteAnisotrop.Descriptor);\r\n    function getElementToAnsiotrop(atomId, ansioId) {\r\n        var atomIdToElement = new Int32Array(atomId.rowCount);\r\n        atomIdToElement.fill(-1);\r\n        for (var i = 0, il = atomId.rowCount; i < il; i++) {\r\n            atomIdToElement[atomId.value(i)] = i;\r\n        }\r\n        var elementToAnsiotrop = new Int32Array(atomId.rowCount);\r\n        elementToAnsiotrop.fill(-1);\r\n        for (var i = 0, il = ansioId.rowCount; i < il; ++i) {\r\n            var ei = atomIdToElement[ansioId.value(i)];\r\n            if (ei !== -1)\r\n                elementToAnsiotrop[ei] = i;\r\n        }\r\n        return elementToAnsiotrop;\r\n    }\r\n    AtomSiteAnisotrop.getElementToAnsiotrop = getElementToAnsiotrop;\r\n    function getElementToAnsiotropFromLabel(atomLabel, ansioLabel) {\r\n        var atomLabelToElement = {};\r\n        for (var i = 0, il = atomLabel.rowCount; i < il; i++) {\r\n            atomLabelToElement[atomLabel.value(i)] = i;\r\n        }\r\n        var elementToAnsiotrop = new Int32Array(atomLabel.rowCount);\r\n        elementToAnsiotrop.fill(-1);\r\n        for (var i = 0, il = ansioLabel.rowCount; i < il; ++i) {\r\n            var ei = atomLabelToElement[ansioLabel.value(i)];\r\n            if (ei !== undefined)\r\n                elementToAnsiotrop[ei] = i;\r\n        }\r\n        return elementToAnsiotrop;\r\n    }\r\n    AtomSiteAnisotrop.getElementToAnsiotropFromLabel = getElementToAnsiotropFromLabel;\r\n})(AtomSiteAnisotrop || (AtomSiteAnisotrop = {}));\r\n//# sourceMappingURL=anisotropic.js.map"]},"metadata":{},"sourceType":"module"}