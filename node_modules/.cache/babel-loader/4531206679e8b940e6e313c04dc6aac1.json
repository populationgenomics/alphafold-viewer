{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { UnitsMeshParams, UnitsMeshVisual } from '../../../mol-repr/structure/units-visual';\nimport { ElementIterator, getElementLoci, eachElement } from '../../../mol-repr/structure/visual/util/element';\nimport { StructureElement } from '../../../mol-model/structure';\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\nimport { sphereVertexCount } from '../../../mol-geo/primitive/sphere';\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\nimport { Vec3, Mat3, Tensor, EPSILON } from '../../../mol-math/linear-algebra';\nimport { isH } from '../../../mol-repr/structure/visual/util/common';\nimport { addEllipsoid } from '../../../mol-geo/geometry/mesh/builder/ellipsoid';\nimport { AtomSiteAnisotrop } from '../../../mol-model-formats/structure/property/anisotropic';\nimport { equalEps } from '../../../mol-math/linear-algebra/3d/common';\nimport { addSphere } from '../../../mol-geo/geometry/mesh/builder/sphere';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\nimport { SortedArray } from '../../../mol-data/int/sorted-array';\nexport var EllipsoidMeshParams = __assign(__assign({}, UnitsMeshParams), {\n  sizeFactor: PD.Numeric(1, {\n    min: 0,\n    max: 10,\n    step: 0.1\n  }),\n  detail: PD.Numeric(0, {\n    min: 0,\n    max: 3,\n    step: 1\n  }, BaseGeometry.CustomQualityParamInfo),\n  ignoreHydrogens: PD.Boolean(false)\n});\nexport function EllipsoidMeshVisual(materialId) {\n  return UnitsMeshVisual({\n    defaultProps: PD.getDefaultValues(EllipsoidMeshParams),\n    createGeometry: createEllipsoidMesh,\n    createLocationIterator: ElementIterator.fromGroup,\n    getLoci: getElementLoci,\n    eachLocation: eachElement,\n    setUpdateState: function (state, newProps, currentProps) {\n      state.createGeometry = newProps.sizeFactor !== currentProps.sizeFactor || newProps.detail !== currentProps.detail || newProps.ignoreHydrogens !== currentProps.ignoreHydrogens;\n    }\n  }, materialId);\n}\nexport function createEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {\n  var child = structure.child;\n  var childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\n  if (child && !childUnit) return Mesh.createEmpty(mesh);\n  var detail = props.detail,\n      sizeFactor = props.sizeFactor,\n      ignoreHydrogens = props.ignoreHydrogens;\n  var elements = unit.elements,\n      model = unit.model;\n  var atomicNumber = unit.model.atomicHierarchy.derived.atom.atomicNumber;\n  var elementCount = elements.length;\n  var vertexCount = elementCount * sphereVertexCount(detail);\n  var builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\n  var atomSiteAnisotrop = AtomSiteAnisotrop.Provider.get(model);\n  if (!atomSiteAnisotrop) return Mesh.createEmpty(mesh);\n  var v = Vec3();\n  var mat = Mat3();\n  var eigvals = Vec3();\n  var eigvec1 = Vec3();\n  var eigvec2 = Vec3();\n  var elementToAnsiotrop = atomSiteAnisotrop.elementToAnsiotrop,\n      data = atomSiteAnisotrop.data;\n  var U = data.U;\n  var space = data._schema.U.space;\n  var pos = unit.conformation.invariantPosition;\n  var l = StructureElement.Location.create(structure);\n  l.unit = unit;\n\n  for (var i = 0; i < elementCount; i++) {\n    var ei = elements[i];\n    var ai = elementToAnsiotrop[ei];\n    if (ai === -1) continue;\n    if (!!childUnit && !SortedArray.has(childUnit.elements, ei) || ignoreHydrogens && isH(atomicNumber, ei)) continue;\n    l.element = ei;\n    pos(ei, v);\n    builderState.currentGroup = i;\n    Tensor.toMat3(mat, space, U.value(ai));\n    Mat3.symmtricFromLower(mat, mat);\n    Mat3.symmetricEigenvalues(eigvals, mat);\n    Mat3.eigenvector(eigvec1, mat, eigvals[1]);\n    Mat3.eigenvector(eigvec2, mat, eigvals[2]);\n\n    for (var j = 0; j < 3; ++j) {\n      // show 50% probability surface, needs sqrt as U matrix is in angstrom-squared\n      // take abs of eigenvalue to avoid reflection\n      // multiply by given size-factor\n      eigvals[j] = sizeFactor * 1.5958 * Math.sqrt(Math.abs(eigvals[j]));\n    }\n\n    if (equalEps(eigvals[0], eigvals[1], EPSILON) && equalEps(eigvals[1], eigvals[2], EPSILON)) {\n      addSphere(builderState, v, eigvals[0], detail);\n    } else {\n      addEllipsoid(builderState, v, eigvec2, eigvec1, eigvals, detail);\n    }\n  }\n\n  var m = MeshBuilder.getMesh(builderState);\n  var sphere = Sphere3D.expand(Sphere3D(), (childUnit || unit).boundary.sphere, 1 * sizeFactor);\n  m.setBoundingSphere(sphere);\n  return m;\n}","map":{"version":3,"sources":["../../../../src/mol-repr/structure/visual/ellipsoid-mesh.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { UnitsMeshParams, UnitsMeshVisual } from '../../../mol-repr/structure/units-visual';\r\nimport { ElementIterator, getElementLoci, eachElement } from '../../../mol-repr/structure/visual/util/element';\r\nimport { StructureElement } from '../../../mol-model/structure';\r\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\r\nimport { sphereVertexCount } from '../../../mol-geo/primitive/sphere';\r\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\r\nimport { Vec3, Mat3, Tensor, EPSILON } from '../../../mol-math/linear-algebra';\r\nimport { isH } from '../../../mol-repr/structure/visual/util/common';\r\nimport { addEllipsoid } from '../../../mol-geo/geometry/mesh/builder/ellipsoid';\r\nimport { AtomSiteAnisotrop } from '../../../mol-model-formats/structure/property/anisotropic';\r\nimport { equalEps } from '../../../mol-math/linear-algebra/3d/common';\r\nimport { addSphere } from '../../../mol-geo/geometry/mesh/builder/sphere';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { BaseGeometry } from '../../../mol-geo/geometry/base';\r\nimport { SortedArray } from '../../../mol-data/int/sorted-array';\r\nexport var EllipsoidMeshParams = __assign(__assign({}, UnitsMeshParams), { sizeFactor: PD.Numeric(1, { min: 0, max: 10, step: 0.1 }), detail: PD.Numeric(0, { min: 0, max: 3, step: 1 }, BaseGeometry.CustomQualityParamInfo), ignoreHydrogens: PD.Boolean(false) });\r\nexport function EllipsoidMeshVisual(materialId) {\r\n    return UnitsMeshVisual({\r\n        defaultProps: PD.getDefaultValues(EllipsoidMeshParams),\r\n        createGeometry: createEllipsoidMesh,\r\n        createLocationIterator: ElementIterator.fromGroup,\r\n        getLoci: getElementLoci,\r\n        eachLocation: eachElement,\r\n        setUpdateState: function (state, newProps, currentProps) {\r\n            state.createGeometry = (newProps.sizeFactor !== currentProps.sizeFactor ||\r\n                newProps.detail !== currentProps.detail ||\r\n                newProps.ignoreHydrogens !== currentProps.ignoreHydrogens);\r\n        }\r\n    }, materialId);\r\n}\r\nexport function createEllipsoidMesh(ctx, unit, structure, theme, props, mesh) {\r\n    var child = structure.child;\r\n    var childUnit = child === null || child === void 0 ? void 0 : child.unitMap.get(unit.id);\r\n    if (child && !childUnit)\r\n        return Mesh.createEmpty(mesh);\r\n    var detail = props.detail, sizeFactor = props.sizeFactor, ignoreHydrogens = props.ignoreHydrogens;\r\n    var elements = unit.elements, model = unit.model;\r\n    var atomicNumber = unit.model.atomicHierarchy.derived.atom.atomicNumber;\r\n    var elementCount = elements.length;\r\n    var vertexCount = elementCount * sphereVertexCount(detail);\r\n    var builderState = MeshBuilder.createState(vertexCount, vertexCount / 2, mesh);\r\n    var atomSiteAnisotrop = AtomSiteAnisotrop.Provider.get(model);\r\n    if (!atomSiteAnisotrop)\r\n        return Mesh.createEmpty(mesh);\r\n    var v = Vec3();\r\n    var mat = Mat3();\r\n    var eigvals = Vec3();\r\n    var eigvec1 = Vec3();\r\n    var eigvec2 = Vec3();\r\n    var elementToAnsiotrop = atomSiteAnisotrop.elementToAnsiotrop, data = atomSiteAnisotrop.data;\r\n    var U = data.U;\r\n    var space = data._schema.U.space;\r\n    var pos = unit.conformation.invariantPosition;\r\n    var l = StructureElement.Location.create(structure);\r\n    l.unit = unit;\r\n    for (var i = 0; i < elementCount; i++) {\r\n        var ei = elements[i];\r\n        var ai = elementToAnsiotrop[ei];\r\n        if (ai === -1)\r\n            continue;\r\n        if (((!!childUnit && !SortedArray.has(childUnit.elements, ei))) ||\r\n            (ignoreHydrogens && isH(atomicNumber, ei)))\r\n            continue;\r\n        l.element = ei;\r\n        pos(ei, v);\r\n        builderState.currentGroup = i;\r\n        Tensor.toMat3(mat, space, U.value(ai));\r\n        Mat3.symmtricFromLower(mat, mat);\r\n        Mat3.symmetricEigenvalues(eigvals, mat);\r\n        Mat3.eigenvector(eigvec1, mat, eigvals[1]);\r\n        Mat3.eigenvector(eigvec2, mat, eigvals[2]);\r\n        for (var j = 0; j < 3; ++j) {\r\n            // show 50% probability surface, needs sqrt as U matrix is in angstrom-squared\r\n            // take abs of eigenvalue to avoid reflection\r\n            // multiply by given size-factor\r\n            eigvals[j] = sizeFactor * 1.5958 * Math.sqrt(Math.abs(eigvals[j]));\r\n        }\r\n        if (equalEps(eigvals[0], eigvals[1], EPSILON) && equalEps(eigvals[1], eigvals[2], EPSILON)) {\r\n            addSphere(builderState, v, eigvals[0], detail);\r\n        }\r\n        else {\r\n            addEllipsoid(builderState, v, eigvec2, eigvec1, eigvals, detail);\r\n        }\r\n    }\r\n    var m = MeshBuilder.getMesh(builderState);\r\n    var sphere = Sphere3D.expand(Sphere3D(), (childUnit || unit).boundary.sphere, 1 * sizeFactor);\r\n    m.setBoundingSphere(sphere);\r\n    return m;\r\n}\r\n//# sourceMappingURL=ellipsoid-mesh.js.map"]},"metadata":{},"sourceType":"module"}