{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\nimport { radToDeg } from '../../../../mol-math/misc';\nexport function calculateUnitDihedralAngles(unit, proteinInfo) {\n  var cIndices = proteinInfo.cIndices,\n      nIndices = proteinInfo.nIndices,\n      residueIndices = proteinInfo.residueIndices;\n  var position = unit.conformation.position;\n  var index = unit.model.atomicHierarchy.index;\n  var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\n  var residueCount = residueIndices.length;\n\n  var p = function (i, v) {\n    return i === -1 ? Vec3.setNaN(v) : position(i, v);\n  };\n\n  var cPosPrev = Vec3(),\n      caPosPrev = Vec3(),\n      nPosPrev = Vec3();\n  var cPos = Vec3(),\n      caPos = Vec3(),\n      nPos = Vec3();\n  var cPosNext = Vec3(),\n      caPosNext = Vec3(),\n      nPosNext = Vec3();\n  if (residueCount === 0) return {\n    phi: new Float32Array(0),\n    psi: new Float32Array(0)\n  };\n  var phi = new Float32Array(residueCount - 1);\n  var psi = new Float32Array(residueCount - 1);\n  p(-1, cPosPrev);\n  p(-1, caPosPrev);\n  p(-1, nPosPrev);\n  p(cIndices[0], cPos);\n  p(traceElementIndex[residueIndices[0]], caPos);\n  p(nIndices[0], nPos);\n  p(cIndices[1], cPosNext);\n  p(traceElementIndex[residueIndices[1]], caPosNext);\n  p(nIndices[1], nPosNext);\n\n  for (var i = 0; i < residueCount - 1; ++i) {\n    // ignore C-terminal residue as acceptor\n    if (index.findAtomOnResidue(residueIndices[i], 'OXT') !== -1) continue; // returns NaN for missing atoms\n\n    phi[i] = radToDeg(Vec3.dihedralAngle(cPosPrev, nPos, caPos, cPos));\n    psi[i] = radToDeg(Vec3.dihedralAngle(nPos, caPos, cPos, nPosNext));\n    cPosPrev = cPos, caPosPrev = caPos, nPosPrev = nPos;\n    cPos = cPosNext, caPos = caPosNext, nPos = nPosNext;\n    p(cIndices[i + 1], cPosNext);\n    p(traceElementIndex[residueIndices[i + 1]], caPosNext);\n    p(nIndices[i + 1], nPosNext);\n  }\n\n  return {\n    phi: phi,\n    psi: psi\n  };\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/dihedral-angles.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nimport { Vec3 } from '../../../../mol-math/linear-algebra';\r\nimport { radToDeg } from '../../../../mol-math/misc';\r\nexport function calculateUnitDihedralAngles(unit, proteinInfo) {\r\n    var cIndices = proteinInfo.cIndices, nIndices = proteinInfo.nIndices, residueIndices = proteinInfo.residueIndices;\r\n    var position = unit.conformation.position;\r\n    var index = unit.model.atomicHierarchy.index;\r\n    var traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex;\r\n    var residueCount = residueIndices.length;\r\n    var p = function (i, v) { return i === -1 ? Vec3.setNaN(v) : position(i, v); };\r\n    var cPosPrev = Vec3(), caPosPrev = Vec3(), nPosPrev = Vec3();\r\n    var cPos = Vec3(), caPos = Vec3(), nPos = Vec3();\r\n    var cPosNext = Vec3(), caPosNext = Vec3(), nPosNext = Vec3();\r\n    if (residueCount === 0)\r\n        return { phi: new Float32Array(0), psi: new Float32Array(0) };\r\n    var phi = new Float32Array(residueCount - 1);\r\n    var psi = new Float32Array(residueCount - 1);\r\n    p(-1, cPosPrev);\r\n    p(-1, caPosPrev);\r\n    p(-1, nPosPrev);\r\n    p(cIndices[0], cPos);\r\n    p(traceElementIndex[residueIndices[0]], caPos);\r\n    p(nIndices[0], nPos);\r\n    p(cIndices[1], cPosNext);\r\n    p(traceElementIndex[residueIndices[1]], caPosNext);\r\n    p(nIndices[1], nPosNext);\r\n    for (var i = 0; i < residueCount - 1; ++i) {\r\n        // ignore C-terminal residue as acceptor\r\n        if (index.findAtomOnResidue(residueIndices[i], 'OXT') !== -1)\r\n            continue;\r\n        // returns NaN for missing atoms\r\n        phi[i] = radToDeg(Vec3.dihedralAngle(cPosPrev, nPos, caPos, cPos));\r\n        psi[i] = radToDeg(Vec3.dihedralAngle(nPos, caPos, cPos, nPosNext));\r\n        cPosPrev = cPos, caPosPrev = caPos, nPosPrev = nPos;\r\n        cPos = cPosNext, caPos = caPosNext, nPos = nPosNext;\r\n        p(cIndices[i + 1], cPosNext);\r\n        p(traceElementIndex[residueIndices[i + 1]], caPosNext);\r\n        p(nIndices[i + 1], nPosNext);\r\n    }\r\n    return { phi: phi, psi: psi };\r\n}\r\n//# sourceMappingURL=dihedral-angles.js.map"]},"metadata":{},"sourceType":"module"}