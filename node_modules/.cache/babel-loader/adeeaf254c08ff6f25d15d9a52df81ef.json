{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nexport var DefaultCircleProps = {\n  radius: 1,\n  segments: 36,\n  thetaStart: 0,\n  thetaLength: Math.PI * 2\n};\nexport function Circle(props) {\n  var _a = __assign(__assign({}, DefaultCircleProps), props),\n      radius = _a.radius,\n      segments = _a.segments,\n      thetaStart = _a.thetaStart,\n      thetaLength = _a.thetaLength;\n\n  var isFull = thetaLength === Math.PI * 2;\n  var count = isFull ? segments + 1 : segments + 2;\n  var vertices = new Float32Array(count * 3);\n  var normals = new Float32Array(count * 3);\n  var indices = new Uint32Array(segments * 3); // center\n\n  vertices[0] = 0;\n  vertices[1] = 0;\n  vertices[2] = 0;\n  normals[0] = 0;\n  normals[1] = 1;\n  normals[2] = 0; // vertices & normals\n\n  for (var s = 0, i = 3; s < segments; ++s, i += 3) {\n    var segment = thetaStart + s / segments * thetaLength;\n    vertices[i] = radius * Math.sin(segment);\n    vertices[i + 1] = 0;\n    vertices[i + 2] = radius * Math.cos(segment);\n    normals[i] = 0;\n    normals[i + 1] = 1;\n    normals[i + 2] = 0;\n  } // indices\n\n\n  for (var s = 1, i = 0; s < segments; ++s, i += 3) {\n    indices[i] = s;\n    indices[i + 1] = s + 1;\n    indices[i + 2] = 0;\n  }\n\n  if (isFull) {\n    var j = (segments - 1) * 3;\n    indices[j] = segments;\n    indices[j + 1] = 1;\n    indices[j + 2] = 0;\n  } else {\n    var segment = thetaStart + thetaLength;\n    var i = (segments + 1) * 3;\n    vertices[i] = radius * Math.sin(segment);\n    vertices[i + 1] = 0;\n    vertices[i + 2] = radius * Math.cos(segment);\n    normals[i] = 0;\n    normals[i + 1] = 1;\n    normals[i + 2] = 0;\n    var j = (segments - 1) * 3;\n    indices[j] = segments;\n    indices[j + 1] = segments + 1;\n    indices[j + 2] = 0;\n  }\n\n  return {\n    vertices: vertices,\n    normals: normals,\n    indices: indices\n  };\n}","map":{"version":3,"sources":["../../../src/mol-geo/primitive/circle.ts"],"names":[],"mappings":"AAAA;;;;AAIG;;AAIH,OAAO,IAAM,kBAAkB,GAAG;AAC9B,EAAA,MAAM,EAAE,CADsB;AAE9B,EAAA,QAAQ,EAAE,EAFoB;AAG9B,EAAA,UAAU,EAAE,CAHkB;AAI9B,EAAA,WAAW,EAAE,IAAI,CAAC,EAAL,GAAU;AAJO,CAA3B;AAQP,OAAM,SAAU,MAAV,CAAiB,KAAjB,EAAqC;AACjC,MAAA,EAAA,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAqD,kBAArD,CAAA,EAA4E,KAA5E,CAAA;AAAA,MAAE,MAAM,GAAA,EAAA,CAAA,MAAR;AAAA,MAAU,QAAQ,GAAA,EAAA,CAAA,QAAlB;AAAA,MAAoB,UAAU,GAAA,EAAA,CAAA,UAA9B;AAAA,MAAgC,WAAW,GAAA,EAAA,CAAA,WAA3C;;AAEN,MAAM,MAAM,GAAG,WAAW,KAAK,IAAI,CAAC,EAAL,GAAU,CAAzC;AACA,MAAM,KAAK,GAAG,MAAM,GAAG,QAAQ,GAAG,CAAd,GAAkB,QAAQ,GAAG,CAAjD;AAEA,MAAM,QAAQ,GAAG,IAAI,YAAJ,CAAiB,KAAK,GAAG,CAAzB,CAAjB;AACA,MAAM,OAAO,GAAG,IAAI,YAAJ,CAAiB,KAAK,GAAG,CAAzB,CAAhB;AACA,MAAM,OAAO,GAAG,IAAI,WAAJ,CAAgB,QAAQ,GAAG,CAA3B,CAAhB,CARuC,CAUvC;;AACA,EAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd;AAAiB,EAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd;AAAiB,EAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd;AAClC,EAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAAgB,EAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAAgB,EAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb,CAZO,CAcvC;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,CAApB,EAAuB,CAAC,GAAG,QAA3B,EAAqC,EAAE,CAAF,EAAK,CAAC,IAAI,CAA/C,EAAkD;AAC9C,QAAM,OAAO,GAAG,UAAU,GAAG,CAAC,GAAG,QAAJ,GAAe,WAA5C;AAEA,IAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAAvB;AACA,IAAA,QAAQ,CAAC,CAAC,GAAG,CAAL,CAAR,GAAkB,CAAlB;AACA,IAAA,QAAQ,CAAC,CAAC,GAAG,CAAL,CAAR,GAAkB,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAA3B;AAEA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAAgB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AAAoB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AACvC,GAvBsC,CAyBvC;;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,CAApB,EAAuB,CAAC,GAAG,QAA3B,EAAqC,EAAE,CAAF,EAAK,CAAC,IAAI,CAA/C,EAAkD;AAC9C,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAAgB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAC,GAAG,CAArB;AAAwB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AAC3C;;AAED,MAAI,MAAJ,EAAY;AACR,QAAM,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAZ,IAAiB,CAA3B;AACA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,QAAb;AACA,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AACA,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AACH,GALD,MAKO;AACH,QAAM,OAAO,GAAG,UAAU,GAAG,WAA7B;AACA,QAAM,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAZ,IAAiB,CAA3B;AAEA,IAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAAvB;AACA,IAAA,QAAQ,CAAC,CAAC,GAAG,CAAL,CAAR,GAAkB,CAAlB;AACA,IAAA,QAAQ,CAAC,CAAC,GAAG,CAAL,CAAR,GAAkB,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,OAAT,CAA3B;AAEA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,CAAb;AAAgB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AAAoB,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AAEpC,QAAM,CAAC,GAAG,CAAC,QAAQ,GAAG,CAAZ,IAAiB,CAA3B;AACA,IAAA,OAAO,CAAC,CAAD,CAAP,GAAa,QAAb;AACA,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,QAAQ,GAAG,CAA5B;AACA,IAAA,OAAO,CAAC,CAAC,GAAG,CAAL,CAAP,GAAiB,CAAjB;AACH;;AAED,SAAO;AAAE,IAAA,QAAQ,EAAA,QAAV;AAAY,IAAA,OAAO,EAAA,OAAnB;AAAqB,IAAA,OAAO,EAAA;AAA5B,GAAP;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nexport var DefaultCircleProps = {\r\n    radius: 1,\r\n    segments: 36,\r\n    thetaStart: 0,\r\n    thetaLength: Math.PI * 2\r\n};\r\nexport function Circle(props) {\r\n    var _a = __assign(__assign({}, DefaultCircleProps), props), radius = _a.radius, segments = _a.segments, thetaStart = _a.thetaStart, thetaLength = _a.thetaLength;\r\n    var isFull = thetaLength === Math.PI * 2;\r\n    var count = isFull ? segments + 1 : segments + 2;\r\n    var vertices = new Float32Array(count * 3);\r\n    var normals = new Float32Array(count * 3);\r\n    var indices = new Uint32Array(segments * 3);\r\n    // center\r\n    vertices[0] = 0;\r\n    vertices[1] = 0;\r\n    vertices[2] = 0;\r\n    normals[0] = 0;\r\n    normals[1] = 1;\r\n    normals[2] = 0;\r\n    // vertices & normals\r\n    for (var s = 0, i = 3; s < segments; ++s, i += 3) {\r\n        var segment = thetaStart + s / segments * thetaLength;\r\n        vertices[i] = radius * Math.sin(segment);\r\n        vertices[i + 1] = 0;\r\n        vertices[i + 2] = radius * Math.cos(segment);\r\n        normals[i] = 0;\r\n        normals[i + 1] = 1;\r\n        normals[i + 2] = 0;\r\n    }\r\n    // indices\r\n    for (var s = 1, i = 0; s < segments; ++s, i += 3) {\r\n        indices[i] = s;\r\n        indices[i + 1] = s + 1;\r\n        indices[i + 2] = 0;\r\n    }\r\n    if (isFull) {\r\n        var j = (segments - 1) * 3;\r\n        indices[j] = segments;\r\n        indices[j + 1] = 1;\r\n        indices[j + 2] = 0;\r\n    }\r\n    else {\r\n        var segment = thetaStart + thetaLength;\r\n        var i = (segments + 1) * 3;\r\n        vertices[i] = radius * Math.sin(segment);\r\n        vertices[i + 1] = 0;\r\n        vertices[i + 2] = radius * Math.cos(segment);\r\n        normals[i] = 0;\r\n        normals[i + 1] = 1;\r\n        normals[i + 2] = 0;\r\n        var j = (segments - 1) * 3;\r\n        indices[j] = segments;\r\n        indices[j + 1] = segments + 1;\r\n        indices[j + 2] = 0;\r\n    }\r\n    return { vertices: vertices, normals: normals, indices: indices };\r\n}\r\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"module"}