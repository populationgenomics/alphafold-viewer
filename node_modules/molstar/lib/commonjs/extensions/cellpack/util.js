"use strict";
/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStructureMean = exports.getFromCellPackDB = exports.getFromOPM = exports.getFromPdb = exports.parsePDBfile = exports.parseCif = void 0;
var tslib_1 = require("tslib");
var cif_1 = require("../../mol-io/reader/cif");
var parser_1 = require("../../mol-io/reader/pdb/parser");
var assets_1 = require("../../mol-util/assets");
var linear_algebra_1 = require("../../mol-math/linear-algebra");
function parseCif(plugin, data) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var comp, parsed;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    comp = cif_1.CIF.parse(data);
                    return [4 /*yield*/, plugin.runTask(comp)];
                case 1:
                    parsed = _a.sent();
                    if (parsed.isError)
                        throw parsed;
                    return [2 /*return*/, parsed.result];
            }
        });
    });
}
exports.parseCif = parseCif;
function parsePDBfile(plugin, data, id) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var comp, parsed;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    comp = (0, parser_1.parsePDB)(data, id);
                    return [4 /*yield*/, plugin.runTask(comp)];
                case 1:
                    parsed = _a.sent();
                    if (parsed.isError)
                        throw parsed;
                    return [2 /*return*/, parsed.result];
            }
        });
    });
}
exports.parsePDBfile = parsePDBfile;
function downloadCif(plugin, url, isBinary, assetManager) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var type, asset;
        var _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    type = isBinary ? 'binary' : 'string';
                    return [4 /*yield*/, plugin.runTask(assetManager.resolve(assets_1.Asset.getUrlAsset(assetManager, url), type))];
                case 1:
                    asset = _b.sent();
                    _a = {};
                    return [4 /*yield*/, parseCif(plugin, asset.data)];
                case 2: return [2 /*return*/, (_a.cif = _b.sent(), _a.asset = asset, _a)];
            }
        });
    });
}
function downloadPDB(plugin, url, id, assetManager) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var asset;
        var _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, assetManager.resolve(assets_1.Asset.getUrlAsset(assetManager, url), 'string').run()];
                case 1:
                    asset = _b.sent();
                    _a = {};
                    return [4 /*yield*/, parsePDBfile(plugin, asset.data, id)];
                case 2: return [2 /*return*/, (_a.pdb = _b.sent(), _a.asset = asset, _a)];
            }
        });
    });
}
function getFromPdb(plugin, pdbId, assetManager) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, cif, asset;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, downloadCif(plugin, "https://models.rcsb.org/" + pdbId.toUpperCase() + ".bcif", true, assetManager)];
                case 1:
                    _a = _b.sent(), cif = _a.cif, asset = _a.asset;
                    return [2 /*return*/, { mmcif: cif.blocks[0], asset: asset }];
            }
        });
    });
}
exports.getFromPdb = getFromPdb;
function getFromOPM(plugin, pdbId, assetManager) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var asset;
        var _a;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, plugin.runTask(assetManager.resolve(assets_1.Asset.getUrlAsset(assetManager, "https://opm-assets.storage.googleapis.com/pdb/" + pdbId.toLowerCase() + ".pdb"), 'string'))];
                case 1:
                    asset = _b.sent();
                    _a = {};
                    return [4 /*yield*/, parsePDBfile(plugin, asset.data, pdbId)];
                case 2: return [2 /*return*/, (_a.pdb = _b.sent(), _a.asset = asset, _a)];
            }
        });
    });
}
exports.getFromOPM = getFromOPM;
function getFromCellPackDB(plugin, id, baseUrl, assetManager) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var isBinary, _a, cif, asset, name_1;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(id.toLowerCase().endsWith('.cif') || id.toLowerCase().endsWith('.bcif'))) return [3 /*break*/, 2];
                    isBinary = id.toLowerCase().endsWith('.bcif');
                    return [4 /*yield*/, downloadCif(plugin, baseUrl + "/other/" + id, isBinary, assetManager)];
                case 1:
                    _a = _b.sent(), cif = _a.cif, asset = _a.asset;
                    return [2 /*return*/, { mmcif: cif.blocks[0], asset: asset }];
                case 2:
                    name_1 = id.endsWith('.pdb') ? id.substring(0, id.length - 4) : id;
                    return [4 /*yield*/, downloadPDB(plugin, baseUrl + "/other/" + name_1 + ".pdb", name_1, assetManager)];
                case 3: return [2 /*return*/, _b.sent()];
            }
        });
    });
}
exports.getFromCellPackDB = getFromCellPackDB;
function getStructureMean(structure) {
    var xSum = 0, ySum = 0, zSum = 0;
    for (var i = 0, il = structure.units.length; i < il; ++i) {
        var unit = structure.units[i];
        var elements = unit.elements;
        var _a = unit.conformation, x = _a.x, y = _a.y, z = _a.z;
        for (var j = 0, jl = elements.length; j < jl; ++j) {
            var eI = elements[j];
            xSum += x(eI);
            ySum += y(eI);
            zSum += z(eI);
        }
    }
    var elementCount = structure.elementCount;
    return linear_algebra_1.Vec3.create(xSum / elementCount, ySum / elementCount, zSum / elementCount);
}
exports.getStructureMean = getStructureMean;
//# sourceMappingURL=util.js.map