/**
 * Copyright (c) 2021 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { calcMeshColorSmoothing } from '../../../../mol-geo/geometry/mesh/color-smoothing';
import { calcTextureMeshColorSmoothing } from '../../../../mol-geo/geometry/texture-mesh/color-smoothing';
import { smoothstep } from '../../../../mol-math/interpolate';
import { ValueCell } from '../../../../mol-util';
import { ParamDefinition as PD } from '../../../../mol-util/param-definition';
export var ColorSmoothingParams = {
    smoothColors: PD.MappedStatic('auto', {
        auto: PD.Group({}),
        on: PD.Group({
            resolutionFactor: PD.Numeric(2, { min: 0.5, max: 6, step: 0.1 }),
            sampleStride: PD.Numeric(3, { min: 1, max: 12, step: 1 }),
        }),
        off: PD.Group({})
    }),
};
export function getColorSmoothingProps(props, theme, resolution) {
    if ((props.smoothColors.name === 'on' || (props.smoothColors.name === 'auto' && theme.color.preferSmoothing)) && resolution && resolution < 3) {
        var stride = 3;
        if (props.smoothColors.name === 'on') {
            resolution *= props.smoothColors.params.resolutionFactor;
            stride = props.smoothColors.params.sampleStride;
        }
        else {
            // https://graphtoy.com/?f1(x,t)=(2-smoothstep(0,1.1,x))*x&coords=0.7,0.6,1.8
            resolution *= 2 - smoothstep(0, 1.1, resolution);
            resolution = Math.max(0.5, resolution);
            if (resolution > 1.2)
                stride = 2;
        }
        return { resolution: resolution, stride: stride };
    }
    ;
}
function isSupportedColorType(x) {
    return x === 'group' || x === 'groupInstance';
}
export function applyMeshColorSmoothing(values, resolution, stride, webgl, colorTexture) {
    if (!isSupportedColorType(values.dColorType.ref.value))
        return;
    var smoothingData = calcMeshColorSmoothing({
        vertexCount: values.uVertexCount.ref.value,
        instanceCount: values.uInstanceCount.ref.value,
        groupCount: values.uGroupCount.ref.value,
        transformBuffer: values.aTransform.ref.value,
        instanceBuffer: values.aInstance.ref.value,
        positionBuffer: values.aPosition.ref.value,
        groupBuffer: values.aGroup.ref.value,
        colorData: values.tColor.ref.value,
        colorType: values.dColorType.ref.value,
        boundingSphere: values.boundingSphere.ref.value,
        invariantBoundingSphere: values.invariantBoundingSphere.ref.value,
    }, resolution, stride, webgl, colorTexture);
    if (smoothingData.kind === 'volume') {
        ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
        ValueCell.update(values.tColorGrid, smoothingData.texture);
        ValueCell.update(values.uColorTexDim, smoothingData.gridTexDim);
        ValueCell.update(values.uColorGridDim, smoothingData.gridDim);
        ValueCell.update(values.uColorGridTransform, smoothingData.gridTransform);
    }
    else if (smoothingData.kind === 'vertex') {
        ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
        ValueCell.update(values.tColor, smoothingData.texture);
        ValueCell.update(values.uColorTexDim, smoothingData.texDim);
    }
}
export function applyTextureMeshColorSmoothing(values, resolution, stride, webgl, colorTexture) {
    if (!isSupportedColorType(values.dColorType.ref.value))
        return;
    stride *= 3; // triple because TextureMesh is never indexed (no elements buffer)
    var smoothingData = calcTextureMeshColorSmoothing({
        vertexCount: values.uVertexCount.ref.value,
        instanceCount: values.uInstanceCount.ref.value,
        groupCount: values.uGroupCount.ref.value,
        transformBuffer: values.aTransform.ref.value,
        instanceBuffer: values.aInstance.ref.value,
        positionTexture: values.tPosition.ref.value,
        groupTexture: values.tGroup.ref.value,
        colorData: values.tColor.ref.value,
        colorType: values.dColorType.ref.value,
        boundingSphere: values.boundingSphere.ref.value,
        invariantBoundingSphere: values.invariantBoundingSphere.ref.value,
    }, resolution, stride, webgl, colorTexture);
    ValueCell.updateIfChanged(values.dColorType, smoothingData.type);
    ValueCell.update(values.tColorGrid, smoothingData.texture);
    ValueCell.update(values.uColorTexDim, smoothingData.gridTexDim);
    ValueCell.update(values.uColorGridDim, smoothingData.gridDim);
    ValueCell.update(values.uColorGridTransform, smoothingData.gridTransform);
}
//# sourceMappingURL=color.js.map