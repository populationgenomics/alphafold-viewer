{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\nimport { lerp, smoothstep } from '../../../../../mol-math/interpolate'; // avoiding namespace lookup improved performance in Chrome (Aug 2020)\n\nvar v3fromArray = Vec3.fromArray;\nvar v3toArray = Vec3.toArray;\nvar v3normalize = Vec3.normalize;\nvar v3sub = Vec3.sub;\nvar v3spline = Vec3.spline;\nvar v3slerp = Vec3.slerp;\nvar v3copy = Vec3.copy;\nvar v3cross = Vec3.cross;\nvar v3orthogonalize = Vec3.orthogonalize;\nvar v3matchDirection = Vec3.matchDirection;\nvar v3scale = Vec3.scale;\nvar v3add = Vec3.add;\nexport function createCurveSegmentState(linearSegments) {\n  var n = linearSegments + 1;\n  var pn = n * 3;\n  return {\n    curvePoints: new Float32Array(pn),\n    tangentVectors: new Float32Array(pn),\n    normalVectors: new Float32Array(pn),\n    binormalVectors: new Float32Array(pn),\n    widthValues: new Float32Array(n),\n    heightValues: new Float32Array(n),\n    linearSegments: linearSegments\n  };\n}\nexport function interpolateCurveSegment(state, controls, tension, shift) {\n  interpolatePointsAndTangents(state, controls, tension, shift);\n  interpolateNormals(state, controls);\n}\nvar tanA = Vec3();\nvar tanB = Vec3();\nvar curvePoint = Vec3();\nexport function interpolatePointsAndTangents(state, controls, tension, shift) {\n  var curvePoints = state.curvePoints,\n      tangentVectors = state.tangentVectors,\n      linearSegments = state.linearSegments;\n  var p0 = controls.p0,\n      p1 = controls.p1,\n      p2 = controls.p2,\n      p3 = controls.p3,\n      p4 = controls.p4,\n      secStrucFirst = controls.secStrucFirst,\n      secStrucLast = controls.secStrucLast;\n  var shift1 = 1 - shift;\n  var tensionBeg = secStrucFirst ? 0.5 : tension;\n  var tensionEnd = secStrucLast ? 0.5 : tension;\n\n  for (var j = 0; j <= linearSegments; ++j) {\n    var t = j * 1.0 / linearSegments;\n\n    if (t < shift1) {\n      var te = lerp(tensionBeg, tension, t);\n      v3spline(curvePoint, p0, p1, p2, p3, t + shift, te);\n      v3spline(tanA, p0, p1, p2, p3, t + shift + 0.01, tensionBeg);\n      v3spline(tanB, p0, p1, p2, p3, t + shift - 0.01, tensionBeg);\n    } else {\n      var te = lerp(tension, tensionEnd, t);\n      v3spline(curvePoint, p1, p2, p3, p4, t - shift1, te);\n      v3spline(tanA, p1, p2, p3, p4, t - shift1 + 0.01, te);\n      v3spline(tanB, p1, p2, p3, p4, t - shift1 - 0.01, te);\n    }\n\n    v3toArray(curvePoint, curvePoints, j * 3);\n    v3normalize(tangentVec, v3sub(tangentVec, tanA, tanB));\n    v3toArray(tangentVec, tangentVectors, j * 3);\n  }\n}\nvar tmpNormal = Vec3();\nvar tangentVec = Vec3();\nvar normalVec = Vec3();\nvar binormalVec = Vec3();\nvar prevNormal = Vec3();\nvar nextNormal = Vec3();\nvar firstTangentVec = Vec3();\nvar lastTangentVec = Vec3();\nvar firstNormalVec = Vec3();\nvar lastNormalVec = Vec3();\n/**\r\n * Populate normalVectors by interpolating from firstDirection to lastDirection with\r\n * resulting vector perpendicular to tangentVectors and binormalVectors\r\n */\n\nexport function interpolateNormals(state, controls) {\n  var curvePoints = state.curvePoints,\n      tangentVectors = state.tangentVectors,\n      normalVectors = state.normalVectors,\n      binormalVectors = state.binormalVectors;\n  var firstDirection = controls.d12,\n      lastDirection = controls.d23;\n  var n = curvePoints.length / 3;\n  v3fromArray(firstTangentVec, tangentVectors, 0);\n  v3fromArray(lastTangentVec, tangentVectors, (n - 1) * 3);\n  v3orthogonalize(firstNormalVec, firstTangentVec, firstDirection);\n  v3orthogonalize(lastNormalVec, lastTangentVec, lastDirection);\n  v3matchDirection(lastNormalVec, lastNormalVec, firstNormalVec);\n  v3copy(prevNormal, firstNormalVec);\n  var n1 = n - 1;\n\n  for (var i = 0; i < n; ++i) {\n    var j = smoothstep(0, n1, i) * n1;\n    var t = i === 0 ? 0 : 1 / (n - j);\n    v3fromArray(tangentVec, tangentVectors, i * 3);\n    v3orthogonalize(normalVec, tangentVec, v3slerp(tmpNormal, prevNormal, lastNormalVec, t));\n    v3toArray(normalVec, normalVectors, i * 3);\n    v3copy(prevNormal, normalVec);\n    v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));\n    v3toArray(binormalVec, binormalVectors, i * 3);\n  }\n\n  for (var i = 1; i < n1; ++i) {\n    v3fromArray(prevNormal, normalVectors, (i - 1) * 3);\n    v3fromArray(normalVec, normalVectors, i * 3);\n    v3fromArray(nextNormal, normalVectors, (i + 1) * 3);\n    v3scale(normalVec, v3add(normalVec, prevNormal, v3add(normalVec, nextNormal, normalVec)), 1 / 3);\n    v3toArray(normalVec, normalVectors, i * 3);\n    v3fromArray(tangentVec, tangentVectors, i * 3);\n    v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));\n    v3toArray(binormalVec, binormalVectors, i * 3);\n  }\n}\nexport function interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift) {\n  var widthValues = state.widthValues,\n      heightValues = state.heightValues,\n      linearSegments = state.linearSegments;\n  var shift1 = 1 - shift;\n\n  for (var i = 0; i <= linearSegments; ++i) {\n    var t = i * 1.0 / linearSegments;\n\n    if (t < shift1) {\n      widthValues[i] = lerp(w0, w1, t + shift);\n      heightValues[i] = lerp(h0, h1, t + shift);\n    } else {\n      widthValues[i] = lerp(w1, w2, t - shift1);\n      heightValues[i] = lerp(h1, h2, t - shift1);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../../src/mol-repr/structure/visual/util/polymer/curve-segment.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Vec3 } from '../../../../../mol-math/linear-algebra';\r\nimport { lerp, smoothstep } from '../../../../../mol-math/interpolate';\r\n// avoiding namespace lookup improved performance in Chrome (Aug 2020)\r\nvar v3fromArray = Vec3.fromArray;\r\nvar v3toArray = Vec3.toArray;\r\nvar v3normalize = Vec3.normalize;\r\nvar v3sub = Vec3.sub;\r\nvar v3spline = Vec3.spline;\r\nvar v3slerp = Vec3.slerp;\r\nvar v3copy = Vec3.copy;\r\nvar v3cross = Vec3.cross;\r\nvar v3orthogonalize = Vec3.orthogonalize;\r\nvar v3matchDirection = Vec3.matchDirection;\r\nvar v3scale = Vec3.scale;\r\nvar v3add = Vec3.add;\r\nexport function createCurveSegmentState(linearSegments) {\r\n    var n = linearSegments + 1;\r\n    var pn = n * 3;\r\n    return {\r\n        curvePoints: new Float32Array(pn),\r\n        tangentVectors: new Float32Array(pn),\r\n        normalVectors: new Float32Array(pn),\r\n        binormalVectors: new Float32Array(pn),\r\n        widthValues: new Float32Array(n),\r\n        heightValues: new Float32Array(n),\r\n        linearSegments: linearSegments\r\n    };\r\n}\r\nexport function interpolateCurveSegment(state, controls, tension, shift) {\r\n    interpolatePointsAndTangents(state, controls, tension, shift);\r\n    interpolateNormals(state, controls);\r\n}\r\nvar tanA = Vec3();\r\nvar tanB = Vec3();\r\nvar curvePoint = Vec3();\r\nexport function interpolatePointsAndTangents(state, controls, tension, shift) {\r\n    var curvePoints = state.curvePoints, tangentVectors = state.tangentVectors, linearSegments = state.linearSegments;\r\n    var p0 = controls.p0, p1 = controls.p1, p2 = controls.p2, p3 = controls.p3, p4 = controls.p4, secStrucFirst = controls.secStrucFirst, secStrucLast = controls.secStrucLast;\r\n    var shift1 = 1 - shift;\r\n    var tensionBeg = secStrucFirst ? 0.5 : tension;\r\n    var tensionEnd = secStrucLast ? 0.5 : tension;\r\n    for (var j = 0; j <= linearSegments; ++j) {\r\n        var t = j * 1.0 / linearSegments;\r\n        if (t < shift1) {\r\n            var te = lerp(tensionBeg, tension, t);\r\n            v3spline(curvePoint, p0, p1, p2, p3, t + shift, te);\r\n            v3spline(tanA, p0, p1, p2, p3, t + shift + 0.01, tensionBeg);\r\n            v3spline(tanB, p0, p1, p2, p3, t + shift - 0.01, tensionBeg);\r\n        }\r\n        else {\r\n            var te = lerp(tension, tensionEnd, t);\r\n            v3spline(curvePoint, p1, p2, p3, p4, t - shift1, te);\r\n            v3spline(tanA, p1, p2, p3, p4, t - shift1 + 0.01, te);\r\n            v3spline(tanB, p1, p2, p3, p4, t - shift1 - 0.01, te);\r\n        }\r\n        v3toArray(curvePoint, curvePoints, j * 3);\r\n        v3normalize(tangentVec, v3sub(tangentVec, tanA, tanB));\r\n        v3toArray(tangentVec, tangentVectors, j * 3);\r\n    }\r\n}\r\nvar tmpNormal = Vec3();\r\nvar tangentVec = Vec3();\r\nvar normalVec = Vec3();\r\nvar binormalVec = Vec3();\r\nvar prevNormal = Vec3();\r\nvar nextNormal = Vec3();\r\nvar firstTangentVec = Vec3();\r\nvar lastTangentVec = Vec3();\r\nvar firstNormalVec = Vec3();\r\nvar lastNormalVec = Vec3();\r\n/**\r\n * Populate normalVectors by interpolating from firstDirection to lastDirection with\r\n * resulting vector perpendicular to tangentVectors and binormalVectors\r\n */\r\nexport function interpolateNormals(state, controls) {\r\n    var curvePoints = state.curvePoints, tangentVectors = state.tangentVectors, normalVectors = state.normalVectors, binormalVectors = state.binormalVectors;\r\n    var firstDirection = controls.d12, lastDirection = controls.d23;\r\n    var n = curvePoints.length / 3;\r\n    v3fromArray(firstTangentVec, tangentVectors, 0);\r\n    v3fromArray(lastTangentVec, tangentVectors, (n - 1) * 3);\r\n    v3orthogonalize(firstNormalVec, firstTangentVec, firstDirection);\r\n    v3orthogonalize(lastNormalVec, lastTangentVec, lastDirection);\r\n    v3matchDirection(lastNormalVec, lastNormalVec, firstNormalVec);\r\n    v3copy(prevNormal, firstNormalVec);\r\n    var n1 = n - 1;\r\n    for (var i = 0; i < n; ++i) {\r\n        var j = smoothstep(0, n1, i) * n1;\r\n        var t = i === 0 ? 0 : 1 / (n - j);\r\n        v3fromArray(tangentVec, tangentVectors, i * 3);\r\n        v3orthogonalize(normalVec, tangentVec, v3slerp(tmpNormal, prevNormal, lastNormalVec, t));\r\n        v3toArray(normalVec, normalVectors, i * 3);\r\n        v3copy(prevNormal, normalVec);\r\n        v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));\r\n        v3toArray(binormalVec, binormalVectors, i * 3);\r\n    }\r\n    for (var i = 1; i < n1; ++i) {\r\n        v3fromArray(prevNormal, normalVectors, (i - 1) * 3);\r\n        v3fromArray(normalVec, normalVectors, i * 3);\r\n        v3fromArray(nextNormal, normalVectors, (i + 1) * 3);\r\n        v3scale(normalVec, v3add(normalVec, prevNormal, v3add(normalVec, nextNormal, normalVec)), 1 / 3);\r\n        v3toArray(normalVec, normalVectors, i * 3);\r\n        v3fromArray(tangentVec, tangentVectors, i * 3);\r\n        v3normalize(binormalVec, v3cross(binormalVec, tangentVec, normalVec));\r\n        v3toArray(binormalVec, binormalVectors, i * 3);\r\n    }\r\n}\r\nexport function interpolateSizes(state, w0, w1, w2, h0, h1, h2, shift) {\r\n    var widthValues = state.widthValues, heightValues = state.heightValues, linearSegments = state.linearSegments;\r\n    var shift1 = 1 - shift;\r\n    for (var i = 0; i <= linearSegments; ++i) {\r\n        var t = i * 1.0 / linearSegments;\r\n        if (t < shift1) {\r\n            widthValues[i] = lerp(w0, w1, t + shift);\r\n            heightValues[i] = lerp(h0, h1, t + shift);\r\n        }\r\n        else {\r\n            widthValues[i] = lerp(w1, w2, t - shift1);\r\n            heightValues[i] = lerp(h1, h2, t - shift1);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=curve-segment.js.map"]},"metadata":{},"sourceType":"module"}