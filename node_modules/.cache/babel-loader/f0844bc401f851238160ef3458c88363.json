{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Task } from '../../mol-task';\nimport { CIF } from '../../mol-io/reader/cif';\nimport { createModels } from './basic/parser';\nimport { ModelSymmetry } from './property/symmetry';\nimport { ModelSecondaryStructure } from './property/secondary-structure';\nimport { Table } from '../../mol-data/db';\nimport { AtomSiteAnisotrop } from './property/anisotropic';\nimport { ComponentBond } from './property/bonds/chem_comp';\nimport { StructConn } from './property/bonds/struct_conn';\nimport { GlobalModelTransformInfo } from '../../mol-model/structure/model/properties/global-transform';\n\nfunction modelSymmetryFromMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  return ModelSymmetry.fromData(model.sourceData.data.db);\n}\n\nModelSymmetry.Provider.formatRegistry.add('mmCIF', modelSymmetryFromMmcif);\n\nfunction secondaryStructureFromMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  var _a = model.sourceData.data.db,\n      struct_conf = _a.struct_conf,\n      struct_sheet_range = _a.struct_sheet_range;\n  return ModelSecondaryStructure.fromStruct(struct_conf, struct_sheet_range, model.atomicHierarchy);\n}\n\nModelSecondaryStructure.Provider.formatRegistry.add('mmCIF', secondaryStructureFromMmcif);\n\nfunction atomSiteAnisotropFromMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  var atom_site_anisotrop = model.sourceData.data.db.atom_site_anisotrop;\n  var data = Table.ofColumns(AtomSiteAnisotrop.Schema, atom_site_anisotrop);\n  var elementToAnsiotrop = AtomSiteAnisotrop.getElementToAnsiotrop(model.atomicConformation.atomId, atom_site_anisotrop.id);\n  return {\n    data: data,\n    elementToAnsiotrop: elementToAnsiotrop\n  };\n}\n\nfunction atomSiteAnisotropApplicableMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return false;\n  return model.sourceData.data.db.atom_site_anisotrop.U.isDefined;\n}\n\nAtomSiteAnisotrop.Provider.formatRegistry.add('mmCIF', atomSiteAnisotropFromMmcif, atomSiteAnisotropApplicableMmcif);\n\nfunction componentBondFromMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  var chem_comp_bond = model.sourceData.data.db.chem_comp_bond;\n  if (chem_comp_bond._rowCount === 0) return;\n  return {\n    data: chem_comp_bond,\n    entries: ComponentBond.getEntriesFromChemCompBond(chem_comp_bond)\n  };\n}\n\nComponentBond.Provider.formatRegistry.add('mmCIF', componentBondFromMmcif);\n\nfunction structConnFromMmcif(model) {\n  if (!MmcifFormat.is(model.sourceData)) return;\n  var struct_conn = model.sourceData.data.db.struct_conn;\n  if (struct_conn._rowCount === 0) return;\n  var entries = StructConn.getEntriesFromStructConn(struct_conn, model);\n  return {\n    data: struct_conn,\n    byAtomIndex: StructConn.getAtomIndexFromEntries(entries),\n    entries: entries\n  };\n}\n\nStructConn.Provider.formatRegistry.add('mmCIF', structConnFromMmcif);\nGlobalModelTransformInfo.Provider.formatRegistry.add('mmCIF', GlobalModelTransformInfo.fromMmCif, GlobalModelTransformInfo.hasData); //\n\nexport { MmcifFormat };\nvar MmcifFormat;\n\n(function (MmcifFormat) {\n  function is(x) {\n    return (x === null || x === void 0 ? void 0 : x.kind) === 'mmCIF';\n  }\n\n  MmcifFormat.is = is;\n\n  function fromFrame(frame, db, source) {\n    if (!db) db = CIF.schema.mmCIF(frame);\n    return {\n      kind: 'mmCIF',\n      name: db._name,\n      data: {\n        db: db,\n        frame: frame,\n        source: source\n      }\n    };\n  }\n\n  MmcifFormat.fromFrame = fromFrame;\n})(MmcifFormat || (MmcifFormat = {}));\n\nexport function trajectoryFromMmCIF(frame) {\n  var format = MmcifFormat.fromFrame(frame);\n  return Task.create('Create mmCIF Model', function (ctx) {\n    return createModels(format.data.db, format, ctx);\n  });\n}","map":{"version":3,"sources":["../../../src/mol-model-formats/structure/mmcif.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Task } from '../../mol-task';\r\nimport { CIF } from '../../mol-io/reader/cif';\r\nimport { createModels } from './basic/parser';\r\nimport { ModelSymmetry } from './property/symmetry';\r\nimport { ModelSecondaryStructure } from './property/secondary-structure';\r\nimport { Table } from '../../mol-data/db';\r\nimport { AtomSiteAnisotrop } from './property/anisotropic';\r\nimport { ComponentBond } from './property/bonds/chem_comp';\r\nimport { StructConn } from './property/bonds/struct_conn';\r\nimport { GlobalModelTransformInfo } from '../../mol-model/structure/model/properties/global-transform';\r\nfunction modelSymmetryFromMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    return ModelSymmetry.fromData(model.sourceData.data.db);\r\n}\r\nModelSymmetry.Provider.formatRegistry.add('mmCIF', modelSymmetryFromMmcif);\r\nfunction secondaryStructureFromMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    var _a = model.sourceData.data.db, struct_conf = _a.struct_conf, struct_sheet_range = _a.struct_sheet_range;\r\n    return ModelSecondaryStructure.fromStruct(struct_conf, struct_sheet_range, model.atomicHierarchy);\r\n}\r\nModelSecondaryStructure.Provider.formatRegistry.add('mmCIF', secondaryStructureFromMmcif);\r\nfunction atomSiteAnisotropFromMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    var atom_site_anisotrop = model.sourceData.data.db.atom_site_anisotrop;\r\n    var data = Table.ofColumns(AtomSiteAnisotrop.Schema, atom_site_anisotrop);\r\n    var elementToAnsiotrop = AtomSiteAnisotrop.getElementToAnsiotrop(model.atomicConformation.atomId, atom_site_anisotrop.id);\r\n    return { data: data, elementToAnsiotrop: elementToAnsiotrop };\r\n}\r\nfunction atomSiteAnisotropApplicableMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return false;\r\n    return model.sourceData.data.db.atom_site_anisotrop.U.isDefined;\r\n}\r\nAtomSiteAnisotrop.Provider.formatRegistry.add('mmCIF', atomSiteAnisotropFromMmcif, atomSiteAnisotropApplicableMmcif);\r\nfunction componentBondFromMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    var chem_comp_bond = model.sourceData.data.db.chem_comp_bond;\r\n    if (chem_comp_bond._rowCount === 0)\r\n        return;\r\n    return {\r\n        data: chem_comp_bond,\r\n        entries: ComponentBond.getEntriesFromChemCompBond(chem_comp_bond)\r\n    };\r\n}\r\nComponentBond.Provider.formatRegistry.add('mmCIF', componentBondFromMmcif);\r\nfunction structConnFromMmcif(model) {\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return;\r\n    var struct_conn = model.sourceData.data.db.struct_conn;\r\n    if (struct_conn._rowCount === 0)\r\n        return;\r\n    var entries = StructConn.getEntriesFromStructConn(struct_conn, model);\r\n    return {\r\n        data: struct_conn,\r\n        byAtomIndex: StructConn.getAtomIndexFromEntries(entries),\r\n        entries: entries,\r\n    };\r\n}\r\nStructConn.Provider.formatRegistry.add('mmCIF', structConnFromMmcif);\r\nGlobalModelTransformInfo.Provider.formatRegistry.add('mmCIF', GlobalModelTransformInfo.fromMmCif, GlobalModelTransformInfo.hasData);\r\n//\r\nexport { MmcifFormat };\r\nvar MmcifFormat;\r\n(function (MmcifFormat) {\r\n    function is(x) {\r\n        return (x === null || x === void 0 ? void 0 : x.kind) === 'mmCIF';\r\n    }\r\n    MmcifFormat.is = is;\r\n    function fromFrame(frame, db, source) {\r\n        if (!db)\r\n            db = CIF.schema.mmCIF(frame);\r\n        return { kind: 'mmCIF', name: db._name, data: { db: db, frame: frame, source: source } };\r\n    }\r\n    MmcifFormat.fromFrame = fromFrame;\r\n})(MmcifFormat || (MmcifFormat = {}));\r\nexport function trajectoryFromMmCIF(frame) {\r\n    var format = MmcifFormat.fromFrame(frame);\r\n    return Task.create('Create mmCIF Model', function (ctx) { return createModels(format.data.db, format, ctx); });\r\n}\r\n//# sourceMappingURL=mmcif.js.map"]},"metadata":{},"sourceType":"module"}