{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Map as ImmutableMap, OrderedSet } from 'immutable';\nimport { StateTransform } from '../transform';\nimport { TransientTree } from './transient';\nexport { StateTree };\nvar StateTree;\n\n(function (StateTree) {\n  var Impl =\n  /** @class */\n  function () {\n    function Impl(transforms, children, dependencies) {\n      this.transforms = transforms;\n      this.children = children;\n      this.dependencies = dependencies;\n    }\n\n    Object.defineProperty(Impl.prototype, \"root\", {\n      get: function () {\n        return this.transforms.get(StateTransform.RootRef);\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    Impl.prototype.asTransient = function () {\n      return new TransientTree(this);\n    };\n\n    return Impl;\n  }();\n  /**\r\n   * Create an instance of an immutable tree.\r\n   */\n\n\n  function createEmpty(customRoot) {\n    var root = customRoot || StateTransform.createRoot();\n    return create(ImmutableMap([[root.ref, root]]), ImmutableMap([[root.ref, OrderedSet()]]), ImmutableMap());\n  }\n\n  StateTree.createEmpty = createEmpty;\n\n  function create(nodes, children, dependencies) {\n    return new Impl(nodes, children, dependencies);\n  }\n\n  StateTree.create = create;\n\n  function _postOrderFunc(c) {\n    _doPostOrder(this, this.tree.transforms.get(c));\n  }\n\n  function _doPostOrder(ctx, root) {\n    var children = ctx.tree.children.get(root.ref);\n\n    if (children && children.size) {\n      children.forEach(_postOrderFunc, ctx);\n    }\n\n    ctx.f(root, ctx.tree, ctx.state);\n  }\n  /**\r\n   * Visit all nodes in a subtree in \"post order\", meaning leafs get visited first.\r\n   */\n\n\n  function doPostOrder(tree, root, state, f) {\n    var ctx = {\n      tree: tree,\n      state: state,\n      f: f\n    };\n\n    _doPostOrder(ctx, root);\n\n    return ctx.state;\n  }\n\n  StateTree.doPostOrder = doPostOrder;\n\n  function _preOrderFunc(c) {\n    _doPreOrder(this, this.tree.transforms.get(c));\n  }\n\n  function _doPreOrder(ctx, root) {\n    var ret = ctx.f(root, ctx.tree, ctx.state);\n    if (typeof ret === 'boolean' && !ret) return;\n    var children = ctx.tree.children.get(root.ref);\n\n    if (children && children.size) {\n      children.forEach(_preOrderFunc, ctx);\n    }\n  }\n  /**\r\n   * Visit all nodes in a subtree in \"pre order\", meaning leafs get visited last.\r\n   * If the visitor function returns false, the visiting for that branch is interrupted.\r\n   */\n\n\n  function doPreOrder(tree, root, state, f) {\n    var ctx = {\n      tree: tree,\n      state: state,\n      f: f\n    };\n\n    _doPreOrder(ctx, root);\n\n    return ctx.state;\n  }\n\n  StateTree.doPreOrder = doPreOrder;\n\n  function _subtree(n, _, subtree) {\n    subtree.push(n);\n  }\n  /**\r\n   * Get all nodes in a subtree, leafs come first.\r\n   */\n\n\n  function subtreePostOrder(tree, root) {\n    return doPostOrder(tree, root, [], _subtree);\n  }\n\n  StateTree.subtreePostOrder = subtreePostOrder;\n\n  function _visitNodeToJson(node, tree, ctx) {\n    // const children: Ref[] = [];\n    // tree.children.get(node.ref).forEach(_visitChildToJson as any, children);\n    ctx.push(StateTransform.toJSON(node));\n  }\n\n  function toJSON(tree) {\n    var transforms = [];\n    doPreOrder(tree, tree.root, transforms, _visitNodeToJson);\n    return {\n      transforms: transforms\n    };\n  }\n\n  StateTree.toJSON = toJSON;\n\n  function fromJSON(data) {\n    var nodes = ImmutableMap().asMutable();\n    var children = ImmutableMap().asMutable();\n    var dependencies = ImmutableMap().asMutable();\n\n    for (var _i = 0, _a = data.transforms; _i < _a.length; _i++) {\n      var t = _a[_i];\n      var transform = StateTransform.fromJSON(t);\n      nodes.set(transform.ref, transform);\n\n      if (!children.has(transform.ref)) {\n        children.set(transform.ref, OrderedSet().asMutable());\n      }\n\n      if (transform.ref !== transform.parent) children.get(transform.parent).add(transform.ref);\n    }\n\n    var dependent = new Set();\n\n    for (var _b = 0, _c = data.transforms; _b < _c.length; _b++) {\n      var t = _c[_b];\n      var ref = t.ref;\n      children.set(ref, children.get(ref).asImmutable());\n      if (!t.dependsOn) continue;\n\n      for (var _d = 0, _e = t.dependsOn; _d < _e.length; _d++) {\n        var d = _e[_d];\n        dependent.add(d);\n\n        if (!dependencies.has(d)) {\n          dependencies.set(d, OrderedSet([ref]).asMutable());\n        } else {\n          dependencies.get(d).add(ref);\n        }\n      }\n    }\n\n    dependent.forEach(function (d) {\n      dependencies.set(d, dependencies.get(d).asImmutable());\n    });\n    return create(nodes.asImmutable(), children.asImmutable(), dependencies.asImmutable());\n  }\n\n  StateTree.fromJSON = fromJSON;\n\n  function dump(tree) {\n    console.log({\n      tr: tree.transforms.keySeq().toArray(),\n      tr1: tree.transforms.valueSeq().toArray().map(function (t) {\n        return t.ref;\n      }),\n      ch: tree.children.keySeq().toArray()\n    });\n  }\n\n  StateTree.dump = dump;\n\n  function _subtreeHasRef(tree, root, ref) {\n    if (root === ref) return true;\n    var children = tree.children.get(root);\n    var it = children.values();\n\n    while (true) {\n      var next = it.next();\n      if (next.done) return false;\n      if (_subtreeHasRef(tree, next.value, ref)) return true;\n    }\n  }\n  /** Check if the subtree with the given root has the provided ref */\n\n\n  function subtreeHasRef(tree, root, ref) {\n    if (!tree.transforms.has(root) || !tree.transforms.has(ref)) return false;\n    return _subtreeHasRef(tree, root, ref);\n  }\n\n  StateTree.subtreeHasRef = subtreeHasRef;\n\n  function getDecoratorRoot(tree, ref) {\n    var children = tree.children.get(ref);\n    if (children.size !== 1) return ref;\n    var child = tree.transforms.get(children.first());\n    if (child.transformer.definition.isDecorator) return getDecoratorRoot(tree, child.ref);\n    return ref;\n  }\n\n  StateTree.getDecoratorRoot = getDecoratorRoot;\n})(StateTree || (StateTree = {}));","map":{"version":3,"sources":["../../../src/mol-state/tree/immutable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Map as ImmutableMap, OrderedSet } from 'immutable';\r\nimport { StateTransform } from '../transform';\r\nimport { TransientTree } from './transient';\r\nexport { StateTree };\r\nvar StateTree;\r\n(function (StateTree) {\r\n    var Impl = /** @class */ (function () {\r\n        function Impl(transforms, children, dependencies) {\r\n            this.transforms = transforms;\r\n            this.children = children;\r\n            this.dependencies = dependencies;\r\n        }\r\n        Object.defineProperty(Impl.prototype, \"root\", {\r\n            get: function () { return this.transforms.get(StateTransform.RootRef); },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Impl.prototype.asTransient = function () {\r\n            return new TransientTree(this);\r\n        };\r\n        return Impl;\r\n    }());\r\n    /**\r\n     * Create an instance of an immutable tree.\r\n     */\r\n    function createEmpty(customRoot) {\r\n        var root = customRoot || StateTransform.createRoot();\r\n        return create(ImmutableMap([[root.ref, root]]), ImmutableMap([[root.ref, OrderedSet()]]), ImmutableMap());\r\n    }\r\n    StateTree.createEmpty = createEmpty;\r\n    function create(nodes, children, dependencies) {\r\n        return new Impl(nodes, children, dependencies);\r\n    }\r\n    StateTree.create = create;\r\n    function _postOrderFunc(c) { _doPostOrder(this, this.tree.transforms.get(c)); }\r\n    function _doPostOrder(ctx, root) {\r\n        var children = ctx.tree.children.get(root.ref);\r\n        if (children && children.size) {\r\n            children.forEach(_postOrderFunc, ctx);\r\n        }\r\n        ctx.f(root, ctx.tree, ctx.state);\r\n    }\r\n    /**\r\n     * Visit all nodes in a subtree in \"post order\", meaning leafs get visited first.\r\n     */\r\n    function doPostOrder(tree, root, state, f) {\r\n        var ctx = { tree: tree, state: state, f: f };\r\n        _doPostOrder(ctx, root);\r\n        return ctx.state;\r\n    }\r\n    StateTree.doPostOrder = doPostOrder;\r\n    function _preOrderFunc(c) { _doPreOrder(this, this.tree.transforms.get(c)); }\r\n    function _doPreOrder(ctx, root) {\r\n        var ret = ctx.f(root, ctx.tree, ctx.state);\r\n        if (typeof ret === 'boolean' && !ret)\r\n            return;\r\n        var children = ctx.tree.children.get(root.ref);\r\n        if (children && children.size) {\r\n            children.forEach(_preOrderFunc, ctx);\r\n        }\r\n    }\r\n    /**\r\n     * Visit all nodes in a subtree in \"pre order\", meaning leafs get visited last.\r\n     * If the visitor function returns false, the visiting for that branch is interrupted.\r\n     */\r\n    function doPreOrder(tree, root, state, f) {\r\n        var ctx = { tree: tree, state: state, f: f };\r\n        _doPreOrder(ctx, root);\r\n        return ctx.state;\r\n    }\r\n    StateTree.doPreOrder = doPreOrder;\r\n    function _subtree(n, _, subtree) { subtree.push(n); }\r\n    /**\r\n     * Get all nodes in a subtree, leafs come first.\r\n     */\r\n    function subtreePostOrder(tree, root) {\r\n        return doPostOrder(tree, root, [], _subtree);\r\n    }\r\n    StateTree.subtreePostOrder = subtreePostOrder;\r\n    function _visitNodeToJson(node, tree, ctx) {\r\n        // const children: Ref[] = [];\r\n        // tree.children.get(node.ref).forEach(_visitChildToJson as any, children);\r\n        ctx.push(StateTransform.toJSON(node));\r\n    }\r\n    function toJSON(tree) {\r\n        var transforms = [];\r\n        doPreOrder(tree, tree.root, transforms, _visitNodeToJson);\r\n        return { transforms: transforms };\r\n    }\r\n    StateTree.toJSON = toJSON;\r\n    function fromJSON(data) {\r\n        var nodes = ImmutableMap().asMutable();\r\n        var children = ImmutableMap().asMutable();\r\n        var dependencies = ImmutableMap().asMutable();\r\n        for (var _i = 0, _a = data.transforms; _i < _a.length; _i++) {\r\n            var t = _a[_i];\r\n            var transform = StateTransform.fromJSON(t);\r\n            nodes.set(transform.ref, transform);\r\n            if (!children.has(transform.ref)) {\r\n                children.set(transform.ref, OrderedSet().asMutable());\r\n            }\r\n            if (transform.ref !== transform.parent)\r\n                children.get(transform.parent).add(transform.ref);\r\n        }\r\n        var dependent = new Set();\r\n        for (var _b = 0, _c = data.transforms; _b < _c.length; _b++) {\r\n            var t = _c[_b];\r\n            var ref = t.ref;\r\n            children.set(ref, children.get(ref).asImmutable());\r\n            if (!t.dependsOn)\r\n                continue;\r\n            for (var _d = 0, _e = t.dependsOn; _d < _e.length; _d++) {\r\n                var d = _e[_d];\r\n                dependent.add(d);\r\n                if (!dependencies.has(d)) {\r\n                    dependencies.set(d, OrderedSet([ref]).asMutable());\r\n                }\r\n                else {\r\n                    dependencies.get(d).add(ref);\r\n                }\r\n            }\r\n        }\r\n        dependent.forEach(function (d) {\r\n            dependencies.set(d, dependencies.get(d).asImmutable());\r\n        });\r\n        return create(nodes.asImmutable(), children.asImmutable(), dependencies.asImmutable());\r\n    }\r\n    StateTree.fromJSON = fromJSON;\r\n    function dump(tree) {\r\n        console.log({\r\n            tr: tree.transforms.keySeq().toArray(),\r\n            tr1: tree.transforms.valueSeq().toArray().map(function (t) { return t.ref; }),\r\n            ch: tree.children.keySeq().toArray()\r\n        });\r\n    }\r\n    StateTree.dump = dump;\r\n    function _subtreeHasRef(tree, root, ref) {\r\n        if (root === ref)\r\n            return true;\r\n        var children = tree.children.get(root);\r\n        var it = children.values();\r\n        while (true) {\r\n            var next = it.next();\r\n            if (next.done)\r\n                return false;\r\n            if (_subtreeHasRef(tree, next.value, ref))\r\n                return true;\r\n        }\r\n    }\r\n    /** Check if the subtree with the given root has the provided ref */\r\n    function subtreeHasRef(tree, root, ref) {\r\n        if (!tree.transforms.has(root) || !tree.transforms.has(ref))\r\n            return false;\r\n        return _subtreeHasRef(tree, root, ref);\r\n    }\r\n    StateTree.subtreeHasRef = subtreeHasRef;\r\n    function getDecoratorRoot(tree, ref) {\r\n        var children = tree.children.get(ref);\r\n        if (children.size !== 1)\r\n            return ref;\r\n        var child = tree.transforms.get(children.first());\r\n        if (child.transformer.definition.isDecorator)\r\n            return getDecoratorRoot(tree, child.ref);\r\n        return ref;\r\n    }\r\n    StateTree.getDecoratorRoot = getDecoratorRoot;\r\n})(StateTree || (StateTree = {}));\r\n//# sourceMappingURL=immutable.js.map"]},"metadata":{},"sourceType":"module"}