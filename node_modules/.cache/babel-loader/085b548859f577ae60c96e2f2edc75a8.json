{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Vec3 } from './vec3';\nimport { EPSILON } from './common';\n\nfunction Quat() {\n  return Quat.zero();\n}\n\n(function (Quat) {\n  function zero() {\n    // force double backing array by 0.1.\n    var ret = [0.1, 0, 0, 0];\n    ret[0] = 0.0;\n    return ret;\n  }\n\n  Quat.zero = zero;\n\n  function identity() {\n    var out = zero();\n    out[3] = 1;\n    return out;\n  }\n\n  Quat.identity = identity;\n\n  function setIdentity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n  }\n\n  Quat.setIdentity = setIdentity;\n\n  function hasNaN(q) {\n    return isNaN(q[0]) || isNaN(q[1]) || isNaN(q[2]) || isNaN(q[3]);\n  }\n\n  Quat.hasNaN = hasNaN;\n\n  function create(x, y, z, w) {\n    var out = identity();\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n  }\n\n  Quat.create = create;\n\n  function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n  }\n\n  Quat.setAxisAngle = setAxisAngle;\n  /**\r\n   * Gets the rotation axis and angle for a given\r\n   *  quaternion. If a quaternion is created with\r\n   *  setAxisAngle, this method will return the same\r\n   *  values as providied in the original parameter list\r\n   *  OR functionally equivalent values.\r\n   * Example: The quaternion formed by axis [0, 0, 1] and\r\n   *  angle -90 is the same as the quaternion formed by\r\n   *  [0, 0, 1] and 270. This method favors the latter.\r\n   */\n\n  function getAxisAngle(out_axis, q) {\n    var rad = Math.acos(q[3]) * 2.0;\n    var s = Math.sin(rad / 2.0);\n\n    if (s !== 0.0) {\n      out_axis[0] = q[0] / s;\n      out_axis[1] = q[1] / s;\n      out_axis[2] = q[2] / s;\n    } else {\n      // If s is zero, return any axis (no rotation - axis does not matter)\n      out_axis[0] = 1;\n      out_axis[1] = 0;\n      out_axis[2] = 0;\n    }\n\n    return rad;\n  }\n\n  Quat.getAxisAngle = getAxisAngle;\n\n  function multiply(out, a, b) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    var bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n  }\n\n  Quat.multiply = multiply;\n\n  function rotateX(out, a, rad) {\n    rad *= 0.5;\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    var bx = Math.sin(rad),\n        bw = Math.cos(rad);\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n  }\n\n  Quat.rotateX = rotateX;\n\n  function rotateY(out, a, rad) {\n    rad *= 0.5;\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    var by = Math.sin(rad),\n        bw = Math.cos(rad);\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n  }\n\n  Quat.rotateY = rotateY;\n\n  function rotateZ(out, a, rad) {\n    rad *= 0.5;\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    var bz = Math.sin(rad),\n        bw = Math.cos(rad);\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n  }\n\n  Quat.rotateZ = rotateZ;\n  /**\r\n   * Calculates the W component of a quat from the X, Y, and Z components.\r\n   * Assumes that quaternion is 1 unit in length.\r\n   * Any existing W component will be ignored.\r\n   */\n\n  function calculateW(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n    return out;\n  }\n\n  Quat.calculateW = calculateW;\n  /**\r\n   * Performs a spherical linear interpolation between two quat\r\n   */\n\n  function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    var bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n    var omega, cosom, sinom, scale0, scale1; // calc cosine\n\n    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)\n\n    if (cosom < 0.0) {\n      cosom = -cosom;\n      bx = -bx;\n      by = -by;\n      bz = -bz;\n      bw = -bw;\n    } // calculate coefficients\n\n\n    if (1.0 - cosom > 0.000001) {\n      // standard case (slerp)\n      omega = Math.acos(cosom);\n      sinom = Math.sin(omega);\n      scale0 = Math.sin((1.0 - t) * omega) / sinom;\n      scale1 = Math.sin(t * omega) / sinom;\n    } else {\n      // \"from\" and \"to\" quaternions are very close\n      //  ... so we can do a linear interpolation\n      scale0 = 1.0 - t;\n      scale1 = t;\n    } // calculate final values\n\n\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    return out;\n  }\n\n  Quat.slerp = slerp;\n\n  function invert(out, a) {\n    var a0 = a[0],\n        a1 = a[1],\n        a2 = a[2],\n        a3 = a[3];\n    var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n  }\n\n  Quat.invert = invert;\n  /**\r\n   * Calculates the conjugate of a quat\r\n   * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n   */\n\n  function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n  }\n\n  Quat.conjugate = conjugate;\n  /**\r\n   * Creates a quaternion from the given 3x3 rotation matrix.\r\n   *\r\n   * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n   * to renormalize the quaternion yourself where necessary.\r\n   */\n\n  function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if (fTrace > 0.0) {\n      // |w| > 1/2, may as well choose w > 1/2\n      fRoot = Math.sqrt(fTrace + 1.0); // 2w\n\n      out[3] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot; // 1/(4w)\n\n      out[0] = (m[5] - m[7]) * fRoot;\n      out[1] = (m[6] - m[2]) * fRoot;\n      out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n      // |w| <= 1/2\n      var i = 0;\n      if (m[4] > m[0]) i = 1;\n      if (m[8] > m[i * 3 + i]) i = 2;\n      var j = (i + 1) % 3;\n      var k = (i + 2) % 3;\n      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n      out[i] = 0.5 * fRoot;\n      fRoot = 0.5 / fRoot;\n      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n  }\n\n  Quat.fromMat3 = fromMat3;\n  var fromUnitVec3Temp = [0, 0, 0];\n  /** Quaternion from two normalized unit vectors. */\n\n  function fromUnitVec3(out, a, b) {\n    // assumes a and b are normalized\n    var r = Vec3.dot(a, b) + 1;\n\n    if (r < EPSILON) {\n      // If u and v are exactly opposite, rotate 180 degrees\n      // around an arbitrary orthogonal axis. Axis normalisation\n      // can happen later, when we normalise the quaternion.\n      r = 0;\n\n      if (Math.abs(a[0]) > Math.abs(a[2])) {\n        Vec3.set(fromUnitVec3Temp, -a[1], a[0], 0);\n      } else {\n        Vec3.set(fromUnitVec3Temp, 0, -a[2], a[1]);\n      }\n    } else {\n      // Otherwise, build quaternion the standard way.\n      Vec3.cross(fromUnitVec3Temp, a, b);\n    }\n\n    out[0] = fromUnitVec3Temp[0];\n    out[1] = fromUnitVec3Temp[1];\n    out[2] = fromUnitVec3Temp[2];\n    out[3] = r;\n    normalize(out, out);\n    return out;\n  }\n\n  Quat.fromUnitVec3 = fromUnitVec3;\n\n  function clone(a) {\n    var out = zero();\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n  }\n\n  Quat.clone = clone;\n\n  function toArray(a, out, offset) {\n    out[offset + 0] = a[0];\n    out[offset + 1] = a[1];\n    out[offset + 2] = a[2];\n    out[offset + 3] = a[3];\n    return out;\n  }\n\n  Quat.toArray = toArray;\n\n  function fromArray(a, array, offset) {\n    a[0] = array[offset + 0];\n    a[1] = array[offset + 1];\n    a[2] = array[offset + 2];\n    a[3] = array[offset + 3];\n    return a;\n  }\n\n  Quat.fromArray = fromArray;\n\n  function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n  }\n\n  Quat.copy = copy;\n\n  function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n  }\n\n  Quat.set = set;\n\n  function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n  }\n\n  Quat.add = add;\n\n  function normalize(out, a) {\n    var x = a[0];\n    var y = a[1];\n    var z = a[2];\n    var w = a[3];\n    var len = x * x + y * y + z * z + w * w;\n\n    if (len > 0) {\n      len = 1 / Math.sqrt(len);\n      out[0] = x * len;\n      out[1] = y * len;\n      out[2] = z * len;\n      out[3] = w * len;\n    }\n\n    return out;\n  }\n\n  Quat.normalize = normalize;\n  /**\r\n   * Sets a quaternion to represent the shortest rotation from one\r\n   * vector to another.\r\n   *\r\n   * Both vectors are assumed to be unit length.\r\n   */\n\n  var rotTmpVec3 = [0, 0, 0];\n  var rotTmpVec3UnitX = [1, 0, 0];\n  var rotTmpVec3UnitY = [0, 1, 0];\n\n  function rotationTo(out, a, b) {\n    var dot = Vec3.dot(a, b);\n\n    if (dot < -0.999999) {\n      Vec3.cross(rotTmpVec3, rotTmpVec3UnitX, a);\n      if (Vec3.magnitude(rotTmpVec3) < 0.000001) Vec3.cross(rotTmpVec3, rotTmpVec3UnitY, a);\n      Vec3.normalize(rotTmpVec3, rotTmpVec3);\n      setAxisAngle(out, rotTmpVec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      Vec3.cross(rotTmpVec3, a, b);\n      out[0] = rotTmpVec3[0];\n      out[1] = rotTmpVec3[1];\n      out[2] = rotTmpVec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  }\n\n  Quat.rotationTo = rotationTo;\n  /**\r\n   * Performs a spherical linear interpolation with two control points\r\n   */\n\n  var sqlerpTemp1 = zero();\n  var sqlerpTemp2 = zero();\n\n  function sqlerp(out, a, b, c, d, t) {\n    slerp(sqlerpTemp1, a, d, t);\n    slerp(sqlerpTemp2, b, c, t);\n    slerp(out, sqlerpTemp1, sqlerpTemp2, 2 * t * (1 - t));\n    return out;\n  }\n\n  Quat.sqlerp = sqlerp;\n  /**\r\n   * Sets the specified quaternion with values corresponding to the given\r\n   * axes. Each axis is a vec3 and is expected to be unit length and\r\n   * perpendicular to all other specified axes.\r\n   */\n\n  var axesTmpMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n  function setAxes(out, view, right, up) {\n    axesTmpMat[0] = right[0];\n    axesTmpMat[3] = right[1];\n    axesTmpMat[6] = right[2];\n    axesTmpMat[1] = up[0];\n    axesTmpMat[4] = up[1];\n    axesTmpMat[7] = up[2];\n    axesTmpMat[2] = -view[0];\n    axesTmpMat[5] = -view[1];\n    axesTmpMat[8] = -view[2];\n    return normalize(out, fromMat3(out, axesTmpMat));\n  }\n\n  Quat.setAxes = setAxes;\n\n  function toString(a, precision) {\n    return \"[\" + a[0].toPrecision(precision) + \" \" + a[1].toPrecision(precision) + \" \" + a[2].toPrecision(precision) + \"  \" + a[3].toPrecision(precision) + \"]\";\n  }\n\n  Quat.toString = toString;\n  Quat.Identity = identity();\n})(Quat || (Quat = {}));\n\nexport { Quat };","map":{"version":3,"sources":["../../../../src/mol-math/linear-algebra/3d/quat.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Vec3 } from './vec3';\r\nimport { EPSILON } from './common';\r\nfunction Quat() {\r\n    return Quat.zero();\r\n}\r\n(function (Quat) {\r\n    function zero() {\r\n        // force double backing array by 0.1.\r\n        var ret = [0.1, 0, 0, 0];\r\n        ret[0] = 0.0;\r\n        return ret;\r\n    }\r\n    Quat.zero = zero;\r\n    function identity() {\r\n        var out = zero();\r\n        out[3] = 1;\r\n        return out;\r\n    }\r\n    Quat.identity = identity;\r\n    function setIdentity(out) {\r\n        out[0] = 0;\r\n        out[1] = 0;\r\n        out[2] = 0;\r\n        out[3] = 1;\r\n    }\r\n    Quat.setIdentity = setIdentity;\r\n    function hasNaN(q) {\r\n        return isNaN(q[0]) || isNaN(q[1]) || isNaN(q[2]) || isNaN(q[3]);\r\n    }\r\n    Quat.hasNaN = hasNaN;\r\n    function create(x, y, z, w) {\r\n        var out = identity();\r\n        out[0] = x;\r\n        out[1] = y;\r\n        out[2] = z;\r\n        out[3] = w;\r\n        return out;\r\n    }\r\n    Quat.create = create;\r\n    function setAxisAngle(out, axis, rad) {\r\n        rad = rad * 0.5;\r\n        var s = Math.sin(rad);\r\n        out[0] = s * axis[0];\r\n        out[1] = s * axis[1];\r\n        out[2] = s * axis[2];\r\n        out[3] = Math.cos(rad);\r\n        return out;\r\n    }\r\n    Quat.setAxisAngle = setAxisAngle;\r\n    /**\r\n     * Gets the rotation axis and angle for a given\r\n     *  quaternion. If a quaternion is created with\r\n     *  setAxisAngle, this method will return the same\r\n     *  values as providied in the original parameter list\r\n     *  OR functionally equivalent values.\r\n     * Example: The quaternion formed by axis [0, 0, 1] and\r\n     *  angle -90 is the same as the quaternion formed by\r\n     *  [0, 0, 1] and 270. This method favors the latter.\r\n     */\r\n    function getAxisAngle(out_axis, q) {\r\n        var rad = Math.acos(q[3]) * 2.0;\r\n        var s = Math.sin(rad / 2.0);\r\n        if (s !== 0.0) {\r\n            out_axis[0] = q[0] / s;\r\n            out_axis[1] = q[1] / s;\r\n            out_axis[2] = q[2] / s;\r\n        }\r\n        else {\r\n            // If s is zero, return any axis (no rotation - axis does not matter)\r\n            out_axis[0] = 1;\r\n            out_axis[1] = 0;\r\n            out_axis[2] = 0;\r\n        }\r\n        return rad;\r\n    }\r\n    Quat.getAxisAngle = getAxisAngle;\r\n    function multiply(out, a, b) {\r\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3];\r\n        var bx = b[0], by = b[1], bz = b[2], bw = b[3];\r\n        out[0] = ax * bw + aw * bx + ay * bz - az * by;\r\n        out[1] = ay * bw + aw * by + az * bx - ax * bz;\r\n        out[2] = az * bw + aw * bz + ax * by - ay * bx;\r\n        out[3] = aw * bw - ax * bx - ay * by - az * bz;\r\n        return out;\r\n    }\r\n    Quat.multiply = multiply;\r\n    function rotateX(out, a, rad) {\r\n        rad *= 0.5;\r\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3];\r\n        var bx = Math.sin(rad), bw = Math.cos(rad);\r\n        out[0] = ax * bw + aw * bx;\r\n        out[1] = ay * bw + az * bx;\r\n        out[2] = az * bw - ay * bx;\r\n        out[3] = aw * bw - ax * bx;\r\n        return out;\r\n    }\r\n    Quat.rotateX = rotateX;\r\n    function rotateY(out, a, rad) {\r\n        rad *= 0.5;\r\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3];\r\n        var by = Math.sin(rad), bw = Math.cos(rad);\r\n        out[0] = ax * bw - az * by;\r\n        out[1] = ay * bw + aw * by;\r\n        out[2] = az * bw + ax * by;\r\n        out[3] = aw * bw - ay * by;\r\n        return out;\r\n    }\r\n    Quat.rotateY = rotateY;\r\n    function rotateZ(out, a, rad) {\r\n        rad *= 0.5;\r\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3];\r\n        var bz = Math.sin(rad), bw = Math.cos(rad);\r\n        out[0] = ax * bw + ay * bz;\r\n        out[1] = ay * bw - ax * bz;\r\n        out[2] = az * bw + aw * bz;\r\n        out[3] = aw * bw - az * bz;\r\n        return out;\r\n    }\r\n    Quat.rotateZ = rotateZ;\r\n    /**\r\n     * Calculates the W component of a quat from the X, Y, and Z components.\r\n     * Assumes that quaternion is 1 unit in length.\r\n     * Any existing W component will be ignored.\r\n     */\r\n    function calculateW(out, a) {\r\n        var x = a[0], y = a[1], z = a[2];\r\n        out[0] = x;\r\n        out[1] = y;\r\n        out[2] = z;\r\n        out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n        return out;\r\n    }\r\n    Quat.calculateW = calculateW;\r\n    /**\r\n     * Performs a spherical linear interpolation between two quat\r\n     */\r\n    function slerp(out, a, b, t) {\r\n        // benchmarks:\r\n        //    http://jsperf.com/quaternion-slerp-implementations\r\n        var ax = a[0], ay = a[1], az = a[2], aw = a[3];\r\n        var bx = b[0], by = b[1], bz = b[2], bw = b[3];\r\n        var omega, cosom, sinom, scale0, scale1;\r\n        // calc cosine\r\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n        // adjust signs (if necessary)\r\n        if (cosom < 0.0) {\r\n            cosom = -cosom;\r\n            bx = -bx;\r\n            by = -by;\r\n            bz = -bz;\r\n            bw = -bw;\r\n        }\r\n        // calculate coefficients\r\n        if ((1.0 - cosom) > 0.000001) {\r\n            // standard case (slerp)\r\n            omega = Math.acos(cosom);\r\n            sinom = Math.sin(omega);\r\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n            scale1 = Math.sin(t * omega) / sinom;\r\n        }\r\n        else {\r\n            // \"from\" and \"to\" quaternions are very close\r\n            //  ... so we can do a linear interpolation\r\n            scale0 = 1.0 - t;\r\n            scale1 = t;\r\n        }\r\n        // calculate final values\r\n        out[0] = scale0 * ax + scale1 * bx;\r\n        out[1] = scale0 * ay + scale1 * by;\r\n        out[2] = scale0 * az + scale1 * bz;\r\n        out[3] = scale0 * aw + scale1 * bw;\r\n        return out;\r\n    }\r\n    Quat.slerp = slerp;\r\n    function invert(out, a) {\r\n        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\r\n        var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n        var invDot = dot ? 1.0 / dot : 0;\r\n        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n        out[0] = -a0 * invDot;\r\n        out[1] = -a1 * invDot;\r\n        out[2] = -a2 * invDot;\r\n        out[3] = a3 * invDot;\r\n        return out;\r\n    }\r\n    Quat.invert = invert;\r\n    /**\r\n     * Calculates the conjugate of a quat\r\n     * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n     */\r\n    function conjugate(out, a) {\r\n        out[0] = -a[0];\r\n        out[1] = -a[1];\r\n        out[2] = -a[2];\r\n        out[3] = a[3];\r\n        return out;\r\n    }\r\n    Quat.conjugate = conjugate;\r\n    /**\r\n     * Creates a quaternion from the given 3x3 rotation matrix.\r\n     *\r\n     * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n     * to renormalize the quaternion yourself where necessary.\r\n     */\r\n    function fromMat3(out, m) {\r\n        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n        // article \"Quaternion Calculus and Fast Animation\".\r\n        var fTrace = m[0] + m[4] + m[8];\r\n        var fRoot;\r\n        if (fTrace > 0.0) {\r\n            // |w| > 1/2, may as well choose w > 1/2\r\n            fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n            out[3] = 0.5 * fRoot;\r\n            fRoot = 0.5 / fRoot; // 1/(4w)\r\n            out[0] = (m[5] - m[7]) * fRoot;\r\n            out[1] = (m[6] - m[2]) * fRoot;\r\n            out[2] = (m[1] - m[3]) * fRoot;\r\n        }\r\n        else {\r\n            // |w| <= 1/2\r\n            var i = 0;\r\n            if (m[4] > m[0])\r\n                i = 1;\r\n            if (m[8] > m[i * 3 + i])\r\n                i = 2;\r\n            var j = (i + 1) % 3;\r\n            var k = (i + 2) % 3;\r\n            fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\r\n            out[i] = 0.5 * fRoot;\r\n            fRoot = 0.5 / fRoot;\r\n            out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\r\n            out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n            out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n        }\r\n        return out;\r\n    }\r\n    Quat.fromMat3 = fromMat3;\r\n    var fromUnitVec3Temp = [0, 0, 0];\r\n    /** Quaternion from two normalized unit vectors. */\r\n    function fromUnitVec3(out, a, b) {\r\n        // assumes a and b are normalized\r\n        var r = Vec3.dot(a, b) + 1;\r\n        if (r < EPSILON) {\r\n            // If u and v are exactly opposite, rotate 180 degrees\r\n            // around an arbitrary orthogonal axis. Axis normalisation\r\n            // can happen later, when we normalise the quaternion.\r\n            r = 0;\r\n            if (Math.abs(a[0]) > Math.abs(a[2])) {\r\n                Vec3.set(fromUnitVec3Temp, -a[1], a[0], 0);\r\n            }\r\n            else {\r\n                Vec3.set(fromUnitVec3Temp, 0, -a[2], a[1]);\r\n            }\r\n        }\r\n        else {\r\n            // Otherwise, build quaternion the standard way.\r\n            Vec3.cross(fromUnitVec3Temp, a, b);\r\n        }\r\n        out[0] = fromUnitVec3Temp[0];\r\n        out[1] = fromUnitVec3Temp[1];\r\n        out[2] = fromUnitVec3Temp[2];\r\n        out[3] = r;\r\n        normalize(out, out);\r\n        return out;\r\n    }\r\n    Quat.fromUnitVec3 = fromUnitVec3;\r\n    function clone(a) {\r\n        var out = zero();\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        return out;\r\n    }\r\n    Quat.clone = clone;\r\n    function toArray(a, out, offset) {\r\n        out[offset + 0] = a[0];\r\n        out[offset + 1] = a[1];\r\n        out[offset + 2] = a[2];\r\n        out[offset + 3] = a[3];\r\n        return out;\r\n    }\r\n    Quat.toArray = toArray;\r\n    function fromArray(a, array, offset) {\r\n        a[0] = array[offset + 0];\r\n        a[1] = array[offset + 1];\r\n        a[2] = array[offset + 2];\r\n        a[3] = array[offset + 3];\r\n        return a;\r\n    }\r\n    Quat.fromArray = fromArray;\r\n    function copy(out, a) {\r\n        out[0] = a[0];\r\n        out[1] = a[1];\r\n        out[2] = a[2];\r\n        out[3] = a[3];\r\n        return out;\r\n    }\r\n    Quat.copy = copy;\r\n    function set(out, x, y, z, w) {\r\n        out[0] = x;\r\n        out[1] = y;\r\n        out[2] = z;\r\n        out[3] = w;\r\n        return out;\r\n    }\r\n    Quat.set = set;\r\n    function add(out, a, b) {\r\n        out[0] = a[0] + b[0];\r\n        out[1] = a[1] + b[1];\r\n        out[2] = a[2] + b[2];\r\n        out[3] = a[3] + b[3];\r\n        return out;\r\n    }\r\n    Quat.add = add;\r\n    function normalize(out, a) {\r\n        var x = a[0];\r\n        var y = a[1];\r\n        var z = a[2];\r\n        var w = a[3];\r\n        var len = x * x + y * y + z * z + w * w;\r\n        if (len > 0) {\r\n            len = 1 / Math.sqrt(len);\r\n            out[0] = x * len;\r\n            out[1] = y * len;\r\n            out[2] = z * len;\r\n            out[3] = w * len;\r\n        }\r\n        return out;\r\n    }\r\n    Quat.normalize = normalize;\r\n    /**\r\n     * Sets a quaternion to represent the shortest rotation from one\r\n     * vector to another.\r\n     *\r\n     * Both vectors are assumed to be unit length.\r\n     */\r\n    var rotTmpVec3 = [0, 0, 0];\r\n    var rotTmpVec3UnitX = [1, 0, 0];\r\n    var rotTmpVec3UnitY = [0, 1, 0];\r\n    function rotationTo(out, a, b) {\r\n        var dot = Vec3.dot(a, b);\r\n        if (dot < -0.999999) {\r\n            Vec3.cross(rotTmpVec3, rotTmpVec3UnitX, a);\r\n            if (Vec3.magnitude(rotTmpVec3) < 0.000001)\r\n                Vec3.cross(rotTmpVec3, rotTmpVec3UnitY, a);\r\n            Vec3.normalize(rotTmpVec3, rotTmpVec3);\r\n            setAxisAngle(out, rotTmpVec3, Math.PI);\r\n            return out;\r\n        }\r\n        else if (dot > 0.999999) {\r\n            out[0] = 0;\r\n            out[1] = 0;\r\n            out[2] = 0;\r\n            out[3] = 1;\r\n            return out;\r\n        }\r\n        else {\r\n            Vec3.cross(rotTmpVec3, a, b);\r\n            out[0] = rotTmpVec3[0];\r\n            out[1] = rotTmpVec3[1];\r\n            out[2] = rotTmpVec3[2];\r\n            out[3] = 1 + dot;\r\n            return normalize(out, out);\r\n        }\r\n    }\r\n    Quat.rotationTo = rotationTo;\r\n    /**\r\n     * Performs a spherical linear interpolation with two control points\r\n     */\r\n    var sqlerpTemp1 = zero();\r\n    var sqlerpTemp2 = zero();\r\n    function sqlerp(out, a, b, c, d, t) {\r\n        slerp(sqlerpTemp1, a, d, t);\r\n        slerp(sqlerpTemp2, b, c, t);\r\n        slerp(out, sqlerpTemp1, sqlerpTemp2, 2 * t * (1 - t));\r\n        return out;\r\n    }\r\n    Quat.sqlerp = sqlerp;\r\n    /**\r\n     * Sets the specified quaternion with values corresponding to the given\r\n     * axes. Each axis is a vec3 and is expected to be unit length and\r\n     * perpendicular to all other specified axes.\r\n     */\r\n    var axesTmpMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n    function setAxes(out, view, right, up) {\r\n        axesTmpMat[0] = right[0];\r\n        axesTmpMat[3] = right[1];\r\n        axesTmpMat[6] = right[2];\r\n        axesTmpMat[1] = up[0];\r\n        axesTmpMat[4] = up[1];\r\n        axesTmpMat[7] = up[2];\r\n        axesTmpMat[2] = -view[0];\r\n        axesTmpMat[5] = -view[1];\r\n        axesTmpMat[8] = -view[2];\r\n        return normalize(out, fromMat3(out, axesTmpMat));\r\n    }\r\n    Quat.setAxes = setAxes;\r\n    function toString(a, precision) {\r\n        return \"[\" + a[0].toPrecision(precision) + \" \" + a[1].toPrecision(precision) + \" \" + a[2].toPrecision(precision) + \"  \" + a[3].toPrecision(precision) + \"]\";\r\n    }\r\n    Quat.toString = toString;\r\n    Quat.Identity = identity();\r\n})(Quat || (Quat = {}));\r\nexport { Quat };\r\n//# sourceMappingURL=quat.js.map"]},"metadata":{},"sourceType":"module"}