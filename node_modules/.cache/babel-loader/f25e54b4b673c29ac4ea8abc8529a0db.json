{"ast":null,"code":"/**\r\n * Copyright (c) 2018 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Type } from '../type';\nimport { Arguments, Argument } from '../symbol';\nimport { symbol, normalizeTable, symbolList } from '../helpers';\nexport var Types;\n\n(function (Types) {\n  Types.AnyVar = Type.Variable('a', Type.Any);\n  Types.AnyValueVar = Type.Variable('a', Type.Any);\n  Types.ConstrainedVar = Type.Variable('a', Type.Any, true);\n  Types.Regex = Type.Value('Core', 'Regex');\n\n  Types.Set = function (t) {\n    return Type.Container('Core', 'Set', t || Types.AnyValueVar);\n  };\n\n  Types.List = function (t) {\n    return Type.Container('Core', 'List', t || Types.AnyVar);\n  };\n\n  Types.Fn = function (t, alias) {\n    return Type.Container('Core', 'Fn', t || Types.AnyVar, alias);\n  };\n\n  Types.Flags = function (t, alias) {\n    return Type.Container('Core', 'Flags', t, alias);\n  };\n\n  Types.BitFlags = Types.Flags(Type.Num, 'BitFlags');\n})(Types || (Types = {}));\n\nfunction unaryOp(type, description) {\n  return symbol(Arguments.Dictionary({\n    0: Argument(type)\n  }), type, description);\n}\n\nfunction binOp(type, description) {\n  return symbol(Arguments.List(type, {\n    nonEmpty: true\n  }), type, description);\n}\n\nfunction binRel(src, target, description) {\n  return symbol(Arguments.Dictionary({\n    0: Argument(src),\n    1: Argument(src)\n  }), target, description);\n}\n\nexport var TTargs = Arguments.Dictionary({\n  0: Argument(Type.Num),\n  1: Argument(Type.Num)\n});\nvar XX = {\n  test: Argument(Type.Str)\n};\nvar t = 0;\nt.test;\nvar type = {\n  '@header': 'Types',\n  bool: symbol(Arguments.Dictionary({\n    0: Argument(Type.AnyValue)\n  }), Type.Bool, 'Convert a value to boolean.'),\n  num: symbol(Arguments.Dictionary({\n    0: Argument(Type.AnyValue)\n  }), Type.Num, 'Convert a value to number.'),\n  str: symbol(Arguments.Dictionary({\n    0: Argument(Type.AnyValue)\n  }), Type.Str, 'Convert a value to string.'),\n  regex: symbol(Arguments.Dictionary({\n    0: Argument(Type.Str, {\n      description: 'Expression'\n    }),\n    1: Argument(Type.Str, {\n      isOptional: true,\n      description: \"Flags, e.g. 'i' for ignore case\"\n    })\n  }), Types.Regex, 'Creates a regular expression from a string using the ECMAscript syntax.'),\n  list: symbol(Arguments.List(Types.AnyVar), Types.List()),\n  set: symbol(Arguments.List(Types.AnyValueVar), Types.Set()),\n  bitflags: symbol(Arguments.Dictionary({\n    0: Argument(Type.Num)\n  }), Types.BitFlags, 'Interpret a number as bitflags.'),\n  compositeKey: symbol(Arguments.List(Type.AnyValue), Type.AnyValue)\n};\nvar logic = {\n  '@header': 'Logic',\n  not: unaryOp(Type.Bool),\n  and: binOp(Type.Bool),\n  or: binOp(Type.Bool)\n};\nvar ctrl = {\n  '@header': 'Control',\n  eval: symbol(Arguments.Dictionary({\n    0: Argument(Types.Fn(Types.AnyVar))\n  }), Types.AnyVar, 'Evaluate a function.'),\n  fn: symbol(Arguments.Dictionary({\n    0: Argument(Types.AnyVar)\n  }), Types.Fn(Types.AnyVar), 'Wrap an expression to a \"lazy\" function.'),\n  if: symbol(Arguments.Dictionary({\n    0: Argument(Type.Bool, {\n      description: 'Condition'\n    }),\n    1: Argument(Type.Variable('a', Type.Any), {\n      description: 'If true'\n    }),\n    2: Argument(Type.Variable('b', Type.Any), {\n      description: 'If false'\n    })\n  }), Type.Union([Type.Variable('a', Type.Any), Type.Variable('b', Type.Any)])),\n  assoc: symbol(Arguments.Dictionary({\n    0: Argument(Type.Str, {\n      description: 'Name'\n    }),\n    1: Argument(Type.Variable('a', Type.Any), {\n      description: 'Value to assign'\n    })\n  }), Type.Variable('a', Type.Any))\n};\nvar rel = {\n  '@header': 'Relational',\n  eq: binRel(Type.Variable('a', Type.AnyValue, true), Type.Bool),\n  neq: binRel(Type.Variable('a', Type.AnyValue, true), Type.Bool),\n  lt: binRel(Type.Num, Type.Bool),\n  lte: binRel(Type.Num, Type.Bool),\n  gr: binRel(Type.Num, Type.Bool),\n  gre: binRel(Type.Num, Type.Bool),\n  inRange: symbol(Arguments.Dictionary({\n    0: Argument(Type.Num, {\n      description: 'Value to test'\n    }),\n    1: Argument(Type.Num, {\n      description: 'Minimum value'\n    }),\n    2: Argument(Type.Num, {\n      description: 'Maximum value'\n    })\n  }), Type.Bool, 'Check if the value of the 1st argument is >= 2nd and <= 3rd.')\n};\nvar math = {\n  '@header': 'Math',\n  add: binOp(Type.Num),\n  sub: binOp(Type.Num),\n  mult: binOp(Type.Num),\n  div: binRel(Type.Num, Type.Num),\n  pow: binRel(Type.Num, Type.Num),\n  mod: binRel(Type.Num, Type.Num),\n  min: binOp(Type.Num),\n  max: binOp(Type.Num),\n  floor: unaryOp(Type.Num),\n  ceil: unaryOp(Type.Num),\n  roundInt: unaryOp(Type.Num),\n  abs: unaryOp(Type.Num),\n  sqrt: unaryOp(Type.Num),\n  cbrt: unaryOp(Type.Num),\n  sin: unaryOp(Type.Num),\n  cos: unaryOp(Type.Num),\n  tan: unaryOp(Type.Num),\n  asin: unaryOp(Type.Num),\n  acos: unaryOp(Type.Num),\n  atan: unaryOp(Type.Num),\n  sinh: unaryOp(Type.Num),\n  cosh: unaryOp(Type.Num),\n  tanh: unaryOp(Type.Num),\n  exp: unaryOp(Type.Num),\n  log: unaryOp(Type.Num),\n  log10: unaryOp(Type.Num),\n  atan2: binRel(Type.Num, Type.Num)\n};\nvar str = {\n  '@header': 'Strings',\n  concat: binOp(Type.Str),\n  match: symbol(Arguments.Dictionary({\n    0: Argument(Types.Regex),\n    1: Argument(Type.Str)\n  }), Type.Bool)\n};\nvar list = {\n  '@header': 'Lists',\n  getAt: symbol(Arguments.Dictionary({\n    0: Argument(Types.List()),\n    1: Argument(Type.Num)\n  }), Types.AnyVar),\n  equal: symbol(Arguments.Dictionary({\n    0: Argument(Types.List()),\n    1: Argument(Types.List())\n  }), Type.Bool)\n};\nvar set = {\n  '@header': 'Sets',\n  has: symbol(Arguments.Dictionary({\n    0: Argument(Types.Set(Types.ConstrainedVar)),\n    1: Argument(Types.ConstrainedVar)\n  }), Type.Bool, 'Check if the the 1st argument includes the value of the 2nd.'),\n  isSubset: symbol(Arguments.Dictionary({\n    0: Argument(Types.Set(Types.ConstrainedVar)),\n    1: Argument(Types.Set(Types.ConstrainedVar))\n  }), Type.Bool, 'Check if the the 1st argument is a subset of the 2nd.')\n};\nvar flags = {\n  '@header': 'Flags',\n  hasAny: symbol(Arguments.Dictionary({\n    0: Argument(Types.Flags(Types.ConstrainedVar)),\n    1: Argument(Types.Flags(Types.ConstrainedVar))\n  }), Type.Bool, 'Check if the the 1st argument has at least one of the 2nd one\\'s flags.'),\n  hasAll: symbol(Arguments.Dictionary({\n    0: Argument(Types.Flags(Types.ConstrainedVar)),\n    1: Argument(Types.Flags(Types.ConstrainedVar))\n  }), Type.Bool, 'Check if the the 1st argument has all 2nd one\\'s flags.')\n};\nexport var core = {\n  '@header': 'Language Primitives',\n  type: type,\n  logic: logic,\n  ctrl: ctrl,\n  rel: rel,\n  math: math,\n  str: str,\n  list: list,\n  set: set,\n  flags: flags\n};\nnormalizeTable(core);\nexport var SymbolList = symbolList(core);\nexport var SymbolMap = function () {\n  var map = Object.create(null);\n\n  for (var _i = 0, SymbolList_1 = SymbolList; _i < SymbolList_1.length; _i++) {\n    var s = SymbolList_1[_i];\n    map[s.id] = s;\n  }\n\n  return map;\n}();","map":{"version":3,"sources":["../../../../src/mol-script/language/symbol-table/core.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Type } from '../type';\r\nimport { Arguments, Argument } from '../symbol';\r\nimport { symbol, normalizeTable, symbolList } from '../helpers';\r\nexport var Types;\r\n(function (Types) {\r\n    Types.AnyVar = Type.Variable('a', Type.Any);\r\n    Types.AnyValueVar = Type.Variable('a', Type.Any);\r\n    Types.ConstrainedVar = Type.Variable('a', Type.Any, true);\r\n    Types.Regex = Type.Value('Core', 'Regex');\r\n    Types.Set = function (t) { return Type.Container('Core', 'Set', t || Types.AnyValueVar); };\r\n    Types.List = function (t) { return Type.Container('Core', 'List', t || Types.AnyVar); };\r\n    Types.Fn = function (t, alias) { return Type.Container('Core', 'Fn', t || Types.AnyVar, alias); };\r\n    Types.Flags = function (t, alias) { return Type.Container('Core', 'Flags', t, alias); };\r\n    Types.BitFlags = Types.Flags(Type.Num, 'BitFlags');\r\n})(Types || (Types = {}));\r\nfunction unaryOp(type, description) {\r\n    return symbol(Arguments.Dictionary({ 0: Argument(type) }), type, description);\r\n}\r\nfunction binOp(type, description) {\r\n    return symbol(Arguments.List(type, { nonEmpty: true }), type, description);\r\n}\r\nfunction binRel(src, target, description) {\r\n    return symbol(Arguments.Dictionary({\r\n        0: Argument(src),\r\n        1: Argument(src)\r\n    }), target, description);\r\n}\r\nexport var TTargs = Arguments.Dictionary({\r\n    0: Argument(Type.Num),\r\n    1: Argument(Type.Num)\r\n});\r\nvar XX = { test: Argument(Type.Str) };\r\nvar t = 0;\r\nt.test;\r\nvar type = {\r\n    '@header': 'Types',\r\n    bool: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Bool, 'Convert a value to boolean.'),\r\n    num: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Num, 'Convert a value to number.'),\r\n    str: symbol(Arguments.Dictionary({ 0: Argument(Type.AnyValue) }), Type.Str, 'Convert a value to string.'),\r\n    regex: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Str, { description: 'Expression' }),\r\n        1: Argument(Type.Str, { isOptional: true, description: \"Flags, e.g. 'i' for ignore case\" })\r\n    }), Types.Regex, 'Creates a regular expression from a string using the ECMAscript syntax.'),\r\n    list: symbol(Arguments.List(Types.AnyVar), Types.List()),\r\n    set: symbol(Arguments.List(Types.AnyValueVar), Types.Set()),\r\n    bitflags: symbol(Arguments.Dictionary({ 0: Argument(Type.Num) }), Types.BitFlags, 'Interpret a number as bitflags.'),\r\n    compositeKey: symbol(Arguments.List(Type.AnyValue), Type.AnyValue),\r\n};\r\nvar logic = {\r\n    '@header': 'Logic',\r\n    not: unaryOp(Type.Bool),\r\n    and: binOp(Type.Bool),\r\n    or: binOp(Type.Bool),\r\n};\r\nvar ctrl = {\r\n    '@header': 'Control',\r\n    eval: symbol(Arguments.Dictionary({ 0: Argument(Types.Fn(Types.AnyVar)) }), Types.AnyVar, 'Evaluate a function.'),\r\n    fn: symbol(Arguments.Dictionary({ 0: Argument(Types.AnyVar) }), Types.Fn(Types.AnyVar), 'Wrap an expression to a \"lazy\" function.'),\r\n    if: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Bool, { description: 'Condition' }),\r\n        1: Argument(Type.Variable('a', Type.Any), { description: 'If true' }),\r\n        2: Argument(Type.Variable('b', Type.Any), { description: 'If false' })\r\n    }), Type.Union([Type.Variable('a', Type.Any), Type.Variable('b', Type.Any)])),\r\n    assoc: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Str, { description: 'Name' }),\r\n        1: Argument(Type.Variable('a', Type.Any), { description: 'Value to assign' })\r\n    }), Type.Variable('a', Type.Any))\r\n};\r\nvar rel = {\r\n    '@header': 'Relational',\r\n    eq: binRel(Type.Variable('a', Type.AnyValue, true), Type.Bool),\r\n    neq: binRel(Type.Variable('a', Type.AnyValue, true), Type.Bool),\r\n    lt: binRel(Type.Num, Type.Bool),\r\n    lte: binRel(Type.Num, Type.Bool),\r\n    gr: binRel(Type.Num, Type.Bool),\r\n    gre: binRel(Type.Num, Type.Bool),\r\n    inRange: symbol(Arguments.Dictionary({\r\n        0: Argument(Type.Num, { description: 'Value to test' }),\r\n        1: Argument(Type.Num, { description: 'Minimum value' }),\r\n        2: Argument(Type.Num, { description: 'Maximum value' })\r\n    }), Type.Bool, 'Check if the value of the 1st argument is >= 2nd and <= 3rd.'),\r\n};\r\nvar math = {\r\n    '@header': 'Math',\r\n    add: binOp(Type.Num),\r\n    sub: binOp(Type.Num),\r\n    mult: binOp(Type.Num),\r\n    div: binRel(Type.Num, Type.Num),\r\n    pow: binRel(Type.Num, Type.Num),\r\n    mod: binRel(Type.Num, Type.Num),\r\n    min: binOp(Type.Num),\r\n    max: binOp(Type.Num),\r\n    floor: unaryOp(Type.Num),\r\n    ceil: unaryOp(Type.Num),\r\n    roundInt: unaryOp(Type.Num),\r\n    abs: unaryOp(Type.Num),\r\n    sqrt: unaryOp(Type.Num),\r\n    cbrt: unaryOp(Type.Num),\r\n    sin: unaryOp(Type.Num),\r\n    cos: unaryOp(Type.Num),\r\n    tan: unaryOp(Type.Num),\r\n    asin: unaryOp(Type.Num),\r\n    acos: unaryOp(Type.Num),\r\n    atan: unaryOp(Type.Num),\r\n    sinh: unaryOp(Type.Num),\r\n    cosh: unaryOp(Type.Num),\r\n    tanh: unaryOp(Type.Num),\r\n    exp: unaryOp(Type.Num),\r\n    log: unaryOp(Type.Num),\r\n    log10: unaryOp(Type.Num),\r\n    atan2: binRel(Type.Num, Type.Num)\r\n};\r\nvar str = {\r\n    '@header': 'Strings',\r\n    concat: binOp(Type.Str),\r\n    match: symbol(Arguments.Dictionary({ 0: Argument(Types.Regex), 1: Argument(Type.Str) }), Type.Bool)\r\n};\r\nvar list = {\r\n    '@header': 'Lists',\r\n    getAt: symbol(Arguments.Dictionary({ 0: Argument(Types.List()), 1: Argument(Type.Num) }), Types.AnyVar),\r\n    equal: symbol(Arguments.Dictionary({ 0: Argument(Types.List()), 1: Argument(Types.List()) }), Type.Bool)\r\n};\r\nvar set = {\r\n    '@header': 'Sets',\r\n    has: symbol(Arguments.Dictionary({ 0: Argument(Types.Set(Types.ConstrainedVar)), 1: Argument(Types.ConstrainedVar) }), Type.Bool, 'Check if the the 1st argument includes the value of the 2nd.'),\r\n    isSubset: symbol(Arguments.Dictionary({ 0: Argument(Types.Set(Types.ConstrainedVar)), 1: Argument(Types.Set(Types.ConstrainedVar)) }), Type.Bool, 'Check if the the 1st argument is a subset of the 2nd.')\r\n};\r\nvar flags = {\r\n    '@header': 'Flags',\r\n    hasAny: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.Flags(Types.ConstrainedVar)),\r\n        1: Argument(Types.Flags(Types.ConstrainedVar))\r\n    }), Type.Bool, 'Check if the the 1st argument has at least one of the 2nd one\\'s flags.'),\r\n    hasAll: symbol(Arguments.Dictionary({\r\n        0: Argument(Types.Flags(Types.ConstrainedVar)),\r\n        1: Argument(Types.Flags(Types.ConstrainedVar))\r\n    }), Type.Bool, 'Check if the the 1st argument has all 2nd one\\'s flags.'),\r\n};\r\nexport var core = {\r\n    '@header': 'Language Primitives',\r\n    type: type,\r\n    logic: logic,\r\n    ctrl: ctrl,\r\n    rel: rel,\r\n    math: math,\r\n    str: str,\r\n    list: list,\r\n    set: set,\r\n    flags: flags\r\n};\r\nnormalizeTable(core);\r\nexport var SymbolList = symbolList(core);\r\nexport var SymbolMap = (function () {\r\n    var map = Object.create(null);\r\n    for (var _i = 0, SymbolList_1 = SymbolList; _i < SymbolList_1.length; _i++) {\r\n        var s = SymbolList_1[_i];\r\n        map[s.id] = s;\r\n    }\r\n    return map;\r\n})();\r\n//# sourceMappingURL=core.js.map"]},"metadata":{},"sourceType":"module"}