/**
 * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { StructureElement } from '../../../../../mol-model/structure';
import { Segmentation } from '../../../../../mol-data/int';
import { SortedRanges } from '../../../../../mol-data/int/sorted-ranges';
import { getPolymerRanges } from '../polymer';
/** Iterates over consecutive pairs of residues/coarse elements in polymers */
export function PolymerBackboneIterator(structure, unit) {
    switch (unit.kind) {
        case 0 /* Atomic */: return new AtomicPolymerBackboneIterator(structure, unit);
        case 1 /* Spheres */:
        case 2 /* Gaussians */:
            return new CoarsePolymerBackboneIterator(structure, unit);
    }
}
function createPolymerBackbonePair(structure, unit) {
    return {
        centerA: StructureElement.Location.create(structure, unit),
        centerB: StructureElement.Location.create(structure, unit),
    };
}
var AtomicPolymerBackboneIterator = /** @class */ (function () {
    function AtomicPolymerBackboneIterator(structure, unit) {
        this.unit = unit;
        this.state = 0 /* nextPolymer */;
        this.hasNext = false;
        this.traceElementIndex = unit.model.atomicHierarchy.derived.residue.traceElementIndex; // can assume it won't be -1 for polymer residues
        this.polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
        this.residueIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);
        this.value = createPolymerBackbonePair(structure, unit);
        this.hasNext = this.residueIt.hasNext && this.polymerIt.hasNext;
    }
    AtomicPolymerBackboneIterator.prototype.move = function () {
        if (this.state === 0 /* nextPolymer */) {
            while (this.polymerIt.hasNext) {
                this.residueIt.setSegment(this.polymerIt.move());
                if (this.residueIt.hasNext) {
                    this.residueSegment = this.residueIt.move();
                    this.value.centerB.element = this.traceElementIndex[this.residueSegment.index];
                    this.state = 2 /* nextResidue */;
                    break;
                }
            }
        }
        if (this.state === 2 /* nextResidue */) {
            this.residueSegment = this.residueIt.move();
            this.value.centerA.element = this.value.centerB.element;
            this.value.centerB.element = this.traceElementIndex[this.residueSegment.index];
            if (!this.residueIt.hasNext) {
                if (this.unit.model.atomicRanges.cyclicPolymerMap.has(this.residueSegment.index)) {
                    this.state = 3 /* cycle */;
                }
                else {
                    // TODO need to advance to a polymer that has two or more residues (can't assume it has)
                    this.state = 0 /* nextPolymer */;
                }
            }
        }
        else if (this.state === 3 /* cycle */) {
            var cyclicPolymerMap = this.unit.model.atomicRanges.cyclicPolymerMap;
            this.value.centerA.element = this.value.centerB.element;
            this.value.centerB.element = this.traceElementIndex[cyclicPolymerMap.get(this.residueSegment.index)];
            // TODO need to advance to a polymer that has two or more residues (can't assume it has)
            this.state = 0 /* nextPolymer */;
        }
        this.hasNext = this.residueIt.hasNext || this.polymerIt.hasNext || this.state === 3 /* cycle */;
        return this.value;
    };
    return AtomicPolymerBackboneIterator;
}());
export { AtomicPolymerBackboneIterator };
var CoarsePolymerBackboneIterator = /** @class */ (function () {
    function CoarsePolymerBackboneIterator(structure, unit) {
        this.unit = unit;
        this.state = 0 /* nextPolymer */;
        this.hasNext = false;
        this.polymerIt = SortedRanges.transientSegments(getPolymerRanges(unit), unit.elements);
        this.value = createPolymerBackbonePair(structure, unit);
        this.hasNext = this.polymerIt.hasNext;
    }
    CoarsePolymerBackboneIterator.prototype.move = function () {
        if (this.state === 0 /* nextPolymer */) {
            if (this.polymerIt.hasNext) {
                this.polymerSegment = this.polymerIt.move();
                this.elementIndex = this.polymerSegment.start;
                if (this.elementIndex + 1 < this.polymerSegment.end) {
                    this.value.centerB.element = this.unit.elements[this.elementIndex];
                    this.state = 1 /* nextElement */;
                }
                else {
                    this.state = 0 /* nextPolymer */;
                }
            }
        }
        if (this.state === 1 /* nextElement */) {
            this.elementIndex += 1;
            this.value.centerA.element = this.value.centerB.element;
            this.value.centerB.element = this.unit.elements[this.elementIndex];
            if (this.elementIndex + 1 >= this.polymerSegment.end) {
                this.state = 0 /* nextPolymer */;
            }
        }
        this.hasNext = this.elementIndex + 1 < this.polymerSegment.end || this.polymerIt.hasNext;
        return this.value;
    };
    return CoarsePolymerBackboneIterator;
}());
export { CoarsePolymerBackboneIterator };
//# sourceMappingURL=backbone-iterator.js.map