{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { StructureElement } from '../../../structure';\nimport { Segmentation } from '../../../../../mol-data/int';\nimport { UUID } from '../../../../../mol-util';\nexport var IndexedCustomProperty;\n\n(function (IndexedCustomProperty) {\n  function getCifDataSource(structure, prop, cache) {\n    if (!prop) return {\n      rowCount: 0\n    };\n    if (cache && cache[prop.id]) return cache[prop.id];\n    var data = prop.getElements(structure);\n    var ret = {\n      data: data,\n      rowCount: data.elements.length\n    };\n    if (cache) cache[prop.id] = ret;\n    return ret;\n  }\n\n  IndexedCustomProperty.getCifDataSource = getCifDataSource;\n\n  function fromAtomMap(map) {\n    return new ElementMappedCustomProperty(map);\n  }\n\n  IndexedCustomProperty.fromAtomMap = fromAtomMap;\n\n  function fromAtomArray(array) {\n    // TODO: create \"array based custom property\" as optimization\n    return new ElementMappedCustomProperty(arrayToMap(array));\n  }\n\n  IndexedCustomProperty.fromAtomArray = fromAtomArray;\n\n  var getResidueSegments = function (model) {\n    return model.atomicHierarchy.residueAtomSegments;\n  };\n\n  function fromResidueMap(map) {\n    return new SegmentedMappedIndexedCustomProperty('residue', map, getResidueSegments, 0\n    /* Atomic */\n    );\n  }\n\n  IndexedCustomProperty.fromResidueMap = fromResidueMap;\n\n  function fromResidueArray(array) {\n    // TODO: create \"array based custom property\" as optimization\n    return new SegmentedMappedIndexedCustomProperty('residue', arrayToMap(array), getResidueSegments, 0\n    /* Atomic */\n    );\n  }\n\n  IndexedCustomProperty.fromResidueArray = fromResidueArray;\n\n  var getChainSegments = function (model) {\n    return model.atomicHierarchy.chainAtomSegments;\n  };\n\n  function fromChainMap(map) {\n    return new SegmentedMappedIndexedCustomProperty('chain', map, getChainSegments, 0\n    /* Atomic */\n    );\n  }\n\n  IndexedCustomProperty.fromChainMap = fromChainMap;\n\n  function fromChainArray(array) {\n    // TODO: create \"array based custom property\" as optimization\n    return new SegmentedMappedIndexedCustomProperty('chain', arrayToMap(array), getChainSegments, 0\n    /* Atomic */\n    );\n  }\n\n  IndexedCustomProperty.fromChainArray = fromChainArray;\n\n  function fromEntityMap(map) {\n    return new EntityMappedCustomProperty(map);\n  }\n\n  IndexedCustomProperty.fromEntityMap = fromEntityMap;\n})(IndexedCustomProperty || (IndexedCustomProperty = {}));\n\nfunction arrayToMap(array) {\n  var ret = new Map();\n\n  for (var i = 0, _i = array.length; i < _i; i++) ret.set(i, array[i]);\n\n  return ret;\n}\n\nvar SegmentedMappedIndexedCustomProperty =\n/** @class */\nfunction () {\n  function SegmentedMappedIndexedCustomProperty(level, map, segmentGetter, kind) {\n    this.level = level;\n    this.map = map;\n    this.segmentGetter = segmentGetter;\n    this.id = UUID.create22();\n    this.kind = kind;\n  }\n\n  SegmentedMappedIndexedCustomProperty.prototype.has = function (idx) {\n    return this.map.has(idx);\n  };\n\n  SegmentedMappedIndexedCustomProperty.prototype.get = function (idx) {\n    return this.map.get(idx);\n  };\n\n  SegmentedMappedIndexedCustomProperty.prototype.getStructureElements = function (structure) {\n    var models = structure.models;\n    if (models.length !== 1) throw new Error(\"Only works on structures with a single model.\");\n    var seenIndices = new Set();\n    var unitGroups = structure.unitSymmetryGroups;\n    var loci = [];\n    var segments = this.segmentGetter(models[0]);\n\n    for (var _a = 0, unitGroups_1 = unitGroups; _a < unitGroups_1.length; _a++) {\n      var unitGroup = unitGroups_1[_a];\n      var unit = unitGroup.units[0];\n\n      if (unit.kind !== this.kind) {\n        continue;\n      }\n\n      var chains = Segmentation.transientSegments(segments, unit.elements);\n\n      while (chains.hasNext) {\n        var seg = chains.move();\n        if (!this.has(seg.index) || seenIndices.has(seg.index)) continue;\n        seenIndices.add(seg.index);\n        loci[loci.length] = StructureElement.Location.create(structure, unit, unit.elements[seg.start]);\n      }\n    }\n\n    loci.sort(function (x, y) {\n      return x.element - y.element;\n    });\n    return loci;\n  };\n\n  SegmentedMappedIndexedCustomProperty.prototype.getElements = function (structure) {\n    var _this = this;\n\n    var index = this.segmentGetter(structure.model).index;\n    var elements = this.getStructureElements(structure);\n    return {\n      elements: elements,\n      property: function (i) {\n        return _this.get(index[elements[i].element]);\n      }\n    };\n  };\n\n  return SegmentedMappedIndexedCustomProperty;\n}();\n\nvar ElementMappedCustomProperty =\n/** @class */\nfunction () {\n  function ElementMappedCustomProperty(map) {\n    this.map = map;\n    this.id = UUID.create22();\n    this.level = 'atom';\n    this.kind = 0\n    /* Atomic */\n    ;\n  }\n\n  ElementMappedCustomProperty.prototype.has = function (idx) {\n    return this.map.has(idx);\n  };\n\n  ElementMappedCustomProperty.prototype.get = function (idx) {\n    return this.map.get(idx);\n  };\n\n  ElementMappedCustomProperty.prototype.getStructureElements = function (structure) {\n    var models = structure.models;\n    if (models.length !== 1) throw new Error(\"Only works on structures with a single model.\");\n    var seenIndices = new Set();\n    var unitGroups = structure.unitSymmetryGroups;\n    var loci = [];\n\n    for (var _a = 0, unitGroups_2 = unitGroups; _a < unitGroups_2.length; _a++) {\n      var unitGroup = unitGroups_2[_a];\n      var unit = unitGroup.units[0];\n\n      if (unit.kind !== this.kind) {\n        continue;\n      }\n\n      var elements = unit.elements;\n\n      for (var i = 0, _i = elements.length; i < _i; i++) {\n        var e = elements[i];\n        if (!this.has(e) || seenIndices.has(e)) continue;\n        seenIndices.add(elements[i]);\n        loci[loci.length] = StructureElement.Location.create(structure, unit, e);\n      }\n    }\n\n    loci.sort(function (x, y) {\n      return x.element - y.element;\n    });\n    return loci;\n  };\n\n  ElementMappedCustomProperty.prototype.getElements = function (structure) {\n    var _this = this;\n\n    var elements = this.getStructureElements(structure);\n    return {\n      elements: elements,\n      property: function (i) {\n        return _this.get(elements[i].element);\n      }\n    };\n  };\n\n  return ElementMappedCustomProperty;\n}();\n\nvar EntityMappedCustomProperty =\n/** @class */\nfunction () {\n  function EntityMappedCustomProperty(map) {\n    this.map = map;\n    this.id = UUID.create22();\n    this.level = 'entity';\n    this.kind = 0\n    /* Atomic */\n    ;\n  }\n\n  EntityMappedCustomProperty.prototype.has = function (idx) {\n    return this.map.has(idx);\n  };\n\n  EntityMappedCustomProperty.prototype.get = function (idx) {\n    return this.map.get(idx);\n  };\n\n  EntityMappedCustomProperty.prototype.getStructureElements = function (structure) {\n    var models = structure.models;\n    if (models.length !== 1) throw new Error(\"Only works on structures with a single model.\");\n    var index = models[0].atomicHierarchy.index;\n    var seenIndices = new Set();\n    var unitGroups = structure.unitSymmetryGroups;\n    var loci = [];\n    var segments = models[0].atomicHierarchy.chainAtomSegments;\n\n    for (var _a = 0, unitGroups_3 = unitGroups; _a < unitGroups_3.length; _a++) {\n      var unitGroup = unitGroups_3[_a];\n      var unit = unitGroup.units[0];\n\n      if (unit.kind !== this.kind) {\n        continue;\n      }\n\n      var chains = Segmentation.transientSegments(segments, unit.elements);\n\n      while (chains.hasNext) {\n        var seg = chains.move();\n        var eI = index.getEntityFromChain(seg.index);\n        if (!this.has(eI) || seenIndices.has(eI)) continue;\n        seenIndices.add(eI);\n        loci[loci.length] = StructureElement.Location.create(structure, unit, unit.elements[seg.start]);\n      }\n    }\n\n    loci.sort(function (x, y) {\n      return x.element - y.element;\n    });\n    return loci;\n  };\n\n  EntityMappedCustomProperty.prototype.getElements = function (structure) {\n    var _this = this;\n\n    var elements = this.getStructureElements(structure);\n    var chainIndex = structure.model.atomicHierarchy.chainAtomSegments.index;\n    var index = structure.model.atomicHierarchy.index;\n    return {\n      elements: elements,\n      property: function (i) {\n        return _this.get(index.getEntityFromChain(chainIndex[elements[i].element]));\n      }\n    };\n  };\n\n  return EntityMappedCustomProperty;\n}();","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/model/properties/custom/indexed.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { StructureElement } from '../../../structure';\r\nimport { Segmentation } from '../../../../../mol-data/int';\r\nimport { UUID } from '../../../../../mol-util';\r\nexport var IndexedCustomProperty;\r\n(function (IndexedCustomProperty) {\r\n    function getCifDataSource(structure, prop, cache) {\r\n        if (!prop)\r\n            return { rowCount: 0 };\r\n        if (cache && cache[prop.id])\r\n            return cache[prop.id];\r\n        var data = prop.getElements(structure);\r\n        var ret = { data: data, rowCount: data.elements.length };\r\n        if (cache)\r\n            cache[prop.id] = ret;\r\n        return ret;\r\n    }\r\n    IndexedCustomProperty.getCifDataSource = getCifDataSource;\r\n    function fromAtomMap(map) {\r\n        return new ElementMappedCustomProperty(map);\r\n    }\r\n    IndexedCustomProperty.fromAtomMap = fromAtomMap;\r\n    function fromAtomArray(array) {\r\n        // TODO: create \"array based custom property\" as optimization\r\n        return new ElementMappedCustomProperty(arrayToMap(array));\r\n    }\r\n    IndexedCustomProperty.fromAtomArray = fromAtomArray;\r\n    var getResidueSegments = function (model) { return model.atomicHierarchy.residueAtomSegments; };\r\n    function fromResidueMap(map) {\r\n        return new SegmentedMappedIndexedCustomProperty('residue', map, getResidueSegments, 0 /* Atomic */);\r\n    }\r\n    IndexedCustomProperty.fromResidueMap = fromResidueMap;\r\n    function fromResidueArray(array) {\r\n        // TODO: create \"array based custom property\" as optimization\r\n        return new SegmentedMappedIndexedCustomProperty('residue', arrayToMap(array), getResidueSegments, 0 /* Atomic */);\r\n    }\r\n    IndexedCustomProperty.fromResidueArray = fromResidueArray;\r\n    var getChainSegments = function (model) { return model.atomicHierarchy.chainAtomSegments; };\r\n    function fromChainMap(map) {\r\n        return new SegmentedMappedIndexedCustomProperty('chain', map, getChainSegments, 0 /* Atomic */);\r\n    }\r\n    IndexedCustomProperty.fromChainMap = fromChainMap;\r\n    function fromChainArray(array) {\r\n        // TODO: create \"array based custom property\" as optimization\r\n        return new SegmentedMappedIndexedCustomProperty('chain', arrayToMap(array), getChainSegments, 0 /* Atomic */);\r\n    }\r\n    IndexedCustomProperty.fromChainArray = fromChainArray;\r\n    function fromEntityMap(map) {\r\n        return new EntityMappedCustomProperty(map);\r\n    }\r\n    IndexedCustomProperty.fromEntityMap = fromEntityMap;\r\n})(IndexedCustomProperty || (IndexedCustomProperty = {}));\r\nfunction arrayToMap(array) {\r\n    var ret = new Map();\r\n    for (var i = 0, _i = array.length; i < _i; i++)\r\n        ret.set(i, array[i]);\r\n    return ret;\r\n}\r\nvar SegmentedMappedIndexedCustomProperty = /** @class */ (function () {\r\n    function SegmentedMappedIndexedCustomProperty(level, map, segmentGetter, kind) {\r\n        this.level = level;\r\n        this.map = map;\r\n        this.segmentGetter = segmentGetter;\r\n        this.id = UUID.create22();\r\n        this.kind = kind;\r\n    }\r\n    SegmentedMappedIndexedCustomProperty.prototype.has = function (idx) { return this.map.has(idx); };\r\n    SegmentedMappedIndexedCustomProperty.prototype.get = function (idx) { return this.map.get(idx); };\r\n    SegmentedMappedIndexedCustomProperty.prototype.getStructureElements = function (structure) {\r\n        var models = structure.models;\r\n        if (models.length !== 1)\r\n            throw new Error(\"Only works on structures with a single model.\");\r\n        var seenIndices = new Set();\r\n        var unitGroups = structure.unitSymmetryGroups;\r\n        var loci = [];\r\n        var segments = this.segmentGetter(models[0]);\r\n        for (var _a = 0, unitGroups_1 = unitGroups; _a < unitGroups_1.length; _a++) {\r\n            var unitGroup = unitGroups_1[_a];\r\n            var unit = unitGroup.units[0];\r\n            if (unit.kind !== this.kind) {\r\n                continue;\r\n            }\r\n            var chains = Segmentation.transientSegments(segments, unit.elements);\r\n            while (chains.hasNext) {\r\n                var seg = chains.move();\r\n                if (!this.has(seg.index) || seenIndices.has(seg.index))\r\n                    continue;\r\n                seenIndices.add(seg.index);\r\n                loci[loci.length] = StructureElement.Location.create(structure, unit, unit.elements[seg.start]);\r\n            }\r\n        }\r\n        loci.sort(function (x, y) { return x.element - y.element; });\r\n        return loci;\r\n    };\r\n    SegmentedMappedIndexedCustomProperty.prototype.getElements = function (structure) {\r\n        var _this = this;\r\n        var index = this.segmentGetter(structure.model).index;\r\n        var elements = this.getStructureElements(structure);\r\n        return { elements: elements, property: function (i) { return _this.get(index[elements[i].element]); } };\r\n    };\r\n    return SegmentedMappedIndexedCustomProperty;\r\n}());\r\nvar ElementMappedCustomProperty = /** @class */ (function () {\r\n    function ElementMappedCustomProperty(map) {\r\n        this.map = map;\r\n        this.id = UUID.create22();\r\n        this.level = 'atom';\r\n        this.kind = 0 /* Atomic */;\r\n    }\r\n    ElementMappedCustomProperty.prototype.has = function (idx) { return this.map.has(idx); };\r\n    ElementMappedCustomProperty.prototype.get = function (idx) { return this.map.get(idx); };\r\n    ElementMappedCustomProperty.prototype.getStructureElements = function (structure) {\r\n        var models = structure.models;\r\n        if (models.length !== 1)\r\n            throw new Error(\"Only works on structures with a single model.\");\r\n        var seenIndices = new Set();\r\n        var unitGroups = structure.unitSymmetryGroups;\r\n        var loci = [];\r\n        for (var _a = 0, unitGroups_2 = unitGroups; _a < unitGroups_2.length; _a++) {\r\n            var unitGroup = unitGroups_2[_a];\r\n            var unit = unitGroup.units[0];\r\n            if (unit.kind !== this.kind) {\r\n                continue;\r\n            }\r\n            var elements = unit.elements;\r\n            for (var i = 0, _i = elements.length; i < _i; i++) {\r\n                var e = elements[i];\r\n                if (!this.has(e) || seenIndices.has(e))\r\n                    continue;\r\n                seenIndices.add(elements[i]);\r\n                loci[loci.length] = StructureElement.Location.create(structure, unit, e);\r\n            }\r\n        }\r\n        loci.sort(function (x, y) { return x.element - y.element; });\r\n        return loci;\r\n    };\r\n    ElementMappedCustomProperty.prototype.getElements = function (structure) {\r\n        var _this = this;\r\n        var elements = this.getStructureElements(structure);\r\n        return { elements: elements, property: function (i) { return _this.get(elements[i].element); } };\r\n    };\r\n    return ElementMappedCustomProperty;\r\n}());\r\nvar EntityMappedCustomProperty = /** @class */ (function () {\r\n    function EntityMappedCustomProperty(map) {\r\n        this.map = map;\r\n        this.id = UUID.create22();\r\n        this.level = 'entity';\r\n        this.kind = 0 /* Atomic */;\r\n    }\r\n    EntityMappedCustomProperty.prototype.has = function (idx) { return this.map.has(idx); };\r\n    EntityMappedCustomProperty.prototype.get = function (idx) { return this.map.get(idx); };\r\n    EntityMappedCustomProperty.prototype.getStructureElements = function (structure) {\r\n        var models = structure.models;\r\n        if (models.length !== 1)\r\n            throw new Error(\"Only works on structures with a single model.\");\r\n        var index = models[0].atomicHierarchy.index;\r\n        var seenIndices = new Set();\r\n        var unitGroups = structure.unitSymmetryGroups;\r\n        var loci = [];\r\n        var segments = models[0].atomicHierarchy.chainAtomSegments;\r\n        for (var _a = 0, unitGroups_3 = unitGroups; _a < unitGroups_3.length; _a++) {\r\n            var unitGroup = unitGroups_3[_a];\r\n            var unit = unitGroup.units[0];\r\n            if (unit.kind !== this.kind) {\r\n                continue;\r\n            }\r\n            var chains = Segmentation.transientSegments(segments, unit.elements);\r\n            while (chains.hasNext) {\r\n                var seg = chains.move();\r\n                var eI = index.getEntityFromChain(seg.index);\r\n                if (!this.has(eI) || seenIndices.has(eI))\r\n                    continue;\r\n                seenIndices.add(eI);\r\n                loci[loci.length] = StructureElement.Location.create(structure, unit, unit.elements[seg.start]);\r\n            }\r\n        }\r\n        loci.sort(function (x, y) { return x.element - y.element; });\r\n        return loci;\r\n    };\r\n    EntityMappedCustomProperty.prototype.getElements = function (structure) {\r\n        var _this = this;\r\n        var elements = this.getStructureElements(structure);\r\n        var chainIndex = structure.model.atomicHierarchy.chainAtomSegments.index;\r\n        var index = structure.model.atomicHierarchy.index;\r\n        return { elements: elements, property: function (i) { return _this.get(index.getEntityFromChain(chainIndex[elements[i].element])); } };\r\n    };\r\n    return EntityMappedCustomProperty;\r\n}());\r\n//# sourceMappingURL=indexed.js.map"]},"metadata":{},"sourceType":"module"}