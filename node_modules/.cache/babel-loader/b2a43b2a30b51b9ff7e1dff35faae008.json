{"ast":null,"code":"/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { Segmentation, SortedArray } from '../../../../../mol-data/int';\nimport { IntAdjacencyGraph } from '../../../../../mol-math/graph';\nimport { BondType } from '../../../model/types';\nimport { sortArray } from '../../../../../mol-data/util';\nimport { arraySetAdd, arraySetRemove } from '../../../../../mol-util/array';\nexport function computeRings(unit) {\n  var size = largestResidue(unit);\n  var state = State(unit, size);\n  var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n\n  while (residuesIt.hasNext) {\n    var seg = residuesIt.move();\n    processResidue(state, seg.start, seg.end);\n  }\n\n  return state.rings;\n}\n\nfunction State(unit, capacity) {\n  return {\n    startVertex: 0,\n    endVertex: 0,\n    count: 0,\n    visited: new Int32Array(capacity),\n    queue: new Int32Array(capacity),\n    pred: new Int32Array(capacity),\n    left: new Int32Array(4\n    /* MaxDepth */\n    ),\n    right: new Int32Array(4\n    /* MaxDepth */\n    ),\n    color: new Int32Array(capacity),\n    currentColor: 0,\n    currentAltLoc: '',\n    hasAltLoc: false,\n    rings: [],\n    currentRings: [],\n    unit: unit,\n    bonds: unit.bonds,\n    altLoc: unit.model.atomicHierarchy.atoms.label_alt_id\n  };\n}\n\nfunction resetState(state) {\n  state.count = state.endVertex - state.startVertex;\n  var visited = state.visited,\n      pred = state.pred,\n      color = state.color;\n\n  for (var i = 0; i < state.count; i++) {\n    visited[i] = -1;\n    pred[i] = -1;\n    color[i] = 0;\n  }\n\n  state.currentColor = 0;\n  state.currentAltLoc = '';\n  state.hasAltLoc = false;\n}\n\nfunction largestResidue(unit) {\n  var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n  var size = 0;\n\n  while (residuesIt.hasNext) {\n    var seg = residuesIt.move();\n    size = Math.max(size, seg.end - seg.start);\n  }\n\n  return size;\n}\n\nfunction processResidue(state, start, end) {\n  var visited = state.visited;\n  state.startVertex = start;\n  state.endVertex = end; // no two atom rings\n\n  if (state.endVertex - state.startVertex < 3) return;\n  state.currentRings = [];\n  var elements = state.unit.elements;\n  var altLocs = [];\n\n  for (var i = state.startVertex; i < state.endVertex; i++) {\n    var altLoc = state.altLoc.value(elements[i]);\n    arraySetAdd(altLocs, altLoc);\n  }\n\n  arraySetRemove(altLocs, '');\n\n  if (altLocs.length === 0) {\n    resetState(state);\n\n    for (var i = 0; i < state.count; i++) {\n      if (visited[i] >= 0) continue;\n      findRings(state, i);\n    }\n  } else {\n    for (var aI = 0; aI < altLocs.length; aI++) {\n      resetState(state);\n      state.hasAltLoc = true;\n      state.currentAltLoc = altLocs[aI];\n\n      for (var i = 0; i < state.count; i++) {\n        if (visited[i] >= 0) continue;\n        var altLoc = state.altLoc.value(elements[state.startVertex + i]);\n\n        if (altLoc && altLoc !== state.currentAltLoc) {\n          continue;\n        }\n\n        findRings(state, i);\n      }\n    }\n  }\n\n  for (var i = 0, _i = state.currentRings.length; i < _i; i++) {\n    state.rings.push(state.currentRings[i]);\n  }\n}\n\nfunction addRing(state, a, b) {\n  // only \"monotonous\" rings\n  if (b < a) {\n    return;\n  }\n\n  var pred = state.pred,\n      color = state.color,\n      left = state.left,\n      right = state.right;\n  var nc = ++state.currentColor;\n  var current = a;\n\n  for (var t = 0; t < 4\n  /* MaxDepth */\n  ; t++) {\n    color[current] = nc;\n    current = pred[current];\n    if (current < 0) break;\n  }\n\n  var leftOffset = 0,\n      rightOffset = 0;\n  var found = false,\n      target = 0;\n  current = b;\n\n  for (var t = 0; t < 4\n  /* MaxDepth */\n  ; t++) {\n    if (color[current] === nc) {\n      target = current;\n      found = true;\n      break;\n    }\n\n    right[rightOffset++] = current;\n    current = pred[current];\n    if (current < 0) break;\n  }\n\n  if (!found) {\n    return;\n  }\n\n  current = a;\n\n  for (var t = 0; t < 4\n  /* MaxDepth */\n  ; t++) {\n    left[leftOffset++] = current;\n    if (target === current) break;\n    current = pred[current];\n    if (current < 0) break;\n  }\n\n  var len = leftOffset + rightOffset; // rings must have at least three elements\n\n  if (len < 3) {\n    return;\n  }\n\n  var ring = new Int32Array(len);\n  var ringOffset = 0;\n\n  for (var t = 0; t < leftOffset; t++) ring[ringOffset++] = state.startVertex + left[t];\n\n  for (var t = rightOffset - 1; t >= 0; t--) ring[ringOffset++] = state.startVertex + right[t];\n\n  sortArray(ring);\n\n  if (state.hasAltLoc) {\n    // we need to check if the ring was already added because alt locs are present.\n    for (var rI = 0, _rI = state.currentRings.length; rI < _rI; rI++) {\n      var r = state.currentRings[rI];\n      if (ring[0] !== r[0]) continue;\n      if (ring.length !== r.length) continue;\n      var areSame = true;\n\n      for (var aI = 0, _aI = ring.length; aI < _aI; aI++) {\n        if (ring[aI] !== r[aI]) {\n          areSame = false;\n          break;\n        }\n      }\n\n      if (areSame) {\n        return;\n      }\n    }\n  }\n\n  state.currentRings.push(SortedArray.ofSortedArray(ring));\n}\n\nfunction findRings(state, from) {\n  var bonds = state.bonds,\n      startVertex = state.startVertex,\n      endVertex = state.endVertex,\n      visited = state.visited,\n      queue = state.queue,\n      pred = state.pred;\n  var elements = state.unit.elements;\n  var neighbor = bonds.b,\n      bondFlags = bonds.edgeProps.flags,\n      offset = bonds.offset;\n  visited[from] = 1;\n  queue[0] = from;\n  var head = 0,\n      size = 1;\n\n  while (head < size) {\n    var top_1 = queue[head++];\n    var a = startVertex + top_1;\n    var start = offset[a],\n        end = offset[a + 1];\n\n    for (var i = start; i < end; i++) {\n      var b = neighbor[i];\n      if (b < startVertex || b >= endVertex || !BondType.isCovalent(bondFlags[i])) continue;\n\n      if (state.hasAltLoc) {\n        var altLoc = state.altLoc.value(elements[b]);\n\n        if (altLoc && state.currentAltLoc !== altLoc) {\n          continue;\n        }\n      }\n\n      var other = b - startVertex;\n\n      if (visited[other] > 0) {\n        if (pred[other] !== top_1 && pred[top_1] !== other) {\n          addRing(state, top_1, other);\n        }\n\n        continue;\n      }\n\n      visited[other] = 1;\n      queue[size++] = other;\n      pred[other] = top_1;\n    }\n  }\n}\n\nexport function getFingerprint(elements) {\n  var len = elements.length;\n  var reversed = new Array(len);\n\n  for (var i = 0; i < len; i++) reversed[i] = elements[len - i - 1];\n\n  var rotNormal = getMinimalRotation(elements);\n  var rotReversed = getMinimalRotation(reversed);\n  var isNormalSmaller = false;\n\n  for (var i = 0; i < len; i++) {\n    var u = elements[(i + rotNormal) % len],\n        v = reversed[(i + rotReversed) % len];\n\n    if (u !== v) {\n      isNormalSmaller = u < v;\n      break;\n    }\n  }\n\n  if (isNormalSmaller) return buildFinderprint(elements, rotNormal);\n  return buildFinderprint(reversed, rotReversed);\n}\n\nfunction getMinimalRotation(elements) {\n  // adapted from http://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\n  var len = elements.length;\n  var f = new Int32Array(len * 2);\n\n  for (var i = 0; i < f.length; i++) f[i] = -1;\n\n  var u = '',\n      v = '',\n      k = 0;\n\n  for (var j = 1; j < f.length; j++) {\n    var i = f[j - k - 1];\n\n    while (i !== -1) {\n      u = elements[j % len];\n      v = elements[(k + i + 1) % len];\n      if (u === v) break;\n      if (u < v) k = j - i - 1;\n      i = f[i];\n    }\n\n    if (i === -1) {\n      u = elements[j % len];\n      v = elements[(k + i + 1) % len];\n\n      if (u !== v) {\n        if (u < v) k = j;\n        f[j - k] = -1;\n      } else f[j - k] = i + 1;\n    } else f[j - k] = i + 1;\n  }\n\n  return k;\n}\n\nfunction buildFinderprint(elements, offset) {\n  var len = elements.length;\n  var ret = [];\n  var i;\n\n  for (i = 0; i < len - 1; i++) {\n    ret.push(elements[(i + offset) % len]);\n    ret.push('-');\n  }\n\n  ret.push(elements[(i + offset) % len]);\n  return ret.join('');\n}\n\nexport function createIndex(rings, aromaticRings) {\n  var elementRingIndices = new Map();\n  var elementAromaticRingIndices = new Map(); // for each ring atom, assign all rings that it is present in\n\n  for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\n    var r = rings[rI];\n\n    for (var i = 0, _i = r.length; i < _i; i++) {\n      var e = r[i];\n      if (elementRingIndices.has(e)) elementRingIndices.get(e).push(rI);else elementRingIndices.set(e, [rI]);\n    }\n  } // for each ring atom, assign all aromatic rings that it is present in\n\n\n  for (var aI = 0, _aI = aromaticRings.length; aI < _aI; aI++) {\n    var rI = aromaticRings[aI];\n    var r = rings[rI];\n\n    for (var i = 0, _i = r.length; i < _i; i++) {\n      var e = r[i];\n      if (elementAromaticRingIndices.has(e)) elementAromaticRingIndices.get(e).push(rI);else elementAromaticRingIndices.set(e, [rI]);\n    }\n  } // create a graph where vertices are rings, edge if two rings share at least one atom\n\n\n  var graph = new IntAdjacencyGraph.UniqueEdgeBuilder(rings.length);\n\n  for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\n    var r = rings[rI];\n\n    for (var i = 0, _i = r.length; i < _i; i++) {\n      var e = r[i];\n      var containedRings = elementRingIndices.get(e);\n      if (containedRings.length === 1) continue;\n\n      for (var j = 0, _j = containedRings.length; j < _j; j++) {\n        var rJ = containedRings[j];\n        if (rI >= rJ) continue;\n        graph.addEdge(rI, rJ);\n      }\n    }\n  }\n\n  var components = IntAdjacencyGraph.connectedComponents(graph.getGraph());\n  var ringComponentIndex = components.componentIndex;\n  var ringComponents = [];\n\n  for (var i = 0; i < components.componentCount; i++) ringComponents[i] = [];\n\n  for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\n    ringComponents[ringComponentIndex[rI]].push(rI);\n  }\n\n  return {\n    elementRingIndices: elementRingIndices,\n    elementAromaticRingIndices: elementAromaticRingIndices,\n    ringComponentIndex: ringComponentIndex,\n    ringComponents: ringComponents\n  };\n}","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/structure/unit/rings/compute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { Segmentation, SortedArray } from '../../../../../mol-data/int';\r\nimport { IntAdjacencyGraph } from '../../../../../mol-math/graph';\r\nimport { BondType } from '../../../model/types';\r\nimport { sortArray } from '../../../../../mol-data/util';\r\nimport { arraySetAdd, arraySetRemove } from '../../../../../mol-util/array';\r\nexport function computeRings(unit) {\r\n    var size = largestResidue(unit);\r\n    var state = State(unit, size);\r\n    var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n    while (residuesIt.hasNext) {\r\n        var seg = residuesIt.move();\r\n        processResidue(state, seg.start, seg.end);\r\n    }\r\n    return state.rings;\r\n}\r\nfunction State(unit, capacity) {\r\n    return {\r\n        startVertex: 0,\r\n        endVertex: 0,\r\n        count: 0,\r\n        visited: new Int32Array(capacity),\r\n        queue: new Int32Array(capacity),\r\n        pred: new Int32Array(capacity),\r\n        left: new Int32Array(4 /* MaxDepth */),\r\n        right: new Int32Array(4 /* MaxDepth */),\r\n        color: new Int32Array(capacity),\r\n        currentColor: 0,\r\n        currentAltLoc: '',\r\n        hasAltLoc: false,\r\n        rings: [],\r\n        currentRings: [],\r\n        unit: unit,\r\n        bonds: unit.bonds,\r\n        altLoc: unit.model.atomicHierarchy.atoms.label_alt_id\r\n    };\r\n}\r\nfunction resetState(state) {\r\n    state.count = state.endVertex - state.startVertex;\r\n    var visited = state.visited, pred = state.pred, color = state.color;\r\n    for (var i = 0; i < state.count; i++) {\r\n        visited[i] = -1;\r\n        pred[i] = -1;\r\n        color[i] = 0;\r\n    }\r\n    state.currentColor = 0;\r\n    state.currentAltLoc = '';\r\n    state.hasAltLoc = false;\r\n}\r\nfunction largestResidue(unit) {\r\n    var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n    var size = 0;\r\n    while (residuesIt.hasNext) {\r\n        var seg = residuesIt.move();\r\n        size = Math.max(size, seg.end - seg.start);\r\n    }\r\n    return size;\r\n}\r\nfunction processResidue(state, start, end) {\r\n    var visited = state.visited;\r\n    state.startVertex = start;\r\n    state.endVertex = end;\r\n    // no two atom rings\r\n    if (state.endVertex - state.startVertex < 3)\r\n        return;\r\n    state.currentRings = [];\r\n    var elements = state.unit.elements;\r\n    var altLocs = [];\r\n    for (var i = state.startVertex; i < state.endVertex; i++) {\r\n        var altLoc = state.altLoc.value(elements[i]);\r\n        arraySetAdd(altLocs, altLoc);\r\n    }\r\n    arraySetRemove(altLocs, '');\r\n    if (altLocs.length === 0) {\r\n        resetState(state);\r\n        for (var i = 0; i < state.count; i++) {\r\n            if (visited[i] >= 0)\r\n                continue;\r\n            findRings(state, i);\r\n        }\r\n    }\r\n    else {\r\n        for (var aI = 0; aI < altLocs.length; aI++) {\r\n            resetState(state);\r\n            state.hasAltLoc = true;\r\n            state.currentAltLoc = altLocs[aI];\r\n            for (var i = 0; i < state.count; i++) {\r\n                if (visited[i] >= 0)\r\n                    continue;\r\n                var altLoc = state.altLoc.value(elements[state.startVertex + i]);\r\n                if (altLoc && altLoc !== state.currentAltLoc) {\r\n                    continue;\r\n                }\r\n                findRings(state, i);\r\n            }\r\n        }\r\n    }\r\n    for (var i = 0, _i = state.currentRings.length; i < _i; i++) {\r\n        state.rings.push(state.currentRings[i]);\r\n    }\r\n}\r\nfunction addRing(state, a, b) {\r\n    // only \"monotonous\" rings\r\n    if (b < a) {\r\n        return;\r\n    }\r\n    var pred = state.pred, color = state.color, left = state.left, right = state.right;\r\n    var nc = ++state.currentColor;\r\n    var current = a;\r\n    for (var t = 0; t < 4 /* MaxDepth */; t++) {\r\n        color[current] = nc;\r\n        current = pred[current];\r\n        if (current < 0)\r\n            break;\r\n    }\r\n    var leftOffset = 0, rightOffset = 0;\r\n    var found = false, target = 0;\r\n    current = b;\r\n    for (var t = 0; t < 4 /* MaxDepth */; t++) {\r\n        if (color[current] === nc) {\r\n            target = current;\r\n            found = true;\r\n            break;\r\n        }\r\n        right[rightOffset++] = current;\r\n        current = pred[current];\r\n        if (current < 0)\r\n            break;\r\n    }\r\n    if (!found) {\r\n        return;\r\n    }\r\n    current = a;\r\n    for (var t = 0; t < 4 /* MaxDepth */; t++) {\r\n        left[leftOffset++] = current;\r\n        if (target === current)\r\n            break;\r\n        current = pred[current];\r\n        if (current < 0)\r\n            break;\r\n    }\r\n    var len = leftOffset + rightOffset;\r\n    // rings must have at least three elements\r\n    if (len < 3) {\r\n        return;\r\n    }\r\n    var ring = new Int32Array(len);\r\n    var ringOffset = 0;\r\n    for (var t = 0; t < leftOffset; t++)\r\n        ring[ringOffset++] = state.startVertex + left[t];\r\n    for (var t = rightOffset - 1; t >= 0; t--)\r\n        ring[ringOffset++] = state.startVertex + right[t];\r\n    sortArray(ring);\r\n    if (state.hasAltLoc) {\r\n        // we need to check if the ring was already added because alt locs are present.\r\n        for (var rI = 0, _rI = state.currentRings.length; rI < _rI; rI++) {\r\n            var r = state.currentRings[rI];\r\n            if (ring[0] !== r[0])\r\n                continue;\r\n            if (ring.length !== r.length)\r\n                continue;\r\n            var areSame = true;\r\n            for (var aI = 0, _aI = ring.length; aI < _aI; aI++) {\r\n                if (ring[aI] !== r[aI]) {\r\n                    areSame = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (areSame) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    state.currentRings.push(SortedArray.ofSortedArray(ring));\r\n}\r\nfunction findRings(state, from) {\r\n    var bonds = state.bonds, startVertex = state.startVertex, endVertex = state.endVertex, visited = state.visited, queue = state.queue, pred = state.pred;\r\n    var elements = state.unit.elements;\r\n    var neighbor = bonds.b, bondFlags = bonds.edgeProps.flags, offset = bonds.offset;\r\n    visited[from] = 1;\r\n    queue[0] = from;\r\n    var head = 0, size = 1;\r\n    while (head < size) {\r\n        var top_1 = queue[head++];\r\n        var a = startVertex + top_1;\r\n        var start = offset[a], end = offset[a + 1];\r\n        for (var i = start; i < end; i++) {\r\n            var b = neighbor[i];\r\n            if (b < startVertex || b >= endVertex || !BondType.isCovalent(bondFlags[i]))\r\n                continue;\r\n            if (state.hasAltLoc) {\r\n                var altLoc = state.altLoc.value(elements[b]);\r\n                if (altLoc && state.currentAltLoc !== altLoc) {\r\n                    continue;\r\n                }\r\n            }\r\n            var other = b - startVertex;\r\n            if (visited[other] > 0) {\r\n                if (pred[other] !== top_1 && pred[top_1] !== other) {\r\n                    addRing(state, top_1, other);\r\n                }\r\n                continue;\r\n            }\r\n            visited[other] = 1;\r\n            queue[size++] = other;\r\n            pred[other] = top_1;\r\n        }\r\n    }\r\n}\r\nexport function getFingerprint(elements) {\r\n    var len = elements.length;\r\n    var reversed = new Array(len);\r\n    for (var i = 0; i < len; i++)\r\n        reversed[i] = elements[len - i - 1];\r\n    var rotNormal = getMinimalRotation(elements);\r\n    var rotReversed = getMinimalRotation(reversed);\r\n    var isNormalSmaller = false;\r\n    for (var i = 0; i < len; i++) {\r\n        var u = elements[(i + rotNormal) % len], v = reversed[(i + rotReversed) % len];\r\n        if (u !== v) {\r\n            isNormalSmaller = u < v;\r\n            break;\r\n        }\r\n    }\r\n    if (isNormalSmaller)\r\n        return buildFinderprint(elements, rotNormal);\r\n    return buildFinderprint(reversed, rotReversed);\r\n}\r\nfunction getMinimalRotation(elements) {\r\n    // adapted from http://en.wikipedia.org/wiki/Lexicographically_minimal_string_rotation\r\n    var len = elements.length;\r\n    var f = new Int32Array(len * 2);\r\n    for (var i = 0; i < f.length; i++)\r\n        f[i] = -1;\r\n    var u = '', v = '', k = 0;\r\n    for (var j = 1; j < f.length; j++) {\r\n        var i = f[j - k - 1];\r\n        while (i !== -1) {\r\n            u = elements[j % len];\r\n            v = elements[(k + i + 1) % len];\r\n            if (u === v)\r\n                break;\r\n            if (u < v)\r\n                k = j - i - 1;\r\n            i = f[i];\r\n        }\r\n        if (i === -1) {\r\n            u = elements[j % len];\r\n            v = elements[(k + i + 1) % len];\r\n            if (u !== v) {\r\n                if (u < v)\r\n                    k = j;\r\n                f[j - k] = -1;\r\n            }\r\n            else\r\n                f[j - k] = i + 1;\r\n        }\r\n        else\r\n            f[j - k] = i + 1;\r\n    }\r\n    return k;\r\n}\r\nfunction buildFinderprint(elements, offset) {\r\n    var len = elements.length;\r\n    var ret = [];\r\n    var i;\r\n    for (i = 0; i < len - 1; i++) {\r\n        ret.push(elements[(i + offset) % len]);\r\n        ret.push('-');\r\n    }\r\n    ret.push(elements[(i + offset) % len]);\r\n    return ret.join('');\r\n}\r\nexport function createIndex(rings, aromaticRings) {\r\n    var elementRingIndices = new Map();\r\n    var elementAromaticRingIndices = new Map();\r\n    // for each ring atom, assign all rings that it is present in\r\n    for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\r\n        var r = rings[rI];\r\n        for (var i = 0, _i = r.length; i < _i; i++) {\r\n            var e = r[i];\r\n            if (elementRingIndices.has(e))\r\n                elementRingIndices.get(e).push(rI);\r\n            else\r\n                elementRingIndices.set(e, [rI]);\r\n        }\r\n    }\r\n    // for each ring atom, assign all aromatic rings that it is present in\r\n    for (var aI = 0, _aI = aromaticRings.length; aI < _aI; aI++) {\r\n        var rI = aromaticRings[aI];\r\n        var r = rings[rI];\r\n        for (var i = 0, _i = r.length; i < _i; i++) {\r\n            var e = r[i];\r\n            if (elementAromaticRingIndices.has(e))\r\n                elementAromaticRingIndices.get(e).push(rI);\r\n            else\r\n                elementAromaticRingIndices.set(e, [rI]);\r\n        }\r\n    }\r\n    // create a graph where vertices are rings, edge if two rings share at least one atom\r\n    var graph = new IntAdjacencyGraph.UniqueEdgeBuilder(rings.length);\r\n    for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\r\n        var r = rings[rI];\r\n        for (var i = 0, _i = r.length; i < _i; i++) {\r\n            var e = r[i];\r\n            var containedRings = elementRingIndices.get(e);\r\n            if (containedRings.length === 1)\r\n                continue;\r\n            for (var j = 0, _j = containedRings.length; j < _j; j++) {\r\n                var rJ = containedRings[j];\r\n                if (rI >= rJ)\r\n                    continue;\r\n                graph.addEdge(rI, rJ);\r\n            }\r\n        }\r\n    }\r\n    var components = IntAdjacencyGraph.connectedComponents(graph.getGraph());\r\n    var ringComponentIndex = components.componentIndex;\r\n    var ringComponents = [];\r\n    for (var i = 0; i < components.componentCount; i++)\r\n        ringComponents[i] = [];\r\n    for (var rI = 0, _rI = rings.length; rI < _rI; rI++) {\r\n        ringComponents[ringComponentIndex[rI]].push(rI);\r\n    }\r\n    return { elementRingIndices: elementRingIndices, elementAromaticRingIndices: elementAromaticRingIndices, ringComponentIndex: ringComponentIndex, ringComponents: ringComponents };\r\n}\r\n//# sourceMappingURL=compute.js.map"]},"metadata":{},"sourceType":"module"}