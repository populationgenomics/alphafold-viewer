{"ast":null,"code":"/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Task } from '../../../mol-task';\nimport { ReaderResult as Result } from '../result';\nimport { FileHandle } from '../../common/file-handle';\nimport { SimpleBuffer } from '../../../mol-io/common/simple-buffer';\nimport { TypedArrayValueType, getElementByteSize, readTypedArray, createTypedArrayBufferContext } from '../../../mol-io/common/typed-array';\nexport function readCcp4Header(file) {\n  return __awaiter(this, void 0, void 0, function () {\n    var headerSize, buffer, MAP, MACHST, littleEndian, modeLE, readInt, readFloat, header;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          headerSize = 1024;\n          return [4\n          /*yield*/\n          , file.readBuffer(0, headerSize)];\n\n        case 1:\n          buffer = _a.sent().buffer;\n          MAP = String.fromCharCode(buffer.readUInt8(52 * 4), buffer.readUInt8(52 * 4 + 1), buffer.readUInt8(52 * 4 + 2), buffer.readUInt8(52 * 4 + 3));\n\n          if (MAP !== 'MAP ') {\n            throw new Error('ccp4 format error, missing \"MAP \" string');\n          }\n\n          MACHST = [buffer.readUInt8(53 * 4), buffer.readUInt8(53 * 4 + 1)];\n          littleEndian = false;\n\n          if (MACHST[0] === 68 && MACHST[1] === 65) {\n            littleEndian = true;\n          } else if (MACHST[0] === 17 && MACHST[1] === 17) {\n            littleEndian = false;\n          } else {\n            modeLE = buffer.readInt32LE(3 * 4);\n            if (modeLE <= 16) littleEndian = true;\n          }\n\n          readInt = littleEndian ? function (o) {\n            return buffer.readInt32LE(o * 4);\n          } : function (o) {\n            return buffer.readInt32BE(o * 4);\n          };\n          readFloat = littleEndian ? function (o) {\n            return buffer.readFloatLE(o * 4);\n          } : function (o) {\n            return buffer.readFloatBE(o * 4);\n          };\n          header = {\n            NC: readInt(0),\n            NR: readInt(1),\n            NS: readInt(2),\n            MODE: readInt(3),\n            NCSTART: readInt(4),\n            NRSTART: readInt(5),\n            NSSTART: readInt(6),\n            NX: readInt(7),\n            NY: readInt(8),\n            NZ: readInt(9),\n            xLength: readFloat(10),\n            yLength: readFloat(11),\n            zLength: readFloat(12),\n            alpha: readFloat(13),\n            beta: readFloat(14),\n            gamma: readFloat(15),\n            MAPC: readInt(16),\n            MAPR: readInt(17),\n            MAPS: readInt(18),\n            AMIN: readFloat(19),\n            AMAX: readFloat(20),\n            AMEAN: readFloat(21),\n            ISPG: readInt(22),\n            NSYMBT: readInt(23),\n            LSKFLG: readInt(24),\n            SKWMAT: [],\n            SKWTRN: [],\n            userFlag1: readInt(39),\n            userFlag2: readInt(40),\n            // bytes 50-52 origin in X,Y,Z used for transforms\n            originX: readFloat(49),\n            originY: readFloat(50),\n            originZ: readFloat(51),\n            MAP: MAP,\n            MACHST: MACHST,\n            ARMS: readFloat(54) // TODO bytes 56 NLABL\n            // TODO bytes 57-256 LABEL\n\n          };\n          return [2\n          /*return*/\n          , {\n            header: header,\n            littleEndian: littleEndian\n          }];\n      }\n    });\n  });\n}\nexport function readCcp4Slices(header, buffer, file, byteOffset, length, littleEndian) {\n  return __awaiter(this, void 0, void 0, function () {\n    var valueByteOffset, int8, b1, b0, j, jl;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          if (!isMapmode2to0(header)) return [3\n          /*break*/\n          , 2];\n          valueByteOffset = 3 * length; // read int8 data to last quarter of the read buffer\n\n          return [4\n          /*yield*/\n          , file.readBuffer(byteOffset, buffer.readBuffer, length, valueByteOffset)];\n\n        case 1:\n          // read int8 data to last quarter of the read buffer\n          _a.sent();\n\n          int8 = new Int8Array(buffer.valuesBuffer.buffer, valueByteOffset);\n          b1 = (header.AMAX - header.AMIN) / 255.0;\n          b0 = 0.5 * (header.AMIN + header.AMAX + b1);\n\n          for (j = 0, jl = length; j < jl; ++j) {\n            buffer.values[j] = b1 * int8[j] + b0;\n          }\n\n          return [3\n          /*break*/\n          , 4];\n\n        case 2:\n          return [4\n          /*yield*/\n          , readTypedArray(buffer, file, byteOffset, length, 0, littleEndian)];\n\n        case 3:\n          _a.sent();\n\n          _a.label = 4;\n\n        case 4:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction getCcp4DataType(mode) {\n  switch (mode) {\n    case 0:\n      return TypedArrayValueType.Int8;\n\n    case 1:\n      return TypedArrayValueType.Int16;\n\n    case 2:\n      return TypedArrayValueType.Float32;\n\n    case 3:\n      throw new Error('mode 3 unsupported, complex 16-bit integers');\n\n    case 4:\n      throw new Error('mode 4 unsupported, complex 32-bit reals');\n\n    case 6:\n      TypedArrayValueType.Uint16;\n\n    case 16:\n      throw new Error('mode 16 unsupported, unsigned char * 3 (for rgb data, non-standard)');\n  }\n\n  throw new Error(\"unknown mode '\" + mode + \"'\");\n}\n/** check if the file was converted by mapmode2to0, see https://github.com/uglymol/uglymol */\n\n\nfunction isMapmode2to0(header) {\n  return header.userFlag1 === -128 && header.userFlag2 === 127;\n}\n\nexport function getCcp4ValueType(header) {\n  return isMapmode2to0(header) ? TypedArrayValueType.Float32 : getCcp4DataType(header.MODE);\n}\nexport function getCcp4DataOffset(header) {\n  return 256 * 4 + header.NSYMBT;\n}\n\nfunction parseInternal(file, size, ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var _a, header, littleEndian, offset, dataType, valueType, count, elementByteSize, byteCount, buffer, result;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , ctx.update({\n            message: 'Parsing CCP4/MRC/MAP file...'\n          })];\n\n        case 1:\n          _b.sent();\n\n          return [4\n          /*yield*/\n          , readCcp4Header(file)];\n\n        case 2:\n          _a = _b.sent(), header = _a.header, littleEndian = _a.littleEndian;\n          offset = getCcp4DataOffset(header);\n          dataType = getCcp4DataType(header.MODE);\n          valueType = getCcp4ValueType(header);\n          count = header.NC * header.NR * header.NS;\n          elementByteSize = getElementByteSize(dataType);\n          byteCount = count * elementByteSize;\n          buffer = createTypedArrayBufferContext(count, valueType);\n          readCcp4Slices(header, buffer, file, offset, byteCount, littleEndian);\n          result = {\n            header: header,\n            values: buffer.values,\n            name: file.name\n          };\n          return [2\n          /*return*/\n          , result];\n      }\n    });\n  });\n}\n\nexport function parseFile(file, size) {\n  var _this = this;\n\n  return Task.create('Parse CCP4/MRC/MAP', function (ctx) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var _a, _b, e_1;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            _c.trys.push([0, 2,, 3]);\n\n            _b = (_a = Result).success;\n            return [4\n            /*yield*/\n            , parseInternal(file, size, ctx)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _b.apply(_a, [_c.sent()])];\n\n          case 2:\n            e_1 = _c.sent();\n            return [2\n            /*return*/\n            , Result.error(e_1)];\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  });\n}\nexport function parse(buffer, name) {\n  return parseFile(FileHandle.fromBuffer(SimpleBuffer.fromUint8Array(buffer), name), buffer.length);\n}","map":{"version":3,"sources":["../../../../src/mol-io/reader/ccp4/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2018-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Task } from '../../../mol-task';\r\nimport { ReaderResult as Result } from '../result';\r\nimport { FileHandle } from '../../common/file-handle';\r\nimport { SimpleBuffer } from '../../../mol-io/common/simple-buffer';\r\nimport { TypedArrayValueType, getElementByteSize, readTypedArray, createTypedArrayBufferContext } from '../../../mol-io/common/typed-array';\r\nexport function readCcp4Header(file) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var headerSize, buffer, MAP, MACHST, littleEndian, modeLE, readInt, readFloat, header;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    headerSize = 1024;\r\n                    return [4 /*yield*/, file.readBuffer(0, headerSize)];\r\n                case 1:\r\n                    buffer = (_a.sent()).buffer;\r\n                    MAP = String.fromCharCode(buffer.readUInt8(52 * 4), buffer.readUInt8(52 * 4 + 1), buffer.readUInt8(52 * 4 + 2), buffer.readUInt8(52 * 4 + 3));\r\n                    if (MAP !== 'MAP ') {\r\n                        throw new Error('ccp4 format error, missing \"MAP \" string');\r\n                    }\r\n                    MACHST = [buffer.readUInt8(53 * 4), buffer.readUInt8(53 * 4 + 1)];\r\n                    littleEndian = false;\r\n                    if (MACHST[0] === 68 && MACHST[1] === 65) {\r\n                        littleEndian = true;\r\n                    }\r\n                    else if (MACHST[0] === 17 && MACHST[1] === 17) {\r\n                        littleEndian = false;\r\n                    }\r\n                    else {\r\n                        modeLE = buffer.readInt32LE(3 * 4);\r\n                        if (modeLE <= 16)\r\n                            littleEndian = true;\r\n                    }\r\n                    readInt = littleEndian ? function (o) { return buffer.readInt32LE(o * 4); } : function (o) { return buffer.readInt32BE(o * 4); };\r\n                    readFloat = littleEndian ? function (o) { return buffer.readFloatLE(o * 4); } : function (o) { return buffer.readFloatBE(o * 4); };\r\n                    header = {\r\n                        NC: readInt(0),\r\n                        NR: readInt(1),\r\n                        NS: readInt(2),\r\n                        MODE: readInt(3),\r\n                        NCSTART: readInt(4),\r\n                        NRSTART: readInt(5),\r\n                        NSSTART: readInt(6),\r\n                        NX: readInt(7),\r\n                        NY: readInt(8),\r\n                        NZ: readInt(9),\r\n                        xLength: readFloat(10),\r\n                        yLength: readFloat(11),\r\n                        zLength: readFloat(12),\r\n                        alpha: readFloat(13),\r\n                        beta: readFloat(14),\r\n                        gamma: readFloat(15),\r\n                        MAPC: readInt(16),\r\n                        MAPR: readInt(17),\r\n                        MAPS: readInt(18),\r\n                        AMIN: readFloat(19),\r\n                        AMAX: readFloat(20),\r\n                        AMEAN: readFloat(21),\r\n                        ISPG: readInt(22),\r\n                        NSYMBT: readInt(23),\r\n                        LSKFLG: readInt(24),\r\n                        SKWMAT: [],\r\n                        SKWTRN: [],\r\n                        userFlag1: readInt(39),\r\n                        userFlag2: readInt(40),\r\n                        // bytes 50-52 origin in X,Y,Z used for transforms\r\n                        originX: readFloat(49),\r\n                        originY: readFloat(50),\r\n                        originZ: readFloat(51),\r\n                        MAP: MAP,\r\n                        MACHST: MACHST,\r\n                        ARMS: readFloat(54),\r\n                        // TODO bytes 56 NLABL\r\n                        // TODO bytes 57-256 LABEL\r\n                    };\r\n                    return [2 /*return*/, { header: header, littleEndian: littleEndian }];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function readCcp4Slices(header, buffer, file, byteOffset, length, littleEndian) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var valueByteOffset, int8, b1, b0, j, jl;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!isMapmode2to0(header)) return [3 /*break*/, 2];\r\n                    valueByteOffset = 3 * length;\r\n                    // read int8 data to last quarter of the read buffer\r\n                    return [4 /*yield*/, file.readBuffer(byteOffset, buffer.readBuffer, length, valueByteOffset)];\r\n                case 1:\r\n                    // read int8 data to last quarter of the read buffer\r\n                    _a.sent();\r\n                    int8 = new Int8Array(buffer.valuesBuffer.buffer, valueByteOffset);\r\n                    b1 = (header.AMAX - header.AMIN) / 255.0;\r\n                    b0 = 0.5 * (header.AMIN + header.AMAX + b1);\r\n                    for (j = 0, jl = length; j < jl; ++j) {\r\n                        buffer.values[j] = b1 * int8[j] + b0;\r\n                    }\r\n                    return [3 /*break*/, 4];\r\n                case 2: return [4 /*yield*/, readTypedArray(buffer, file, byteOffset, length, 0, littleEndian)];\r\n                case 3:\r\n                    _a.sent();\r\n                    _a.label = 4;\r\n                case 4: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getCcp4DataType(mode) {\r\n    switch (mode) {\r\n        case 0: return TypedArrayValueType.Int8;\r\n        case 1: return TypedArrayValueType.Int16;\r\n        case 2: return TypedArrayValueType.Float32;\r\n        case 3: throw new Error('mode 3 unsupported, complex 16-bit integers');\r\n        case 4: throw new Error('mode 4 unsupported, complex 32-bit reals');\r\n        case 6: TypedArrayValueType.Uint16;\r\n        case 16: throw new Error('mode 16 unsupported, unsigned char * 3 (for rgb data, non-standard)');\r\n    }\r\n    throw new Error(\"unknown mode '\" + mode + \"'\");\r\n}\r\n/** check if the file was converted by mapmode2to0, see https://github.com/uglymol/uglymol */\r\nfunction isMapmode2to0(header) {\r\n    return header.userFlag1 === -128 && header.userFlag2 === 127;\r\n}\r\nexport function getCcp4ValueType(header) {\r\n    return isMapmode2to0(header) ? TypedArrayValueType.Float32 : getCcp4DataType(header.MODE);\r\n}\r\nexport function getCcp4DataOffset(header) {\r\n    return 256 * 4 + header.NSYMBT;\r\n}\r\nfunction parseInternal(file, size, ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, header, littleEndian, offset, dataType, valueType, count, elementByteSize, byteCount, buffer, result;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, ctx.update({ message: 'Parsing CCP4/MRC/MAP file...' })];\r\n                case 1:\r\n                    _b.sent();\r\n                    return [4 /*yield*/, readCcp4Header(file)];\r\n                case 2:\r\n                    _a = _b.sent(), header = _a.header, littleEndian = _a.littleEndian;\r\n                    offset = getCcp4DataOffset(header);\r\n                    dataType = getCcp4DataType(header.MODE);\r\n                    valueType = getCcp4ValueType(header);\r\n                    count = header.NC * header.NR * header.NS;\r\n                    elementByteSize = getElementByteSize(dataType);\r\n                    byteCount = count * elementByteSize;\r\n                    buffer = createTypedArrayBufferContext(count, valueType);\r\n                    readCcp4Slices(header, buffer, file, offset, byteCount, littleEndian);\r\n                    result = { header: header, values: buffer.values, name: file.name };\r\n                    return [2 /*return*/, result];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function parseFile(file, size) {\r\n    var _this = this;\r\n    return Task.create('Parse CCP4/MRC/MAP', function (ctx) { return __awaiter(_this, void 0, void 0, function () {\r\n        var _a, _b, e_1;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    _c.trys.push([0, 2, , 3]);\r\n                    _b = (_a = Result).success;\r\n                    return [4 /*yield*/, parseInternal(file, size, ctx)];\r\n                case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\r\n                case 2:\r\n                    e_1 = _c.sent();\r\n                    return [2 /*return*/, Result.error(e_1)];\r\n                case 3: return [2 /*return*/];\r\n            }\r\n        });\r\n    }); });\r\n}\r\nexport function parse(buffer, name) {\r\n    return parseFile(FileHandle.fromBuffer(SimpleBuffer.fromUint8Array(buffer), name), buffer.length);\r\n}\r\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}