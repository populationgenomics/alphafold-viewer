{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { Structure } from '../../structure';\nimport { Unit } from '../../unit';\nimport { getElementIdx, getElementPairThreshold, getElementThreshold, isHydrogen, MetalsSet, DefaultBondComputationProps } from './common';\nimport { InterUnitBonds } from './data';\nimport { SortedArray } from '../../../../../mol-data/int';\nimport { Vec3, Mat4 } from '../../../../../mol-math/linear-algebra';\nimport { getInterBondOrderFromTable } from '../../../model/properties/atomic/bonds';\nimport { IndexPairBonds } from '../../../../../mol-model-formats/structure/property/bonds/index-pair';\nimport { InterUnitGraph } from '../../../../../mol-math/graph/inter-unit-graph';\nimport { StructConn } from '../../../../../mol-model-formats/structure/property/bonds/struct_conn';\nimport { equalEps } from '../../../../../mol-math/linear-algebra/3d/common';\nimport { Model } from '../../../model';\nvar tmpDistVecA = Vec3();\nvar tmpDistVecB = Vec3();\n\nfunction getDistance(unitA, indexA, unitB, indexB) {\n  unitA.conformation.position(indexA, tmpDistVecA);\n  unitB.conformation.position(indexB, tmpDistVecB);\n  return Vec3.distance(tmpDistVecA, tmpDistVecB);\n}\n\nvar _imageTransform = Mat4();\n\nvar _imageA = Vec3();\n\nfunction findPairBonds(unitA, unitB, props, builder) {\n  var maxRadius = props.maxRadius;\n  var atomsA = unitA.elements,\n      residueIndexA = unitA.residueIndex;\n  var _a = unitA.model.atomicConformation,\n      xA = _a.x,\n      yA = _a.y,\n      zA = _a.z;\n  var atomsB = unitB.elements,\n      residueIndexB = unitB.residueIndex;\n  var atomCount = unitA.elements.length;\n  var _b = unitA.model.atomicHierarchy.atoms,\n      type_symbolA = _b.type_symbol,\n      label_alt_idA = _b.label_alt_id,\n      label_atom_idA = _b.label_atom_id,\n      label_comp_idA = _b.label_comp_id;\n  var _c = unitB.model.atomicHierarchy.atoms,\n      type_symbolB = _c.type_symbol,\n      label_alt_idB = _c.label_alt_id,\n      label_atom_idB = _c.label_atom_id,\n      label_comp_idB = _c.label_comp_id;\n  var auth_seq_idA = unitA.model.atomicHierarchy.residues.auth_seq_id;\n  var auth_seq_idB = unitB.model.atomicHierarchy.residues.auth_seq_id;\n  var occupancyA = unitA.model.atomicConformation.occupancy;\n  var occupancyB = unitB.model.atomicConformation.occupancy;\n  var hasOccupancy = occupancyA.isDefined && occupancyB.isDefined;\n  var structConn = unitA.model === unitB.model && StructConn.Provider.get(unitA.model);\n  var indexPairs = !props.forceCompute && unitA.model === unitB.model && IndexPairBonds.Provider.get(unitA.model);\n  var sourceIndex = unitA.model.atomicHierarchy.atomSourceIndex;\n  var invertedIndex = (indexPairs ? Model.getInvertedAtomSourceIndex(unitB.model) : {\n    invertedIndex: void 0\n  }).invertedIndex;\n  var structConnExhaustive = unitA.model === unitB.model && StructConn.isExhaustive(unitA.model); // the lookup queries need to happen in the \"unitB space\".\n  // that means _imageA = inverseOperB(operA(aI))\n\n  var imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);\n  var isNotIdentity = !Mat4.isIdentity(imageTransform);\n  var _d = unitB.boundary.sphere,\n      bCenter = _d.center,\n      bRadius = _d.radius;\n  var testDistanceSq = (bRadius + maxRadius) * (bRadius + maxRadius);\n  builder.startUnitPair(unitA.id, unitB.id);\n\n  for (var _aI = 0; _aI < atomCount; _aI++) {\n    var aI = atomsA[_aI];\n    Vec3.set(_imageA, xA[aI], yA[aI], zA[aI]);\n    if (isNotIdentity) Vec3.transformMat4(_imageA, _imageA, imageTransform);\n    if (Vec3.squaredDistance(_imageA, bCenter) > testDistanceSq) continue;\n\n    if (!props.forceCompute && indexPairs) {\n      var maxDistance = indexPairs.maxDistance;\n      var _e = indexPairs.bonds,\n          offset = _e.offset,\n          b = _e.b,\n          _f = _e.edgeProps,\n          order = _f.order,\n          distance = _f.distance,\n          flag = _f.flag;\n      var srcA = sourceIndex.value(aI);\n\n      for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {\n        var bI = invertedIndex[b[i]];\n\n        var _bI = SortedArray.indexOf(unitB.elements, bI);\n\n        if (_bI < 0) continue;\n        if (type_symbolA.value(aI) === 'H' && type_symbolB.value(bI) === 'H') continue;\n        var d = distance[i];\n        var dist = getDistance(unitA, aI, unitB, bI);\n\n        if (d !== -1 && equalEps(dist, d, 0.5) || dist < maxDistance) {\n          builder.add(_aI, _bI, {\n            order: order[i],\n            flag: flag[i]\n          });\n        }\n      }\n\n      continue; // assume `indexPairs` supplies all bonds\n    }\n\n    var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);\n\n    if (structConnEntries && structConnEntries.length) {\n      var added = false;\n\n      for (var _i = 0, structConnEntries_1 = structConnEntries; _i < structConnEntries_1.length; _i++) {\n        var se = structConnEntries_1[_i];\n        var partnerA = se.partnerA,\n            partnerB = se.partnerB;\n        var p = partnerA.atomIndex === aI ? partnerB : partnerA;\n\n        var _bI = SortedArray.indexOf(unitB.elements, p.atomIndex);\n\n        if (_bI < 0) continue; // check if the bond is within MAX_RADIUS for this pair of units\n\n        if (getDistance(unitA, aI, unitB, p.atomIndex) > maxRadius) continue;\n        builder.add(_aI, _bI, {\n          order: se.order,\n          flag: se.flags\n        });\n        added = true;\n      } // assume, for an atom, that if any inter unit bond is given\n      // all are given and thus we don't need to compute any other\n\n\n      if (added) continue;\n    }\n\n    if (structConnExhaustive) continue;\n    var occA = occupancyA.value(aI);\n    var lookup3d = unitB.lookup3d;\n\n    var _g = lookup3d.find(_imageA[0], _imageA[1], _imageA[2], maxRadius),\n        indices = _g.indices,\n        count = _g.count,\n        squaredDistances = _g.squaredDistances;\n\n    if (count === 0) continue;\n    var aeI = getElementIdx(type_symbolA.value(aI));\n    var isHa = isHydrogen(aeI);\n    var thresholdA = getElementThreshold(aeI);\n    var altA = label_alt_idA.value(aI);\n    var metalA = MetalsSet.has(aeI);\n    var atomIdA = label_atom_idA.value(aI);\n    var compIdA = label_comp_idA.value(residueIndexA[aI]);\n\n    for (var ni = 0; ni < count; ni++) {\n      var _bI = indices[ni];\n      var bI = atomsB[_bI];\n      var altB = label_alt_idB.value(bI);\n      if (altA && altB && altA !== altB) continue; // Do not include bonds between images of the same residue with partial occupancy.\n      // TODO: is this condition good enough?\n      // - It works for cases like 3WQJ (label_asym_id: I) which have partial occupancy.\n      // - Does NOT work for cases like 1RB8 (DC 7) with full occupancy.\n\n      if (hasOccupancy && occupancyB.value(bI) < 1 && occA < 1) {\n        if (auth_seq_idA.value(aI) === auth_seq_idB.value(bI)) {\n          continue;\n        }\n      }\n\n      var beI = getElementIdx(type_symbolB.value(bI));\n      var isHb = isHydrogen(beI);\n      if (isHa && isHb) continue;\n      var isMetal = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);\n      var dist = Math.sqrt(squaredDistances[ni]);\n      if (dist === 0) continue;\n      var thresholdAB = getElementPairThreshold(aeI, beI);\n      var pairingThreshold = thresholdAB > 0 ? thresholdAB : beI < 0 ? thresholdA : (thresholdA + getElementThreshold(beI)) / 1.95; // not sure if avg or min but max is too big\n\n      if (dist <= pairingThreshold) {\n        var atomIdB = label_atom_idB.value(bI);\n        var compIdB = label_comp_idB.value(residueIndexB[bI]);\n        builder.add(_aI, _bI, {\n          order: getInterBondOrderFromTable(compIdA, compIdB, atomIdA, atomIdB),\n          flag: (isMetal ? 2\n          /* MetallicCoordination */\n          : 1\n          /* Covalent */\n          ) | 32\n          /* Computed */\n\n        });\n      }\n    }\n  }\n\n  builder.finishUnitPair();\n}\n\nvar DefaultInterBondComputationProps = __assign(__assign({}, DefaultBondComputationProps), {\n  ignoreWater: true\n});\n\nfunction findBonds(structure, props) {\n  var builder = new InterUnitGraph.Builder();\n  var hasIndexPairBonds = structure.models.some(function (m) {\n    return IndexPairBonds.Provider.get(m);\n  });\n\n  if (props.noCompute || structure.isCoarseGrained && !hasIndexPairBonds) {\n    // TODO add function that only adds bonds defined in structConn and avoids using\n    //      structure.lookup and unit.lookup (expensive for large structure and not\n    //      needed for archival files or files with an MD topology)\n    return new InterUnitBonds(builder.getMap());\n  }\n\n  Structure.eachUnitPair(structure, function (unitA, unitB) {\n    findPairBonds(unitA, unitB, props, builder);\n  }, {\n    maxRadius: props.maxRadius,\n    validUnit: function (unit) {\n      return Unit.isAtomic(unit);\n    },\n    validUnitPair: function (unitA, unitB) {\n      return props.validUnitPair(structure, unitA, unitB);\n    }\n  });\n  return new InterUnitBonds(builder.getMap());\n}\n\nfunction computeInterUnitBonds(structure, props) {\n  var p = __assign(__assign({}, DefaultInterBondComputationProps), props);\n\n  return findBonds(structure, __assign(__assign({}, p), {\n    validUnitPair: props && props.validUnitPair || function (s, a, b) {\n      var mtA = a.model.atomicHierarchy.derived.residue.moleculeType;\n      var mtB = b.model.atomicHierarchy.derived.residue.moleculeType;\n      var notWater = (!Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== 2\n      /* Water */\n      ) && (!Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== 2\n      /* Water */\n      );\n      return Structure.validUnitPair(s, a, b) && (notWater || !p.ignoreWater);\n    }\n  }));\n}\n\nexport { computeInterUnitBonds };","map":{"version":3,"sources":["../../../../../../src/mol-model/structure/structure/unit/bonds/inter-compute.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { Structure } from '../../structure';\r\nimport { Unit } from '../../unit';\r\nimport { getElementIdx, getElementPairThreshold, getElementThreshold, isHydrogen, MetalsSet, DefaultBondComputationProps } from './common';\r\nimport { InterUnitBonds } from './data';\r\nimport { SortedArray } from '../../../../../mol-data/int';\r\nimport { Vec3, Mat4 } from '../../../../../mol-math/linear-algebra';\r\nimport { getInterBondOrderFromTable } from '../../../model/properties/atomic/bonds';\r\nimport { IndexPairBonds } from '../../../../../mol-model-formats/structure/property/bonds/index-pair';\r\nimport { InterUnitGraph } from '../../../../../mol-math/graph/inter-unit-graph';\r\nimport { StructConn } from '../../../../../mol-model-formats/structure/property/bonds/struct_conn';\r\nimport { equalEps } from '../../../../../mol-math/linear-algebra/3d/common';\r\nimport { Model } from '../../../model';\r\nvar tmpDistVecA = Vec3();\r\nvar tmpDistVecB = Vec3();\r\nfunction getDistance(unitA, indexA, unitB, indexB) {\r\n    unitA.conformation.position(indexA, tmpDistVecA);\r\n    unitB.conformation.position(indexB, tmpDistVecB);\r\n    return Vec3.distance(tmpDistVecA, tmpDistVecB);\r\n}\r\nvar _imageTransform = Mat4();\r\nvar _imageA = Vec3();\r\nfunction findPairBonds(unitA, unitB, props, builder) {\r\n    var maxRadius = props.maxRadius;\r\n    var atomsA = unitA.elements, residueIndexA = unitA.residueIndex;\r\n    var _a = unitA.model.atomicConformation, xA = _a.x, yA = _a.y, zA = _a.z;\r\n    var atomsB = unitB.elements, residueIndexB = unitB.residueIndex;\r\n    var atomCount = unitA.elements.length;\r\n    var _b = unitA.model.atomicHierarchy.atoms, type_symbolA = _b.type_symbol, label_alt_idA = _b.label_alt_id, label_atom_idA = _b.label_atom_id, label_comp_idA = _b.label_comp_id;\r\n    var _c = unitB.model.atomicHierarchy.atoms, type_symbolB = _c.type_symbol, label_alt_idB = _c.label_alt_id, label_atom_idB = _c.label_atom_id, label_comp_idB = _c.label_comp_id;\r\n    var auth_seq_idA = unitA.model.atomicHierarchy.residues.auth_seq_id;\r\n    var auth_seq_idB = unitB.model.atomicHierarchy.residues.auth_seq_id;\r\n    var occupancyA = unitA.model.atomicConformation.occupancy;\r\n    var occupancyB = unitB.model.atomicConformation.occupancy;\r\n    var hasOccupancy = occupancyA.isDefined && occupancyB.isDefined;\r\n    var structConn = unitA.model === unitB.model && StructConn.Provider.get(unitA.model);\r\n    var indexPairs = !props.forceCompute && unitA.model === unitB.model && IndexPairBonds.Provider.get(unitA.model);\r\n    var sourceIndex = unitA.model.atomicHierarchy.atomSourceIndex;\r\n    var invertedIndex = (indexPairs ? Model.getInvertedAtomSourceIndex(unitB.model) : { invertedIndex: void 0 }).invertedIndex;\r\n    var structConnExhaustive = unitA.model === unitB.model && StructConn.isExhaustive(unitA.model);\r\n    // the lookup queries need to happen in the \"unitB space\".\r\n    // that means _imageA = inverseOperB(operA(aI))\r\n    var imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);\r\n    var isNotIdentity = !Mat4.isIdentity(imageTransform);\r\n    var _d = unitB.boundary.sphere, bCenter = _d.center, bRadius = _d.radius;\r\n    var testDistanceSq = (bRadius + maxRadius) * (bRadius + maxRadius);\r\n    builder.startUnitPair(unitA.id, unitB.id);\r\n    for (var _aI = 0; _aI < atomCount; _aI++) {\r\n        var aI = atomsA[_aI];\r\n        Vec3.set(_imageA, xA[aI], yA[aI], zA[aI]);\r\n        if (isNotIdentity)\r\n            Vec3.transformMat4(_imageA, _imageA, imageTransform);\r\n        if (Vec3.squaredDistance(_imageA, bCenter) > testDistanceSq)\r\n            continue;\r\n        if (!props.forceCompute && indexPairs) {\r\n            var maxDistance = indexPairs.maxDistance;\r\n            var _e = indexPairs.bonds, offset = _e.offset, b = _e.b, _f = _e.edgeProps, order = _f.order, distance = _f.distance, flag = _f.flag;\r\n            var srcA = sourceIndex.value(aI);\r\n            for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {\r\n                var bI = invertedIndex[b[i]];\r\n                var _bI = SortedArray.indexOf(unitB.elements, bI);\r\n                if (_bI < 0)\r\n                    continue;\r\n                if (type_symbolA.value(aI) === 'H' && type_symbolB.value(bI) === 'H')\r\n                    continue;\r\n                var d = distance[i];\r\n                var dist = getDistance(unitA, aI, unitB, bI);\r\n                if ((d !== -1 && equalEps(dist, d, 0.5)) || dist < maxDistance) {\r\n                    builder.add(_aI, _bI, { order: order[i], flag: flag[i] });\r\n                }\r\n            }\r\n            continue; // assume `indexPairs` supplies all bonds\r\n        }\r\n        var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);\r\n        if (structConnEntries && structConnEntries.length) {\r\n            var added = false;\r\n            for (var _i = 0, structConnEntries_1 = structConnEntries; _i < structConnEntries_1.length; _i++) {\r\n                var se = structConnEntries_1[_i];\r\n                var partnerA = se.partnerA, partnerB = se.partnerB;\r\n                var p = partnerA.atomIndex === aI ? partnerB : partnerA;\r\n                var _bI = SortedArray.indexOf(unitB.elements, p.atomIndex);\r\n                if (_bI < 0)\r\n                    continue;\r\n                // check if the bond is within MAX_RADIUS for this pair of units\r\n                if (getDistance(unitA, aI, unitB, p.atomIndex) > maxRadius)\r\n                    continue;\r\n                builder.add(_aI, _bI, { order: se.order, flag: se.flags });\r\n                added = true;\r\n            }\r\n            // assume, for an atom, that if any inter unit bond is given\r\n            // all are given and thus we don't need to compute any other\r\n            if (added)\r\n                continue;\r\n        }\r\n        if (structConnExhaustive)\r\n            continue;\r\n        var occA = occupancyA.value(aI);\r\n        var lookup3d = unitB.lookup3d;\r\n        var _g = lookup3d.find(_imageA[0], _imageA[1], _imageA[2], maxRadius), indices = _g.indices, count = _g.count, squaredDistances = _g.squaredDistances;\r\n        if (count === 0)\r\n            continue;\r\n        var aeI = getElementIdx(type_symbolA.value(aI));\r\n        var isHa = isHydrogen(aeI);\r\n        var thresholdA = getElementThreshold(aeI);\r\n        var altA = label_alt_idA.value(aI);\r\n        var metalA = MetalsSet.has(aeI);\r\n        var atomIdA = label_atom_idA.value(aI);\r\n        var compIdA = label_comp_idA.value(residueIndexA[aI]);\r\n        for (var ni = 0; ni < count; ni++) {\r\n            var _bI = indices[ni];\r\n            var bI = atomsB[_bI];\r\n            var altB = label_alt_idB.value(bI);\r\n            if (altA && altB && altA !== altB)\r\n                continue;\r\n            // Do not include bonds between images of the same residue with partial occupancy.\r\n            // TODO: is this condition good enough?\r\n            // - It works for cases like 3WQJ (label_asym_id: I) which have partial occupancy.\r\n            // - Does NOT work for cases like 1RB8 (DC 7) with full occupancy.\r\n            if (hasOccupancy && occupancyB.value(bI) < 1 && occA < 1) {\r\n                if (auth_seq_idA.value(aI) === auth_seq_idB.value(bI)) {\r\n                    continue;\r\n                }\r\n            }\r\n            var beI = getElementIdx(type_symbolB.value(bI));\r\n            var isHb = isHydrogen(beI);\r\n            if (isHa && isHb)\r\n                continue;\r\n            var isMetal = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);\r\n            var dist = Math.sqrt(squaredDistances[ni]);\r\n            if (dist === 0)\r\n                continue;\r\n            var thresholdAB = getElementPairThreshold(aeI, beI);\r\n            var pairingThreshold = thresholdAB > 0\r\n                ? thresholdAB\r\n                : beI < 0\r\n                    ? thresholdA\r\n                    : (thresholdA + getElementThreshold(beI)) / 1.95; // not sure if avg or min but max is too big\r\n            if (dist <= pairingThreshold) {\r\n                var atomIdB = label_atom_idB.value(bI);\r\n                var compIdB = label_comp_idB.value(residueIndexB[bI]);\r\n                builder.add(_aI, _bI, {\r\n                    order: getInterBondOrderFromTable(compIdA, compIdB, atomIdA, atomIdB),\r\n                    flag: (isMetal ? 2 /* MetallicCoordination */ : 1 /* Covalent */) | 32 /* Computed */\r\n                });\r\n            }\r\n        }\r\n    }\r\n    builder.finishUnitPair();\r\n}\r\nvar DefaultInterBondComputationProps = __assign(__assign({}, DefaultBondComputationProps), { ignoreWater: true });\r\nfunction findBonds(structure, props) {\r\n    var builder = new InterUnitGraph.Builder();\r\n    var hasIndexPairBonds = structure.models.some(function (m) { return IndexPairBonds.Provider.get(m); });\r\n    if (props.noCompute || (structure.isCoarseGrained && !hasIndexPairBonds)) {\r\n        // TODO add function that only adds bonds defined in structConn and avoids using\r\n        //      structure.lookup and unit.lookup (expensive for large structure and not\r\n        //      needed for archival files or files with an MD topology)\r\n        return new InterUnitBonds(builder.getMap());\r\n    }\r\n    Structure.eachUnitPair(structure, function (unitA, unitB) {\r\n        findPairBonds(unitA, unitB, props, builder);\r\n    }, {\r\n        maxRadius: props.maxRadius,\r\n        validUnit: function (unit) { return Unit.isAtomic(unit); },\r\n        validUnitPair: function (unitA, unitB) { return props.validUnitPair(structure, unitA, unitB); }\r\n    });\r\n    return new InterUnitBonds(builder.getMap());\r\n}\r\nfunction computeInterUnitBonds(structure, props) {\r\n    var p = __assign(__assign({}, DefaultInterBondComputationProps), props);\r\n    return findBonds(structure, __assign(__assign({}, p), { validUnitPair: (props && props.validUnitPair) || (function (s, a, b) {\r\n            var mtA = a.model.atomicHierarchy.derived.residue.moleculeType;\r\n            var mtB = b.model.atomicHierarchy.derived.residue.moleculeType;\r\n            var notWater = ((!Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== 2 /* Water */) &&\r\n                (!Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== 2 /* Water */));\r\n            return Structure.validUnitPair(s, a, b) && (notWater || !p.ignoreWater);\r\n        }) }));\r\n}\r\nexport { computeInterUnitBonds };\r\n//# sourceMappingURL=inter-compute.js.map"]},"metadata":{},"sourceType":"module"}