{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { VdWLookup } from './common'; // TODO\n// - iterate over units and elements\n// - avoid using serial-element index whenever possible\n// - calculate atomRadiusType only for invariant units\n// - factor serialResidueIndex out\n\nvar updateChunk = 5000;\nexport function computeArea(runtime, ctx) {\n  return __awaiter(this, void 0, void 0, function () {\n    var atomRadius, i;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          atomRadius = ctx.atomRadiusType;\n          i = 0;\n          _a.label = 1;\n\n        case 1:\n          if (!(i < atomRadius.length)) return [3\n          /*break*/\n          , 5];\n          if (!runtime.shouldUpdate) return [3\n          /*break*/\n          , 3];\n          return [4\n          /*yield*/\n          , runtime.update({\n            message: 'Computing per residue surface accessibility...',\n            current: i,\n            max: atomRadius.length\n          })];\n\n        case 2:\n          _a.sent();\n\n          _a.label = 3;\n\n        case 3:\n          computeRange(ctx, i, Math.min(i + updateChunk, atomRadius.length));\n          _a.label = 4;\n\n        case 4:\n          i += updateChunk;\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nfunction computeRange(ctx, begin, end) {\n  var structure = ctx.structure,\n      atomRadiusType = ctx.atomRadiusType,\n      serialResidueIndex = ctx.serialResidueIndex,\n      area = ctx.area,\n      spherePoints = ctx.spherePoints,\n      scalingConstant = ctx.scalingConstant,\n      maxLookupRadius = ctx.maxLookupRadius,\n      probeSize = ctx.probeSize;\n  var lookup3d = structure.lookup3d,\n      serialMapping = structure.serialMapping,\n      unitIndexMap = structure.unitIndexMap,\n      units = structure.units;\n  var cumulativeUnitElementCount = serialMapping.cumulativeUnitElementCount,\n      elementIndices = serialMapping.elementIndices,\n      unitIndices = serialMapping.unitIndices;\n\n  for (var aI = begin; aI < end; ++aI) {\n    var vdw1 = VdWLookup[atomRadiusType[aI]];\n    if (vdw1 === VdWLookup[0]) continue;\n    var aUnit = units[unitIndices[aI]];\n    var aElementIndex = elementIndices[aI];\n    var aX = aUnit.conformation.x(aElementIndex);\n    var aY = aUnit.conformation.y(aElementIndex);\n    var aZ = aUnit.conformation.z(aElementIndex); // pre-filter by lookup3d (provides >10x speed-up compared to naive evaluation)\n\n    var _a = lookup3d.find(aX, aY, aZ, maxLookupRadius),\n        count = _a.count,\n        lUnits = _a.units,\n        indices = _a.indices,\n        squaredDistances = _a.squaredDistances; // see optimizations proposed in Eisenhaber et al., 1995 (https://doi.org/10.1002/jcc.540160303)\n    // collect neighbors for each atom\n\n\n    var radius1 = probeSize + vdw1;\n    var cutoff1 = probeSize + radius1;\n    var neighbors = []; // TODO reuse\n\n    for (var iI = 0; iI < count; ++iI) {\n      var bUnit = lUnits[iI];\n      var bI = cumulativeUnitElementCount[unitIndexMap.get(bUnit.id)] + indices[iI];\n      var bElementIndex = elementIndices[bI];\n      var vdw2 = VdWLookup[atomRadiusType[bI]];\n      if (aUnit === bUnit && aElementIndex === bElementIndex || vdw2 === VdWLookup[0]) continue;\n      var radius2 = probeSize + vdw2;\n\n      if (squaredDistances[iI] < (cutoff1 + vdw2) * (cutoff1 + vdw2)) {\n        var bElementIndex_1 = elementIndices[bI]; // while here: compute values for later lookup\n\n        neighbors[neighbors.length] = [squaredDistances[iI], (squaredDistances[iI] + radius1 * radius1 - radius2 * radius2) / (2 * radius1), bUnit.conformation.x(bElementIndex_1) - aX, bUnit.conformation.y(bElementIndex_1) - aY, bUnit.conformation.z(bElementIndex_1) - aZ];\n      }\n    } // sort ascendingly by distance for improved downstream performance\n\n\n    neighbors.sort(function (a, b) {\n      return a[0] - b[0];\n    });\n    var accessiblePointCount = 0;\n\n    sl: for (var sI = 0; sI < spherePoints.length; ++sI) {\n      var _b = spherePoints[sI],\n          sX = _b[0],\n          sY = _b[1],\n          sZ = _b[2];\n\n      for (var nI = 0; nI < neighbors.length; ++nI) {\n        var _c = neighbors[nI],\n            sqRadius = _c[1],\n            nX = _c[2],\n            nY = _c[3],\n            nZ = _c[4];\n        var dot = sX * nX + sY * nY + sZ * nZ;\n\n        if (dot > sqRadius) {\n          continue sl;\n        }\n      }\n\n      ++accessiblePointCount;\n    }\n\n    area[serialResidueIndex[aI]] += scalingConstant * accessiblePointCount * radius1 * radius1;\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/accessible-surface-area/shrake-rupley/area.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { VdWLookup } from './common';\r\n// TODO\r\n// - iterate over units and elements\r\n// - avoid using serial-element index whenever possible\r\n// - calculate atomRadiusType only for invariant units\r\n// - factor serialResidueIndex out\r\nvar updateChunk = 5000;\r\nexport function computeArea(runtime, ctx) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var atomRadius, i;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    atomRadius = ctx.atomRadiusType;\r\n                    i = 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(i < atomRadius.length)) return [3 /*break*/, 5];\r\n                    if (!runtime.shouldUpdate) return [3 /*break*/, 3];\r\n                    return [4 /*yield*/, runtime.update({ message: 'Computing per residue surface accessibility...', current: i, max: atomRadius.length })];\r\n                case 2:\r\n                    _a.sent();\r\n                    _a.label = 3;\r\n                case 3:\r\n                    computeRange(ctx, i, Math.min(i + updateChunk, atomRadius.length));\r\n                    _a.label = 4;\r\n                case 4:\r\n                    i += updateChunk;\r\n                    return [3 /*break*/, 1];\r\n                case 5: return [2 /*return*/];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction computeRange(ctx, begin, end) {\r\n    var structure = ctx.structure, atomRadiusType = ctx.atomRadiusType, serialResidueIndex = ctx.serialResidueIndex, area = ctx.area, spherePoints = ctx.spherePoints, scalingConstant = ctx.scalingConstant, maxLookupRadius = ctx.maxLookupRadius, probeSize = ctx.probeSize;\r\n    var lookup3d = structure.lookup3d, serialMapping = structure.serialMapping, unitIndexMap = structure.unitIndexMap, units = structure.units;\r\n    var cumulativeUnitElementCount = serialMapping.cumulativeUnitElementCount, elementIndices = serialMapping.elementIndices, unitIndices = serialMapping.unitIndices;\r\n    for (var aI = begin; aI < end; ++aI) {\r\n        var vdw1 = VdWLookup[atomRadiusType[aI]];\r\n        if (vdw1 === VdWLookup[0])\r\n            continue;\r\n        var aUnit = units[unitIndices[aI]];\r\n        var aElementIndex = elementIndices[aI];\r\n        var aX = aUnit.conformation.x(aElementIndex);\r\n        var aY = aUnit.conformation.y(aElementIndex);\r\n        var aZ = aUnit.conformation.z(aElementIndex);\r\n        // pre-filter by lookup3d (provides >10x speed-up compared to naive evaluation)\r\n        var _a = lookup3d.find(aX, aY, aZ, maxLookupRadius), count = _a.count, lUnits = _a.units, indices = _a.indices, squaredDistances = _a.squaredDistances;\r\n        // see optimizations proposed in Eisenhaber et al., 1995 (https://doi.org/10.1002/jcc.540160303)\r\n        // collect neighbors for each atom\r\n        var radius1 = probeSize + vdw1;\r\n        var cutoff1 = probeSize + radius1;\r\n        var neighbors = []; // TODO reuse\r\n        for (var iI = 0; iI < count; ++iI) {\r\n            var bUnit = lUnits[iI];\r\n            var bI = cumulativeUnitElementCount[unitIndexMap.get(bUnit.id)] + indices[iI];\r\n            var bElementIndex = elementIndices[bI];\r\n            var vdw2 = VdWLookup[atomRadiusType[bI]];\r\n            if ((aUnit === bUnit && aElementIndex === bElementIndex) || vdw2 === VdWLookup[0])\r\n                continue;\r\n            var radius2 = probeSize + vdw2;\r\n            if (squaredDistances[iI] < (cutoff1 + vdw2) * (cutoff1 + vdw2)) {\r\n                var bElementIndex_1 = elementIndices[bI];\r\n                // while here: compute values for later lookup\r\n                neighbors[neighbors.length] = [squaredDistances[iI],\r\n                    (squaredDistances[iI] + radius1 * radius1 - radius2 * radius2) / (2 * radius1),\r\n                    bUnit.conformation.x(bElementIndex_1) - aX,\r\n                    bUnit.conformation.y(bElementIndex_1) - aY,\r\n                    bUnit.conformation.z(bElementIndex_1) - aZ];\r\n            }\r\n        }\r\n        // sort ascendingly by distance for improved downstream performance\r\n        neighbors.sort(function (a, b) { return a[0] - b[0]; });\r\n        var accessiblePointCount = 0;\r\n        sl: for (var sI = 0; sI < spherePoints.length; ++sI) {\r\n            var _b = spherePoints[sI], sX = _b[0], sY = _b[1], sZ = _b[2];\r\n            for (var nI = 0; nI < neighbors.length; ++nI) {\r\n                var _c = neighbors[nI], sqRadius = _c[1], nX = _c[2], nY = _c[3], nZ = _c[4];\r\n                var dot = sX * nX + sY * nY + sZ * nZ;\r\n                if (dot > sqRadius) {\r\n                    continue sl;\r\n                }\r\n            }\r\n            ++accessiblePointCount;\r\n        }\r\n        area[serialResidueIndex[aI]] += scalingConstant * accessiblePointCount * radius1 * radius1;\r\n    }\r\n}\r\n//# sourceMappingURL=area.js.map"]},"metadata":{},"sourceType":"module"}