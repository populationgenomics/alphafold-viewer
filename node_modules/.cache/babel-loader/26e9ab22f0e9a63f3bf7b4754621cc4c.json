{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign, __awaiter, __generator } from \"tslib\";\nimport { IntMap, SortedArray, Segmentation, Interval, OrderedSet } from '../../../mol-data/int';\nimport { UniqueArray } from '../../../mol-data/generic';\nimport { SymmetryOperator } from '../../../mol-math/geometry/symmetry-operator';\nimport { Model } from '../model';\nimport { sort, arraySwap, hash1, sortArray, hashString, hashFnv32a } from '../../../mol-data/util';\nimport { StructureElement } from './element';\nimport { Unit } from './unit';\nimport { StructureLookup3D } from './util/lookup3d';\nimport { StructureSubsetBuilder } from './util/subset-builder';\nimport { computeInterUnitBonds, Bond } from './unit/bonds';\nimport { StructureSymmetry } from './symmetry';\nimport { StructureProperties } from './properties';\nimport { computeCarbohydrates } from './carbohydrates/compute';\nimport { Vec3, Mat4 } from '../../../mol-math/linear-algebra';\nimport { idFactory } from '../../../mol-util/id-factory';\nimport { GridLookup3D } from '../../../mol-math/geometry';\nimport { CustomProperties } from '../../custom-property';\nimport { AtomicHierarchy } from '../model/properties/atomic';\nimport { StructureSelection } from '../query/selection';\nimport { getBoundary } from '../../../mol-math/geometry/boundary';\nimport { CustomStructureProperty } from '../../../mol-model-props/common/custom-structure-property';\nimport { Task } from '../../../mol-task';\nimport { computeStructureBoundary } from './util/boundary';\n\nvar Structure =\n/** @class */\nfunction () {\n  /**\r\n   * @param units Array of all units in the structure, sorted by unit.id\r\n   * @param unitMap Maps unit.id to index of unit in units array\r\n   * @param unitIndexMap Array of all units in the structure, sorted by unit.id\r\n   */\n  function Structure(units, unitMap, unitIndexMap, state, asParent) {\n    this.units = units;\n    this.unitMap = unitMap;\n    this.unitIndexMap = unitIndexMap;\n    this.state = state; // always assign to ensure object shape\n\n    this._child = asParent === null || asParent === void 0 ? void 0 : asParent.child;\n    this._target = asParent === null || asParent === void 0 ? void 0 : asParent.target;\n    this._proxy = undefined;\n  }\n\n  Structure.prototype.subsetBuilder = function (isSorted) {\n    return new StructureSubsetBuilder(this, isSorted);\n  };\n\n  Object.defineProperty(Structure.prototype, \"elementCount\", {\n    /** Count of all elements in the structure, i.e. the sum of the elements in the units */\n    get: function () {\n      return this.state.elementCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"bondCount\", {\n    /** Count of all bonds (intra- and inter-unit) in the structure */\n    get: function () {\n      if (this.state.bondCount === -1) {\n        this.state.bondCount = this.interUnitBonds.edgeCount + Bond.getIntraUnitBondCount(this);\n      }\n\n      return this.state.bondCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"hasCustomProperties\", {\n    get: function () {\n      return !!this.state.customProps && this.state.customProps.all.length > 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"customPropertyDescriptors\", {\n    get: function () {\n      if (!this.state.customProps) this.state.customProps = new CustomProperties();\n      return this.state.customProps;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"currentPropertyData\", {\n    /**\r\n     * Property data unique to this instance of the structure.\r\n     */\n    get: function () {\n      if (!this.state.propertyData) this.state.propertyData = Object.create(null);\n      return this.state.propertyData;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"inheritedPropertyData\", {\n    /**\r\n     * Property data of the parent structure if it exists, currentPropertyData otherwise.\r\n     */\n    get: function () {\n      return this.parent ? this.parent.currentPropertyData : this.currentPropertyData;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"polymerResidueCount\", {\n    /** Count of all polymer residues in the structure */\n    get: function () {\n      if (this.state.polymerResidueCount === -1) {\n        this.state.polymerResidueCount = getPolymerResidueCount(this);\n      }\n\n      return this.state.polymerResidueCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"polymerGapCount\", {\n    /** Count of all polymer gaps in the structure */\n    get: function () {\n      if (this.state.polymerGapCount === -1) {\n        this.state.polymerGapCount = getPolymerGapCount(this);\n      }\n\n      return this.state.polymerGapCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"polymerUnitCount\", {\n    get: function () {\n      if (this.state.polymerUnitCount === -1) {\n        this.state.polymerUnitCount = getPolymerUnitCount(this);\n      }\n\n      return this.state.polymerUnitCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"uniqueElementCount\", {\n    get: function () {\n      if (this.state.uniqueElementCount === -1) {\n        this.state.uniqueElementCount = getUniqueElementCount(this);\n      }\n\n      return this.state.uniqueElementCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"atomicResidueCount\", {\n    get: function () {\n      if (this.state.atomicResidueCount === -1) {\n        this.state.atomicResidueCount = getAtomicResidueCount(this);\n      }\n\n      return this.state.atomicResidueCount;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"isCoarseGrained\", {\n    /**\r\n     * True if any model the structure is based on is coarse grained.\r\n     * @see Model.isCoarseGrained\r\n     */\n    get: function () {\n      return this.models.some(function (m) {\n        return Model.isCoarseGrained(m);\n      });\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"isEmpty\", {\n    get: function () {\n      return this.units.length === 0;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"hashCode\", {\n    get: function () {\n      if (this.state.hashCode !== -1) return this.state.hashCode;\n      return this.computeHash();\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"transformHash\", {\n    /** Hash based on all unit.id values in the structure, reflecting the units transformation */\n    get: function () {\n      if (this.state.transformHash !== -1) return this.state.transformHash;\n      this.state.transformHash = hashFnv32a(this.units.map(function (u) {\n        return u.id;\n      }));\n      return this.state.transformHash;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Structure.prototype.computeHash = function () {\n    var hash = 23;\n\n    for (var i = 0, _i = this.units.length; i < _i; i++) {\n      var u = this.units[i];\n      hash = 31 * hash + u.id | 0;\n      hash = 31 * hash + SortedArray.hashCode(u.elements) | 0;\n    }\n\n    hash = 31 * hash + this.elementCount | 0;\n    hash = hash1(hash);\n    if (hash === -1) hash = 0;\n    this.state.hashCode = hash;\n    return hash;\n  };\n  /** Returns a new element location iterator */\n\n\n  Structure.prototype.elementLocations = function () {\n    return new Structure.ElementLocationIterator(this);\n  };\n\n  Object.defineProperty(Structure.prototype, \"root\", {\n    /** The parent or itself in case this is the root */\n    get: function () {\n      var _a;\n\n      return (_a = this.state.parent) !== null && _a !== void 0 ? _a : this;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"parent\", {\n    /** The root/top-most parent or `undefined` in case this is the root */\n    get: function () {\n      return this.state.parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"coordinateSystem\", {\n    /**\r\n     * Conformation transformation that was applied to every unit of this structure.\r\n     *\r\n     * Coordinate system applies to the *current* structure only.\r\n     * A parent structure can have a different coordinate system and thefore it has to be composed \"manualy\"\r\n     * by the consumer.\r\n     */\n    get: function () {\n      return this.state.coordinateSystem;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"label\", {\n    get: function () {\n      return this.state.label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"boundary\", {\n    get: function () {\n      if (this.state.boundary) return this.state.boundary;\n      this.state.boundary = computeStructureBoundary(this);\n      return this.state.boundary;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"lookup3d\", {\n    get: function () {\n      if (this.state.lookup3d) return this.state.lookup3d;\n      this.state.lookup3d = new StructureLookup3D(this);\n      return this.state.lookup3d;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"interUnitBonds\", {\n    get: function () {\n      if (this.state.interUnitBonds) return this.state.interUnitBonds;\n      this.state.interUnitBonds = computeInterUnitBonds(this, {\n        ignoreWater: !this.dynamicBonds\n      });\n      return this.state.interUnitBonds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"dynamicBonds\", {\n    get: function () {\n      return this.state.dynamicBonds;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"unitSymmetryGroups\", {\n    get: function () {\n      if (this.state.unitSymmetryGroups) return this.state.unitSymmetryGroups;\n      this.state.unitSymmetryGroups = StructureSymmetry.computeTransformGroups(this);\n      return this.state.unitSymmetryGroups;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"unitSymmetryGroupsIndexMap\", {\n    /** Maps unit.id to index of SymmetryGroup in unitSymmetryGroups array */\n    get: function () {\n      if (this.state.unitSymmetryGroupsIndexMap) return this.state.unitSymmetryGroupsIndexMap;\n      this.state.unitSymmetryGroupsIndexMap = Unit.SymmetryGroup.getUnitSymmetryGroupsIndexMap(this.unitSymmetryGroups);\n      return this.state.unitSymmetryGroupsIndexMap;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"carbohydrates\", {\n    get: function () {\n      if (this.state.carbohydrates) return this.state.carbohydrates;\n      this.state.carbohydrates = computeCarbohydrates(this);\n      return this.state.carbohydrates;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"models\", {\n    get: function () {\n      if (this.state.models) return this.state.models;\n      this.state.models = getModels(this);\n      return this.state.models;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"uniqueResidueNames\", {\n    get: function () {\n      return this.state.uniqueResidueNames || (this.state.uniqueResidueNames = getUniqueResidueNames(this));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"uniqueElementSymbols\", {\n    get: function () {\n      return this.state.uniqueElementSymbols || (this.state.uniqueElementSymbols = getUniqueElementSymbols(this));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"entityIndices\", {\n    get: function () {\n      return this.state.entityIndices || (this.state.entityIndices = getEntityIndices(this));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"uniqueAtomicResidueIndices\", {\n    get: function () {\n      return this.state.uniqueAtomicResidueIndices || (this.state.uniqueAtomicResidueIndices = getUniqueAtomicResidueIndices(this));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"isAtomic\", {\n    /** Contains only atomic units */\n    get: function () {\n      for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\n        var u = _b[_a];\n        if (!Unit.isAtomic(u)) return false;\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"hasAtomic\", {\n    /** Contains some atomic units */\n    get: function () {\n      for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\n        var u = _b[_a];\n        if (Unit.isAtomic(u)) return true;\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"isCoarse\", {\n    /** Contains only coarse units */\n    get: function () {\n      for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\n        var u = _b[_a];\n        if (!Unit.isCoarse(u)) return false;\n      }\n\n      return true;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"hasCoarse\", {\n    /** Contains some coarse units */\n    get: function () {\n      for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\n        var u = _b[_a];\n        if (Unit.isCoarse(u)) return true;\n      }\n\n      return false;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"serialMapping\", {\n    /**\r\n     * Provides mapping for serial element indices accross all units.\r\n     *\r\n     * Note that this is especially costly for structures with many units that are grouped\r\n     * into few symmetry groups. Use only when needed and prefer `StructureElement`\r\n     * to address elements in a structure.\r\n     */\n    get: function () {\n      return this.state.serialMapping || (this.state.serialMapping = getSerialMapping(this));\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"model\", {\n    /**\r\n     * If the structure is based on a single model or has a master-/representative-model, return it.\r\n     * Otherwise throw an exception.\r\n     */\n    get: function () {\n      if (this.state.model) return this.state.model;\n      if (this.state.representativeModel) return this.state.representativeModel;\n      if (this.state.masterModel) return this.state.masterModel;\n      var models = this.models;\n\n      if (models.length > 1) {\n        throw new Error('The structure is based on multiple models and has neither a master- nor a representative-model.');\n      }\n\n      this.state.model = models[0];\n      return this.state.model;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"masterModel\", {\n    /** The master-model, other models can have bonds to it  */\n    get: function () {\n      return this.state.masterModel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"representativeModel\", {\n    /** A representative model, e.g. the first model of a trajectory */\n    get: function () {\n      return this.state.representativeModel;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Structure.prototype.hasElement = function (e) {\n    if (!this.unitMap.has(e.unit.id)) return false;\n    return SortedArray.has(this.unitMap.get(e.unit.id).elements, e.element);\n  };\n\n  Structure.prototype.getModelIndex = function (m) {\n    return this.models.indexOf(m);\n  };\n\n  Structure.prototype.remapModel = function (m) {\n    var _a = this.state,\n        dynamicBonds = _a.dynamicBonds,\n        interUnitBonds = _a.interUnitBonds;\n    var units = [];\n\n    for (var _b = 0, _c = this.unitSymmetryGroups; _b < _c.length; _b++) {\n      var ug = _c[_b];\n      var unit = ug.units[0].remapModel(m, dynamicBonds);\n      units.push(unit);\n\n      for (var i = 1, il = ug.units.length; i < il; ++i) {\n        var u = ug.units[i];\n        units.push(u.remapModel(m, dynamicBonds, unit.props));\n      }\n    }\n\n    return Structure.create(units, {\n      label: this.label,\n      interUnitBonds: dynamicBonds ? undefined : interUnitBonds,\n      dynamicBonds: dynamicBonds\n    });\n  };\n  /**\r\n   * For `structure` with `parent` this returns a proxy that\r\n   * targets `parent` and has `structure` attached as a child.\r\n   */\n\n\n  Structure.prototype.asParent = function () {\n    if (this._proxy) return this._proxy;\n\n    if (this.parent) {\n      var p = this.parent.coordinateSystem.isIdentity ? this.parent : Structure.transform(this.parent, this.parent.coordinateSystem.inverse);\n      var s = this.coordinateSystem.isIdentity ? p : Structure.transform(p, this.coordinateSystem.matrix);\n      this._proxy = new Structure(s.units, s.unitMap, s.unitIndexMap, __assign(__assign({}, s.state), {\n        dynamicBonds: this.dynamicBonds\n      }), {\n        child: this,\n        target: this.parent\n      });\n    } else {\n      this._proxy = this;\n    }\n\n    return this._proxy;\n  };\n\n  Object.defineProperty(Structure.prototype, \"child\", {\n    get: function () {\n      return this._child;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Structure.prototype, \"target\", {\n    /** Get the proxy target. Usefull for equality checks. */\n    get: function () {\n      var _a;\n\n      return (_a = this._target) !== null && _a !== void 0 ? _a : this;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return Structure;\n}();\n\nfunction cmpUnits(units, i, j) {\n  return units[i].id - units[j].id;\n}\n\nfunction getModels(s) {\n  var units = s.units;\n  var arr = UniqueArray.create();\n\n  for (var _a = 0, units_1 = units; _a < units_1.length; _a++) {\n    var u = units_1[_a];\n    UniqueArray.add(arr, u.model.id, u.model);\n  }\n\n  return arr.array;\n}\n\nfunction getUniqueResidueNames(s) {\n  var microheterogeneityCompIds = StructureProperties.residue.microheterogeneityCompIds;\n  var names = new Set();\n  var loc = StructureElement.Location.create(s);\n\n  for (var _a = 0, _b = s.unitSymmetryGroups; _a < _b.length; _a++) {\n    var unitGroup = _b[_a];\n    var unit = unitGroup.units[0]; // TODO: support coarse unit?\n\n    if (!Unit.isAtomic(unit)) continue;\n    var residues = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n    loc.unit = unit;\n\n    while (residues.hasNext) {\n      var seg = residues.move();\n      loc.element = unit.elements[seg.start];\n      var compIds = microheterogeneityCompIds(loc);\n\n      for (var _c = 0, compIds_1 = compIds; _c < compIds_1.length; _c++) {\n        var compId = compIds_1[_c];\n        names.add(compId);\n      }\n    }\n  }\n\n  return names;\n}\n\nfunction getUniqueElementSymbols(s) {\n  var prop = StructureProperties.atom.type_symbol;\n  var symbols = new Set();\n  var loc = StructureElement.Location.create(s);\n\n  for (var _a = 0, _b = s.unitSymmetryGroups; _a < _b.length; _a++) {\n    var unitGroup = _b[_a];\n    var unit = unitGroup.units[0];\n    if (!Unit.isAtomic(unit)) continue;\n    loc.unit = unit;\n\n    for (var i = 0, il = unit.elements.length; i < il; ++i) {\n      loc.element = unit.elements[i];\n      symbols.add(prop(loc));\n    }\n  }\n\n  return symbols;\n}\n\nfunction getEntityIndices(structure) {\n  var units = structure.units;\n  var l = StructureElement.Location.create(structure);\n  var keys = UniqueArray.create();\n\n  for (var _a = 0, units_2 = units; _a < units_2.length; _a++) {\n    var unit = units_2[_a];\n    var prop = unit.kind === 0\n    /* Atomic */\n    ? StructureProperties.entity.key : StructureProperties.coarse.entityKey;\n    l.unit = unit;\n    var elements = unit.elements;\n    var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\n\n    while (chainsIt.hasNext) {\n      var chainSegment = chainsIt.move();\n      l.element = elements[chainSegment.start];\n      var key = prop(l);\n      UniqueArray.add(keys, key, key);\n    }\n  }\n\n  sortArray(keys.array);\n  return keys.array;\n}\n\nfunction getUniqueAtomicResidueIndices(structure) {\n  var map = new Map();\n  var modelIds = [];\n  var unitGroups = structure.unitSymmetryGroups;\n\n  for (var _a = 0, unitGroups_1 = unitGroups; _a < unitGroups_1.length; _a++) {\n    var unitGroup = unitGroups_1[_a];\n    var unit = unitGroup.units[0];\n    if (!Unit.isAtomic(unit)) continue;\n    var uniqueResidues = void 0;\n    if (map.has(unit.model.id)) uniqueResidues = map.get(unit.model.id);else {\n      uniqueResidues = UniqueArray.create();\n      modelIds.push(unit.model.id);\n      map.set(unit.model.id, uniqueResidues);\n    }\n    var residues = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\n\n    while (residues.hasNext) {\n      var seg = residues.move();\n      UniqueArray.add(uniqueResidues, seg.index, seg.index);\n    }\n  }\n\n  var ret = new Map();\n\n  for (var _b = 0, modelIds_1 = modelIds; _b < modelIds_1.length; _b++) {\n    var id = modelIds_1[_b];\n    var array = map.get(id).array;\n    sortArray(array);\n    ret.set(id, array);\n  }\n\n  return ret;\n}\n\nfunction getUniqueElementCount(structure) {\n  var unitSymmetryGroups = structure.unitSymmetryGroups;\n  var uniqueElementCount = 0;\n\n  for (var i = 0, _i = unitSymmetryGroups.length; i < _i; i++) {\n    uniqueElementCount += unitSymmetryGroups[i].elements.length;\n  }\n\n  return uniqueElementCount;\n}\n\nfunction getPolymerResidueCount(structure) {\n  var units = structure.units;\n  var polymerResidueCount = 0;\n\n  for (var i = 0, _i = units.length; i < _i; i++) {\n    polymerResidueCount += units[i].polymerElements.length;\n  }\n\n  return polymerResidueCount;\n}\n\nfunction getPolymerGapCount(structure) {\n  var units = structure.units;\n  var polymerGapCount = 0;\n\n  for (var i = 0, _i = units.length; i < _i; i++) {\n    polymerGapCount += units[i].gapElements.length / 2;\n  }\n\n  return polymerGapCount;\n}\n\nfunction getPolymerUnitCount(structure) {\n  var units = structure.units;\n  var polymerUnitCount = 0;\n\n  for (var i = 0, _i = units.length; i < _i; i++) {\n    if (units[i].polymerElements.length > 0) polymerUnitCount += 1;\n  }\n\n  return polymerUnitCount;\n}\n\nfunction getAtomicResidueCount(structure) {\n  var units = structure.units;\n  var atomicResidueCount = 0;\n\n  for (var i = 0, _i = units.length; i < _i; i++) {\n    var unit = units[i];\n    if (!Unit.isAtomic(unit)) continue;\n    var elements = unit.elements,\n        residueIndex = unit.residueIndex;\n    var idx = -1;\n    var prevIdx = -1;\n\n    for (var j = 0, jl = elements.length; j < jl; ++j) {\n      idx = residueIndex[elements[j]];\n\n      if (idx !== prevIdx) {\n        atomicResidueCount += 1;\n        prevIdx = idx;\n      }\n    }\n  }\n\n  return atomicResidueCount;\n}\n\nfunction getSerialMapping(structure) {\n  var units = structure.units,\n      elementCount = structure.elementCount,\n      unitIndexMap = structure.unitIndexMap;\n  var cumulativeUnitElementCount = new Uint32Array(units.length);\n  var unitIndices = new Uint32Array(elementCount);\n  var elementIndices = new Uint32Array(elementCount);\n\n  for (var i = 0, m = 0, il = units.length; i < il; ++i) {\n    cumulativeUnitElementCount[i] = m;\n    var elements = units[i].elements;\n\n    for (var j = 0, jl = elements.length; j < jl; ++j) {\n      var mj = m + j;\n      unitIndices[mj] = i;\n      elementIndices[mj] = elements[j];\n    }\n\n    m += elements.length;\n  }\n\n  return {\n    cumulativeUnitElementCount: cumulativeUnitElementCount,\n    unitIndices: unitIndices,\n    elementIndices: elementIndices,\n    getSerialIndex: function (unit, element) {\n      return cumulativeUnitElementCount[unitIndexMap.get(unit.id)] + OrderedSet.indexOf(unit.elements, element);\n    }\n  };\n}\n\n(function (Structure) {\n  Structure.Empty = create([]);\n\n  function Loci(structure) {\n    return {\n      kind: 'structure-loci',\n      structure: structure\n    };\n  }\n\n  Structure.Loci = Loci;\n\n  function toStructureElementLoci(structure) {\n    var elements = [];\n\n    for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\n      var unit = _b[_a];\n      elements.push({\n        unit: unit,\n        indices: Interval.ofBounds(0, unit.elements.length)\n      });\n    }\n\n    return StructureElement.Loci(structure, elements);\n  }\n\n  Structure.toStructureElementLoci = toStructureElementLoci;\n\n  function toSubStructureElementLoci(parent, structure) {\n    return StructureSelection.toLociWithSourceUnits(StructureSelection.Singletons(parent, structure));\n  }\n\n  Structure.toSubStructureElementLoci = toSubStructureElementLoci;\n\n  function isLoci(x) {\n    return !!x && x.kind === 'structure-loci';\n  }\n\n  Structure.isLoci = isLoci;\n\n  function areLociEqual(a, b) {\n    return a.structure === b.structure;\n  }\n\n  Structure.areLociEqual = areLociEqual;\n\n  function isLociEmpty(loci) {\n    return loci.structure.isEmpty;\n  }\n\n  Structure.isLociEmpty = isLociEmpty;\n\n  function remapLoci(loci, structure) {\n    if (structure === loci.structure) return loci;\n    return Loci(structure);\n  }\n\n  Structure.remapLoci = remapLoci;\n\n  function create(units, props) {\n    if (props === void 0) {\n      props = {};\n    } // init units\n\n\n    var unitMap = IntMap.Mutable();\n    var unitIndexMap = IntMap.Mutable();\n    var elementCount = 0;\n    var isSorted = true;\n    var lastId = units.length > 0 ? units[0].id : 0;\n\n    for (var i = 0, _i = units.length; i < _i; i++) {\n      var u = units[i];\n      unitMap.set(u.id, u);\n      elementCount += u.elements.length;\n      if (u.id < lastId) isSorted = false;\n      lastId = u.id;\n    }\n\n    if (!isSorted) sort(units, 0, units.length, cmpUnits, arraySwap);\n\n    for (var i = 0, _i = units.length; i < _i; i++) {\n      unitIndexMap.set(units[i].id, i);\n    } // initial state\n\n\n    var state = {\n      hashCode: -1,\n      transformHash: -1,\n      elementCount: elementCount,\n      bondCount: -1,\n      uniqueElementCount: -1,\n      atomicResidueCount: -1,\n      polymerResidueCount: -1,\n      polymerGapCount: -1,\n      polymerUnitCount: -1,\n      dynamicBonds: false,\n      coordinateSystem: SymmetryOperator.Default,\n      label: ''\n    }; // handle props\n\n    if (props.parent) state.parent = props.parent.parent || props.parent;\n    if (props.interUnitBonds) state.interUnitBonds = props.interUnitBonds;\n    if (props.dynamicBonds) state.dynamicBonds = props.dynamicBonds;else if (props.parent) state.dynamicBonds = props.parent.dynamicBonds;\n    if (props.coordinateSystem) state.coordinateSystem = props.coordinateSystem;else if (props.parent) state.coordinateSystem = props.parent.coordinateSystem;\n    if (props.label) state.label = props.label;else if (props.parent) state.label = props.parent.label;\n    if (props.masterModel) state.masterModel = props.masterModel;else if (props.parent) state.masterModel = props.parent.masterModel;\n    if (props.representativeModel) state.representativeModel = props.representativeModel;else if (props.parent) state.representativeModel = props.parent.representativeModel;\n    return new Structure(units, unitMap, unitIndexMap, state);\n  }\n\n  Structure.create = create;\n\n  function ofTrajectory(trajectory, ctx) {\n    return __awaiter(this, void 0, void 0, function () {\n      var units, first, count, i, il, frame, structure, j, jl, u, invariantId, chainGroupId, newUnit;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (trajectory.frameCount === 0) return [2\n            /*return*/\n            , Structure.Empty];\n            units = [];\n            first = void 0;\n            count = 0;\n            i = 0, il = trajectory.frameCount;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < il)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , Task.resolveInContext(trajectory.getFrameAtIndex(i), ctx)];\n\n          case 2:\n            frame = _a.sent();\n            if (!first) first = frame;\n            structure = ofModel(frame);\n\n            for (j = 0, jl = structure.units.length; j < jl; ++j) {\n              u = structure.units[j];\n              invariantId = u.invariantId + count;\n              chainGroupId = u.chainGroupId + count;\n              newUnit = Unit.create(units.length, invariantId, chainGroupId, u.traits, u.kind, u.model, u.conformation.operator, u.elements);\n              units.push(newUnit);\n            }\n\n            count = units.length;\n            _a.label = 3;\n\n          case 3:\n            ++i;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , create(units, {\n              representativeModel: first,\n              label: first.label\n            })];\n        }\n      });\n    });\n  }\n\n  Structure.ofTrajectory = ofTrajectory;\n  var PARTITION = false;\n  /**\r\n   * Construct a Structure from a model.\r\n   *\r\n   * Generally, a single unit corresponds to a single chain, with the exception\r\n   * of consecutive \"single atom chains\" with same entity_id and same auth_asym_id.\r\n   */\n\n  function ofModel(model, props) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    var chains = model.atomicHierarchy.chainAtomSegments;\n    var index = model.atomicHierarchy.index;\n    var auth_asym_id = model.atomicHierarchy.chains.auth_asym_id;\n    var atomicChainOperatorMappinng = model.atomicChainOperatorMappinng;\n    var builder = new StructureBuilder(__assign({\n      label: model.label\n    }, props));\n\n    for (var c = 0; c < chains.count; c++) {\n      var operator = atomicChainOperatorMappinng.get(c) || SymmetryOperator.Default;\n      var start = chains.offsets[c]; // set to true for chains that consist of \"single atom residues\",\n      // note that it assumes there are no \"zero atom residues\"\n\n      var singleAtomResidues = AtomicHierarchy.chainResidueCount(model.atomicHierarchy, c) === chains.offsets[c + 1] - chains.offsets[c];\n      var multiChain = false;\n\n      if (isWaterChain(model, c)) {\n        // merge consecutive water chains\n        while (c + 1 < chains.count && isWaterChain(model, c + 1)) {\n          var op1 = atomicChainOperatorMappinng.get(c);\n          var op2 = atomicChainOperatorMappinng.get(c + 1);\n          if (op1 !== op2) break;\n          multiChain = true;\n          c++;\n        }\n      } else {\n        // merge consecutive \"single atom chains\" with same entity_id and auth_asym_id\n        while (c + 1 < chains.count && chains.offsets[c + 1] - chains.offsets[c] === 1 && chains.offsets[c + 2] - chains.offsets[c + 1] === 1) {\n          singleAtomResidues = true;\n          var e1 = index.getEntityFromChain(c);\n          var e2 = index.getEntityFromChain(c + 1);\n          if (e1 !== e2) break;\n          var a1 = auth_asym_id.value(c);\n          var a2 = auth_asym_id.value(c + 1);\n          if (a1 !== a2) break;\n          var op1 = atomicChainOperatorMappinng.get(c);\n          var op2 = atomicChainOperatorMappinng.get(c + 1);\n          if (op1 !== op2) break;\n          multiChain = true;\n          c++;\n        }\n      }\n\n      var elements = SortedArray.ofBounds(start, chains.offsets[c + 1]);\n\n      if (PARTITION) {\n        // check for polymer to exclude CA/P-only models\n        if (singleAtomResidues && !isPolymerChain(model, c)) {\n          partitionAtomicUnitByAtom(model, elements, builder, multiChain, operator);\n        } else if (elements.length > 200000 || isWaterChain(model, c)) {\n          // split up very large chains e.g. lipid bilayers, micelles or water with explicit H\n          partitionAtomicUnitByResidue(model, elements, builder, multiChain, operator);\n        } else {\n          builder.addUnit(0\n          /* Atomic */\n          , model, operator, elements, multiChain ? 1\n          /* MultiChain */\n          : 0\n          /* None */\n          );\n        }\n      } else {\n        builder.addUnit(0\n        /* Atomic */\n        , model, operator, elements, multiChain ? 1\n        /* MultiChain */\n        : 0\n        /* None */\n        );\n      }\n    }\n\n    var cs = model.coarseHierarchy;\n\n    if (cs.isDefined) {\n      if (cs.spheres.count > 0) {\n        addCoarseUnits(builder, model, model.coarseHierarchy.spheres, 1\n        /* Spheres */\n        );\n      }\n\n      if (cs.gaussians.count > 0) {\n        addCoarseUnits(builder, model, model.coarseHierarchy.gaussians, 2\n        /* Gaussians */\n        );\n      }\n    }\n\n    return builder.getStructure();\n  }\n\n  Structure.ofModel = ofModel;\n\n  function isWaterChain(model, chainIndex) {\n    var e = model.atomicHierarchy.index.getEntityFromChain(chainIndex);\n    return model.entities.data.type.value(e) === 'water';\n  }\n\n  function isPolymerChain(model, chainIndex) {\n    var e = model.atomicHierarchy.index.getEntityFromChain(chainIndex);\n    return model.entities.data.type.value(e) === 'polymer';\n  }\n\n  function partitionAtomicUnitByAtom(model, indices, builder, multiChain, operator) {\n    var _a = model.atomicConformation,\n        x = _a.x,\n        y = _a.y,\n        z = _a.z;\n    var position = {\n      x: x,\n      y: y,\n      z: z,\n      indices: indices\n    };\n    var lookup = GridLookup3D(position, getBoundary(position), 8192);\n    var _b = lookup.buckets,\n        offset = _b.offset,\n        count = _b.count,\n        array = _b.array;\n    var traits = (multiChain ? 1\n    /* MultiChain */\n    : 0\n    /* None */\n    ) | (offset.length > 1 ? 2\n    /* Partitioned */\n    : 0\n    /* None */\n    );\n    builder.beginChainGroup();\n\n    for (var i = 0, _i = offset.length; i < _i; i++) {\n      var start = offset[i];\n      var set = new Int32Array(count[i]);\n\n      for (var j = 0, _j = count[i]; j < _j; j++) {\n        set[j] = indices[array[start + j]];\n      }\n\n      builder.addUnit(0\n      /* Atomic */\n      , model, operator, SortedArray.ofSortedArray(set), traits);\n    }\n\n    builder.endChainGroup();\n  } // keeps atoms of residues together\n\n\n  function partitionAtomicUnitByResidue(model, indices, builder, multiChain, operator) {\n    var residueAtomSegments = model.atomicHierarchy.residueAtomSegments;\n    var startIndices = [];\n    var endIndices = [];\n    var residueIt = Segmentation.transientSegments(residueAtomSegments, indices);\n\n    while (residueIt.hasNext) {\n      var residueSegment = residueIt.move();\n      startIndices[startIndices.length] = indices[residueSegment.start];\n      endIndices[endIndices.length] = indices[residueSegment.end];\n    }\n\n    var firstResidueAtomCount = endIndices[0] - startIndices[0];\n    var gridCellCount = 512 * firstResidueAtomCount;\n    var _a = model.atomicConformation,\n        x = _a.x,\n        y = _a.y,\n        z = _a.z;\n    var position = {\n      x: x,\n      y: y,\n      z: z,\n      indices: SortedArray.ofSortedArray(startIndices)\n    };\n    var lookup = GridLookup3D(position, getBoundary(position), gridCellCount);\n    var _b = lookup.buckets,\n        offset = _b.offset,\n        count = _b.count,\n        array = _b.array;\n    var traits = (multiChain ? 1\n    /* MultiChain */\n    : 0\n    /* None */\n    ) | (offset.length > 1 ? 2\n    /* Partitioned */\n    : 0\n    /* None */\n    );\n    builder.beginChainGroup();\n\n    for (var i = 0, _i = offset.length; i < _i; i++) {\n      var start = offset[i];\n      var set = [];\n\n      for (var j = 0, _j = count[i]; j < _j; j++) {\n        var k = array[start + j];\n\n        for (var l = startIndices[k], _l = endIndices[k]; l < _l; l++) {\n          set[set.length] = l;\n        }\n      }\n\n      builder.addUnit(0\n      /* Atomic */\n      , model, operator, SortedArray.ofSortedArray(new Int32Array(set)), traits);\n    }\n\n    builder.endChainGroup();\n  }\n\n  function addCoarseUnits(builder, model, elements, kind) {\n    var chainElementSegments = elements.chainElementSegments;\n\n    for (var cI = 0; cI < chainElementSegments.count; cI++) {\n      var elements_1 = SortedArray.ofBounds(chainElementSegments.offsets[cI], chainElementSegments.offsets[cI + 1]);\n      builder.addUnit(kind, model, SymmetryOperator.Default, elements_1, 0\n      /* None */\n      );\n    }\n  }\n\n  function transform(s, transform) {\n    if (Mat4.isIdentity(transform)) return s;\n    if (!Mat4.isRotationAndTranslation(transform, SymmetryOperator.RotationTranslationEpsilon)) throw new Error('Only rotation/translation combination can be applied.');\n    var units = [];\n\n    for (var _a = 0, _b = s.units; _a < _b.length; _a++) {\n      var u = _b[_a];\n      var old = u.conformation.operator;\n      var op = SymmetryOperator.create(old.name, transform, old);\n      units.push(u.applyOperator(u.id, op));\n    }\n\n    var cs = s.coordinateSystem;\n    var newCS = SymmetryOperator.compose(SymmetryOperator.create(cs.name, transform, cs), cs);\n    return create(units, {\n      parent: s,\n      coordinateSystem: newCS\n    });\n  }\n\n  Structure.transform = transform;\n\n  var StructureBuilder =\n  /** @class */\n  function () {\n    function StructureBuilder(props) {\n      if (props === void 0) {\n        props = {};\n      }\n\n      this.props = props;\n      this.units = [];\n      this.invariantId = idFactory();\n      this.chainGroupId = -1;\n      this.inChainGroup = false;\n      this.p = Vec3();\n      this.singleElementUnits = new Map();\n    }\n\n    StructureBuilder.prototype.beginChainGroup = function () {\n      this.chainGroupId++;\n      this.inChainGroup = true;\n    };\n\n    StructureBuilder.prototype.endChainGroup = function () {\n      this.inChainGroup = false;\n    };\n\n    StructureBuilder.prototype.addUnit = function (kind, model, operator, elements, traits, invariantId) {\n      if (invariantId === undefined) invariantId = this.invariantId();\n      var chainGroupId = this.inChainGroup ? this.chainGroupId : ++this.chainGroupId;\n      var unit = Unit.create(this.units.length, invariantId, chainGroupId, traits, kind, model, operator, elements);\n      return this.add(unit);\n    };\n\n    StructureBuilder.prototype.add = function (unit) {\n      // this is to avoid adding many identical single atom units,\n      // for example, from 'degenerate' spacegroups\n      // - Diamond (COD 9008564)\n      if (unit.elements.length === 1) {\n        unit.conformation.position(unit.elements[0], this.p);\n        var hash = [unit.invariantId, this.p[0], this.p[1], this.p[2]].join('|');\n\n        if (this.singleElementUnits.has(hash)) {\n          return this.singleElementUnits.get(hash);\n        } else {\n          this.singleElementUnits.set(hash, unit);\n        }\n      }\n\n      this.units.push(unit);\n      return unit;\n    };\n\n    StructureBuilder.prototype.addWithOperator = function (unit, operator, dontCompose) {\n      if (dontCompose === void 0) {\n        dontCompose = false;\n      }\n\n      return this.add(unit.applyOperator(this.units.length, operator, dontCompose));\n    };\n\n    StructureBuilder.prototype.getStructure = function () {\n      return create(this.units, this.props);\n    };\n\n    Object.defineProperty(StructureBuilder.prototype, \"isEmpty\", {\n      get: function () {\n        return this.units.length === 0;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return StructureBuilder;\n  }();\n\n  Structure.StructureBuilder = StructureBuilder;\n\n  function Builder(props) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    return new StructureBuilder(props);\n  }\n\n  Structure.Builder = Builder;\n\n  function hashCode(s) {\n    return s.hashCode;\n  }\n\n  Structure.hashCode = hashCode;\n  /** Hash based on all unit.model conformation values in the structure */\n\n  function conformationHash(s) {\n    return hashString(s.units.map(function (u) {\n      return Unit.conformationId(u);\n    }).join('|'));\n  }\n\n  Structure.conformationHash = conformationHash; // TODO: there should be a version that properly supports partitioned units\n\n  function areUnitIdsEqual(a, b) {\n    if (a === b) return true;\n    if (a.elementCount !== b.elementCount) return false;\n    var len = a.units.length;\n    if (len !== b.units.length) return false;\n\n    for (var i = 0; i < len; i++) {\n      if (a.units[i].id !== b.units[i].id) return false;\n    }\n\n    return true;\n  }\n\n  Structure.areUnitIdsEqual = areUnitIdsEqual;\n\n  function areUnitIdsAndIndicesEqual(a, b) {\n    if (!areUnitIdsEqual(a, b)) return false;\n\n    for (var i = 0, il = a.units.length; i < il; i++) {\n      if (!SortedArray.areEqual(a.units[i].elements, b.units[i].elements)) return false;\n    }\n\n    return true;\n  }\n\n  Structure.areUnitIdsAndIndicesEqual = areUnitIdsAndIndicesEqual;\n\n  function areHierarchiesEqual(a, b) {\n    if (a.hashCode !== b.hashCode) return false;\n    var len = a.models.length;\n    if (len !== b.models.length) return false;\n\n    for (var i = 0; i < len; i++) {\n      if (!Model.areHierarchiesEqual(a.models[i], b.models[i])) return false;\n    }\n\n    return true;\n  }\n\n  Structure.areHierarchiesEqual = areHierarchiesEqual;\n\n  function areEquivalent(a, b) {\n    return a === b || a.hashCode === b.hashCode && StructureSymmetry.areTransformGroupsEquivalent(a.unitSymmetryGroups, b.unitSymmetryGroups);\n  }\n\n  Structure.areEquivalent = areEquivalent;\n  /** Check if the structures or their parents are equivalent */\n\n  function areRootsEquivalent(a, b) {\n    return areEquivalent(a.root, b.root);\n  }\n\n  Structure.areRootsEquivalent = areRootsEquivalent;\n  /** Check if the structures or their parents are equal */\n\n  function areRootsEqual(a, b) {\n    return a.root === b.root;\n  }\n\n  Structure.areRootsEqual = areRootsEqual;\n\n  var ElementLocationIterator =\n  /** @class */\n  function () {\n    function ElementLocationIterator(structure) {\n      this.structure = structure;\n      this.unitIndex = 0;\n      this.maxIdx = 0;\n      this.idx = -1;\n      this.current = StructureElement.Location.create(structure);\n      this.hasNext = structure.elementCount > 0;\n\n      if (this.hasNext) {\n        this.elements = structure.units[0].elements;\n        this.maxIdx = this.elements.length - 1;\n        this.current.unit = structure.units[0];\n      }\n    }\n\n    ElementLocationIterator.prototype.move = function () {\n      this.advance();\n      this.current.element = this.elements[this.idx];\n      return this.current;\n    };\n\n    ElementLocationIterator.prototype.advance = function () {\n      if (this.idx < this.maxIdx) {\n        this.idx++;\n        if (this.idx === this.maxIdx) this.hasNext = this.unitIndex + 1 < this.structure.units.length;\n        return;\n      }\n\n      this.idx = 0;\n      this.unitIndex++;\n\n      if (this.unitIndex >= this.structure.units.length) {\n        this.hasNext = false;\n        return;\n      }\n\n      this.current.unit = this.structure.units[this.unitIndex];\n      this.elements = this.current.unit.elements;\n      this.maxIdx = this.elements.length - 1;\n\n      if (this.maxIdx === 0) {\n        this.hasNext = this.unitIndex + 1 < this.structure.units.length;\n      }\n    };\n\n    return ElementLocationIterator;\n  }();\n\n  Structure.ElementLocationIterator = ElementLocationIterator;\n  var distVec = Vec3();\n\n  function unitElementMinDistance(unit, p, eRadius) {\n    var elements = unit.elements,\n        _a = unit.conformation,\n        position = _a.position,\n        r = _a.r,\n        dV = distVec;\n    var minD = Number.MAX_VALUE;\n\n    for (var i = 0, _i = elements.length; i < _i; i++) {\n      var e = elements[i];\n      var d = Vec3.distance(p, position(e, dV)) - eRadius - r(e);\n      if (d < minD) minD = d;\n    }\n\n    return minD;\n  }\n\n  function minDistanceToPoint(s, point, radius) {\n    var units = s.units;\n    var minD = Number.MAX_VALUE;\n\n    for (var i = 0, _i = units.length; i < _i; i++) {\n      var unit = units[i];\n      var d = unitElementMinDistance(unit, point, radius);\n      if (d < minD) minD = d;\n    }\n\n    return minD;\n  }\n\n  Structure.minDistanceToPoint = minDistanceToPoint;\n  var distPivot = Vec3();\n\n  function distance(a, b) {\n    if (a.elementCount === 0 || b.elementCount === 0) return 0;\n    var units = a.units;\n    var minD = Number.MAX_VALUE;\n\n    for (var i = 0, _i = units.length; i < _i; i++) {\n      var unit = units[i];\n      var elements = unit.elements,\n          _a = unit.conformation,\n          position = _a.position,\n          r = _a.r;\n\n      for (var i_1 = 0, _i_1 = elements.length; i_1 < _i_1; i_1++) {\n        var e = elements[i_1];\n        var d = minDistanceToPoint(b, position(e, distPivot), r(e));\n        if (d < minD) minD = d;\n      }\n    }\n\n    return minD;\n  }\n\n  Structure.distance = distance;\n\n  function elementDescription(s) {\n    return s.elementCount === 1 ? '1 element' : s.elementCount + \" elements\";\n  }\n\n  Structure.elementDescription = elementDescription;\n\n  function validUnitPair(s, a, b) {\n    return s.masterModel ? a.model === b.model || a.model === s.masterModel || b.model === s.masterModel : a.model === b.model;\n  }\n\n  Structure.validUnitPair = validUnitPair;\n  /**\r\n   * Iterate over all unit pairs of a structure and invokes callback for valid units\r\n   * and unit pairs if within a max distance.\r\n   */\n\n  function eachUnitPair(structure, callback, props) {\n    var maxRadius = props.maxRadius,\n        validUnit = props.validUnit,\n        validUnitPair = props.validUnitPair;\n    if (!structure.units.some(function (u) {\n      return validUnit(u);\n    })) return;\n    var lookup = structure.lookup3d;\n    var imageCenter = Vec3();\n\n    for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\n      var unit = _b[_a];\n      if (!validUnit(unit)) continue;\n      var bs = unit.boundary.sphere;\n      Vec3.transformMat4(imageCenter, bs.center, unit.conformation.operator.matrix);\n      var closeUnits = lookup.findUnitIndices(imageCenter[0], imageCenter[1], imageCenter[2], bs.radius + maxRadius);\n\n      for (var i = 0; i < closeUnits.count; i++) {\n        var other = structure.units[closeUnits.indices[i]];\n        if (!validUnit(other) || unit.id >= other.id || !validUnitPair(unit, other)) continue;\n        if (other.elements.length >= unit.elements.length) callback(unit, other);else callback(other, unit);\n      }\n    }\n  }\n\n  Structure.eachUnitPair = eachUnitPair;\n  ;\n\n  function eachAtomicHierarchyElement(structure, _a) {\n    var chain = _a.chain,\n        residue = _a.residue,\n        atom = _a.atom;\n    var l = StructureElement.Location.create(structure);\n\n    for (var _b = 0, _c = structure.units; _b < _c.length; _b++) {\n      var unit = _c[_b];\n      if (unit.kind !== 0\n      /* Atomic */\n      ) continue;\n      l.unit = unit;\n      var elements = unit.elements;\n      var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\n      var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\n\n      while (chainsIt.hasNext) {\n        var chainSegment = chainsIt.move();\n\n        if (chain) {\n          l.element = elements[chainSegment.start];\n          chain(l);\n        }\n\n        if (!residue && !atom) continue;\n        residuesIt.setSegment(chainSegment);\n\n        while (residuesIt.hasNext) {\n          var residueSegment = residuesIt.move();\n\n          if (residue) {\n            l.element = elements[residueSegment.start];\n            residue(l);\n          }\n\n          if (!atom) continue;\n\n          for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\n            l.element = elements[j];\n            atom(l);\n          }\n        }\n      }\n    }\n  }\n\n  Structure.eachAtomicHierarchyElement = eachAtomicHierarchyElement; //\n\n  Structure.DefaultSizeThresholds = {\n    /** Must be lower to be small */\n    smallResidueCount: 10,\n\n    /** Must be lower to be medium */\n    mediumResidueCount: 5000,\n\n    /** Must be lower to be large (big ribosomes like 4UG0 should still be `large`) */\n    largeResidueCount: 30000,\n\n    /**\r\n     * Structures above `largeResidueCount` are consider huge when they have\r\n     * a `highSymmetryUnitCount` or gigantic when not\r\n     */\n    highSymmetryUnitCount: 10,\n\n    /** Fiber-like structure are consider small when below this */\n    fiberResidueCount: 15\n  };\n\n  function getPolymerSymmetryGroups(structure) {\n    return structure.unitSymmetryGroups.filter(function (ug) {\n      return ug.units[0].polymerElements.length > 0;\n    });\n  }\n  /**\r\n   * Try to match fiber-like structures like 6nk4\r\n   */\n\n\n  function isFiberLike(structure, thresholds) {\n    var polymerSymmetryGroups = getPolymerSymmetryGroups(structure);\n    return polymerSymmetryGroups.length === 1 && polymerSymmetryGroups[0].units.length > 2 && polymerSymmetryGroups[0].units[0].polymerElements.length < thresholds.fiberResidueCount;\n  }\n\n  function hasHighSymmetry(structure, thresholds) {\n    var polymerSymmetryGroups = getPolymerSymmetryGroups(structure);\n    return polymerSymmetryGroups.length >= 1 && polymerSymmetryGroups[0].units.length > thresholds.highSymmetryUnitCount;\n  }\n\n  var Size;\n\n  (function (Size) {\n    Size[Size[\"Small\"] = 0] = \"Small\";\n    Size[Size[\"Medium\"] = 1] = \"Medium\";\n    Size[Size[\"Large\"] = 2] = \"Large\";\n    Size[Size[\"Huge\"] = 3] = \"Huge\";\n    Size[Size[\"Gigantic\"] = 4] = \"Gigantic\";\n  })(Size = Structure.Size || (Structure.Size = {}));\n  /**\r\n   * @param residueCountFactor - modifies the threshold counts, useful when estimating\r\n   *                             the size of a structure comprised of multiple models\r\n   */\n\n\n  function getSize(structure, thresholds, residueCountFactor) {\n    if (thresholds === void 0) {\n      thresholds = {};\n    }\n\n    if (residueCountFactor === void 0) {\n      residueCountFactor = 1;\n    }\n\n    var t = __assign(__assign({}, Structure.DefaultSizeThresholds), thresholds);\n\n    if (structure.polymerResidueCount >= t.largeResidueCount * residueCountFactor) {\n      if (hasHighSymmetry(structure, t)) {\n        return Size.Huge;\n      } else {\n        return Size.Gigantic;\n      }\n    } else if (isFiberLike(structure, t)) {\n      return Size.Small;\n    } else if (structure.polymerResidueCount < t.smallResidueCount * residueCountFactor) {\n      return Size.Small;\n    } else if (structure.polymerResidueCount < t.mediumResidueCount * residueCountFactor) {\n      return Size.Medium;\n    } else {\n      return Size.Large;\n    }\n  }\n\n  Structure.getSize = getSize;\n  Structure.Index = CustomStructureProperty.createSimple('index', 'root');\n  var PrincipalAxesProp = '__PrincipalAxes__';\n\n  function getPrincipalAxes(structure) {\n    if (structure.currentPropertyData[PrincipalAxesProp]) return structure.currentPropertyData[PrincipalAxesProp];\n    var principalAxes = StructureElement.Loci.getPrincipalAxes(Structure.toStructureElementLoci(structure));\n    structure.currentPropertyData[PrincipalAxesProp] = principalAxes;\n    return principalAxes;\n  }\n\n  Structure.getPrincipalAxes = getPrincipalAxes;\n})(Structure || (Structure = {}));\n\nexport { Structure };","map":{"version":3,"sources":["../../../../src/mol-model/structure/structure/structure.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;;AAEH,SAAS,MAAT,EAAiB,WAAjB,EAAwC,YAAxC,EAAsD,QAAtD,EAAgE,UAAhE,QAAkF,uBAAlF;AACA,SAAS,WAAT,QAA4B,2BAA5B;AACA,SAAS,gBAAT,QAAiC,8CAAjC;AACA,SAAS,KAAT,QAAoC,UAApC;AACA,SAAS,IAAT,EAAe,SAAf,EAA0B,KAA1B,EAAiC,SAAjC,EAA4C,UAA5C,EAAwD,UAAxD,QAA0E,wBAA1E;AACA,SAAS,gBAAT,QAAiC,WAAjC;AACA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,iBAAT,QAAkC,iBAAlC;AAEA,SAAS,sBAAT,QAAuC,uBAAvC;AACA,SAAyB,qBAAzB,EAAgD,IAAhD,QAA4D,cAA5D;AACA,SAAS,iBAAT,QAAkC,YAAlC;AACA,SAAS,mBAAT,QAAoC,cAApC;AAGA,SAAS,oBAAT,QAAqC,yBAArC;AACA,SAAS,IAAT,EAAe,IAAf,QAA2B,kCAA3B;AACA,SAAS,SAAT,QAA0B,8BAA1B;AACA,SAAS,YAAT,QAA6B,4BAA7B;AAEA,SAAS,gBAAT,QAAiC,uBAAjC;AACA,SAAS,eAAT,QAAgC,4BAAhC;AACA,SAAS,kBAAT,QAAmC,oBAAnC;AACA,SAAS,WAAT,QAAsC,qCAAtC;AAEA,SAAS,uBAAT,QAAwC,2DAAxC;AAEA,SAAyB,IAAzB,QAAqC,mBAArC;AACA,SAAS,wBAAT,QAAyC,iBAAzC;;AAsCA,IAAA,SAAA;AAAA;AAAA,YAAA;AA2UI;;;;AAIG;AACH,WAAA,SAAA,CAAqB,KAArB,EAA0D,OAA1D,EAA0F,YAA1F,EAAyI,KAAzI,EAAuJ,QAAvJ,EAAyM;AAApL,SAAA,KAAA,GAAA,KAAA;AAAqC,SAAA,OAAA,GAAA,OAAA;AAAgC,SAAA,YAAA,GAAA,YAAA;AAA+C,SAAA,KAAA,GAAA,KAAA,CAAgE,CACrM;;AACA,SAAK,MAAL,GAAc,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,KAAxB;AACA,SAAK,OAAL,GAAe,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAQ,KAAA,CAAR,GAAA,QAAQ,CAAE,MAAzB;AACA,SAAK,MAAL,GAAc,SAAd;AACH;;AApVD,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,QAAd,EAA+B;AAC3B,WAAO,IAAI,sBAAJ,CAA2B,IAA3B,EAAiC,QAAjC,CAAP;AACH,GAFD;;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,cAAJ,EAAgB;AADhB;SACA,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,YAAlB;AACH,KAFe;qBAAA;;AAAA,GAAhB;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;AADb;SACA,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,SAAX,KAAyB,CAAC,CAA9B,EAAiC;AAC7B,aAAK,KAAL,CAAW,SAAX,GAAuB,KAAK,cAAL,CAAoB,SAApB,GAAgC,IAAI,CAAC,qBAAL,CAA2B,IAA3B,CAAvD;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,SAAlB;AACH,KALY;qBAAA;;AAAA,GAAb;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;SAAvB,YAAA;AACI,aAAO,CAAC,CAAC,KAAK,KAAL,CAAW,WAAb,IAA4B,KAAK,KAAL,CAAW,WAAX,CAAuB,GAAvB,CAA2B,MAA3B,GAAoC,CAAvE;AACH,KAFsB;qBAAA;;AAAA,GAAvB;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,2BAAJ,EAA6B;SAA7B,YAAA;AACI,UAAI,CAAC,KAAK,KAAL,CAAW,WAAhB,EAA6B,KAAK,KAAL,CAAW,WAAX,GAAyB,IAAI,gBAAJ,EAAzB;AAC7B,aAAO,KAAK,KAAL,CAAW,WAAlB;AACH,KAH4B;qBAAA;;AAAA,GAA7B;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;AAHvB;;AAEG;SACH,YAAA;AACI,UAAI,CAAC,KAAK,KAAL,CAAW,YAAhB,EAA8B,KAAK,KAAL,CAAW,YAAX,GAA0B,MAAM,CAAC,MAAP,CAAc,IAAd,CAA1B;AAC9B,aAAO,KAAK,KAAL,CAAW,YAAlB;AACH,KAHsB;qBAAA;;AAAA,GAAvB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,uBAAJ,EAAyB;AAHzB;;AAEG;SACH,YAAA;AACI,aAAO,KAAK,MAAL,GAAc,KAAK,MAAL,CAAY,mBAA1B,GAAgD,KAAK,mBAA5D;AACH,KAFwB;qBAAA;;AAAA,GAAzB;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;AADvB;SACA,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,mBAAX,KAAmC,CAAC,CAAxC,EAA2C;AACvC,aAAK,KAAL,CAAW,mBAAX,GAAiC,sBAAsB,CAAC,IAAD,CAAvD;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,mBAAlB;AACH,KALsB;qBAAA;;AAAA,GAAvB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,iBAAJ,EAAmB;AADnB;SACA,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,eAAX,KAA+B,CAAC,CAApC,EAAuC;AACnC,aAAK,KAAL,CAAW,eAAX,GAA6B,kBAAkB,CAAC,IAAD,CAA/C;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,eAAlB;AACH,KALkB;qBAAA;;AAAA,GAAnB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,kBAAJ,EAAoB;SAApB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,gBAAX,KAAgC,CAAC,CAArC,EAAwC;AACpC,aAAK,KAAL,CAAW,gBAAX,GAA8B,mBAAmB,CAAC,IAAD,CAAjD;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,gBAAlB;AACH,KALmB;qBAAA;;AAAA,GAApB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,oBAAJ,EAAsB;SAAtB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,kBAAX,KAAkC,CAAC,CAAvC,EAA0C;AACtC,aAAK,KAAL,CAAW,kBAAX,GAAgC,qBAAqB,CAAC,IAAD,CAArD;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,kBAAlB;AACH,KALqB;qBAAA;;AAAA,GAAtB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,oBAAJ,EAAsB;SAAtB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,kBAAX,KAAkC,CAAC,CAAvC,EAA0C;AACtC,aAAK,KAAL,CAAW,kBAAX,GAAgC,qBAAqB,CAAC,IAAD,CAArD;AACH;;AACD,aAAO,KAAK,KAAL,CAAW,kBAAlB;AACH,KALqB;qBAAA;;AAAA,GAAtB;AAWA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,iBAAJ,EAAmB;AAJnB;;;AAGG;SACH,YAAA;AACI,aAAO,KAAK,MAAL,CAAY,IAAZ,CAAiB,UAAA,CAAA,EAAC;AAAI,eAAA,KAAK,CAAC,eAAN,CAAA,CAAA,CAAA;AAAwB,OAA9C,CAAP;AACH,KAFkB;qBAAA;;AAAA,GAAnB;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;SAAX,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA7B;AACH,KAFU;qBAAA;;AAAA,GAAX;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;SAAZ,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,QAAX,KAAwB,CAAC,CAA7B,EAAgC,OAAO,KAAK,KAAL,CAAW,QAAlB;AAChC,aAAO,KAAK,WAAL,EAAP;AACH,KAHW;qBAAA;;AAAA,GAAZ;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,eAAJ,EAAiB;AADjB;SACA,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,aAAX,KAA6B,CAAC,CAAlC,EAAqC,OAAO,KAAK,KAAL,CAAW,aAAlB;AACrC,WAAK,KAAL,CAAW,aAAX,GAA2B,UAAU,CAAC,KAAK,KAAL,CAAW,GAAX,CAAe,UAAA,CAAA,EAAC;AAAI,eAAA,CAAC,CAAD,EAAA;AAAI,OAAxB,CAAD,CAArC;AACA,aAAO,KAAK,KAAL,CAAW,aAAlB;AACH,KAJgB;qBAAA;;AAAA,GAAjB;;AAMQ,EAAA,SAAA,CAAA,SAAA,CAAA,WAAA,GAAR,YAAA;AACI,QAAI,IAAI,GAAG,EAAX;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,KAAL,CAAW,MAAhC,EAAwC,CAAC,GAAG,EAA5C,EAAgD,CAAC,EAAjD,EAAqD;AACjD,UAAM,CAAC,GAAG,KAAK,KAAL,CAAW,CAAX,CAAV;AACA,MAAA,IAAI,GAAI,KAAK,IAAL,GAAY,CAAC,CAAC,EAAf,GAAqB,CAA5B;AACA,MAAA,IAAI,GAAI,KAAK,IAAL,GAAY,WAAW,CAAC,QAAZ,CAAqB,CAAC,CAAC,QAAvB,CAAb,GAAiD,CAAxD;AACH;;AACD,IAAA,IAAI,GAAI,KAAK,IAAL,GAAY,KAAK,YAAlB,GAAkC,CAAzC;AACA,IAAA,IAAI,GAAG,KAAK,CAAC,IAAD,CAAZ;AACA,QAAI,IAAI,KAAK,CAAC,CAAd,EAAiB,IAAI,GAAG,CAAP;AACjB,SAAK,KAAL,CAAW,QAAX,GAAsB,IAAtB;AACA,WAAO,IAAP;AACH,GAZO;AAcR;;;AACA,EAAA,SAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,YAAA;AACI,WAAO,IAAI,SAAS,CAAC,uBAAd,CAAsC,IAAtC,CAAP;AACH,GAFD;;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;AADR;SACA,YAAA;;;AACI,aAAO,CAAA,EAAA,GAAA,KAAK,KAAL,CAAW,MAAX,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,IAA5B;AACH,KAFO;qBAAA;;AAAA,GAAR;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;AADV;SACA,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,MAAlB;AACH,KAFS;qBAAA;;AAAA,GAAV;AAWA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,kBAAJ,EAAoB;AAPpB;;;;;;AAMG;SACH,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,gBAAlB;AACH,KAFmB;qBAAA;;AAAA,GAApB;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;SAAT,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,KAAlB;AACH,KAFQ;qBAAA;;AAAA,GAAT;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;SAAZ,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,QAAf,EAAyB,OAAO,KAAK,KAAL,CAAW,QAAlB;AACzB,WAAK,KAAL,CAAW,QAAX,GAAsB,wBAAwB,CAAC,IAAD,CAA9C;AACA,aAAO,KAAK,KAAL,CAAW,QAAlB;AACH,KAJW;qBAAA;;AAAA,GAAZ;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;SAAZ,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,QAAf,EAAyB,OAAO,KAAK,KAAL,CAAW,QAAlB;AACzB,WAAK,KAAL,CAAW,QAAX,GAAsB,IAAI,iBAAJ,CAAsB,IAAtB,CAAtB;AACA,aAAO,KAAK,KAAL,CAAW,QAAlB;AACH,KAJW;qBAAA;;AAAA,GAAZ;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,gBAAJ,EAAkB;SAAlB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,cAAf,EAA+B,OAAO,KAAK,KAAL,CAAW,cAAlB;AAC/B,WAAK,KAAL,CAAW,cAAX,GAA4B,qBAAqB,CAAC,IAAD,EAAO;AAAE,QAAA,WAAW,EAAE,CAAC,KAAK;AAArB,OAAP,CAAjD;AACA,aAAO,KAAK,KAAL,CAAW,cAAlB;AACH,KAJiB;qBAAA;;AAAA,GAAlB;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,cAAJ,EAAgB;SAAhB,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,YAAlB;AACH,KAFe;qBAAA;;AAAA,GAAhB;AAIA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,oBAAJ,EAAsB;SAAtB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,kBAAf,EAAmC,OAAO,KAAK,KAAL,CAAW,kBAAlB;AACnC,WAAK,KAAL,CAAW,kBAAX,GAAgC,iBAAiB,CAAC,sBAAlB,CAAyC,IAAzC,CAAhC;AACA,aAAO,KAAK,KAAL,CAAW,kBAAlB;AACH,KAJqB;qBAAA;;AAAA,GAAtB;AAOA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,4BAAJ,EAA8B;AAD9B;SACA,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,0BAAf,EAA2C,OAAO,KAAK,KAAL,CAAW,0BAAlB;AAC3C,WAAK,KAAL,CAAW,0BAAX,GAAwC,IAAI,CAAC,aAAL,CAAmB,6BAAnB,CAAiD,KAAK,kBAAtD,CAAxC;AACA,aAAO,KAAK,KAAL,CAAW,0BAAlB;AACH,KAJ6B;qBAAA;;AAAA,GAA9B;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,eAAJ,EAAiB;SAAjB,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,aAAf,EAA8B,OAAO,KAAK,KAAL,CAAW,aAAlB;AAC9B,WAAK,KAAL,CAAW,aAAX,GAA2B,oBAAoB,CAAC,IAAD,CAA/C;AACA,aAAO,KAAK,KAAL,CAAW,aAAlB;AACH,KAJgB;qBAAA;;AAAA,GAAjB;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;SAAV,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,MAAf,EAAuB,OAAO,KAAK,KAAL,CAAW,MAAlB;AACvB,WAAK,KAAL,CAAW,MAAX,GAAoB,SAAS,CAAC,IAAD,CAA7B;AACA,aAAO,KAAK,KAAL,CAAW,MAAlB;AACH,KAJS;qBAAA;;AAAA,GAAV;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,oBAAJ,EAAsB;SAAtB,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,kBAAX,KACC,KAAK,KAAL,CAAW,kBAAX,GAAgC,qBAAqB,CAAC,IAAD,CADtD,CAAP;AAEH,KAHqB;qBAAA;;AAAA,GAAtB;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,sBAAJ,EAAwB;SAAxB,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,oBAAX,KACC,KAAK,KAAL,CAAW,oBAAX,GAAkC,uBAAuB,CAAC,IAAD,CAD1D,CAAP;AAEH,KAHuB;qBAAA;;AAAA,GAAxB;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,eAAJ,EAAiB;SAAjB,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,aAAX,KACC,KAAK,KAAL,CAAW,aAAX,GAA2B,gBAAgB,CAAC,IAAD,CAD5C,CAAP;AAEH,KAHgB;qBAAA;;AAAA,GAAjB;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,4BAAJ,EAA8B;SAA9B,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,0BAAX,KACC,KAAK,KAAL,CAAW,0BAAX,GAAwC,6BAA6B,CAAC,IAAD,CADtE,CAAP;AAEH,KAH6B;qBAAA;;AAAA,GAA9B;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;AADZ;SACA,YAAA;AACI,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,KAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA0B;AAArB,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AAAuB,YAAI,CAAC,IAAI,CAAC,QAAL,CAAc,CAAd,CAAL,EAAuB,OAAO,KAAP;AAAa;;AAChE,aAAO,IAAP;AACH,KAHW;qBAAA;;AAAA,GAAZ;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;AADb;SACA,YAAA;AACI,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,KAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA0B;AAArB,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AAAuB,YAAI,IAAI,CAAC,QAAL,CAAc,CAAd,CAAJ,EAAsB,OAAO,IAAP;AAAY;;AAC9D,aAAO,KAAP;AACH,KAHY;qBAAA;;AAAA,GAAb;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,UAAJ,EAAY;AADZ;SACA,YAAA;AACI,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,KAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA0B;AAArB,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AAAuB,YAAI,CAAC,IAAI,CAAC,QAAL,CAAc,CAAd,CAAL,EAAuB,OAAO,KAAP;AAAa;;AAChE,aAAO,IAAP;AACH,KAHW;qBAAA;;AAAA,GAAZ;AAMA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,WAAJ,EAAa;AADb;SACA,YAAA;AACI,WAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,KAArB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAA0B;AAArB,YAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AAAuB,YAAI,IAAI,CAAC,QAAL,CAAc,CAAd,CAAJ,EAAsB,OAAO,IAAP;AAAY;;AAC9D,aAAO,KAAP;AACH,KAHY;qBAAA;;AAAA,GAAb;AAYA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,eAAJ,EAAiB;AAPjB;;;;;;AAMG;SACH,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,aAAX,KAA6B,KAAK,KAAL,CAAW,aAAX,GAA2B,gBAAgB,CAAC,IAAD,CAAxE,CAAP;AACH,KAFgB;qBAAA;;AAAA,GAAjB;AAQA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;AAJT;;;AAGG;SACH,YAAA;AACI,UAAI,KAAK,KAAL,CAAW,KAAf,EAAsB,OAAO,KAAK,KAAL,CAAW,KAAlB;AACtB,UAAI,KAAK,KAAL,CAAW,mBAAf,EAAoC,OAAO,KAAK,KAAL,CAAW,mBAAlB;AACpC,UAAI,KAAK,KAAL,CAAW,WAAf,EAA4B,OAAO,KAAK,KAAL,CAAW,WAAlB;AAC5B,UAAM,MAAM,GAAG,KAAK,MAApB;;AACA,UAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACnB,cAAM,IAAI,KAAJ,CAAU,iGAAV,CAAN;AACH;;AACD,WAAK,KAAL,CAAW,KAAX,GAAmB,MAAM,CAAC,CAAD,CAAzB;AACA,aAAO,KAAK,KAAL,CAAW,KAAlB;AACH,KAVQ;qBAAA;;AAAA,GAAT;AAaA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,aAAJ,EAAe;AADf;SACA,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,WAAlB;AACH,KAFc;qBAAA;;AAAA,GAAf;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,qBAAJ,EAAuB;AADvB;SACA,YAAA;AACI,aAAO,KAAK,KAAL,CAAW,mBAAlB;AACH,KAFsB;qBAAA;;AAAA,GAAvB;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,CAAX,EAAuC;AACnC,QAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,CAAC,CAAC,IAAF,CAAO,EAAxB,CAAL,EAAkC,OAAO,KAAP;AAClC,WAAO,WAAW,CAAC,GAAZ,CAAgB,KAAK,OAAL,CAAa,GAAb,CAAiB,CAAC,CAAC,IAAF,CAAO,EAAxB,EAA4B,QAA5C,EAAsD,CAAC,CAAC,OAAxD,CAAP;AACH,GAHD;;AAKA,EAAA,SAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,CAAd,EAAsB;AAClB,WAAO,KAAK,MAAL,CAAY,OAAZ,CAAoB,CAApB,CAAP;AACH,GAFD;;AAIA,EAAA,SAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,CAAX,EAAmB;AACT,QAAA,EAAA,GAAmC,KAAK,KAAxC;AAAA,QAAE,YAAY,GAAA,EAAA,CAAA,YAAd;AAAA,QAAgB,cAAc,GAAA,EAAA,CAAA,cAA9B;AACN,QAAM,KAAK,GAAW,EAAtB;;AACA,SAAiB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,kBAAtB,EAAiB,EAAA,GAAA,EAAA,CAAA,MAAjB,EAAiB,EAAA,EAAjB,EAA0C;AAArC,UAAM,EAAE,GAAA,EAAA,CAAA,EAAA,CAAR;AACD,UAAM,IAAI,GAAG,EAAE,CAAC,KAAH,CAAS,CAAT,EAAY,UAAZ,CAAuB,CAAvB,EAA0B,YAA1B,CAAb;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,EAAE,CAAC,KAAH,CAAS,MAA9B,EAAsC,CAAC,GAAG,EAA1C,EAA8C,EAAE,CAAhD,EAAmD;AAC/C,YAAM,CAAC,GAAG,EAAE,CAAC,KAAH,CAAS,CAAT,CAAV;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,UAAF,CAAa,CAAb,EAAgB,YAAhB,EAA8B,IAAI,CAAC,KAAnC,CAAX;AACH;AACJ;;AACD,WAAO,SAAS,CAAC,MAAV,CAAiB,KAAjB,EAAwB;AAC3B,MAAA,KAAK,EAAE,KAAK,KADe;AAE3B,MAAA,cAAc,EAAE,YAAY,GAAG,SAAH,GAAe,cAFhB;AAG3B,MAAA,YAAY,EAAA;AAHe,KAAxB,CAAP;AAKH,GAhBD;AAsBA;;;AAGG;;;AACH,EAAA,SAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACI,QAAI,KAAK,MAAT,EAAiB,OAAO,KAAK,MAAZ;;AACjB,QAAI,KAAK,MAAT,EAAiB;AACb,UAAM,CAAC,GAAG,KAAK,MAAL,CAAY,gBAAZ,CAA6B,UAA7B,GAA0C,KAAK,MAA/C,GAAwD,SAAS,CAAC,SAAV,CAAoB,KAAK,MAAzB,EAAiC,KAAK,MAAL,CAAY,gBAAZ,CAA6B,OAA9D,CAAlE;AACA,UAAM,CAAC,GAAG,KAAK,gBAAL,CAAsB,UAAtB,GAAmC,CAAnC,GAAuC,SAAS,CAAC,SAAV,CAAoB,CAApB,EAAuB,KAAK,gBAAL,CAAsB,MAA7C,CAAjD;AACA,WAAK,MAAL,GAAc,IAAI,SAAJ,CAAc,CAAC,CAAC,KAAhB,EAAuB,CAAC,CAAC,OAAzB,EAAkC,CAAC,CAAC,YAApC,EAAgD,QAAA,CAAA,QAAA,CAAA,EAAA,EAAO,CAAC,CAAC,KAAT,CAAA,EAAc;AAAE,QAAA,YAAY,EAAE,KAAK;AAArB,OAAd,CAAhD,EAAmG;AAAE,QAAA,KAAK,EAAE,IAAT;AAAe,QAAA,MAAM,EAAE,KAAK;AAA5B,OAAnG,CAAd;AACH,KAJD,MAIO;AACH,WAAK,MAAL,GAAc,IAAd;AACH;;AACD,WAAO,KAAK,MAAZ;AACH,GAVD;;AAYA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;SAAT,YAAA;AACI,aAAO,KAAK,MAAZ;AACH,KAFQ;qBAAA;;AAAA,GAAT;AAKA,EAAA,MAAA,CAAA,cAAA,CAAI,SAAA,CAAA,SAAJ,EAAI,QAAJ,EAAU;AADV;SACA,YAAA;;;AACI,aAAO,CAAA,EAAA,GAAA,KAAK,OAAL,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,EAAZ,GAAgB,IAAvB;AACH,KAFS;qBAAA;;AAAA,GAAV;AAeJ,SAAA,SAAA;AAAC,CAtVD,EAAA;;AAwVA,SAAS,QAAT,CAAkB,KAAlB,EAA0C,CAA1C,EAAqD,CAArD,EAA8D;AAC1D,SAAO,KAAK,CAAC,CAAD,CAAL,CAAS,EAAT,GAAc,KAAK,CAAC,CAAD,CAAL,CAAS,EAA9B;AAEH;;AAED,SAAS,SAAT,CAAmB,CAAnB,EAA+B;AACnB,MAAA,KAAK,GAAK,CAAC,CAAN,KAAL;AACR,MAAM,GAAG,GAAG,WAAW,CAAC,MAAZ,EAAZ;;AACA,OAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,OAAA,GAAA,KAAhB,EAAgB,EAAA,GAAA,OAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAAuB;AAAlB,QAAM,CAAC,GAAA,OAAA,CAAA,EAAA,CAAP;AACD,IAAA,WAAW,CAAC,GAAZ,CAAgB,GAAhB,EAAqB,CAAC,CAAC,KAAF,CAAQ,EAA7B,EAAiC,CAAC,CAAC,KAAnC;AACH;;AACD,SAAO,GAAG,CAAC,KAAX;AACH;;AAED,SAAS,qBAAT,CAA+B,CAA/B,EAA2C;AAC/B,MAAA,yBAAyB,GAAK,mBAAmB,CAAC,OAApB,CAAL,yBAAzB;AACR,MAAM,KAAK,GAAG,IAAI,GAAJ,EAAd;AACA,MAAM,GAAG,GAAG,gBAAgB,CAAC,QAAjB,CAA0B,MAA1B,CAAiC,CAAjC,CAAZ;;AACA,OAAwB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,CAAC,CAAC,kBAA1B,EAAwB,EAAA,GAAA,EAAA,CAAA,MAAxB,EAAwB,EAAA,EAAxB,EAA8C;AAAzC,QAAM,SAAS,GAAA,EAAA,CAAA,EAAA,CAAf;AACD,QAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAb,CAD0C,CAE1C;;AACA,QAAI,CAAC,IAAI,CAAC,QAAL,CAAc,IAAd,CAAL,EAA0B;AAC1B,QAAM,QAAQ,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,mBAA1D,EAA+E,IAAI,CAAC,QAApF,CAAjB;AACA,IAAA,GAAG,CAAC,IAAJ,GAAW,IAAX;;AACA,WAAO,QAAQ,CAAC,OAAhB,EAAyB;AACrB,UAAM,GAAG,GAAG,QAAQ,CAAC,IAAT,EAAZ;AACA,MAAA,GAAG,CAAC,OAAJ,GAAc,IAAI,CAAC,QAAL,CAAc,GAAG,CAAC,KAAlB,CAAd;AACA,UAAM,OAAO,GAAG,yBAAyB,CAAC,GAAD,CAAzC;;AACA,WAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,SAAA,GAAA,OAArB,EAAqB,EAAA,GAAA,SAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAA4B;AAAvB,YAAM,MAAM,GAAA,SAAA,CAAA,EAAA,CAAZ;AAAyB,QAAA,KAAK,CAAC,GAAN,CAAU,MAAV;AAAkB;AACnD;AACJ;;AACD,SAAO,KAAP;AACH;;AAED,SAAS,uBAAT,CAAiC,CAAjC,EAA6C;AACzC,MAAM,IAAI,GAAG,mBAAmB,CAAC,IAApB,CAAyB,WAAtC;AACA,MAAM,OAAO,GAAG,IAAI,GAAJ,EAAhB;AACA,MAAM,GAAG,GAAG,gBAAgB,CAAC,QAAjB,CAA0B,MAA1B,CAAiC,CAAjC,CAAZ;;AACA,OAAwB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,CAAC,CAAC,kBAA1B,EAAwB,EAAA,GAAA,EAAA,CAAA,MAAxB,EAAwB,EAAA,EAAxB,EAA8C;AAAzC,QAAM,SAAS,GAAA,EAAA,CAAA,EAAA,CAAf;AACD,QAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAb;AACA,QAAI,CAAC,IAAI,CAAC,QAAL,CAAc,IAAd,CAAL,EAA0B;AAC1B,IAAA,GAAG,CAAC,IAAJ,GAAW,IAAX;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,IAAI,CAAC,QAAL,CAAc,MAAnC,EAA2C,CAAC,GAAG,EAA/C,EAAmD,EAAE,CAArD,EAAwD;AACpD,MAAA,GAAG,CAAC,OAAJ,GAAc,IAAI,CAAC,QAAL,CAAc,CAAd,CAAd;AACA,MAAA,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,GAAD,CAAhB;AACH;AACJ;;AACD,SAAO,OAAP;AACH;;AAED,SAAS,gBAAT,CAA0B,SAA1B,EAA8C;AAClC,MAAA,KAAK,GAAK,SAAS,CAAd,KAAL;AACR,MAAM,CAAC,GAAG,gBAAgB,CAAC,QAAjB,CAA0B,MAA1B,CAAiC,SAAjC,CAAV;AACA,MAAM,IAAI,GAAG,WAAW,CAAC,MAAZ,EAAb;;AAEA,OAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,OAAA,GAAA,KAAnB,EAAmB,EAAA,GAAA,OAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAA0B;AAArB,QAAM,IAAI,GAAA,OAAA,CAAA,EAAA,CAAV;AACD,QAAM,IAAI,GAAG,IAAI,CAAC,IAAL,KAAS;AAAA;AAAT,MAAiC,mBAAmB,CAAC,MAApB,CAA2B,GAA5D,GAAkE,mBAAmB,CAAC,MAApB,CAA2B,SAA1G;AAEA,IAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AACA,QAAM,QAAQ,GAAG,IAAI,CAAC,QAAtB;AAEA,QAAM,QAAQ,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,iBAA1D,EAA6E,QAA7E,CAAjB;;AACA,WAAO,QAAQ,CAAC,OAAhB,EAAyB;AACrB,UAAM,YAAY,GAAG,QAAQ,CAAC,IAAT,EAArB;AACA,MAAA,CAAC,CAAC,OAAF,GAAY,QAAQ,CAAC,YAAY,CAAC,KAAd,CAApB;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,CAAD,CAAhB;AACA,MAAA,WAAW,CAAC,GAAZ,CAAgB,IAAhB,EAAsB,GAAtB,EAA2B,GAA3B;AACH;AACJ;;AAED,EAAA,SAAS,CAAC,IAAI,CAAC,KAAN,CAAT;AACA,SAAO,IAAI,CAAC,KAAZ;AACH;;AAED,SAAS,6BAAT,CAAuC,SAAvC,EAA2D;AACvD,MAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;AACA,MAAM,QAAQ,GAAW,EAAzB;AAEA,MAAM,UAAU,GAAG,SAAS,CAAC,kBAA7B;;AACA,OAAwB,IAAA,EAAA,GAAA,CAAA,EAAA,YAAA,GAAA,UAAxB,EAAwB,EAAA,GAAA,YAAA,CAAA,MAAxB,EAAwB,EAAA,EAAxB,EAAoC;AAA/B,QAAM,SAAS,GAAA,YAAA,CAAA,EAAA,CAAf;AACD,QAAM,IAAI,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAb;AACA,QAAI,CAAC,IAAI,CAAC,QAAL,CAAc,IAAd,CAAL,EAA0B;AAE1B,QAAI,cAAc,GAAA,KAAA,CAAlB;AACA,QAAI,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,KAAL,CAAW,EAAnB,CAAJ,EAA4B,cAAc,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,KAAL,CAAW,EAAnB,CAAjB,CAA5B,KACK;AACD,MAAA,cAAc,GAAG,WAAW,CAAC,MAAZ,EAAjB;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,KAAL,CAAW,EAAzB;AACA,MAAA,GAAG,CAAC,GAAJ,CAAQ,IAAI,CAAC,KAAL,CAAW,EAAnB,EAAuB,cAAvB;AACH;AAED,QAAM,QAAQ,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,mBAA1D,EAA+E,IAAI,CAAC,QAApF,CAAjB;;AACA,WAAO,QAAQ,CAAC,OAAhB,EAAyB;AACrB,UAAM,GAAG,GAAG,QAAQ,CAAC,IAAT,EAAZ;AACA,MAAA,WAAW,CAAC,GAAZ,CAAgB,cAAhB,EAAgC,GAAG,CAAC,KAApC,EAA2C,GAAG,CAAC,KAA/C;AACH;AACJ;;AAED,MAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;;AACA,OAAiB,IAAA,EAAA,GAAA,CAAA,EAAA,UAAA,GAAA,QAAjB,EAAiB,EAAA,GAAA,UAAA,CAAA,MAAjB,EAAiB,EAAA,EAAjB,EAA2B;AAAtB,QAAM,EAAE,GAAA,UAAA,CAAA,EAAA,CAAR;AACD,QAAM,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,EAAR,EAAa,KAA3B;AACA,IAAA,SAAS,CAAC,KAAD,CAAT;AACA,IAAA,GAAG,CAAC,GAAJ,CAAQ,EAAR,EAAY,KAAZ;AACH;;AACD,SAAO,GAAP;AACH;;AAED,SAAS,qBAAT,CAA+B,SAA/B,EAAmD;AACvC,MAAA,kBAAkB,GAAK,SAAS,CAAd,kBAAlB;AACR,MAAI,kBAAkB,GAAG,CAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,kBAAkB,CAAC,MAAxC,EAAgD,CAAC,GAAG,EAApD,EAAwD,CAAC,EAAzD,EAA6D;AACzD,IAAA,kBAAkB,IAAI,kBAAkB,CAAC,CAAD,CAAlB,CAAsB,QAAtB,CAA+B,MAArD;AACH;;AACD,SAAO,kBAAP;AACH;;AAED,SAAS,sBAAT,CAAgC,SAAhC,EAAoD;AACxC,MAAA,KAAK,GAAK,SAAS,CAAd,KAAL;AACR,MAAI,mBAAmB,GAAG,CAA1B;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,IAAA,mBAAmB,IAAI,KAAK,CAAC,CAAD,CAAL,CAAS,eAAT,CAAyB,MAAhD;AACH;;AACD,SAAO,mBAAP;AACH;;AAED,SAAS,kBAAT,CAA4B,SAA5B,EAAgD;AACpC,MAAA,KAAK,GAAK,SAAS,CAAd,KAAL;AACR,MAAI,eAAe,GAAG,CAAtB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,IAAA,eAAe,IAAI,KAAK,CAAC,CAAD,CAAL,CAAS,WAAT,CAAqB,MAArB,GAA8B,CAAjD;AACH;;AACD,SAAO,eAAP;AACH;;AAED,SAAS,mBAAT,CAA6B,SAA7B,EAAiD;AACrC,MAAA,KAAK,GAAK,SAAS,CAAd,KAAL;AACR,MAAI,gBAAgB,GAAG,CAAvB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,QAAI,KAAK,CAAC,CAAD,CAAL,CAAS,eAAT,CAAyB,MAAzB,GAAkC,CAAtC,EAAyC,gBAAgB,IAAI,CAApB;AAC5C;;AACD,SAAO,gBAAP;AACH;;AAED,SAAS,qBAAT,CAA+B,SAA/B,EAAmD;AACvC,MAAA,KAAK,GAAK,SAAS,CAAd,KAAL;AACR,MAAI,kBAAkB,GAAG,CAAzB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,QAAM,IAAI,GAAG,KAAK,CAAC,CAAD,CAAlB;AACA,QAAI,CAAC,IAAI,CAAC,QAAL,CAAc,IAAd,CAAL,EAA0B;AAClB,QAAA,QAAQ,GAAmB,IAAI,CAAvB,QAAR;AAAA,QAAU,YAAY,GAAK,IAAI,CAAT,YAAtB;AACR,QAAI,GAAG,GAAG,CAAC,CAAX;AACA,QAAI,OAAO,GAAG,CAAC,CAAf;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,QAAQ,CAAC,MAA9B,EAAsC,CAAC,GAAG,EAA1C,EAA8C,EAAE,CAAhD,EAAmD;AAC/C,MAAA,GAAG,GAAG,YAAY,CAAC,QAAQ,CAAC,CAAD,CAAT,CAAlB;;AACA,UAAI,GAAG,KAAK,OAAZ,EAAqB;AACjB,QAAA,kBAAkB,IAAI,CAAtB;AACA,QAAA,OAAO,GAAG,GAAV;AACH;AACJ;AACJ;;AACD,SAAO,kBAAP;AACH;;AAYD,SAAS,gBAAT,CAA0B,SAA1B,EAA8C;AAClC,MAAA,KAAK,GAAiC,SAAS,CAA1C,KAAL;AAAA,MAAO,YAAY,GAAmB,SAAS,CAA5B,YAAnB;AAAA,MAAqB,YAAY,GAAK,SAAS,CAAd,YAAjC;AACR,MAAM,0BAA0B,GAAG,IAAI,WAAJ,CAAgB,KAAK,CAAC,MAAtB,CAAnC;AACA,MAAM,WAAW,GAAG,IAAI,WAAJ,CAAgB,YAAhB,CAApB;AACA,MAAM,cAAc,GAAG,IAAI,WAAJ,CAAgB,YAAhB,CAAvB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,CAAf,EAAkB,EAAE,GAAG,KAAK,CAAC,MAAlC,EAA0C,CAAC,GAAG,EAA9C,EAAkD,EAAE,CAApD,EAAuD;AACnD,IAAA,0BAA0B,CAAC,CAAD,CAA1B,GAAgC,CAAhC;AACQ,QAAA,QAAQ,GAAK,KAAK,CAAC,CAAD,CAAL,CAAL,QAAR;;AACR,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,QAAQ,CAAC,MAA9B,EAAsC,CAAC,GAAG,EAA1C,EAA8C,EAAE,CAAhD,EAAmD;AAC/C,UAAM,EAAE,GAAG,CAAC,GAAG,CAAf;AACA,MAAA,WAAW,CAAC,EAAD,CAAX,GAAkB,CAAlB;AACA,MAAA,cAAc,CAAC,EAAD,CAAd,GAAqB,QAAQ,CAAC,CAAD,CAA7B;AACH;;AACD,IAAA,CAAC,IAAI,QAAQ,CAAC,MAAd;AACH;;AACD,SAAO;AACH,IAAA,0BAA0B,EAAA,0BADvB;AAEH,IAAA,WAAW,EAAA,WAFR;AAGH,IAAA,cAAc,EAAA,cAHX;AAKH,IAAA,cAAc,EAAE,UAAC,IAAD,EAAO,OAAP,EAAc;AAAK,aAAA,0BAA0B,CAAC,YAAY,CAAC,GAAb,CAAiB,IAAI,CAAC,EAAtB,CAAD,CAA1B,GAAwD,UAAU,CAAC,OAAX,CAAmB,IAAI,CAAC,QAAxB,EAAxD,OAAwD,CAAxD;AAA2H;AAL3J,GAAP;AAOH;;AAED,CAAA,UAAU,SAAV,EAAmB;AACF,EAAA,SAAA,CAAA,KAAA,GAAQ,MAAM,CAAC,EAAD,CAAd;;AA0Bb,WAAgB,IAAhB,CAAqB,SAArB,EAAyC;AACrC,WAAO;AAAE,MAAA,IAAI,EAAE,gBAAR;AAA0B,MAAA,SAAS,EAAA;AAAnC,KAAP;AACH;;AAFe,EAAA,SAAA,CAAA,IAAA,GAAI,IAAJ;;AAIhB,WAAgB,sBAAhB,CAAuC,SAAvC,EAA2D;AACvD,QAAM,QAAQ,GAA2C,EAAzD;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAS,CAAC,KAA7B,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAoC;AAA/B,UAAM,IAAI,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,MAAA,QAAQ,CAAC,IAAT,CAAc;AAAE,QAAA,IAAI,EAAA,IAAN;AAAQ,QAAA,OAAO,EAAE,QAAQ,CAAC,QAAT,CAAkB,CAAlB,EAAqB,IAAI,CAAC,QAAL,CAAc,MAAnC;AAAjB,OAAd;AACH;;AACD,WAAO,gBAAgB,CAAC,IAAjB,CAAsB,SAAtB,EAAiC,QAAjC,CAAP;AACH;;AANe,EAAA,SAAA,CAAA,sBAAA,GAAsB,sBAAtB;;AAQhB,WAAgB,yBAAhB,CAA0C,MAA1C,EAA6D,SAA7D,EAAiF;AAC7E,WAAO,kBAAkB,CAAC,qBAAnB,CAAyC,kBAAkB,CAAC,UAAnB,CAA8B,MAA9B,EAAsC,SAAtC,CAAzC,CAAP;AACH;;AAFe,EAAA,SAAA,CAAA,yBAAA,GAAyB,yBAAzB;;AAIhB,WAAgB,MAAhB,CAAuB,CAAvB,EAA6B;AACzB,WAAO,CAAC,CAAC,CAAF,IAAO,CAAC,CAAC,IAAF,KAAW,gBAAzB;AACH;;AAFe,EAAA,SAAA,CAAA,MAAA,GAAM,MAAN;;AAIhB,WAAgB,YAAhB,CAA6B,CAA7B,EAAsC,CAAtC,EAA6C;AACzC,WAAO,CAAC,CAAC,SAAF,KAAgB,CAAC,CAAC,SAAzB;AACH;;AAFe,EAAA,SAAA,CAAA,YAAA,GAAY,YAAZ;;AAIhB,WAAgB,WAAhB,CAA4B,IAA5B,EAAsC;AAClC,WAAO,IAAI,CAAC,SAAL,CAAe,OAAtB;AACH;;AAFe,EAAA,SAAA,CAAA,WAAA,GAAW,WAAX;;AAIhB,WAAgB,SAAhB,CAA0B,IAA1B,EAAsC,SAAtC,EAA0D;AACtD,QAAI,SAAS,KAAK,IAAI,CAAC,SAAvB,EAAkC,OAAO,IAAP;AAClC,WAAO,IAAI,CAAC,SAAD,CAAX;AACH;;AAHe,EAAA,SAAA,CAAA,SAAA,GAAS,SAAT;;AAKhB,WAAgB,MAAhB,CAAuB,KAAvB,EAAmD,KAAnD,EAAoE;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,EAAA;AAAiB,KAAA,CAChE;;;AACA,QAAM,OAAO,GAAG,MAAM,CAAC,OAAP,EAAhB;AACA,QAAM,YAAY,GAAG,MAAM,CAAC,OAAP,EAArB;AACA,QAAI,YAAY,GAAG,CAAnB;AACA,QAAI,QAAQ,GAAG,IAAf;AACA,QAAI,MAAM,GAAG,KAAK,CAAC,MAAN,GAAe,CAAf,GAAmB,KAAK,CAAC,CAAD,CAAL,CAAS,EAA5B,GAAiC,CAA9C;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,UAAM,CAAC,GAAG,KAAK,CAAC,CAAD,CAAf;AACA,MAAA,OAAO,CAAC,GAAR,CAAY,CAAC,CAAC,EAAd,EAAkB,CAAlB;AACA,MAAA,YAAY,IAAI,CAAC,CAAC,QAAF,CAAW,MAA3B;AACA,UAAI,CAAC,CAAC,EAAF,GAAO,MAAX,EAAmB,QAAQ,GAAG,KAAX;AACnB,MAAA,MAAM,GAAG,CAAC,CAAC,EAAX;AACH;;AACD,QAAI,CAAC,QAAL,EAAe,IAAI,CAAC,KAAD,EAAQ,CAAR,EAAW,KAAK,CAAC,MAAjB,EAAyB,QAAzB,EAAmC,SAAnC,CAAJ;;AACf,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,MAAA,YAAY,CAAC,GAAb,CAAiB,KAAK,CAAC,CAAD,CAAL,CAAS,EAA1B,EAA8B,CAA9B;AACH,KAjB+D,CAmBhE;;;AACA,QAAM,KAAK,GAAU;AACjB,MAAA,QAAQ,EAAE,CAAC,CADM;AAEjB,MAAA,aAAa,EAAE,CAAC,CAFC;AAGjB,MAAA,YAAY,EAAA,YAHK;AAIjB,MAAA,SAAS,EAAE,CAAC,CAJK;AAKjB,MAAA,kBAAkB,EAAE,CAAC,CALJ;AAMjB,MAAA,kBAAkB,EAAE,CAAC,CANJ;AAOjB,MAAA,mBAAmB,EAAE,CAAC,CAPL;AAQjB,MAAA,eAAe,EAAE,CAAC,CARD;AASjB,MAAA,gBAAgB,EAAE,CAAC,CATF;AAUjB,MAAA,YAAY,EAAE,KAVG;AAWjB,MAAA,gBAAgB,EAAE,gBAAgB,CAAC,OAXlB;AAYjB,MAAA,KAAK,EAAE;AAZU,KAArB,CApBgE,CAmChE;;AACA,QAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,MAAN,GAAe,KAAK,CAAC,MAAN,CAAa,MAAb,IAAuB,KAAK,CAAC,MAA5C;AAClB,QAAI,KAAK,CAAC,cAAV,EAA0B,KAAK,CAAC,cAAN,GAAuB,KAAK,CAAC,cAA7B;AAE1B,QAAI,KAAK,CAAC,YAAV,EAAwB,KAAK,CAAC,YAAN,GAAqB,KAAK,CAAC,YAA3B,CAAxB,KACK,IAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,YAAN,GAAqB,KAAK,CAAC,MAAN,CAAa,YAAlC;AAEvB,QAAI,KAAK,CAAC,gBAAV,EAA4B,KAAK,CAAC,gBAAN,GAAyB,KAAK,CAAC,gBAA/B,CAA5B,KACK,IAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,gBAAN,GAAyB,KAAK,CAAC,MAAN,CAAa,gBAAtC;AAEvB,QAAI,KAAK,CAAC,KAAV,EAAiB,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,KAApB,CAAjB,KACK,IAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,KAAN,GAAc,KAAK,CAAC,MAAN,CAAa,KAA3B;AAEvB,QAAI,KAAK,CAAC,WAAV,EAAuB,KAAK,CAAC,WAAN,GAAoB,KAAK,CAAC,WAA1B,CAAvB,KACK,IAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,WAAN,GAAoB,KAAK,CAAC,MAAN,CAAa,WAAjC;AAEvB,QAAI,KAAK,CAAC,mBAAV,EAA+B,KAAK,CAAC,mBAAN,GAA4B,KAAK,CAAC,mBAAlC,CAA/B,KACK,IAAI,KAAK,CAAC,MAAV,EAAkB,KAAK,CAAC,mBAAN,GAA4B,KAAK,CAAC,MAAN,CAAa,mBAAzC;AAEvB,WAAO,IAAI,SAAJ,CAAc,KAAd,EAAqB,OAArB,EAA8B,YAA9B,EAA4C,KAA5C,CAAP;AACH;;AAvDe,EAAA,SAAA,CAAA,MAAA,GAAM,MAAN;;AAyDhB,WAAsB,YAAtB,CAAmC,UAAnC,EAA2D,GAA3D,EAA8E;;;;;;AAC1E,gBAAI,UAAU,CAAC,UAAX,KAA0B,CAA9B,EAAiC,OAAA,CAAA;AAAA;AAAA,cAAO,SAAA,CAAA,KAAP,CAAA;AAE3B,YAAA,KAAK,GAAW,EAAhB;AAEF,YAAA,KAAK,GAAsB,KAAK,CAAhC;AACA,YAAA,KAAK,GAAG,CAAR;AACK,YAAA,CAAC,GAAG,CAAJ,EAAO,EAAE,GAAG,UAAU,CAAC,UAAvB;;;;gBAAmC,EAAA,CAAC,GAAG,EAAJ,C,EAAM,OAAA,CAAA;AAAA;AAAA,cAAA,CAAA,CAAA;AAChC,mBAAA,CAAA;AAAA;AAAA,cAAM,IAAI,CAAC,gBAAL,CAAsB,UAAU,CAAC,eAAX,CAA2B,CAA3B,CAAtB,EAAqD,GAArD,CAAN,CAAA;;;AAAR,YAAA,KAAK,GAAG,EAAA,CAAA,IAAA,EAAR;AACN,gBAAI,CAAC,KAAL,EAAY,KAAK,GAAG,KAAR;AACN,YAAA,SAAS,GAAG,OAAO,CAAC,KAAD,CAAnB;;AACN,iBAAS,CAAC,GAAG,CAAJ,EAAO,EAAE,GAAG,SAAS,CAAC,KAAV,CAAgB,MAArC,EAA6C,CAAC,GAAG,EAAjD,EAAqD,EAAE,CAAvD,EAA0D;AAChD,cAAA,CAAC,GAAG,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAAJ;AACA,cAAA,WAAW,GAAG,CAAC,CAAC,WAAF,GAAgB,KAA9B;AACA,cAAA,YAAY,GAAG,CAAC,CAAC,YAAF,GAAiB,KAAhC;AACA,cAAA,OAAO,GAAG,IAAI,CAAC,MAAL,CAAY,KAAK,CAAC,MAAlB,EAA0B,WAA1B,EAAuC,YAAvC,EAAqD,CAAC,CAAC,MAAvD,EAA+D,CAAC,CAAC,IAAjE,EAAuE,CAAC,CAAC,KAAzE,EAAgF,CAAC,CAAC,YAAF,CAAe,QAA/F,EAAyG,CAAC,CAAC,QAA3G,CAAV;AACN,cAAA,KAAK,CAAC,IAAN,CAAW,OAAX;AACH;;AACD,YAAA,KAAK,GAAG,KAAK,CAAC,MAAd;;;;AAXgD,cAAE,CAAF;;;;;;AAcpD,mBAAA,CAAA;AAAA;AAAA,cAAO,MAAM,CAAC,KAAD,EAAQ;AAAE,cAAA,mBAAmB,EAAE,KAAvB;AAA+B,cAAA,KAAK,EAAE,KAAM,CAAC;AAA7C,aAAR,CAAb,CAAA;;;;AACH;;AAtBqB,EAAA,SAAA,CAAA,YAAA,GAAY,YAAZ;AAwBtB,MAAM,SAAS,GAAG,KAAlB;AAEA;;;;;AAKG;;AACH,WAAgB,OAAhB,CAAwB,KAAxB,EAAsC,KAAtC,EAAuD;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,EAAA;AAAiB;;AACnD,QAAM,MAAM,GAAG,KAAK,CAAC,eAAN,CAAsB,iBAArC;AACQ,QAAA,KAAK,GAAK,KAAK,CAAC,eAAN,CAAL,KAAL;AACA,QAAA,YAAY,GAAK,KAAK,CAAC,eAAN,CAAsB,MAAtB,CAAL,YAAZ;AACA,QAAA,2BAA2B,GAAK,KAAK,CAAV,2BAA3B;AACR,QAAM,OAAO,GAAG,IAAI,gBAAJ,CAAoB,QAAA,CAAA;AAAG,MAAA,KAAK,EAAE,KAAK,CAAC;AAAhB,KAAA,EAA0B,KAA1B,CAApB,CAAhB;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAb,EAA8B,CAAC,GAAG,MAAM,CAAC,KAAzC,EAAgD,CAAC,EAAjD,EAAqD;AACjD,UAAM,QAAQ,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,CAAhC,KAAsC,gBAAgB,CAAC,OAAxE;AACA,UAAM,KAAK,GAAG,MAAM,CAAC,OAAP,CAAe,CAAf,CAAd,CAFiD,CAIjD;AACA;;AACA,UAAI,kBAAkB,GAAG,eAAe,CAAC,iBAAhB,CAAkC,KAAK,CAAC,eAAxC,EAAyD,CAAzD,MAAgE,MAAM,CAAC,OAAP,CAAe,CAAC,GAAG,CAAnB,IAAwB,MAAM,CAAC,OAAP,CAAe,CAAf,CAAjH;AAEA,UAAI,UAAU,GAAG,KAAjB;;AAEA,UAAI,YAAY,CAAC,KAAD,EAAQ,CAAR,CAAhB,EAA4B;AACxB;AACA,eAAO,CAAC,GAAG,CAAJ,GAAQ,MAAM,CAAC,KAAf,IAAwB,YAAY,CAAC,KAAD,EAAQ,CAAC,GAAG,CAAZ,CAA3C,EAAyE;AACrE,cAAM,GAAG,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,CAAhC,CAAZ;AACA,cAAM,GAAG,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,CAAC,GAAG,CAApC,CAAZ;AACA,cAAI,GAAG,KAAK,GAAZ,EAAiB;AAEjB,UAAA,UAAU,GAAG,IAAb;AACA,UAAA,CAAC;AACJ;AACJ,OAVD,MAUO;AACH;AACA,eAAO,CAAC,GAAG,CAAJ,GAAQ,MAAM,CAAC,KAAf,IACA,MAAM,CAAC,OAAP,CAAe,CAAC,GAAG,CAAnB,IAAwB,MAAM,CAAC,OAAP,CAAe,CAAf,CAAxB,KAA8C,CAD9C,IAEA,MAAM,CAAC,OAAP,CAAe,CAAC,GAAG,CAAnB,IAAwB,MAAM,CAAC,OAAP,CAAe,CAAC,GAAG,CAAnB,CAAxB,KAAkD,CAFzD,EAGE;AACE,UAAA,kBAAkB,GAAG,IAArB;AACA,cAAM,EAAE,GAAG,KAAK,CAAC,kBAAN,CAAyB,CAAzB,CAAX;AACA,cAAM,EAAE,GAAG,KAAK,CAAC,kBAAN,CAAyB,CAAC,GAAG,CAA7B,CAAX;AACA,cAAI,EAAE,KAAK,EAAX,EAAe;AAEf,cAAM,EAAE,GAAG,YAAY,CAAC,KAAb,CAAmB,CAAnB,CAAX;AACA,cAAM,EAAE,GAAG,YAAY,CAAC,KAAb,CAAmB,CAAC,GAAG,CAAvB,CAAX;AACA,cAAI,EAAE,KAAK,EAAX,EAAe;AAEf,cAAM,GAAG,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,CAAhC,CAAZ;AACA,cAAM,GAAG,GAAG,2BAA2B,CAAC,GAA5B,CAAgC,CAAC,GAAG,CAApC,CAAZ;AACA,cAAI,GAAG,KAAK,GAAZ,EAAiB;AAEjB,UAAA,UAAU,GAAG,IAAb;AACA,UAAA,CAAC;AACJ;AACJ;;AAED,UAAM,QAAQ,GAAG,WAAW,CAAC,QAAZ,CAAqB,KAArB,EAA4C,MAAM,CAAC,OAAP,CAAe,CAAC,GAAG,CAAnB,CAA5C,CAAjB;;AAEA,UAAI,SAAJ,EAAe;AACX;AACA,YAAI,kBAAkB,IAAI,CAAC,cAAc,CAAC,KAAD,EAAQ,CAAR,CAAzC,EAAqD;AACjD,UAAA,yBAAyB,CAAC,KAAD,EAAQ,QAAR,EAAkB,OAAlB,EAA2B,UAA3B,EAAuC,QAAvC,CAAzB;AACH,SAFD,MAEO,IAAI,QAAQ,CAAC,MAAT,GAAkB,MAAlB,IAA4B,YAAY,CAAC,KAAD,EAAQ,CAAR,CAA5C,EAAwD;AAC3D;AACA,UAAA,4BAA4B,CAAC,KAAD,EAAQ,QAAR,EAAkB,OAAlB,EAA2B,UAA3B,EAAuC,QAAvC,CAA5B;AACH,SAHM,MAGA;AACH,UAAA,OAAO,CAAC,OAAR,CAAe;AAAA;AAAf,YAAkC,KAAlC,EAAyC,QAAzC,EAAmD,QAAnD,EAA6D,UAAU,GAAE;AAAA;AAAF,YAA0B;AAAA;AAAjG;AACH;AACJ,OAVD,MAUO;AACH,QAAA,OAAO,CAAC,OAAR,CAAe;AAAA;AAAf,UAAkC,KAAlC,EAAyC,QAAzC,EAAmD,QAAnD,EAA6D,UAAU,GAAE;AAAA;AAAF,UAA0B;AAAA;AAAjG;AACH;AACJ;;AAED,QAAM,EAAE,GAAG,KAAK,CAAC,eAAjB;;AACA,QAAI,EAAE,CAAC,SAAP,EAAkB;AACd,UAAI,EAAE,CAAC,OAAH,CAAW,KAAX,GAAmB,CAAvB,EAA0B;AACtB,QAAA,cAAc,CAAC,OAAD,EAAU,KAAV,EAAiB,KAAK,CAAC,eAAN,CAAsB,OAAvC,EAA8C;AAAA;AAA9C,SAAd;AACH;;AACD,UAAI,EAAE,CAAC,SAAH,CAAa,KAAb,GAAqB,CAAzB,EAA4B;AACxB,QAAA,cAAc,CAAC,OAAD,EAAU,KAAV,EAAiB,KAAK,CAAC,eAAN,CAAsB,SAAvC,EAAgD;AAAA;AAAhD,SAAd;AACH;AACJ;;AAED,WAAO,OAAO,CAAC,YAAR,EAAP;AACH;;AA/Ee,EAAA,SAAA,CAAA,OAAA,GAAO,OAAP;;AAiFhB,WAAS,YAAT,CAAsB,KAAtB,EAAoC,UAApC,EAA0D;AACtD,QAAM,CAAC,GAAG,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAA4B,kBAA5B,CAA+C,UAA/C,CAAV;AACA,WAAO,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,IAApB,CAAyB,KAAzB,CAA+B,CAA/B,MAAsC,OAA7C;AACH;;AAED,WAAS,cAAT,CAAwB,KAAxB,EAAsC,UAAtC,EAA4D;AACxD,QAAM,CAAC,GAAG,KAAK,CAAC,eAAN,CAAsB,KAAtB,CAA4B,kBAA5B,CAA+C,UAA/C,CAAV;AACA,WAAO,KAAK,CAAC,QAAN,CAAe,IAAf,CAAoB,IAApB,CAAyB,KAAzB,CAA+B,CAA/B,MAAsC,SAA7C;AACH;;AAED,WAAS,yBAAT,CAAmC,KAAnC,EAAiD,OAAjD,EAAuE,OAAvE,EAAkG,UAAlG,EAAuH,QAAvH,EAAiJ;AACvI,QAAA,EAAA,GAAc,KAAK,CAAC,kBAApB;AAAA,QAAE,CAAC,GAAA,EAAA,CAAA,CAAH;AAAA,QAAK,CAAC,GAAA,EAAA,CAAA,CAAN;AAAA,QAAQ,CAAC,GAAA,EAAA,CAAA,CAAT;AACN,QAAM,QAAQ,GAAG;AAAE,MAAA,CAAC,EAAA,CAAH;AAAK,MAAA,CAAC,EAAA,CAAN;AAAQ,MAAA,CAAC,EAAA,CAAT;AAAW,MAAA,OAAO,EAAA;AAAlB,KAAjB;AACA,QAAM,MAAM,GAAG,YAAY,CAAC,QAAD,EAAW,WAAW,CAAC,QAAD,CAAtB,EAAkC,IAAlC,CAA3B;AACM,QAAA,EAAA,GAA2B,MAAM,CAAC,OAAlC;AAAA,QAAE,MAAM,GAAA,EAAA,CAAA,MAAR;AAAA,QAAU,KAAK,GAAA,EAAA,CAAA,KAAf;AAAA,QAAiB,KAAK,GAAA,EAAA,CAAA,KAAtB;AAEN,QAAM,MAAM,GAAG,CAAC,UAAU,GAAE;AAAA;AAAF,MAA0B;AAAA;AAArC,SAA0D,MAAM,CAAC,MAAP,GAAgB,CAAhB,GAAmB;AAAA;AAAnB,MAA4C;AAAA;AAAtG,KAAf;AAEA,IAAA,OAAO,CAAC,eAAR;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAA5B,EAAoC,CAAC,GAAG,EAAxC,EAA4C,CAAC,EAA7C,EAAiD;AAC7C,UAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB;AACA,UAAM,GAAG,GAAG,IAAI,UAAJ,CAAe,KAAK,CAAC,CAAD,CAApB,CAAZ;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,CAAD,CAA1B,EAA+B,CAAC,GAAG,EAAnC,EAAuC,CAAC,EAAxC,EAA4C;AACxC,QAAA,GAAG,CAAC,CAAD,CAAH,GAAS,OAAO,CAAC,KAAK,CAAC,KAAK,GAAG,CAAT,CAAN,CAAhB;AACH;;AACD,MAAA,OAAO,CAAC,OAAR,CAAe;AAAA;AAAf,QAAkC,KAAlC,EAAyC,QAAzC,EAAmD,WAAW,CAAC,aAAZ,CAA0B,GAA1B,CAAnD,EAAmF,MAAnF;AACH;;AACD,IAAA,OAAO,CAAC,aAAR;AACH,GAlQc,CAoQf;;;AACA,WAAS,4BAAT,CAAsC,KAAtC,EAAoD,OAApD,EAA0E,OAA1E,EAAqG,UAArG,EAA0H,QAA1H,EAAoJ;AACxI,QAAA,mBAAmB,GAAK,KAAK,CAAC,eAAN,CAAL,mBAAnB;AAER,QAAM,YAAY,GAAa,EAA/B;AACA,QAAM,UAAU,GAAa,EAA7B;AAEA,QAAM,SAAS,GAAG,YAAY,CAAC,iBAAb,CAA+B,mBAA/B,EAAoD,OAApD,CAAlB;;AACA,WAAO,SAAS,CAAC,OAAjB,EAA0B;AACtB,UAAM,cAAc,GAAG,SAAS,CAAC,IAAV,EAAvB;AACA,MAAA,YAAY,CAAC,YAAY,CAAC,MAAd,CAAZ,GAAoC,OAAO,CAAC,cAAc,CAAC,KAAhB,CAA3C;AACA,MAAA,UAAU,CAAC,UAAU,CAAC,MAAZ,CAAV,GAAgC,OAAO,CAAC,cAAc,CAAC,GAAhB,CAAvC;AACH;;AAED,QAAM,qBAAqB,GAAG,UAAU,CAAC,CAAD,CAAV,GAAgB,YAAY,CAAC,CAAD,CAA1D;AACA,QAAM,aAAa,GAAG,MAAM,qBAA5B;AAEM,QAAA,EAAA,GAAc,KAAK,CAAC,kBAApB;AAAA,QAAE,CAAC,GAAA,EAAA,CAAA,CAAH;AAAA,QAAK,CAAC,GAAA,EAAA,CAAA,CAAN;AAAA,QAAQ,CAAC,GAAA,EAAA,CAAA,CAAT;AACN,QAAM,QAAQ,GAAG;AAAE,MAAA,CAAC,EAAA,CAAH;AAAK,MAAA,CAAC,EAAA,CAAN;AAAQ,MAAA,CAAC,EAAA,CAAT;AAAW,MAAA,OAAO,EAAE,WAAW,CAAC,aAAZ,CAA0B,YAA1B;AAApB,KAAjB;AACA,QAAM,MAAM,GAAG,YAAY,CAAC,QAAD,EAAW,WAAW,CAAC,QAAD,CAAtB,EAAkC,aAAlC,CAA3B;AACM,QAAA,EAAA,GAA2B,MAAM,CAAC,OAAlC;AAAA,QAAE,MAAM,GAAA,EAAA,CAAA,MAAR;AAAA,QAAU,KAAK,GAAA,EAAA,CAAA,KAAf;AAAA,QAAiB,KAAK,GAAA,EAAA,CAAA,KAAtB;AAEN,QAAM,MAAM,GAAG,CAAC,UAAU,GAAE;AAAA;AAAF,MAA0B;AAAA;AAArC,SAA0D,MAAM,CAAC,MAAP,GAAgB,CAAhB,GAAmB;AAAA;AAAnB,MAA4C;AAAA;AAAtG,KAAf;AAEA,IAAA,OAAO,CAAC,eAAR;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,MAA5B,EAAoC,CAAC,GAAG,EAAxC,EAA4C,CAAC,EAA7C,EAAiD;AAC7C,UAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB;AACA,UAAM,GAAG,GAAa,EAAtB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,CAAD,CAA1B,EAA+B,CAAC,GAAG,EAAnC,EAAuC,CAAC,EAAxC,EAA4C;AACxC,YAAM,CAAC,GAAG,KAAK,CAAC,KAAK,GAAG,CAAT,CAAf;;AACA,aAAK,IAAI,CAAC,GAAG,YAAY,CAAC,CAAD,CAApB,EAAyB,EAAE,GAAG,UAAU,CAAC,CAAD,CAA7C,EAAkD,CAAC,GAAG,EAAtD,EAA0D,CAAC,EAA3D,EAA+D;AAC3D,UAAA,GAAG,CAAC,GAAG,CAAC,MAAL,CAAH,GAAkB,CAAlB;AACH;AACJ;;AACD,MAAA,OAAO,CAAC,OAAR,CAAe;AAAA;AAAf,QAAkC,KAAlC,EAAyC,QAAzC,EAAmD,WAAW,CAAC,aAAZ,CAA0B,IAAI,UAAJ,CAAe,GAAf,CAA1B,CAAnD,EAAmG,MAAnG;AACH;;AACD,IAAA,OAAO,CAAC,aAAR;AACH;;AAED,WAAS,cAAT,CAAwB,OAAxB,EAAmD,KAAnD,EAAiE,QAAjE,EAA2F,IAA3F,EAA0G;AAC9F,QAAA,oBAAoB,GAAK,QAAQ,CAAb,oBAApB;;AACR,SAAK,IAAI,EAAE,GAAG,CAAd,EAAiB,EAAE,GAAG,oBAAoB,CAAC,KAA3C,EAAkD,EAAE,EAApD,EAAwD;AACpD,UAAM,UAAQ,GAAG,WAAW,CAAC,QAAZ,CAAmC,oBAAoB,CAAC,OAArB,CAA6B,EAA7B,CAAnC,EAAqE,oBAAoB,CAAC,OAArB,CAA6B,EAAE,GAAG,CAAlC,CAArE,CAAjB;AACA,MAAA,OAAO,CAAC,OAAR,CAAgB,IAAhB,EAAsB,KAAtB,EAA6B,gBAAgB,CAAC,OAA9C,EAAuD,UAAvD,EAA+D;AAAA;AAA/D;AACH;AACJ;;AAED,WAAgB,SAAhB,CAA0B,CAA1B,EAAwC,SAAxC,EAAuD;AACnD,QAAI,IAAI,CAAC,UAAL,CAAgB,SAAhB,CAAJ,EAAgC,OAAO,CAAP;AAChC,QAAI,CAAC,IAAI,CAAC,wBAAL,CAA8B,SAA9B,EAAyC,gBAAgB,CAAC,0BAA1D,CAAL,EAA4F,MAAM,IAAI,KAAJ,CAAU,uDAAV,CAAN;AAE5F,QAAM,KAAK,GAAW,EAAtB;;AACA,SAAgB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,CAAC,CAAC,KAAlB,EAAgB,EAAA,GAAA,EAAA,CAAA,MAAhB,EAAgB,EAAA,EAAhB,EAAyB;AAApB,UAAM,CAAC,GAAA,EAAA,CAAA,EAAA,CAAP;AACD,UAAM,GAAG,GAAG,CAAC,CAAC,YAAF,CAAe,QAA3B;AACA,UAAM,EAAE,GAAG,gBAAgB,CAAC,MAAjB,CAAwB,GAAG,CAAC,IAA5B,EAAkC,SAAlC,EAA6C,GAA7C,CAAX;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,aAAF,CAAgB,CAAC,CAAC,EAAlB,EAAsB,EAAtB,CAAX;AACH;;AAED,QAAM,EAAE,GAAG,CAAC,CAAC,gBAAb;AACA,QAAM,KAAK,GAAG,gBAAgB,CAAC,OAAjB,CAAyB,gBAAgB,CAAC,MAAjB,CAAwB,EAAE,CAAC,IAA3B,EAAiC,SAAjC,EAA4C,EAA5C,CAAzB,EAA0E,EAA1E,CAAd;AACA,WAAO,MAAM,CAAC,KAAD,EAAQ;AAAE,MAAA,MAAM,EAAE,CAAV;AAAa,MAAA,gBAAgB,EAAE;AAA/B,KAAR,CAAb;AACH;;AAde,EAAA,SAAA,CAAA,SAAA,GAAS,SAAT;;AAgBhB,MAAA,gBAAA;AAAA;AAAA,cAAA;AAuDI,aAAA,gBAAA,CAAoB,KAApB,EAAqC;AAAjB,UAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,KAAA,GAAA,EAAA;AAAiB;;AAAjB,WAAA,KAAA,GAAA,KAAA;AAtDZ,WAAA,KAAA,GAAgB,EAAhB;AACA,WAAA,WAAA,GAAc,SAAS,EAAvB;AAEA,WAAA,YAAA,GAAe,CAAC,CAAhB;AACA,WAAA,YAAA,GAAe,KAAf;AAEA,WAAA,CAAA,GAAI,IAAI,EAAR;AACA,WAAA,kBAAA,GAAqB,IAAI,GAAJ,EAArB;AAiDP;;AA/CD,IAAA,gBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACI,WAAK,YAAL;AACA,WAAK,YAAL,GAAoB,IAApB;AACH,KAHD;;AAKA,IAAA,gBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACI,WAAK,YAAL,GAAoB,KAApB;AACH,KAFD;;AAIA,IAAA,gBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAAyB,KAAzB,EAAuC,QAAvC,EAAmE,QAAnE,EAAmG,MAAnG,EAAwH,WAAxH,EAA4I;AACxI,UAAI,WAAW,KAAK,SAApB,EAA+B,WAAW,GAAG,KAAK,WAAL,EAAd;AAC/B,UAAM,YAAY,GAAG,KAAK,YAAL,GAAoB,KAAK,YAAzB,GAAwC,EAAE,KAAK,YAApE;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,MAAL,CAAY,KAAK,KAAL,CAAW,MAAvB,EAA+B,WAA/B,EAA4C,YAA5C,EAA0D,MAA1D,EAAkE,IAAlE,EAAwE,KAAxE,EAA+E,QAA/E,EAAyF,QAAzF,CAAb;AACA,aAAO,KAAK,GAAL,CAAS,IAAT,CAAP;AACH,KALD;;AAOQ,IAAA,gBAAA,CAAA,SAAA,CAAA,GAAA,GAAR,UAAY,IAAZ,EAAsB;AAClB;AACA;AACA;AACA,UAAI,IAAI,CAAC,QAAL,CAAc,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,QAAA,IAAI,CAAC,YAAL,CAAkB,QAAlB,CAA2B,IAAI,CAAC,QAAL,CAAc,CAAd,CAA3B,EAA6C,KAAK,CAAlD;AACA,YAAM,IAAI,GAAG,CAAC,IAAI,CAAC,WAAN,EAAmB,KAAK,CAAL,CAAO,CAAP,CAAnB,EAA8B,KAAK,CAAL,CAAO,CAAP,CAA9B,EAAyC,KAAK,CAAL,CAAO,CAAP,CAAzC,EAAoD,IAApD,CAAyD,GAAzD,CAAb;;AACA,YAAI,KAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAA5B,CAAJ,EAAuC;AACnC,iBAAO,KAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAA5B,CAAP;AACH,SAFD,MAEO;AACH,eAAK,kBAAL,CAAwB,GAAxB,CAA4B,IAA5B,EAAkC,IAAlC;AACH;AACJ;;AACD,WAAK,KAAL,CAAW,IAAX,CAAgB,IAAhB;AACA,aAAO,IAAP;AACH,KAfO;;AAiBR,IAAA,gBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,IAAhB,EAA4B,QAA5B,EAAwD,WAAxD,EAA2E;AAAnB,UAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,WAAA,GAAA,KAAA;AAAmB;;AACvE,aAAO,KAAK,GAAL,CAAS,IAAI,CAAC,aAAL,CAAmB,KAAK,KAAL,CAAW,MAA9B,EAAsC,QAAtC,EAAgD,WAAhD,CAAT,CAAP;AACH,KAFD;;AAIA,IAAA,gBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACI,aAAO,MAAM,CAAC,KAAK,KAAN,EAAa,KAAK,KAAlB,CAAb;AACH,KAFD;;AAIA,IAAA,MAAA,CAAA,cAAA,CAAI,gBAAA,CAAA,SAAJ,EAAI,SAAJ,EAAW;WAAX,YAAA;AACI,eAAO,KAAK,KAAL,CAAW,MAAX,KAAsB,CAA7B;AACH,OAFU;uBAAA;;AAAA,KAAX;AAOJ,WAAA,gBAAA;AAAC,GA1DD,EAAA;;AAAa,EAAA,SAAA,CAAA,gBAAA,GAAgB,gBAAhB;;AA4Db,WAAgB,OAAhB,CAAwB,KAAxB,EAAyC;AAAjB,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,EAAA;AAAiB;;AACrC,WAAO,IAAI,gBAAJ,CAAqB,KAArB,CAAP;AACH;;AAFe,EAAA,SAAA,CAAA,OAAA,GAAO,OAAP;;AAIhB,WAAgB,QAAhB,CAAyB,CAAzB,EAAqC;AACjC,WAAO,CAAC,CAAC,QAAT;AACH;;AAFe,EAAA,SAAA,CAAA,QAAA,GAAQ,QAAR;AAIhB;;AACA,WAAgB,gBAAhB,CAAiC,CAAjC,EAA6C;AACzC,WAAO,UAAU,CAAC,CAAC,CAAC,KAAF,CAAQ,GAAR,CAAY,UAAA,CAAA,EAAC;AAAI,aAAA,IAAI,CAAC,cAAL,CAAA,CAAA,CAAA;AAAsB,KAAvC,EAAyC,IAAzC,CAA8C,GAA9C,CAAD,CAAjB;AACH;;AAFe,EAAA,SAAA,CAAA,gBAAA,GAAgB,gBAAhB,CAxYD,CA4Yf;;AACA,WAAgB,eAAhB,CAAgC,CAAhC,EAA8C,CAA9C,EAA0D;AACtD,QAAI,CAAC,KAAK,CAAV,EAAa,OAAO,IAAP;AAEb,QAAI,CAAC,CAAC,YAAF,KAAmB,CAAC,CAAC,YAAzB,EAAuC,OAAO,KAAP;AACvC,QAAM,GAAG,GAAG,CAAC,CAAC,KAAF,CAAQ,MAApB;AACA,QAAI,GAAG,KAAK,CAAC,CAAC,KAAF,CAAQ,MAApB,EAA4B,OAAO,KAAP;;AAE5B,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC1B,UAAI,CAAC,CAAC,KAAF,CAAQ,CAAR,EAAW,EAAX,KAAkB,CAAC,CAAC,KAAF,CAAQ,CAAR,EAAW,EAAjC,EAAqC,OAAO,KAAP;AACxC;;AAED,WAAO,IAAP;AACH;;AAZe,EAAA,SAAA,CAAA,eAAA,GAAe,eAAf;;AAchB,WAAgB,yBAAhB,CAA0C,CAA1C,EAAwD,CAAxD,EAAoE;AAChE,QAAI,CAAC,eAAe,CAAC,CAAD,EAAI,CAAJ,CAApB,EAA4B,OAAO,KAAP;;AAE5B,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,CAAC,CAAC,KAAF,CAAQ,MAA7B,EAAqC,CAAC,GAAG,EAAzC,EAA6C,CAAC,EAA9C,EAAkD;AAC9C,UAAI,CAAC,WAAW,CAAC,QAAZ,CAAqB,CAAC,CAAC,KAAF,CAAQ,CAAR,EAAW,QAAhC,EAA0C,CAAC,CAAC,KAAF,CAAQ,CAAR,EAAW,QAArD,CAAL,EAAqE,OAAO,KAAP;AACxE;;AACD,WAAO,IAAP;AACH;;AAPe,EAAA,SAAA,CAAA,yBAAA,GAAyB,yBAAzB;;AAShB,WAAgB,mBAAhB,CAAoC,CAApC,EAAkD,CAAlD,EAA8D;AAC1D,QAAI,CAAC,CAAC,QAAF,KAAe,CAAC,CAAC,QAArB,EAA+B,OAAO,KAAP;AAE/B,QAAM,GAAG,GAAG,CAAC,CAAC,MAAF,CAAS,MAArB;AACA,QAAI,GAAG,KAAK,CAAC,CAAC,MAAF,CAAS,MAArB,EAA6B,OAAO,KAAP;;AAE7B,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAApB,EAAyB,CAAC,EAA1B,EAA8B;AAC1B,UAAI,CAAC,KAAK,CAAC,mBAAN,CAA0B,CAAC,CAAC,MAAF,CAAS,CAAT,CAA1B,EAAuC,CAAC,CAAC,MAAF,CAAS,CAAT,CAAvC,CAAL,EAA0D,OAAO,KAAP;AAC7D;;AACD,WAAO,IAAP;AACH;;AAVe,EAAA,SAAA,CAAA,mBAAA,GAAmB,mBAAnB;;AAYhB,WAAgB,aAAhB,CAA8B,CAA9B,EAA4C,CAA5C,EAAwD;AACpD,WAAO,CAAC,KAAK,CAAN,IACH,CAAC,CAAC,QAAF,KAAe,CAAC,CAAC,QAAjB,IACA,iBAAiB,CAAC,4BAAlB,CAA+C,CAAC,CAAC,kBAAjD,EAAqE,CAAC,CAAC,kBAAvE,CAFJ;AAIH;;AALe,EAAA,SAAA,CAAA,aAAA,GAAa,aAAb;AAOhB;;AACA,WAAgB,kBAAhB,CAAmC,CAAnC,EAAiD,CAAjD,EAA6D;AACzD,WAAO,aAAa,CAAC,CAAC,CAAC,IAAH,EAAS,CAAC,CAAC,IAAX,CAApB;AACH;;AAFe,EAAA,SAAA,CAAA,kBAAA,GAAkB,kBAAlB;AAIhB;;AACA,WAAgB,aAAhB,CAA8B,CAA9B,EAA4C,CAA5C,EAAwD;AACpD,WAAO,CAAC,CAAC,IAAF,KAAW,CAAC,CAAC,IAApB;AACH;;AAFe,EAAA,SAAA,CAAA,aAAA,GAAa,aAAb;;AAIhB,MAAA,uBAAA;AAAA;AAAA,cAAA;AAqCI,aAAA,uBAAA,CAAoB,SAApB,EAAwC;AAApB,WAAA,SAAA,GAAA,SAAA;AAnCZ,WAAA,SAAA,GAAY,CAAZ;AAEA,WAAA,MAAA,GAAS,CAAT;AACA,WAAA,GAAA,GAAM,CAAC,CAAP;AAiCJ,WAAK,OAAL,GAAe,gBAAgB,CAAC,QAAjB,CAA0B,MAA1B,CAAiC,SAAjC,CAAf;AACA,WAAK,OAAL,GAAe,SAAS,CAAC,YAAV,GAAyB,CAAxC;;AACA,UAAI,KAAK,OAAT,EAAkB;AACd,aAAK,QAAL,GAAgB,SAAS,CAAC,KAAV,CAAgB,CAAhB,EAAmB,QAAnC;AACA,aAAK,MAAL,GAAc,KAAK,QAAL,CAAc,MAAd,GAAuB,CAArC;AACA,aAAK,OAAL,CAAa,IAAb,GAAoB,SAAS,CAAC,KAAV,CAAgB,CAAhB,CAApB;AACH;AACJ;;AArCD,IAAA,uBAAA,CAAA,SAAA,CAAA,IAAA,GAAA,YAAA;AACI,WAAK,OAAL;AACA,WAAK,OAAL,CAAa,OAAb,GAAuB,KAAK,QAAL,CAAc,KAAK,GAAnB,CAAvB;AACA,aAAO,KAAK,OAAZ;AACH,KAJD;;AAMQ,IAAA,uBAAA,CAAA,SAAA,CAAA,OAAA,GAAR,YAAA;AACI,UAAI,KAAK,GAAL,GAAW,KAAK,MAApB,EAA4B;AACxB,aAAK,GAAL;AAEA,YAAI,KAAK,GAAL,KAAa,KAAK,MAAtB,EAA8B,KAAK,OAAL,GAAe,KAAK,SAAL,GAAiB,CAAjB,GAAqB,KAAK,SAAL,CAAe,KAAf,CAAqB,MAAzD;AAC9B;AACH;;AAED,WAAK,GAAL,GAAW,CAAX;AACA,WAAK,SAAL;;AACA,UAAI,KAAK,SAAL,IAAkB,KAAK,SAAL,CAAe,KAAf,CAAqB,MAA3C,EAAmD;AAC/C,aAAK,OAAL,GAAe,KAAf;AACA;AACH;;AAED,WAAK,OAAL,CAAa,IAAb,GAAoB,KAAK,SAAL,CAAe,KAAf,CAAqB,KAAK,SAA1B,CAApB;AACA,WAAK,QAAL,GAAgB,KAAK,OAAL,CAAa,IAAb,CAAkB,QAAlC;AACA,WAAK,MAAL,GAAc,KAAK,QAAL,CAAc,MAAd,GAAuB,CAArC;;AACA,UAAI,KAAK,MAAL,KAAgB,CAApB,EAAuB;AACnB,aAAK,OAAL,GAAe,KAAK,SAAL,GAAiB,CAAjB,GAAqB,KAAK,SAAL,CAAe,KAAf,CAAqB,MAAzD;AACH;AACJ,KArBO;;AAgCZ,WAAA,uBAAA;AAAC,GA9CD,EAAA;;AAAa,EAAA,SAAA,CAAA,uBAAA,GAAuB,uBAAvB;AAgDb,MAAM,OAAO,GAAG,IAAI,EAApB;;AACA,WAAS,sBAAT,CAAgC,IAAhC,EAA4C,CAA5C,EAAqD,OAArD,EAAoE;AACxD,QAAA,QAAQ,GAAoC,IAAI,CAAxC,QAAR;AAAA,QAAU,EAAA,GAAkC,IAAI,CAAT,YAAvC;AAAA,QAA0B,QAAQ,GAAA,EAAA,CAAA,QAAlC;AAAA,QAAoC,CAAC,GAAA,EAAA,CAAA,CAArC;AAAA,QAAkD,EAAE,GAAG,OAAvD;AACR,QAAI,IAAI,GAAG,MAAM,CAAC,SAAlB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,QAAQ,CAAC,MAA9B,EAAsC,CAAC,GAAG,EAA1C,EAA8C,CAAC,EAA/C,EAAmD;AAC/C,UAAM,CAAC,GAAG,QAAQ,CAAC,CAAD,CAAlB;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,EAAiB,QAAQ,CAAC,CAAD,EAAI,EAAJ,CAAzB,IAAoC,OAApC,GAA8C,CAAC,CAAC,CAAD,CAAzD;AACA,UAAI,CAAC,GAAG,IAAR,EAAc,IAAI,GAAG,CAAP;AACjB;;AACD,WAAO,IAAP;AACH;;AAED,WAAgB,kBAAhB,CAAmC,CAAnC,EAAiD,KAAjD,EAA8D,MAA9D,EAA4E;AAChE,QAAA,KAAK,GAAK,CAAC,CAAN,KAAL;AACR,QAAI,IAAI,GAAG,MAAM,CAAC,SAAlB;;AACA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,UAAM,IAAI,GAAG,KAAK,CAAC,CAAD,CAAlB;AACA,UAAM,CAAC,GAAG,sBAAsB,CAAC,IAAD,EAAO,KAAP,EAAc,MAAd,CAAhC;AACA,UAAI,CAAC,GAAG,IAAR,EAAc,IAAI,GAAG,CAAP;AACjB;;AACD,WAAO,IAAP;AACH;;AATe,EAAA,SAAA,CAAA,kBAAA,GAAkB,kBAAlB;AAWhB,MAAM,SAAS,GAAG,IAAI,EAAtB;;AACA,WAAgB,QAAhB,CAAyB,CAAzB,EAAuC,CAAvC,EAAmD;AAC/C,QAAI,CAAC,CAAC,YAAF,KAAmB,CAAnB,IAAwB,CAAC,CAAC,YAAF,KAAmB,CAA/C,EAAkD,OAAO,CAAP;AAE1C,QAAA,KAAK,GAAK,CAAC,CAAN,KAAL;AACR,QAAI,IAAI,GAAG,MAAM,CAAC,SAAlB;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,EAA5C,EAAgD;AAC5C,UAAM,IAAI,GAAG,KAAK,CAAC,CAAD,CAAlB;AACQ,UAAA,QAAQ,GAAoC,IAAI,CAAxC,QAAR;AAAA,UAAU,EAAA,GAAkC,IAAI,CAAT,YAAvC;AAAA,UAA0B,QAAQ,GAAA,EAAA,CAAA,QAAlC;AAAA,UAAoC,CAAC,GAAA,EAAA,CAAA,CAArC;;AACR,WAAK,IAAI,GAAC,GAAG,CAAR,EAAW,IAAE,GAAG,QAAQ,CAAC,MAA9B,EAAsC,GAAC,GAAG,IAA1C,EAA8C,GAAC,EAA/C,EAAmD;AAC/C,YAAM,CAAC,GAAG,QAAQ,CAAC,GAAD,CAAlB;AACA,YAAM,CAAC,GAAG,kBAAkB,CAAC,CAAD,EAAI,QAAQ,CAAC,CAAD,EAAI,SAAJ,CAAZ,EAA4B,CAAC,CAAC,CAAD,CAA7B,CAA5B;AACA,YAAI,CAAC,GAAG,IAAR,EAAc,IAAI,GAAG,CAAP;AACjB;AACJ;;AACD,WAAO,IAAP;AACH;;AAhBe,EAAA,SAAA,CAAA,QAAA,GAAQ,QAAR;;AAkBhB,WAAgB,kBAAhB,CAAmC,CAAnC,EAA+C;AAC3C,WAAO,CAAC,CAAC,YAAF,KAAmB,CAAnB,GAAuB,WAAvB,GAAwC,CAAC,CAAC,YAAF,GAAc,WAA7D;AACH;;AAFe,EAAA,SAAA,CAAA,kBAAA,GAAkB,kBAAlB;;AAIhB,WAAgB,aAAhB,CAA8B,CAA9B,EAA4C,CAA5C,EAAqD,CAArD,EAA4D;AACxD,WAAO,CAAC,CAAC,WAAF,GACD,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,KAAd,IAAuB,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,WAArC,IAAoD,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,WADjE,GAED,CAAC,CAAC,KAAF,KAAY,CAAC,CAAC,KAFpB;AAGH;;AAJe,EAAA,SAAA,CAAA,aAAA,GAAa,aAAb;AAYhB;;;AAGG;;AACH,WAAgB,YAAhB,CAA6B,SAA7B,EAAmD,QAAnD,EAAiG,KAAjG,EAAyH;AAC7G,QAAA,SAAS,GAA+B,KAAK,CAApC,SAAT;AAAA,QAAW,SAAS,GAAoB,KAAK,CAAzB,SAApB;AAAA,QAAsB,aAAa,GAAK,KAAK,CAAV,aAAnC;AACR,QAAI,CAAC,SAAS,CAAC,KAAV,CAAgB,IAAhB,CAAqB,UAAA,CAAA,EAAC;AAAI,aAAA,SAAS,CAAT,CAAS,CAAT;AAAY,KAAtC,CAAL,EAA8C;AAE9C,QAAM,MAAM,GAAG,SAAS,CAAC,QAAzB;AACA,QAAM,WAAW,GAAG,IAAI,EAAxB;;AAEA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAS,CAAC,KAA7B,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAoC;AAA/B,UAAM,IAAI,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,UAAI,CAAC,SAAS,CAAC,IAAD,CAAd,EAAsB;AAEtB,UAAM,EAAE,GAAG,IAAI,CAAC,QAAL,CAAc,MAAzB;AACA,MAAA,IAAI,CAAC,aAAL,CAAmB,WAAnB,EAAgC,EAAE,CAAC,MAAnC,EAA2C,IAAI,CAAC,YAAL,CAAkB,QAAlB,CAA2B,MAAtE;AACA,UAAM,UAAU,GAAG,MAAM,CAAC,eAAP,CAAuB,WAAW,CAAC,CAAD,CAAlC,EAAuC,WAAW,CAAC,CAAD,CAAlD,EAAuD,WAAW,CAAC,CAAD,CAAlE,EAAuE,EAAE,CAAC,MAAH,GAAY,SAAnF,CAAnB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,KAA/B,EAAsC,CAAC,EAAvC,EAA2C;AACvC,YAAM,KAAK,GAAG,SAAS,CAAC,KAAV,CAAgB,UAAU,CAAC,OAAX,CAAmB,CAAnB,CAAhB,CAAd;AACA,YAAI,CAAC,SAAS,CAAC,KAAD,CAAV,IAAqB,IAAI,CAAC,EAAL,IAAW,KAAK,CAAC,EAAtC,IAA4C,CAAC,aAAa,CAAC,IAAD,EAAO,KAAP,CAA9D,EAA6E;AAE7E,YAAI,KAAK,CAAC,QAAN,CAAe,MAAf,IAAyB,IAAI,CAAC,QAAL,CAAc,MAA3C,EAAmD,QAAQ,CAAC,IAAD,EAAO,KAAP,CAAR,CAAnD,KACK,QAAQ,CAAC,KAAD,EAAQ,IAAR,CAAR;AACR;AACJ;AACJ;;AArBe,EAAA,SAAA,CAAA,YAAA,GAAY,YAAZ;AA+Bf;;AAED,WAAgB,0BAAhB,CAA2C,SAA3C,EAAiE,EAAjE,EAA8H;QAA3D,KAAK,GAAA,EAAA,CAAA,K;QAAE,OAAO,GAAA,EAAA,CAAA,O;QAAE,IAAI,GAAA,EAAA,CAAA,I;AACnF,QAAM,CAAC,GAAG,gBAAgB,CAAC,QAAjB,CAA0B,MAA1B,CAA8C,SAA9C,CAAV;;AACA,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAS,CAAC,KAA7B,EAAmB,EAAA,GAAA,EAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAAoC;AAA/B,UAAM,IAAI,GAAA,EAAA,CAAA,EAAA,CAAV;AACD,UAAI,IAAI,CAAC,IAAL,KAAS;AAAA;AAAb,QAAoC;AAEpC,MAAA,CAAC,CAAC,IAAF,GAAS,IAAT;AAEQ,UAAA,QAAQ,GAAK,IAAI,CAAT,QAAR;AACR,UAAM,QAAQ,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,iBAA1D,EAA6E,QAA7E,CAAjB;AACA,UAAM,UAAU,GAAG,YAAY,CAAC,iBAAb,CAA+B,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,mBAA1D,EAA+E,QAA/E,CAAnB;;AAEA,aAAO,QAAQ,CAAC,OAAhB,EAAyB;AACrB,YAAM,YAAY,GAAG,QAAQ,CAAC,IAAT,EAArB;;AAEA,YAAI,KAAJ,EAAW;AACP,UAAA,CAAC,CAAC,OAAF,GAAY,QAAQ,CAAC,YAAY,CAAC,KAAd,CAApB;AACA,UAAA,KAAK,CAAC,CAAD,CAAL;AACH;;AAED,YAAI,CAAC,OAAD,IAAY,CAAC,IAAjB,EAAuB;AAEvB,QAAA,UAAU,CAAC,UAAX,CAAsB,YAAtB;;AACA,eAAO,UAAU,CAAC,OAAlB,EAA2B;AACvB,cAAM,cAAc,GAAG,UAAU,CAAC,IAAX,EAAvB;;AAEA,cAAI,OAAJ,EAAa;AACT,YAAA,CAAC,CAAC,OAAF,GAAY,QAAQ,CAAC,cAAc,CAAC,KAAhB,CAApB;AACA,YAAA,OAAO,CAAC,CAAD,CAAP;AACH;;AAED,cAAI,CAAC,IAAL,EAAW;;AAEX,eAAK,IAAI,CAAC,GAAG,cAAc,CAAC,KAAvB,EAA8B,EAAE,GAAG,cAAc,CAAC,GAAvD,EAA4D,CAAC,GAAG,EAAhE,EAAoE,CAAC,EAArE,EAAyE;AACrE,YAAA,CAAC,CAAC,OAAF,GAAY,QAAQ,CAAC,CAAD,CAApB;AACA,YAAA,IAAI,CAAC,CAAD,CAAJ;AACH;AACJ;AACJ;AACJ;AACJ;;AAvCe,EAAA,SAAA,CAAA,0BAAA,GAA0B,0BAA1B,CAhlBD,CAynBf;;AAEa,EAAA,SAAA,CAAA,qBAAA,GAAwB;AACjC;AACA,IAAA,iBAAiB,EAAE,EAFc;;AAGjC;AACA,IAAA,kBAAkB,EAAE,IAJa;;AAKjC;AACA,IAAA,iBAAiB,EAAE,KANc;;AAOjC;;;AAGG;AACH,IAAA,qBAAqB,EAAE,EAXU;;AAYjC;AACA,IAAA,iBAAiB,EAAE;AAbc,GAAxB;;AAiBb,WAAS,wBAAT,CAAkC,SAAlC,EAAsD;AAClD,WAAO,SAAS,CAAC,kBAAV,CAA6B,MAA7B,CAAoC,UAAA,EAAA,EAAE;AAAI,aAAA,EAAE,CAAC,KAAH,CAAS,CAAT,EAAY,eAAZ,CAA4B,MAA5B,GAAA,CAAA;AAAsC,KAAhF,CAAP;AACH;AAED;;AAEG;;;AACH,WAAS,WAAT,CAAqB,SAArB,EAA2C,UAA3C,EAAqE;AACjE,QAAM,qBAAqB,GAAG,wBAAwB,CAAC,SAAD,CAAtD;AACA,WACI,qBAAqB,CAAC,MAAtB,KAAiC,CAAjC,IACA,qBAAqB,CAAC,CAAD,CAArB,CAAyB,KAAzB,CAA+B,MAA/B,GAAwC,CADxC,IAEA,qBAAqB,CAAC,CAAD,CAArB,CAAyB,KAAzB,CAA+B,CAA/B,EAAkC,eAAlC,CAAkD,MAAlD,GAA2D,UAAU,CAAC,iBAH1E;AAKH;;AAED,WAAS,eAAT,CAAyB,SAAzB,EAA+C,UAA/C,EAAyE;AACrE,QAAM,qBAAqB,GAAG,wBAAwB,CAAC,SAAD,CAAtD;AACA,WACI,qBAAqB,CAAC,MAAtB,IAAgC,CAAhC,IACA,qBAAqB,CAAC,CAAD,CAArB,CAAyB,KAAzB,CAA+B,MAA/B,GAAwC,UAAU,CAAC,qBAFvD;AAIH;;AAED,MAAY,IAAZ;;AAAA,GAAA,UAAY,IAAZ,EAAgB;AAAG,IAAA,IAAA,CAAA,IAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AAAO,IAAA,IAAA,CAAA,IAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AAAQ,IAAA,IAAA,CAAA,IAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AAAO,IAAA,IAAA,CAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AAAM,IAAA,IAAA,CAAA,IAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AAAU,GAAzD,EAAY,IAAI,GAAJ,SAAA,CAAA,IAAA,KAAA,SAAA,CAAA,IAAA,GAAI,EAAJ,CAAZ;AAEA;;;AAGG;;;AACH,WAAgB,OAAhB,CAAwB,SAAxB,EAA8C,UAA9C,EAAwF,kBAAxF,EAA8G;AAAhE,QAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,UAAA,GAAA,EAAA;AAAwC;;AAAE,QAAA,kBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,kBAAA,GAAA,CAAA;AAAsB;;AAC1G,QAAM,CAAC,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,SAAA,CAAA,qBAAR,CAAA,EAAkC,UAAlC,CAAP;;AACA,QAAI,SAAS,CAAC,mBAAV,IAAiC,CAAC,CAAC,iBAAF,GAAsB,kBAA3D,EAA+E;AAC3E,UAAI,eAAe,CAAC,SAAD,EAAY,CAAZ,CAAnB,EAAmC;AAC/B,eAAO,IAAI,CAAC,IAAZ;AACH,OAFD,MAEO;AACH,eAAO,IAAI,CAAC,QAAZ;AACH;AACJ,KAND,MAMO,IAAI,WAAW,CAAC,SAAD,EAAY,CAAZ,CAAf,EAA+B;AAClC,aAAO,IAAI,CAAC,KAAZ;AACH,KAFM,MAEA,IAAI,SAAS,CAAC,mBAAV,GAAgC,CAAC,CAAC,iBAAF,GAAsB,kBAA1D,EAA8E;AACjF,aAAO,IAAI,CAAC,KAAZ;AACH,KAFM,MAEA,IAAI,SAAS,CAAC,mBAAV,GAAgC,CAAC,CAAC,kBAAF,GAAuB,kBAA3D,EAA+E;AAClF,aAAO,IAAI,CAAC,MAAZ;AACH,KAFM,MAEA;AACH,aAAO,IAAI,CAAC,KAAZ;AACH;AACJ;;AAjBe,EAAA,SAAA,CAAA,OAAA,GAAO,OAAP;AAsBH,EAAA,SAAA,CAAA,KAAA,GAAQ,uBAAuB,CAAC,YAAxB,CAA4C,OAA5C,EAAqD,MAArD,CAAR;AAEb,MAAM,iBAAiB,GAAG,mBAA1B;;AACA,WAAgB,gBAAhB,CAAiC,SAAjC,EAAqD;AACjD,QAAI,SAAS,CAAC,mBAAV,CAA8B,iBAA9B,CAAJ,EAAsD,OAAO,SAAS,CAAC,mBAAV,CAA8B,iBAA9B,CAAP;AACtD,QAAM,aAAa,GAAG,gBAAgB,CAAC,IAAjB,CAAsB,gBAAtB,CAAuC,SAAS,CAAC,sBAAV,CAAiC,SAAjC,CAAvC,CAAtB;AACA,IAAA,SAAS,CAAC,mBAAV,CAA8B,iBAA9B,IAAmD,aAAnD;AACA,WAAO,aAAP;AACH;;AALe,EAAA,SAAA,CAAA,gBAAA,GAAgB,gBAAhB;AAMnB,CAzsBD,EAAU,SAAS,KAAT,SAAS,GAAA,EAAA,CAAnB;;AA2sBA,SAAS,SAAT","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign, __awaiter, __generator } from \"tslib\";\r\nimport { IntMap, SortedArray, Segmentation, Interval, OrderedSet } from '../../../mol-data/int';\r\nimport { UniqueArray } from '../../../mol-data/generic';\r\nimport { SymmetryOperator } from '../../../mol-math/geometry/symmetry-operator';\r\nimport { Model } from '../model';\r\nimport { sort, arraySwap, hash1, sortArray, hashString, hashFnv32a } from '../../../mol-data/util';\r\nimport { StructureElement } from './element';\r\nimport { Unit } from './unit';\r\nimport { StructureLookup3D } from './util/lookup3d';\r\nimport { StructureSubsetBuilder } from './util/subset-builder';\r\nimport { computeInterUnitBonds, Bond } from './unit/bonds';\r\nimport { StructureSymmetry } from './symmetry';\r\nimport { StructureProperties } from './properties';\r\nimport { computeCarbohydrates } from './carbohydrates/compute';\r\nimport { Vec3, Mat4 } from '../../../mol-math/linear-algebra';\r\nimport { idFactory } from '../../../mol-util/id-factory';\r\nimport { GridLookup3D } from '../../../mol-math/geometry';\r\nimport { CustomProperties } from '../../custom-property';\r\nimport { AtomicHierarchy } from '../model/properties/atomic';\r\nimport { StructureSelection } from '../query/selection';\r\nimport { getBoundary } from '../../../mol-math/geometry/boundary';\r\nimport { CustomStructureProperty } from '../../../mol-model-props/common/custom-structure-property';\r\nimport { Task } from '../../../mol-task';\r\nimport { computeStructureBoundary } from './util/boundary';\r\nvar Structure = /** @class */ (function () {\r\n    /**\r\n     * @param units Array of all units in the structure, sorted by unit.id\r\n     * @param unitMap Maps unit.id to index of unit in units array\r\n     * @param unitIndexMap Array of all units in the structure, sorted by unit.id\r\n     */\r\n    function Structure(units, unitMap, unitIndexMap, state, asParent) {\r\n        this.units = units;\r\n        this.unitMap = unitMap;\r\n        this.unitIndexMap = unitIndexMap;\r\n        this.state = state;\r\n        // always assign to ensure object shape\r\n        this._child = asParent === null || asParent === void 0 ? void 0 : asParent.child;\r\n        this._target = asParent === null || asParent === void 0 ? void 0 : asParent.target;\r\n        this._proxy = undefined;\r\n    }\r\n    Structure.prototype.subsetBuilder = function (isSorted) {\r\n        return new StructureSubsetBuilder(this, isSorted);\r\n    };\r\n    Object.defineProperty(Structure.prototype, \"elementCount\", {\r\n        /** Count of all elements in the structure, i.e. the sum of the elements in the units */\r\n        get: function () {\r\n            return this.state.elementCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"bondCount\", {\r\n        /** Count of all bonds (intra- and inter-unit) in the structure */\r\n        get: function () {\r\n            if (this.state.bondCount === -1) {\r\n                this.state.bondCount = this.interUnitBonds.edgeCount + Bond.getIntraUnitBondCount(this);\r\n            }\r\n            return this.state.bondCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"hasCustomProperties\", {\r\n        get: function () {\r\n            return !!this.state.customProps && this.state.customProps.all.length > 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"customPropertyDescriptors\", {\r\n        get: function () {\r\n            if (!this.state.customProps)\r\n                this.state.customProps = new CustomProperties();\r\n            return this.state.customProps;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"currentPropertyData\", {\r\n        /**\r\n         * Property data unique to this instance of the structure.\r\n         */\r\n        get: function () {\r\n            if (!this.state.propertyData)\r\n                this.state.propertyData = Object.create(null);\r\n            return this.state.propertyData;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"inheritedPropertyData\", {\r\n        /**\r\n         * Property data of the parent structure if it exists, currentPropertyData otherwise.\r\n         */\r\n        get: function () {\r\n            return this.parent ? this.parent.currentPropertyData : this.currentPropertyData;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"polymerResidueCount\", {\r\n        /** Count of all polymer residues in the structure */\r\n        get: function () {\r\n            if (this.state.polymerResidueCount === -1) {\r\n                this.state.polymerResidueCount = getPolymerResidueCount(this);\r\n            }\r\n            return this.state.polymerResidueCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"polymerGapCount\", {\r\n        /** Count of all polymer gaps in the structure */\r\n        get: function () {\r\n            if (this.state.polymerGapCount === -1) {\r\n                this.state.polymerGapCount = getPolymerGapCount(this);\r\n            }\r\n            return this.state.polymerGapCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"polymerUnitCount\", {\r\n        get: function () {\r\n            if (this.state.polymerUnitCount === -1) {\r\n                this.state.polymerUnitCount = getPolymerUnitCount(this);\r\n            }\r\n            return this.state.polymerUnitCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"uniqueElementCount\", {\r\n        get: function () {\r\n            if (this.state.uniqueElementCount === -1) {\r\n                this.state.uniqueElementCount = getUniqueElementCount(this);\r\n            }\r\n            return this.state.uniqueElementCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"atomicResidueCount\", {\r\n        get: function () {\r\n            if (this.state.atomicResidueCount === -1) {\r\n                this.state.atomicResidueCount = getAtomicResidueCount(this);\r\n            }\r\n            return this.state.atomicResidueCount;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"isCoarseGrained\", {\r\n        /**\r\n         * True if any model the structure is based on is coarse grained.\r\n         * @see Model.isCoarseGrained\r\n         */\r\n        get: function () {\r\n            return this.models.some(function (m) { return Model.isCoarseGrained(m); });\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"isEmpty\", {\r\n        get: function () {\r\n            return this.units.length === 0;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"hashCode\", {\r\n        get: function () {\r\n            if (this.state.hashCode !== -1)\r\n                return this.state.hashCode;\r\n            return this.computeHash();\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"transformHash\", {\r\n        /** Hash based on all unit.id values in the structure, reflecting the units transformation */\r\n        get: function () {\r\n            if (this.state.transformHash !== -1)\r\n                return this.state.transformHash;\r\n            this.state.transformHash = hashFnv32a(this.units.map(function (u) { return u.id; }));\r\n            return this.state.transformHash;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Structure.prototype.computeHash = function () {\r\n        var hash = 23;\r\n        for (var i = 0, _i = this.units.length; i < _i; i++) {\r\n            var u = this.units[i];\r\n            hash = (31 * hash + u.id) | 0;\r\n            hash = (31 * hash + SortedArray.hashCode(u.elements)) | 0;\r\n        }\r\n        hash = (31 * hash + this.elementCount) | 0;\r\n        hash = hash1(hash);\r\n        if (hash === -1)\r\n            hash = 0;\r\n        this.state.hashCode = hash;\r\n        return hash;\r\n    };\r\n    /** Returns a new element location iterator */\r\n    Structure.prototype.elementLocations = function () {\r\n        return new Structure.ElementLocationIterator(this);\r\n    };\r\n    Object.defineProperty(Structure.prototype, \"root\", {\r\n        /** The parent or itself in case this is the root */\r\n        get: function () {\r\n            var _a;\r\n            return (_a = this.state.parent) !== null && _a !== void 0 ? _a : this;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"parent\", {\r\n        /** The root/top-most parent or `undefined` in case this is the root */\r\n        get: function () {\r\n            return this.state.parent;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"coordinateSystem\", {\r\n        /**\r\n         * Conformation transformation that was applied to every unit of this structure.\r\n         *\r\n         * Coordinate system applies to the *current* structure only.\r\n         * A parent structure can have a different coordinate system and thefore it has to be composed \"manualy\"\r\n         * by the consumer.\r\n         */\r\n        get: function () {\r\n            return this.state.coordinateSystem;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"label\", {\r\n        get: function () {\r\n            return this.state.label;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"boundary\", {\r\n        get: function () {\r\n            if (this.state.boundary)\r\n                return this.state.boundary;\r\n            this.state.boundary = computeStructureBoundary(this);\r\n            return this.state.boundary;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"lookup3d\", {\r\n        get: function () {\r\n            if (this.state.lookup3d)\r\n                return this.state.lookup3d;\r\n            this.state.lookup3d = new StructureLookup3D(this);\r\n            return this.state.lookup3d;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"interUnitBonds\", {\r\n        get: function () {\r\n            if (this.state.interUnitBonds)\r\n                return this.state.interUnitBonds;\r\n            this.state.interUnitBonds = computeInterUnitBonds(this, { ignoreWater: !this.dynamicBonds });\r\n            return this.state.interUnitBonds;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"dynamicBonds\", {\r\n        get: function () {\r\n            return this.state.dynamicBonds;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"unitSymmetryGroups\", {\r\n        get: function () {\r\n            if (this.state.unitSymmetryGroups)\r\n                return this.state.unitSymmetryGroups;\r\n            this.state.unitSymmetryGroups = StructureSymmetry.computeTransformGroups(this);\r\n            return this.state.unitSymmetryGroups;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"unitSymmetryGroupsIndexMap\", {\r\n        /** Maps unit.id to index of SymmetryGroup in unitSymmetryGroups array */\r\n        get: function () {\r\n            if (this.state.unitSymmetryGroupsIndexMap)\r\n                return this.state.unitSymmetryGroupsIndexMap;\r\n            this.state.unitSymmetryGroupsIndexMap = Unit.SymmetryGroup.getUnitSymmetryGroupsIndexMap(this.unitSymmetryGroups);\r\n            return this.state.unitSymmetryGroupsIndexMap;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"carbohydrates\", {\r\n        get: function () {\r\n            if (this.state.carbohydrates)\r\n                return this.state.carbohydrates;\r\n            this.state.carbohydrates = computeCarbohydrates(this);\r\n            return this.state.carbohydrates;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"models\", {\r\n        get: function () {\r\n            if (this.state.models)\r\n                return this.state.models;\r\n            this.state.models = getModels(this);\r\n            return this.state.models;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"uniqueResidueNames\", {\r\n        get: function () {\r\n            return this.state.uniqueResidueNames\r\n                || (this.state.uniqueResidueNames = getUniqueResidueNames(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"uniqueElementSymbols\", {\r\n        get: function () {\r\n            return this.state.uniqueElementSymbols\r\n                || (this.state.uniqueElementSymbols = getUniqueElementSymbols(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"entityIndices\", {\r\n        get: function () {\r\n            return this.state.entityIndices\r\n                || (this.state.entityIndices = getEntityIndices(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"uniqueAtomicResidueIndices\", {\r\n        get: function () {\r\n            return this.state.uniqueAtomicResidueIndices\r\n                || (this.state.uniqueAtomicResidueIndices = getUniqueAtomicResidueIndices(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"isAtomic\", {\r\n        /** Contains only atomic units */\r\n        get: function () {\r\n            for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\r\n                var u = _b[_a];\r\n                if (!Unit.isAtomic(u))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"hasAtomic\", {\r\n        /** Contains some atomic units */\r\n        get: function () {\r\n            for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\r\n                var u = _b[_a];\r\n                if (Unit.isAtomic(u))\r\n                    return true;\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"isCoarse\", {\r\n        /** Contains only coarse units */\r\n        get: function () {\r\n            for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\r\n                var u = _b[_a];\r\n                if (!Unit.isCoarse(u))\r\n                    return false;\r\n            }\r\n            return true;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"hasCoarse\", {\r\n        /** Contains some coarse units */\r\n        get: function () {\r\n            for (var _a = 0, _b = this.units; _a < _b.length; _a++) {\r\n                var u = _b[_a];\r\n                if (Unit.isCoarse(u))\r\n                    return true;\r\n            }\r\n            return false;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"serialMapping\", {\r\n        /**\r\n         * Provides mapping for serial element indices accross all units.\r\n         *\r\n         * Note that this is especially costly for structures with many units that are grouped\r\n         * into few symmetry groups. Use only when needed and prefer `StructureElement`\r\n         * to address elements in a structure.\r\n         */\r\n        get: function () {\r\n            return this.state.serialMapping || (this.state.serialMapping = getSerialMapping(this));\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"model\", {\r\n        /**\r\n         * If the structure is based on a single model or has a master-/representative-model, return it.\r\n         * Otherwise throw an exception.\r\n         */\r\n        get: function () {\r\n            if (this.state.model)\r\n                return this.state.model;\r\n            if (this.state.representativeModel)\r\n                return this.state.representativeModel;\r\n            if (this.state.masterModel)\r\n                return this.state.masterModel;\r\n            var models = this.models;\r\n            if (models.length > 1) {\r\n                throw new Error('The structure is based on multiple models and has neither a master- nor a representative-model.');\r\n            }\r\n            this.state.model = models[0];\r\n            return this.state.model;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"masterModel\", {\r\n        /** The master-model, other models can have bonds to it  */\r\n        get: function () {\r\n            return this.state.masterModel;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"representativeModel\", {\r\n        /** A representative model, e.g. the first model of a trajectory */\r\n        get: function () {\r\n            return this.state.representativeModel;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Structure.prototype.hasElement = function (e) {\r\n        if (!this.unitMap.has(e.unit.id))\r\n            return false;\r\n        return SortedArray.has(this.unitMap.get(e.unit.id).elements, e.element);\r\n    };\r\n    Structure.prototype.getModelIndex = function (m) {\r\n        return this.models.indexOf(m);\r\n    };\r\n    Structure.prototype.remapModel = function (m) {\r\n        var _a = this.state, dynamicBonds = _a.dynamicBonds, interUnitBonds = _a.interUnitBonds;\r\n        var units = [];\r\n        for (var _b = 0, _c = this.unitSymmetryGroups; _b < _c.length; _b++) {\r\n            var ug = _c[_b];\r\n            var unit = ug.units[0].remapModel(m, dynamicBonds);\r\n            units.push(unit);\r\n            for (var i = 1, il = ug.units.length; i < il; ++i) {\r\n                var u = ug.units[i];\r\n                units.push(u.remapModel(m, dynamicBonds, unit.props));\r\n            }\r\n        }\r\n        return Structure.create(units, {\r\n            label: this.label,\r\n            interUnitBonds: dynamicBonds ? undefined : interUnitBonds,\r\n            dynamicBonds: dynamicBonds\r\n        });\r\n    };\r\n    /**\r\n     * For `structure` with `parent` this returns a proxy that\r\n     * targets `parent` and has `structure` attached as a child.\r\n     */\r\n    Structure.prototype.asParent = function () {\r\n        if (this._proxy)\r\n            return this._proxy;\r\n        if (this.parent) {\r\n            var p = this.parent.coordinateSystem.isIdentity ? this.parent : Structure.transform(this.parent, this.parent.coordinateSystem.inverse);\r\n            var s = this.coordinateSystem.isIdentity ? p : Structure.transform(p, this.coordinateSystem.matrix);\r\n            this._proxy = new Structure(s.units, s.unitMap, s.unitIndexMap, __assign(__assign({}, s.state), { dynamicBonds: this.dynamicBonds }), { child: this, target: this.parent });\r\n        }\r\n        else {\r\n            this._proxy = this;\r\n        }\r\n        return this._proxy;\r\n    };\r\n    Object.defineProperty(Structure.prototype, \"child\", {\r\n        get: function () {\r\n            return this._child;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Structure.prototype, \"target\", {\r\n        /** Get the proxy target. Usefull for equality checks. */\r\n        get: function () {\r\n            var _a;\r\n            return (_a = this._target) !== null && _a !== void 0 ? _a : this;\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    return Structure;\r\n}());\r\nfunction cmpUnits(units, i, j) {\r\n    return units[i].id - units[j].id;\r\n}\r\nfunction getModels(s) {\r\n    var units = s.units;\r\n    var arr = UniqueArray.create();\r\n    for (var _a = 0, units_1 = units; _a < units_1.length; _a++) {\r\n        var u = units_1[_a];\r\n        UniqueArray.add(arr, u.model.id, u.model);\r\n    }\r\n    return arr.array;\r\n}\r\nfunction getUniqueResidueNames(s) {\r\n    var microheterogeneityCompIds = StructureProperties.residue.microheterogeneityCompIds;\r\n    var names = new Set();\r\n    var loc = StructureElement.Location.create(s);\r\n    for (var _a = 0, _b = s.unitSymmetryGroups; _a < _b.length; _a++) {\r\n        var unitGroup = _b[_a];\r\n        var unit = unitGroup.units[0];\r\n        // TODO: support coarse unit?\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        var residues = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n        loc.unit = unit;\r\n        while (residues.hasNext) {\r\n            var seg = residues.move();\r\n            loc.element = unit.elements[seg.start];\r\n            var compIds = microheterogeneityCompIds(loc);\r\n            for (var _c = 0, compIds_1 = compIds; _c < compIds_1.length; _c++) {\r\n                var compId = compIds_1[_c];\r\n                names.add(compId);\r\n            }\r\n        }\r\n    }\r\n    return names;\r\n}\r\nfunction getUniqueElementSymbols(s) {\r\n    var prop = StructureProperties.atom.type_symbol;\r\n    var symbols = new Set();\r\n    var loc = StructureElement.Location.create(s);\r\n    for (var _a = 0, _b = s.unitSymmetryGroups; _a < _b.length; _a++) {\r\n        var unitGroup = _b[_a];\r\n        var unit = unitGroup.units[0];\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        loc.unit = unit;\r\n        for (var i = 0, il = unit.elements.length; i < il; ++i) {\r\n            loc.element = unit.elements[i];\r\n            symbols.add(prop(loc));\r\n        }\r\n    }\r\n    return symbols;\r\n}\r\nfunction getEntityIndices(structure) {\r\n    var units = structure.units;\r\n    var l = StructureElement.Location.create(structure);\r\n    var keys = UniqueArray.create();\r\n    for (var _a = 0, units_2 = units; _a < units_2.length; _a++) {\r\n        var unit = units_2[_a];\r\n        var prop = unit.kind === 0 /* Atomic */ ? StructureProperties.entity.key : StructureProperties.coarse.entityKey;\r\n        l.unit = unit;\r\n        var elements = unit.elements;\r\n        var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\r\n        while (chainsIt.hasNext) {\r\n            var chainSegment = chainsIt.move();\r\n            l.element = elements[chainSegment.start];\r\n            var key = prop(l);\r\n            UniqueArray.add(keys, key, key);\r\n        }\r\n    }\r\n    sortArray(keys.array);\r\n    return keys.array;\r\n}\r\nfunction getUniqueAtomicResidueIndices(structure) {\r\n    var map = new Map();\r\n    var modelIds = [];\r\n    var unitGroups = structure.unitSymmetryGroups;\r\n    for (var _a = 0, unitGroups_1 = unitGroups; _a < unitGroups_1.length; _a++) {\r\n        var unitGroup = unitGroups_1[_a];\r\n        var unit = unitGroup.units[0];\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        var uniqueResidues = void 0;\r\n        if (map.has(unit.model.id))\r\n            uniqueResidues = map.get(unit.model.id);\r\n        else {\r\n            uniqueResidues = UniqueArray.create();\r\n            modelIds.push(unit.model.id);\r\n            map.set(unit.model.id, uniqueResidues);\r\n        }\r\n        var residues = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, unit.elements);\r\n        while (residues.hasNext) {\r\n            var seg = residues.move();\r\n            UniqueArray.add(uniqueResidues, seg.index, seg.index);\r\n        }\r\n    }\r\n    var ret = new Map();\r\n    for (var _b = 0, modelIds_1 = modelIds; _b < modelIds_1.length; _b++) {\r\n        var id = modelIds_1[_b];\r\n        var array = map.get(id).array;\r\n        sortArray(array);\r\n        ret.set(id, array);\r\n    }\r\n    return ret;\r\n}\r\nfunction getUniqueElementCount(structure) {\r\n    var unitSymmetryGroups = structure.unitSymmetryGroups;\r\n    var uniqueElementCount = 0;\r\n    for (var i = 0, _i = unitSymmetryGroups.length; i < _i; i++) {\r\n        uniqueElementCount += unitSymmetryGroups[i].elements.length;\r\n    }\r\n    return uniqueElementCount;\r\n}\r\nfunction getPolymerResidueCount(structure) {\r\n    var units = structure.units;\r\n    var polymerResidueCount = 0;\r\n    for (var i = 0, _i = units.length; i < _i; i++) {\r\n        polymerResidueCount += units[i].polymerElements.length;\r\n    }\r\n    return polymerResidueCount;\r\n}\r\nfunction getPolymerGapCount(structure) {\r\n    var units = structure.units;\r\n    var polymerGapCount = 0;\r\n    for (var i = 0, _i = units.length; i < _i; i++) {\r\n        polymerGapCount += units[i].gapElements.length / 2;\r\n    }\r\n    return polymerGapCount;\r\n}\r\nfunction getPolymerUnitCount(structure) {\r\n    var units = structure.units;\r\n    var polymerUnitCount = 0;\r\n    for (var i = 0, _i = units.length; i < _i; i++) {\r\n        if (units[i].polymerElements.length > 0)\r\n            polymerUnitCount += 1;\r\n    }\r\n    return polymerUnitCount;\r\n}\r\nfunction getAtomicResidueCount(structure) {\r\n    var units = structure.units;\r\n    var atomicResidueCount = 0;\r\n    for (var i = 0, _i = units.length; i < _i; i++) {\r\n        var unit = units[i];\r\n        if (!Unit.isAtomic(unit))\r\n            continue;\r\n        var elements = unit.elements, residueIndex = unit.residueIndex;\r\n        var idx = -1;\r\n        var prevIdx = -1;\r\n        for (var j = 0, jl = elements.length; j < jl; ++j) {\r\n            idx = residueIndex[elements[j]];\r\n            if (idx !== prevIdx) {\r\n                atomicResidueCount += 1;\r\n                prevIdx = idx;\r\n            }\r\n        }\r\n    }\r\n    return atomicResidueCount;\r\n}\r\nfunction getSerialMapping(structure) {\r\n    var units = structure.units, elementCount = structure.elementCount, unitIndexMap = structure.unitIndexMap;\r\n    var cumulativeUnitElementCount = new Uint32Array(units.length);\r\n    var unitIndices = new Uint32Array(elementCount);\r\n    var elementIndices = new Uint32Array(elementCount);\r\n    for (var i = 0, m = 0, il = units.length; i < il; ++i) {\r\n        cumulativeUnitElementCount[i] = m;\r\n        var elements = units[i].elements;\r\n        for (var j = 0, jl = elements.length; j < jl; ++j) {\r\n            var mj = m + j;\r\n            unitIndices[mj] = i;\r\n            elementIndices[mj] = elements[j];\r\n        }\r\n        m += elements.length;\r\n    }\r\n    return {\r\n        cumulativeUnitElementCount: cumulativeUnitElementCount,\r\n        unitIndices: unitIndices,\r\n        elementIndices: elementIndices,\r\n        getSerialIndex: function (unit, element) { return cumulativeUnitElementCount[unitIndexMap.get(unit.id)] + OrderedSet.indexOf(unit.elements, element); }\r\n    };\r\n}\r\n(function (Structure) {\r\n    Structure.Empty = create([]);\r\n    function Loci(structure) {\r\n        return { kind: 'structure-loci', structure: structure };\r\n    }\r\n    Structure.Loci = Loci;\r\n    function toStructureElementLoci(structure) {\r\n        var elements = [];\r\n        for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\r\n            var unit = _b[_a];\r\n            elements.push({ unit: unit, indices: Interval.ofBounds(0, unit.elements.length) });\r\n        }\r\n        return StructureElement.Loci(structure, elements);\r\n    }\r\n    Structure.toStructureElementLoci = toStructureElementLoci;\r\n    function toSubStructureElementLoci(parent, structure) {\r\n        return StructureSelection.toLociWithSourceUnits(StructureSelection.Singletons(parent, structure));\r\n    }\r\n    Structure.toSubStructureElementLoci = toSubStructureElementLoci;\r\n    function isLoci(x) {\r\n        return !!x && x.kind === 'structure-loci';\r\n    }\r\n    Structure.isLoci = isLoci;\r\n    function areLociEqual(a, b) {\r\n        return a.structure === b.structure;\r\n    }\r\n    Structure.areLociEqual = areLociEqual;\r\n    function isLociEmpty(loci) {\r\n        return loci.structure.isEmpty;\r\n    }\r\n    Structure.isLociEmpty = isLociEmpty;\r\n    function remapLoci(loci, structure) {\r\n        if (structure === loci.structure)\r\n            return loci;\r\n        return Loci(structure);\r\n    }\r\n    Structure.remapLoci = remapLoci;\r\n    function create(units, props) {\r\n        if (props === void 0) { props = {}; }\r\n        // init units\r\n        var unitMap = IntMap.Mutable();\r\n        var unitIndexMap = IntMap.Mutable();\r\n        var elementCount = 0;\r\n        var isSorted = true;\r\n        var lastId = units.length > 0 ? units[0].id : 0;\r\n        for (var i = 0, _i = units.length; i < _i; i++) {\r\n            var u = units[i];\r\n            unitMap.set(u.id, u);\r\n            elementCount += u.elements.length;\r\n            if (u.id < lastId)\r\n                isSorted = false;\r\n            lastId = u.id;\r\n        }\r\n        if (!isSorted)\r\n            sort(units, 0, units.length, cmpUnits, arraySwap);\r\n        for (var i = 0, _i = units.length; i < _i; i++) {\r\n            unitIndexMap.set(units[i].id, i);\r\n        }\r\n        // initial state\r\n        var state = {\r\n            hashCode: -1,\r\n            transformHash: -1,\r\n            elementCount: elementCount,\r\n            bondCount: -1,\r\n            uniqueElementCount: -1,\r\n            atomicResidueCount: -1,\r\n            polymerResidueCount: -1,\r\n            polymerGapCount: -1,\r\n            polymerUnitCount: -1,\r\n            dynamicBonds: false,\r\n            coordinateSystem: SymmetryOperator.Default,\r\n            label: ''\r\n        };\r\n        // handle props\r\n        if (props.parent)\r\n            state.parent = props.parent.parent || props.parent;\r\n        if (props.interUnitBonds)\r\n            state.interUnitBonds = props.interUnitBonds;\r\n        if (props.dynamicBonds)\r\n            state.dynamicBonds = props.dynamicBonds;\r\n        else if (props.parent)\r\n            state.dynamicBonds = props.parent.dynamicBonds;\r\n        if (props.coordinateSystem)\r\n            state.coordinateSystem = props.coordinateSystem;\r\n        else if (props.parent)\r\n            state.coordinateSystem = props.parent.coordinateSystem;\r\n        if (props.label)\r\n            state.label = props.label;\r\n        else if (props.parent)\r\n            state.label = props.parent.label;\r\n        if (props.masterModel)\r\n            state.masterModel = props.masterModel;\r\n        else if (props.parent)\r\n            state.masterModel = props.parent.masterModel;\r\n        if (props.representativeModel)\r\n            state.representativeModel = props.representativeModel;\r\n        else if (props.parent)\r\n            state.representativeModel = props.parent.representativeModel;\r\n        return new Structure(units, unitMap, unitIndexMap, state);\r\n    }\r\n    Structure.create = create;\r\n    function ofTrajectory(trajectory, ctx) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var units, first, count, i, il, frame, structure, j, jl, u, invariantId, chainGroupId, newUnit;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (trajectory.frameCount === 0)\r\n                            return [2 /*return*/, Structure.Empty];\r\n                        units = [];\r\n                        first = void 0;\r\n                        count = 0;\r\n                        i = 0, il = trajectory.frameCount;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < il)) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, Task.resolveInContext(trajectory.getFrameAtIndex(i), ctx)];\r\n                    case 2:\r\n                        frame = _a.sent();\r\n                        if (!first)\r\n                            first = frame;\r\n                        structure = ofModel(frame);\r\n                        for (j = 0, jl = structure.units.length; j < jl; ++j) {\r\n                            u = structure.units[j];\r\n                            invariantId = u.invariantId + count;\r\n                            chainGroupId = u.chainGroupId + count;\r\n                            newUnit = Unit.create(units.length, invariantId, chainGroupId, u.traits, u.kind, u.model, u.conformation.operator, u.elements);\r\n                            units.push(newUnit);\r\n                        }\r\n                        count = units.length;\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        ++i;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, create(units, { representativeModel: first, label: first.label })];\r\n                }\r\n            });\r\n        });\r\n    }\r\n    Structure.ofTrajectory = ofTrajectory;\r\n    var PARTITION = false;\r\n    /**\r\n     * Construct a Structure from a model.\r\n     *\r\n     * Generally, a single unit corresponds to a single chain, with the exception\r\n     * of consecutive \"single atom chains\" with same entity_id and same auth_asym_id.\r\n     */\r\n    function ofModel(model, props) {\r\n        if (props === void 0) { props = {}; }\r\n        var chains = model.atomicHierarchy.chainAtomSegments;\r\n        var index = model.atomicHierarchy.index;\r\n        var auth_asym_id = model.atomicHierarchy.chains.auth_asym_id;\r\n        var atomicChainOperatorMappinng = model.atomicChainOperatorMappinng;\r\n        var builder = new StructureBuilder(__assign({ label: model.label }, props));\r\n        for (var c = 0; c < chains.count; c++) {\r\n            var operator = atomicChainOperatorMappinng.get(c) || SymmetryOperator.Default;\r\n            var start = chains.offsets[c];\r\n            // set to true for chains that consist of \"single atom residues\",\r\n            // note that it assumes there are no \"zero atom residues\"\r\n            var singleAtomResidues = AtomicHierarchy.chainResidueCount(model.atomicHierarchy, c) === chains.offsets[c + 1] - chains.offsets[c];\r\n            var multiChain = false;\r\n            if (isWaterChain(model, c)) {\r\n                // merge consecutive water chains\r\n                while (c + 1 < chains.count && isWaterChain(model, c + 1)) {\r\n                    var op1 = atomicChainOperatorMappinng.get(c);\r\n                    var op2 = atomicChainOperatorMappinng.get(c + 1);\r\n                    if (op1 !== op2)\r\n                        break;\r\n                    multiChain = true;\r\n                    c++;\r\n                }\r\n            }\r\n            else {\r\n                // merge consecutive \"single atom chains\" with same entity_id and auth_asym_id\r\n                while (c + 1 < chains.count\r\n                    && chains.offsets[c + 1] - chains.offsets[c] === 1\r\n                    && chains.offsets[c + 2] - chains.offsets[c + 1] === 1) {\r\n                    singleAtomResidues = true;\r\n                    var e1 = index.getEntityFromChain(c);\r\n                    var e2 = index.getEntityFromChain(c + 1);\r\n                    if (e1 !== e2)\r\n                        break;\r\n                    var a1 = auth_asym_id.value(c);\r\n                    var a2 = auth_asym_id.value(c + 1);\r\n                    if (a1 !== a2)\r\n                        break;\r\n                    var op1 = atomicChainOperatorMappinng.get(c);\r\n                    var op2 = atomicChainOperatorMappinng.get(c + 1);\r\n                    if (op1 !== op2)\r\n                        break;\r\n                    multiChain = true;\r\n                    c++;\r\n                }\r\n            }\r\n            var elements = SortedArray.ofBounds(start, chains.offsets[c + 1]);\r\n            if (PARTITION) {\r\n                // check for polymer to exclude CA/P-only models\r\n                if (singleAtomResidues && !isPolymerChain(model, c)) {\r\n                    partitionAtomicUnitByAtom(model, elements, builder, multiChain, operator);\r\n                }\r\n                else if (elements.length > 200000 || isWaterChain(model, c)) {\r\n                    // split up very large chains e.g. lipid bilayers, micelles or water with explicit H\r\n                    partitionAtomicUnitByResidue(model, elements, builder, multiChain, operator);\r\n                }\r\n                else {\r\n                    builder.addUnit(0 /* Atomic */, model, operator, elements, multiChain ? 1 /* MultiChain */ : 0 /* None */);\r\n                }\r\n            }\r\n            else {\r\n                builder.addUnit(0 /* Atomic */, model, operator, elements, multiChain ? 1 /* MultiChain */ : 0 /* None */);\r\n            }\r\n        }\r\n        var cs = model.coarseHierarchy;\r\n        if (cs.isDefined) {\r\n            if (cs.spheres.count > 0) {\r\n                addCoarseUnits(builder, model, model.coarseHierarchy.spheres, 1 /* Spheres */);\r\n            }\r\n            if (cs.gaussians.count > 0) {\r\n                addCoarseUnits(builder, model, model.coarseHierarchy.gaussians, 2 /* Gaussians */);\r\n            }\r\n        }\r\n        return builder.getStructure();\r\n    }\r\n    Structure.ofModel = ofModel;\r\n    function isWaterChain(model, chainIndex) {\r\n        var e = model.atomicHierarchy.index.getEntityFromChain(chainIndex);\r\n        return model.entities.data.type.value(e) === 'water';\r\n    }\r\n    function isPolymerChain(model, chainIndex) {\r\n        var e = model.atomicHierarchy.index.getEntityFromChain(chainIndex);\r\n        return model.entities.data.type.value(e) === 'polymer';\r\n    }\r\n    function partitionAtomicUnitByAtom(model, indices, builder, multiChain, operator) {\r\n        var _a = model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n        var position = { x: x, y: y, z: z, indices: indices };\r\n        var lookup = GridLookup3D(position, getBoundary(position), 8192);\r\n        var _b = lookup.buckets, offset = _b.offset, count = _b.count, array = _b.array;\r\n        var traits = (multiChain ? 1 /* MultiChain */ : 0 /* None */) | (offset.length > 1 ? 2 /* Partitioned */ : 0 /* None */);\r\n        builder.beginChainGroup();\r\n        for (var i = 0, _i = offset.length; i < _i; i++) {\r\n            var start = offset[i];\r\n            var set = new Int32Array(count[i]);\r\n            for (var j = 0, _j = count[i]; j < _j; j++) {\r\n                set[j] = indices[array[start + j]];\r\n            }\r\n            builder.addUnit(0 /* Atomic */, model, operator, SortedArray.ofSortedArray(set), traits);\r\n        }\r\n        builder.endChainGroup();\r\n    }\r\n    // keeps atoms of residues together\r\n    function partitionAtomicUnitByResidue(model, indices, builder, multiChain, operator) {\r\n        var residueAtomSegments = model.atomicHierarchy.residueAtomSegments;\r\n        var startIndices = [];\r\n        var endIndices = [];\r\n        var residueIt = Segmentation.transientSegments(residueAtomSegments, indices);\r\n        while (residueIt.hasNext) {\r\n            var residueSegment = residueIt.move();\r\n            startIndices[startIndices.length] = indices[residueSegment.start];\r\n            endIndices[endIndices.length] = indices[residueSegment.end];\r\n        }\r\n        var firstResidueAtomCount = endIndices[0] - startIndices[0];\r\n        var gridCellCount = 512 * firstResidueAtomCount;\r\n        var _a = model.atomicConformation, x = _a.x, y = _a.y, z = _a.z;\r\n        var position = { x: x, y: y, z: z, indices: SortedArray.ofSortedArray(startIndices) };\r\n        var lookup = GridLookup3D(position, getBoundary(position), gridCellCount);\r\n        var _b = lookup.buckets, offset = _b.offset, count = _b.count, array = _b.array;\r\n        var traits = (multiChain ? 1 /* MultiChain */ : 0 /* None */) | (offset.length > 1 ? 2 /* Partitioned */ : 0 /* None */);\r\n        builder.beginChainGroup();\r\n        for (var i = 0, _i = offset.length; i < _i; i++) {\r\n            var start = offset[i];\r\n            var set = [];\r\n            for (var j = 0, _j = count[i]; j < _j; j++) {\r\n                var k = array[start + j];\r\n                for (var l = startIndices[k], _l = endIndices[k]; l < _l; l++) {\r\n                    set[set.length] = l;\r\n                }\r\n            }\r\n            builder.addUnit(0 /* Atomic */, model, operator, SortedArray.ofSortedArray(new Int32Array(set)), traits);\r\n        }\r\n        builder.endChainGroup();\r\n    }\r\n    function addCoarseUnits(builder, model, elements, kind) {\r\n        var chainElementSegments = elements.chainElementSegments;\r\n        for (var cI = 0; cI < chainElementSegments.count; cI++) {\r\n            var elements_1 = SortedArray.ofBounds(chainElementSegments.offsets[cI], chainElementSegments.offsets[cI + 1]);\r\n            builder.addUnit(kind, model, SymmetryOperator.Default, elements_1, 0 /* None */);\r\n        }\r\n    }\r\n    function transform(s, transform) {\r\n        if (Mat4.isIdentity(transform))\r\n            return s;\r\n        if (!Mat4.isRotationAndTranslation(transform, SymmetryOperator.RotationTranslationEpsilon))\r\n            throw new Error('Only rotation/translation combination can be applied.');\r\n        var units = [];\r\n        for (var _a = 0, _b = s.units; _a < _b.length; _a++) {\r\n            var u = _b[_a];\r\n            var old = u.conformation.operator;\r\n            var op = SymmetryOperator.create(old.name, transform, old);\r\n            units.push(u.applyOperator(u.id, op));\r\n        }\r\n        var cs = s.coordinateSystem;\r\n        var newCS = SymmetryOperator.compose(SymmetryOperator.create(cs.name, transform, cs), cs);\r\n        return create(units, { parent: s, coordinateSystem: newCS });\r\n    }\r\n    Structure.transform = transform;\r\n    var StructureBuilder = /** @class */ (function () {\r\n        function StructureBuilder(props) {\r\n            if (props === void 0) { props = {}; }\r\n            this.props = props;\r\n            this.units = [];\r\n            this.invariantId = idFactory();\r\n            this.chainGroupId = -1;\r\n            this.inChainGroup = false;\r\n            this.p = Vec3();\r\n            this.singleElementUnits = new Map();\r\n        }\r\n        StructureBuilder.prototype.beginChainGroup = function () {\r\n            this.chainGroupId++;\r\n            this.inChainGroup = true;\r\n        };\r\n        StructureBuilder.prototype.endChainGroup = function () {\r\n            this.inChainGroup = false;\r\n        };\r\n        StructureBuilder.prototype.addUnit = function (kind, model, operator, elements, traits, invariantId) {\r\n            if (invariantId === undefined)\r\n                invariantId = this.invariantId();\r\n            var chainGroupId = this.inChainGroup ? this.chainGroupId : ++this.chainGroupId;\r\n            var unit = Unit.create(this.units.length, invariantId, chainGroupId, traits, kind, model, operator, elements);\r\n            return this.add(unit);\r\n        };\r\n        StructureBuilder.prototype.add = function (unit) {\r\n            // this is to avoid adding many identical single atom units,\r\n            // for example, from 'degenerate' spacegroups\r\n            // - Diamond (COD 9008564)\r\n            if (unit.elements.length === 1) {\r\n                unit.conformation.position(unit.elements[0], this.p);\r\n                var hash = [unit.invariantId, this.p[0], this.p[1], this.p[2]].join('|');\r\n                if (this.singleElementUnits.has(hash)) {\r\n                    return this.singleElementUnits.get(hash);\r\n                }\r\n                else {\r\n                    this.singleElementUnits.set(hash, unit);\r\n                }\r\n            }\r\n            this.units.push(unit);\r\n            return unit;\r\n        };\r\n        StructureBuilder.prototype.addWithOperator = function (unit, operator, dontCompose) {\r\n            if (dontCompose === void 0) { dontCompose = false; }\r\n            return this.add(unit.applyOperator(this.units.length, operator, dontCompose));\r\n        };\r\n        StructureBuilder.prototype.getStructure = function () {\r\n            return create(this.units, this.props);\r\n        };\r\n        Object.defineProperty(StructureBuilder.prototype, \"isEmpty\", {\r\n            get: function () {\r\n                return this.units.length === 0;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        return StructureBuilder;\r\n    }());\r\n    Structure.StructureBuilder = StructureBuilder;\r\n    function Builder(props) {\r\n        if (props === void 0) { props = {}; }\r\n        return new StructureBuilder(props);\r\n    }\r\n    Structure.Builder = Builder;\r\n    function hashCode(s) {\r\n        return s.hashCode;\r\n    }\r\n    Structure.hashCode = hashCode;\r\n    /** Hash based on all unit.model conformation values in the structure */\r\n    function conformationHash(s) {\r\n        return hashString(s.units.map(function (u) { return Unit.conformationId(u); }).join('|'));\r\n    }\r\n    Structure.conformationHash = conformationHash;\r\n    // TODO: there should be a version that properly supports partitioned units\r\n    function areUnitIdsEqual(a, b) {\r\n        if (a === b)\r\n            return true;\r\n        if (a.elementCount !== b.elementCount)\r\n            return false;\r\n        var len = a.units.length;\r\n        if (len !== b.units.length)\r\n            return false;\r\n        for (var i = 0; i < len; i++) {\r\n            if (a.units[i].id !== b.units[i].id)\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    Structure.areUnitIdsEqual = areUnitIdsEqual;\r\n    function areUnitIdsAndIndicesEqual(a, b) {\r\n        if (!areUnitIdsEqual(a, b))\r\n            return false;\r\n        for (var i = 0, il = a.units.length; i < il; i++) {\r\n            if (!SortedArray.areEqual(a.units[i].elements, b.units[i].elements))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    Structure.areUnitIdsAndIndicesEqual = areUnitIdsAndIndicesEqual;\r\n    function areHierarchiesEqual(a, b) {\r\n        if (a.hashCode !== b.hashCode)\r\n            return false;\r\n        var len = a.models.length;\r\n        if (len !== b.models.length)\r\n            return false;\r\n        for (var i = 0; i < len; i++) {\r\n            if (!Model.areHierarchiesEqual(a.models[i], b.models[i]))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    Structure.areHierarchiesEqual = areHierarchiesEqual;\r\n    function areEquivalent(a, b) {\r\n        return a === b || (a.hashCode === b.hashCode &&\r\n            StructureSymmetry.areTransformGroupsEquivalent(a.unitSymmetryGroups, b.unitSymmetryGroups));\r\n    }\r\n    Structure.areEquivalent = areEquivalent;\r\n    /** Check if the structures or their parents are equivalent */\r\n    function areRootsEquivalent(a, b) {\r\n        return areEquivalent(a.root, b.root);\r\n    }\r\n    Structure.areRootsEquivalent = areRootsEquivalent;\r\n    /** Check if the structures or their parents are equal */\r\n    function areRootsEqual(a, b) {\r\n        return a.root === b.root;\r\n    }\r\n    Structure.areRootsEqual = areRootsEqual;\r\n    var ElementLocationIterator = /** @class */ (function () {\r\n        function ElementLocationIterator(structure) {\r\n            this.structure = structure;\r\n            this.unitIndex = 0;\r\n            this.maxIdx = 0;\r\n            this.idx = -1;\r\n            this.current = StructureElement.Location.create(structure);\r\n            this.hasNext = structure.elementCount > 0;\r\n            if (this.hasNext) {\r\n                this.elements = structure.units[0].elements;\r\n                this.maxIdx = this.elements.length - 1;\r\n                this.current.unit = structure.units[0];\r\n            }\r\n        }\r\n        ElementLocationIterator.prototype.move = function () {\r\n            this.advance();\r\n            this.current.element = this.elements[this.idx];\r\n            return this.current;\r\n        };\r\n        ElementLocationIterator.prototype.advance = function () {\r\n            if (this.idx < this.maxIdx) {\r\n                this.idx++;\r\n                if (this.idx === this.maxIdx)\r\n                    this.hasNext = this.unitIndex + 1 < this.structure.units.length;\r\n                return;\r\n            }\r\n            this.idx = 0;\r\n            this.unitIndex++;\r\n            if (this.unitIndex >= this.structure.units.length) {\r\n                this.hasNext = false;\r\n                return;\r\n            }\r\n            this.current.unit = this.structure.units[this.unitIndex];\r\n            this.elements = this.current.unit.elements;\r\n            this.maxIdx = this.elements.length - 1;\r\n            if (this.maxIdx === 0) {\r\n                this.hasNext = this.unitIndex + 1 < this.structure.units.length;\r\n            }\r\n        };\r\n        return ElementLocationIterator;\r\n    }());\r\n    Structure.ElementLocationIterator = ElementLocationIterator;\r\n    var distVec = Vec3();\r\n    function unitElementMinDistance(unit, p, eRadius) {\r\n        var elements = unit.elements, _a = unit.conformation, position = _a.position, r = _a.r, dV = distVec;\r\n        var minD = Number.MAX_VALUE;\r\n        for (var i = 0, _i = elements.length; i < _i; i++) {\r\n            var e = elements[i];\r\n            var d = Vec3.distance(p, position(e, dV)) - eRadius - r(e);\r\n            if (d < minD)\r\n                minD = d;\r\n        }\r\n        return minD;\r\n    }\r\n    function minDistanceToPoint(s, point, radius) {\r\n        var units = s.units;\r\n        var minD = Number.MAX_VALUE;\r\n        for (var i = 0, _i = units.length; i < _i; i++) {\r\n            var unit = units[i];\r\n            var d = unitElementMinDistance(unit, point, radius);\r\n            if (d < minD)\r\n                minD = d;\r\n        }\r\n        return minD;\r\n    }\r\n    Structure.minDistanceToPoint = minDistanceToPoint;\r\n    var distPivot = Vec3();\r\n    function distance(a, b) {\r\n        if (a.elementCount === 0 || b.elementCount === 0)\r\n            return 0;\r\n        var units = a.units;\r\n        var minD = Number.MAX_VALUE;\r\n        for (var i = 0, _i = units.length; i < _i; i++) {\r\n            var unit = units[i];\r\n            var elements = unit.elements, _a = unit.conformation, position = _a.position, r = _a.r;\r\n            for (var i_1 = 0, _i_1 = elements.length; i_1 < _i_1; i_1++) {\r\n                var e = elements[i_1];\r\n                var d = minDistanceToPoint(b, position(e, distPivot), r(e));\r\n                if (d < minD)\r\n                    minD = d;\r\n            }\r\n        }\r\n        return minD;\r\n    }\r\n    Structure.distance = distance;\r\n    function elementDescription(s) {\r\n        return s.elementCount === 1 ? '1 element' : s.elementCount + \" elements\";\r\n    }\r\n    Structure.elementDescription = elementDescription;\r\n    function validUnitPair(s, a, b) {\r\n        return s.masterModel\r\n            ? a.model === b.model || a.model === s.masterModel || b.model === s.masterModel\r\n            : a.model === b.model;\r\n    }\r\n    Structure.validUnitPair = validUnitPair;\r\n    /**\r\n     * Iterate over all unit pairs of a structure and invokes callback for valid units\r\n     * and unit pairs if within a max distance.\r\n     */\r\n    function eachUnitPair(structure, callback, props) {\r\n        var maxRadius = props.maxRadius, validUnit = props.validUnit, validUnitPair = props.validUnitPair;\r\n        if (!structure.units.some(function (u) { return validUnit(u); }))\r\n            return;\r\n        var lookup = structure.lookup3d;\r\n        var imageCenter = Vec3();\r\n        for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\r\n            var unit = _b[_a];\r\n            if (!validUnit(unit))\r\n                continue;\r\n            var bs = unit.boundary.sphere;\r\n            Vec3.transformMat4(imageCenter, bs.center, unit.conformation.operator.matrix);\r\n            var closeUnits = lookup.findUnitIndices(imageCenter[0], imageCenter[1], imageCenter[2], bs.radius + maxRadius);\r\n            for (var i = 0; i < closeUnits.count; i++) {\r\n                var other = structure.units[closeUnits.indices[i]];\r\n                if (!validUnit(other) || unit.id >= other.id || !validUnitPair(unit, other))\r\n                    continue;\r\n                if (other.elements.length >= unit.elements.length)\r\n                    callback(unit, other);\r\n                else\r\n                    callback(other, unit);\r\n            }\r\n        }\r\n    }\r\n    Structure.eachUnitPair = eachUnitPair;\r\n    ;\r\n    function eachAtomicHierarchyElement(structure, _a) {\r\n        var chain = _a.chain, residue = _a.residue, atom = _a.atom;\r\n        var l = StructureElement.Location.create(structure);\r\n        for (var _b = 0, _c = structure.units; _b < _c.length; _b++) {\r\n            var unit = _c[_b];\r\n            if (unit.kind !== 0 /* Atomic */)\r\n                continue;\r\n            l.unit = unit;\r\n            var elements = unit.elements;\r\n            var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\r\n            var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\r\n            while (chainsIt.hasNext) {\r\n                var chainSegment = chainsIt.move();\r\n                if (chain) {\r\n                    l.element = elements[chainSegment.start];\r\n                    chain(l);\r\n                }\r\n                if (!residue && !atom)\r\n                    continue;\r\n                residuesIt.setSegment(chainSegment);\r\n                while (residuesIt.hasNext) {\r\n                    var residueSegment = residuesIt.move();\r\n                    if (residue) {\r\n                        l.element = elements[residueSegment.start];\r\n                        residue(l);\r\n                    }\r\n                    if (!atom)\r\n                        continue;\r\n                    for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\r\n                        l.element = elements[j];\r\n                        atom(l);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Structure.eachAtomicHierarchyElement = eachAtomicHierarchyElement;\r\n    //\r\n    Structure.DefaultSizeThresholds = {\r\n        /** Must be lower to be small */\r\n        smallResidueCount: 10,\r\n        /** Must be lower to be medium */\r\n        mediumResidueCount: 5000,\r\n        /** Must be lower to be large (big ribosomes like 4UG0 should still be `large`) */\r\n        largeResidueCount: 30000,\r\n        /**\r\n         * Structures above `largeResidueCount` are consider huge when they have\r\n         * a `highSymmetryUnitCount` or gigantic when not\r\n         */\r\n        highSymmetryUnitCount: 10,\r\n        /** Fiber-like structure are consider small when below this */\r\n        fiberResidueCount: 15,\r\n    };\r\n    function getPolymerSymmetryGroups(structure) {\r\n        return structure.unitSymmetryGroups.filter(function (ug) { return ug.units[0].polymerElements.length > 0; });\r\n    }\r\n    /**\r\n     * Try to match fiber-like structures like 6nk4\r\n     */\r\n    function isFiberLike(structure, thresholds) {\r\n        var polymerSymmetryGroups = getPolymerSymmetryGroups(structure);\r\n        return (polymerSymmetryGroups.length === 1 &&\r\n            polymerSymmetryGroups[0].units.length > 2 &&\r\n            polymerSymmetryGroups[0].units[0].polymerElements.length < thresholds.fiberResidueCount);\r\n    }\r\n    function hasHighSymmetry(structure, thresholds) {\r\n        var polymerSymmetryGroups = getPolymerSymmetryGroups(structure);\r\n        return (polymerSymmetryGroups.length >= 1 &&\r\n            polymerSymmetryGroups[0].units.length > thresholds.highSymmetryUnitCount);\r\n    }\r\n    var Size;\r\n    (function (Size) {\r\n        Size[Size[\"Small\"] = 0] = \"Small\";\r\n        Size[Size[\"Medium\"] = 1] = \"Medium\";\r\n        Size[Size[\"Large\"] = 2] = \"Large\";\r\n        Size[Size[\"Huge\"] = 3] = \"Huge\";\r\n        Size[Size[\"Gigantic\"] = 4] = \"Gigantic\";\r\n    })(Size = Structure.Size || (Structure.Size = {}));\r\n    /**\r\n     * @param residueCountFactor - modifies the threshold counts, useful when estimating\r\n     *                             the size of a structure comprised of multiple models\r\n     */\r\n    function getSize(structure, thresholds, residueCountFactor) {\r\n        if (thresholds === void 0) { thresholds = {}; }\r\n        if (residueCountFactor === void 0) { residueCountFactor = 1; }\r\n        var t = __assign(__assign({}, Structure.DefaultSizeThresholds), thresholds);\r\n        if (structure.polymerResidueCount >= t.largeResidueCount * residueCountFactor) {\r\n            if (hasHighSymmetry(structure, t)) {\r\n                return Size.Huge;\r\n            }\r\n            else {\r\n                return Size.Gigantic;\r\n            }\r\n        }\r\n        else if (isFiberLike(structure, t)) {\r\n            return Size.Small;\r\n        }\r\n        else if (structure.polymerResidueCount < t.smallResidueCount * residueCountFactor) {\r\n            return Size.Small;\r\n        }\r\n        else if (structure.polymerResidueCount < t.mediumResidueCount * residueCountFactor) {\r\n            return Size.Medium;\r\n        }\r\n        else {\r\n            return Size.Large;\r\n        }\r\n    }\r\n    Structure.getSize = getSize;\r\n    Structure.Index = CustomStructureProperty.createSimple('index', 'root');\r\n    var PrincipalAxesProp = '__PrincipalAxes__';\r\n    function getPrincipalAxes(structure) {\r\n        if (structure.currentPropertyData[PrincipalAxesProp])\r\n            return structure.currentPropertyData[PrincipalAxesProp];\r\n        var principalAxes = StructureElement.Loci.getPrincipalAxes(Structure.toStructureElementLoci(structure));\r\n        structure.currentPropertyData[PrincipalAxesProp] = principalAxes;\r\n        return principalAxes;\r\n    }\r\n    Structure.getPrincipalAxes = getPrincipalAxes;\r\n})(Structure || (Structure = {}));\r\nexport { Structure };\r\n//# sourceMappingURL=structure.js.map"]},"metadata":{},"sourceType":"module"}