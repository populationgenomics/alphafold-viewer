{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\nimport { DSSPType } from './common';\n/**\r\n * A minimal helix is defined by two consecutive n-turns.\r\n * For example, a 4-helix, of minimal length 4 from residues i to i + 3,\r\n * requires 4-turns at residues i - 1 and i,\r\n *\r\n *      3-helix(i,i + 2)=: [3-turn(i - 1) and 3-turn(i)]\r\n *      4-helix(i,i + 3)=: [4-turn(i - 1) and 4-turn(i)]\r\n *      5-helix(i,i + 4)=: [5-turn(i - 1) and 5-turn(i)]\r\n *\r\n * Type: G (n=3), H (n=4), I (n=5)\r\n */\n\nexport function assignHelices(ctx) {\n  var proteinInfo = ctx.proteinInfo,\n      flags = ctx.flags;\n  var residueCount = proteinInfo.residueIndices.length;\n  var turnFlag = [1024\n  /* T3S */\n  , 2048\n  /* T4S */\n  , 4096\n  /* T5S */\n  , 128\n  /* T3 */\n  , 256\n  /* T4 */\n  , 512\n  /* T5 */\n  ];\n  var helixFlag = [0, 0, 0, 8\n  /* G */\n  , 1\n  /* H */\n  , 16\n  /* I */\n  ];\n  var helixCheckOrder = ctx.params.oldOrdering ? [4, 3, 5] : [3, 4, 5];\n\n  for (var ni = 0; ni < helixCheckOrder.length; ni++) {\n    var n = helixCheckOrder[ni];\n\n    for (var i = 1, il = residueCount - n; i < il; i++) {\n      var fI = DSSPType.create(flags[i]);\n      var fI1 = DSSPType.create(flags[i - 1]);\n      var fI2 = DSSPType.create(flags[i + 1]); // TODO rework to elegant solution which will not break instantly\n\n      if (ctx.params.oldOrdering) {\n        if (n === 3 && (DSSPType.is(fI, 1\n        /* H */\n        ) || DSSPType.is(fI2, 1\n        /* H */\n        )) || // for 3-10 yield to alpha helix\n        n === 5 && (DSSPType.is(fI, 1\n        /* H */\n        ) || DSSPType.is(fI, 8\n        /* G */\n        ) || DSSPType.is(fI2, 1\n        /* H */\n        ) || DSSPType.is(fI2, 8\n        /* G */\n        ))) {\n          // for pi yield to all other helices\n          continue;\n        }\n      } else {\n        if (n === 4 && (DSSPType.is(fI, 8\n        /* G */\n        ) || DSSPType.is(fI2, 8\n        /* G */\n        )) || // for alpha helix yield to 3-10\n        n === 5 && (DSSPType.is(fI, 1\n        /* H */\n        ) || DSSPType.is(fI, 8\n        /* G */\n        ) || DSSPType.is(fI2, 1\n        /* H */\n        ) || DSSPType.is(fI2, 8\n        /* G */\n        ))) {\n          // for pi yield to all other helices\n          continue;\n        }\n      }\n\n      if (DSSPType.is(fI, turnFlag[n]) && DSSPType.is(fI, turnFlag[n - 3]) && // check fI for turn start of proper type\n      DSSPType.is(fI1, turnFlag[n]) && DSSPType.is(fI1, turnFlag[n - 3])) {\n        // check fI1 accordingly\n        if (ctx.params.oldDefinition) {\n          for (var k = 0; k < n; k++) {\n            flags[i + k] |= helixFlag[n];\n          }\n        } else {\n          for (var k = -1; k <= n; k++) {\n            flags[i + k] |= helixFlag[n];\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../src/mol-model-props/computed/secondary-structure/dssp/helices.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n * @author Sebastian Bittrich <sebastian.bittrich@rcsb.org>\r\n */\r\nimport { DSSPType } from './common';\r\n/**\r\n * A minimal helix is defined by two consecutive n-turns.\r\n * For example, a 4-helix, of minimal length 4 from residues i to i + 3,\r\n * requires 4-turns at residues i - 1 and i,\r\n *\r\n *      3-helix(i,i + 2)=: [3-turn(i - 1) and 3-turn(i)]\r\n *      4-helix(i,i + 3)=: [4-turn(i - 1) and 4-turn(i)]\r\n *      5-helix(i,i + 4)=: [5-turn(i - 1) and 5-turn(i)]\r\n *\r\n * Type: G (n=3), H (n=4), I (n=5)\r\n */\r\nexport function assignHelices(ctx) {\r\n    var proteinInfo = ctx.proteinInfo, flags = ctx.flags;\r\n    var residueCount = proteinInfo.residueIndices.length;\r\n    var turnFlag = [1024 /* T3S */, 2048 /* T4S */, 4096 /* T5S */, 128 /* T3 */, 256 /* T4 */, 512 /* T5 */];\r\n    var helixFlag = [0, 0, 0, 8 /* G */, 1 /* H */, 16 /* I */];\r\n    var helixCheckOrder = ctx.params.oldOrdering ? [4, 3, 5] : [3, 4, 5];\r\n    for (var ni = 0; ni < helixCheckOrder.length; ni++) {\r\n        var n = helixCheckOrder[ni];\r\n        for (var i = 1, il = residueCount - n; i < il; i++) {\r\n            var fI = DSSPType.create(flags[i]);\r\n            var fI1 = DSSPType.create(flags[i - 1]);\r\n            var fI2 = DSSPType.create(flags[i + 1]);\r\n            // TODO rework to elegant solution which will not break instantly\r\n            if (ctx.params.oldOrdering) {\r\n                if ((n === 3 && (DSSPType.is(fI, 1 /* H */) || DSSPType.is(fI2, 1 /* H */)) || // for 3-10 yield to alpha helix\r\n                    (n === 5 && ((DSSPType.is(fI, 1 /* H */) || DSSPType.is(fI, 8 /* G */)) || (DSSPType.is(fI2, 1 /* H */) || DSSPType.is(fI2, 8 /* G */)))))) { // for pi yield to all other helices\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                if ((n === 4 && (DSSPType.is(fI, 8 /* G */) || DSSPType.is(fI2, 8 /* G */)) || // for alpha helix yield to 3-10\r\n                    (n === 5 && ((DSSPType.is(fI, 1 /* H */) || DSSPType.is(fI, 8 /* G */)) || (DSSPType.is(fI2, 1 /* H */) || DSSPType.is(fI2, 8 /* G */)))))) { // for pi yield to all other helices\r\n                    continue;\r\n                }\r\n            }\r\n            if (DSSPType.is(fI, turnFlag[n]) && DSSPType.is(fI, turnFlag[n - 3]) && // check fI for turn start of proper type\r\n                DSSPType.is(fI1, turnFlag[n]) && DSSPType.is(fI1, turnFlag[n - 3])) { // check fI1 accordingly\r\n                if (ctx.params.oldDefinition) {\r\n                    for (var k = 0; k < n; k++) {\r\n                        flags[i + k] |= helixFlag[n];\r\n                    }\r\n                }\r\n                else {\r\n                    for (var k = -1; k <= n; k++) {\r\n                        flags[i + k] |= helixFlag[n];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=helices.js.map"]},"metadata":{},"sourceType":"module"}