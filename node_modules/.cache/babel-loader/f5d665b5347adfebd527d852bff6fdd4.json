{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { ValueCell } from '../../../mol-util';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\nimport { createColors } from '../color-data';\nimport { createMarkers } from '../marker-data';\nimport { BaseGeometry } from '../base';\nimport { createEmptyOverpaint } from '../overpaint-data';\nimport { createEmptyTransparency } from '../transparency-data';\nimport { calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\nimport { createNullTexture } from '../../../mol-gl/webgl/texture';\nimport { Vec2, Vec4 } from '../../../mol-math/linear-algebra';\nimport { createEmptyClipping } from '../clipping-data';\nimport { NullLocation } from '../../../mol-model/location';\nexport var TextureMesh;\n\n(function (TextureMesh) {\n  var DoubleBuffer =\n  /** @class */\n  function () {\n    function DoubleBuffer() {\n      this.index = 0;\n      this.textures = [];\n    }\n\n    DoubleBuffer.prototype.get = function () {\n      return this.textures[this.index];\n    };\n\n    DoubleBuffer.prototype.set = function (vertex, group, normal) {\n      this.textures[this.index] = Object.assign(this.textures[this.index] || {}, {\n        vertex: vertex,\n        group: group,\n        normal: normal\n      });\n      this.index = (this.index + 1) % 2;\n    };\n\n    DoubleBuffer.prototype.destroy = function () {\n      for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\n        var buffer = _a[_i];\n        buffer.vertex.destroy();\n        buffer.group.destroy();\n        buffer.normal.destroy();\n      }\n    };\n\n    return DoubleBuffer;\n  }();\n\n  TextureMesh.DoubleBuffer = DoubleBuffer;\n\n  function create(vertexCount, groupCount, vertexTexture, groupTexture, normalTexture, boundingSphere, textureMesh) {\n    var width = vertexTexture.getWidth();\n    var height = vertexTexture.getHeight();\n\n    if (textureMesh) {\n      textureMesh.vertexCount = vertexCount;\n      textureMesh.groupCount = groupCount;\n      ValueCell.update(textureMesh.geoTextureDim, Vec2.set(textureMesh.geoTextureDim.ref.value, width, height));\n      ValueCell.update(textureMesh.vertexTexture, vertexTexture);\n      ValueCell.update(textureMesh.groupTexture, groupTexture);\n      ValueCell.update(textureMesh.normalTexture, normalTexture);\n      textureMesh.doubleBuffer.set(vertexTexture, groupTexture, normalTexture);\n      Sphere3D.copy(textureMesh.boundingSphere, boundingSphere);\n      return textureMesh;\n    } else {\n      return {\n        kind: 'texture-mesh',\n        vertexCount: vertexCount,\n        groupCount: groupCount,\n        geoTextureDim: ValueCell.create(Vec2.create(width, height)),\n        vertexTexture: ValueCell.create(vertexTexture),\n        groupTexture: ValueCell.create(groupTexture),\n        normalTexture: ValueCell.create(normalTexture),\n        doubleBuffer: new DoubleBuffer(),\n        boundingSphere: Sphere3D.clone(boundingSphere)\n      };\n    }\n  }\n\n  TextureMesh.create = create;\n\n  function createEmpty(textureMesh) {\n    var vt = textureMesh ? textureMesh.vertexTexture.ref.value : createNullTexture();\n    var gt = textureMesh ? textureMesh.groupTexture.ref.value : createNullTexture();\n    var nt = textureMesh ? textureMesh.normalTexture.ref.value : createNullTexture();\n    var bs = textureMesh ? textureMesh.boundingSphere : Sphere3D();\n    return create(0, 0, vt, gt, nt, bs, textureMesh);\n  }\n\n  TextureMesh.createEmpty = createEmpty;\n  TextureMesh.Params = __assign(__assign({}, BaseGeometry.Params), {\n    doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo),\n    flipSided: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    flatShaded: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory),\n    xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory)\n  });\n  TextureMesh.Utils = {\n    Params: TextureMesh.Params,\n    createEmpty: createEmpty,\n    createValues: createValues,\n    createValuesSimple: createValuesSimple,\n    updateValues: updateValues,\n    updateBoundingSphere: updateBoundingSphere,\n    createRenderableState: BaseGeometry.createRenderableState,\n    updateRenderableState: BaseGeometry.updateRenderableState,\n    createPositionIterator: function () {\n      return LocationIterator(1, 1, 1, function () {\n        return NullLocation;\n      });\n    }\n  };\n\n  function createValues(textureMesh, transform, locationIt, theme, props) {\n    var instanceCount = locationIt.instanceCount,\n        groupCount = locationIt.groupCount;\n    var positionIt = TextureMesh.Utils.createPositionIterator(textureMesh, transform);\n    var color = createColors(locationIt, positionIt, theme.color);\n    var marker = createMarkers(instanceCount * groupCount);\n    var overpaint = createEmptyOverpaint();\n    var transparency = createEmptyTransparency();\n    var clipping = createEmptyClipping();\n    var counts = {\n      drawCount: textureMesh.vertexCount,\n      vertexCount: textureMesh.vertexCount,\n      groupCount: groupCount,\n      instanceCount: instanceCount\n    };\n    var invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\n    return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({\n      uGeoTexDim: textureMesh.geoTextureDim,\n      tPosition: textureMesh.vertexTexture,\n      tGroup: textureMesh.groupTexture,\n      tNormal: textureMesh.normalTexture,\n      boundingSphere: ValueCell.create(boundingSphere),\n      invariantBoundingSphere: ValueCell.create(invariantBoundingSphere),\n      uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere))\n    }, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), {\n      dDoubleSided: ValueCell.create(props.doubleSided),\n      dFlatShaded: ValueCell.create(props.flatShaded),\n      dFlipSided: ValueCell.create(props.flipSided),\n      dIgnoreLight: ValueCell.create(props.ignoreLight),\n      dXrayShaded: ValueCell.create(props.xrayShaded),\n      dGeoTexture: ValueCell.create(true)\n    });\n  }\n\n  function createValuesSimple(textureMesh, props, colorValue, sizeValue, transform) {\n    var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\n\n    var p = __assign(__assign({}, PD.getDefaultValues(TextureMesh.Params)), props);\n\n    return createValues(textureMesh, s.transform, s.locationIterator, s.theme, p);\n  }\n\n  function updateValues(values, props) {\n    BaseGeometry.updateValues(values, props);\n    ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\n    ValueCell.updateIfChanged(values.dFlatShaded, props.flatShaded);\n    ValueCell.updateIfChanged(values.dFlipSided, props.flipSided);\n    ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\n    ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\n  }\n\n  function updateBoundingSphere(values, textureMesh) {\n    var invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);\n    var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\n\n    if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\n      ValueCell.update(values.boundingSphere, boundingSphere);\n    }\n\n    if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\n      ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\n      ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\n    }\n  }\n})(TextureMesh || (TextureMesh = {}));","map":{"version":3,"sources":["../../../../src/mol-geo/geometry/texture-mesh/texture-mesh.ts"],"names":[],"mappings":"AAAA;;;;AAIG;;AAEH,SAAS,SAAT,QAA0B,mBAA1B;AACA,SAAS,QAAT,QAAyB,4BAAzB;AACA,SAAS,eAAe,IAAI,EAA5B,QAAsC,oCAAtC;AACA,SAAS,gBAAT,QAAiC,yCAAjC;AAEA,SAAS,YAAT,QAA6B,eAA7B;AACA,SAAS,aAAT,QAA8B,gBAA9B;AAIA,SAAS,YAAT,QAA6B,SAA7B;AACA,SAAS,oBAAT,QAAqC,mBAArC;AACA,SAAS,uBAAT,QAAwC,sBAAxC;AAEA,SAAS,gCAAT,QAAiD,iCAAjD;AACA,SAAS,iBAAT,QAA2C,+BAA3C;AACA,SAAS,IAAT,EAAe,IAAf,QAA2B,kCAA3B;AACA,SAAS,mBAAT,QAAoC,kBAApC;AACA,SAAS,YAAT,QAA6B,6BAA7B;AAqBA,OAAM,IAAW,WAAX;;AAAN,CAAA,UAAiB,WAAjB,EAA4B;AACxB,MAAA,YAAA;AAAA;AAAA,cAAA;AAAA,aAAA,YAAA,GAAA;AACY,WAAA,KAAA,GAAQ,CAAR;AACA,WAAA,QAAA,GAAiF,EAAjF;AAoBX;;AAlBG,IAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,YAAA;AACI,aAAO,KAAK,QAAL,CAAc,KAAK,KAAnB,CAAP;AACH,KAFD;;AAIA,IAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,MAAJ,EAAqB,KAArB,EAAqC,MAArC,EAAoD;AAChD,WAAK,QAAL,CAAc,KAAK,KAAnB,IAA4B,MAAM,CAAC,MAAP,CAAc,KAAK,QAAL,CAAc,KAAK,KAAnB,KAA6B,EAA3C,EAA+C;AACvE,QAAA,MAAM,EAAA,MADiE;AAC/D,QAAA,KAAK,EAAA,KAD0D;AACxD,QAAA,MAAM,EAAA;AADkD,OAA/C,CAA5B;AAGA,WAAK,KAAL,GAAa,CAAC,KAAK,KAAL,GAAa,CAAd,IAAmB,CAAhC;AACH,KALD;;AAOA,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACI,WAAqB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,KAAK,QAA1B,EAAqB,EAAA,GAAA,EAAA,CAAA,MAArB,EAAqB,EAAA,EAArB,EAAoC;AAA/B,YAAM,MAAM,GAAA,EAAA,CAAA,EAAA,CAAZ;AACD,QAAA,MAAO,CAAC,MAAR,CAAe,OAAf;AACA,QAAA,MAAO,CAAC,KAAR,CAAc,OAAd;AACA,QAAA,MAAO,CAAC,MAAR,CAAe,OAAf;AACH;AACJ,KAND;;AAOJ,WAAA,YAAA;AAAC,GAtBD,EAAA;;AAAa,EAAA,WAAA,CAAA,YAAA,GAAY,YAAZ;;AAwBb,WAAgB,MAAhB,CAAuB,WAAvB,EAA4C,UAA5C,EAAgE,aAAhE,EAAwF,YAAxF,EAA+G,aAA/G,EAAuI,cAAvI,EAAiK,WAAjK,EAA0L;AACtL,QAAM,KAAK,GAAG,aAAa,CAAC,QAAd,EAAd;AACA,QAAM,MAAM,GAAG,aAAa,CAAC,SAAd,EAAf;;AACA,QAAI,WAAJ,EAAiB;AACb,MAAA,WAAW,CAAC,WAAZ,GAA0B,WAA1B;AACA,MAAA,WAAW,CAAC,UAAZ,GAAyB,UAAzB;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,WAAW,CAAC,aAA7B,EAA4C,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,aAAZ,CAA0B,GAA1B,CAA8B,KAAvC,EAA8C,KAA9C,EAAqD,MAArD,CAA5C;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,WAAW,CAAC,aAA7B,EAA4C,aAA5C;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,WAAW,CAAC,YAA7B,EAA2C,YAA3C;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,WAAW,CAAC,aAA7B,EAA4C,aAA5C;AACA,MAAA,WAAW,CAAC,YAAZ,CAAyB,GAAzB,CAA6B,aAA7B,EAA4C,YAA5C,EAA0D,aAA1D;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,WAAW,CAAC,cAA1B,EAA0C,cAA1C;AACA,aAAO,WAAP;AACH,KAVD,MAUO;AACH,aAAO;AACH,QAAA,IAAI,EAAE,cADH;AAEH,QAAA,WAAW,EAAA,WAFR;AAGH,QAAA,UAAU,EAAA,UAHP;AAIH,QAAA,aAAa,EAAE,SAAS,CAAC,MAAV,CAAiB,IAAI,CAAC,MAAL,CAAY,KAAZ,EAAmB,MAAnB,CAAjB,CAJZ;AAKH,QAAA,aAAa,EAAE,SAAS,CAAC,MAAV,CAAiB,aAAjB,CALZ;AAMH,QAAA,YAAY,EAAE,SAAS,CAAC,MAAV,CAAiB,YAAjB,CANX;AAOH,QAAA,aAAa,EAAE,SAAS,CAAC,MAAV,CAAiB,aAAjB,CAPZ;AAQH,QAAA,YAAY,EAAE,IAAI,YAAJ,EARX;AASH,QAAA,cAAc,EAAE,QAAQ,CAAC,KAAT,CAAe,cAAf;AATb,OAAP;AAWH;AACJ;;AA1Be,EAAA,WAAA,CAAA,MAAA,GAAM,MAAN;;AA4BhB,WAAgB,WAAhB,CAA4B,WAA5B,EAAqD;AACjD,QAAM,EAAE,GAAG,WAAW,GAAG,WAAW,CAAC,aAAZ,CAA0B,GAA1B,CAA8B,KAAjC,GAAyC,iBAAiB,EAAhF;AACA,QAAM,EAAE,GAAG,WAAW,GAAG,WAAW,CAAC,YAAZ,CAAyB,GAAzB,CAA6B,KAAhC,GAAwC,iBAAiB,EAA/E;AACA,QAAM,EAAE,GAAG,WAAW,GAAG,WAAW,CAAC,aAAZ,CAA0B,GAA1B,CAA8B,KAAjC,GAAyC,iBAAiB,EAAhF;AACA,QAAM,EAAE,GAAG,WAAW,GAAG,WAAW,CAAC,cAAf,GAAgC,QAAQ,EAA9D;AACA,WAAO,MAAM,CAAC,CAAD,EAAI,CAAJ,EAAO,EAAP,EAAW,EAAX,EAAe,EAAf,EAAmB,EAAnB,EAAuB,WAAvB,CAAb;AACH;;AANe,EAAA,WAAA,CAAA,WAAA,GAAW,WAAX;AAQH,EAAA,WAAA,CAAA,MAAA,GAAM,QAAA,CAAA,QAAA,CAAA,EAAA,EACZ,YAAY,CAAC,MADD,CAAA,EACO;AACtB,IAAA,WAAW,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB,YAAY,CAAC,sBAA/B,CADS;AAEtB,IAAA,SAAS,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB,YAAY,CAAC,eAA/B,CAFW;AAGtB,IAAA,UAAU,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB,YAAY,CAAC,eAA/B,CAHU;AAItB,IAAA,WAAW,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB,YAAY,CAAC,eAA/B,CAJS;AAKtB,IAAA,UAAU,EAAE,EAAE,CAAC,OAAH,CAAW,KAAX,EAAkB,YAAY,CAAC,eAA/B;AALU,GADP,CAAN;AAUA,EAAA,WAAA,CAAA,KAAA,GAA4C;AACrD,IAAA,MAAM,EAAA,WAAA,CAAA,MAD+C;AAErD,IAAA,WAAW,EAAA,WAF0C;AAGrD,IAAA,YAAY,EAAA,YAHyC;AAIrD,IAAA,kBAAkB,EAAA,kBAJmC;AAKrD,IAAA,YAAY,EAAA,YALyC;AAMrD,IAAA,oBAAoB,EAAA,oBANiC;AAOrD,IAAA,qBAAqB,EAAE,YAAY,CAAC,qBAPiB;AAQrD,IAAA,qBAAqB,EAAE,YAAY,CAAC,qBARiB;AASrD,IAAA,sBAAsB,EAAE,YAAA;AAAM,aAAA,gBAAgB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,YAAA;AAAM,eAAA,YAAA;AAAhC,OAAgB,CAAhB;AAA6C;AATtB,GAA5C;;AAYb,WAAS,YAAT,CAAsB,WAAtB,EAAgD,SAAhD,EAA0E,UAA1E,EAAwG,KAAxG,EAAsH,KAAtH,EAA8I;AAClI,QAAA,aAAa,GAAiB,UAAU,CAA3B,aAAb;AAAA,QAAe,UAAU,GAAK,UAAU,CAAf,UAAzB;AACR,QAAM,UAAU,GAAG,WAAA,CAAA,KAAA,CAAM,sBAAN,CAA6B,WAA7B,EAA0C,SAA1C,CAAnB;AAEA,QAAM,KAAK,GAAG,YAAY,CAAC,UAAD,EAAa,UAAb,EAAyB,KAAK,CAAC,KAA/B,CAA1B;AACA,QAAM,MAAM,GAAG,aAAa,CAAC,aAAa,GAAG,UAAjB,CAA5B;AACA,QAAM,SAAS,GAAG,oBAAoB,EAAtC;AACA,QAAM,YAAY,GAAG,uBAAuB,EAA5C;AACA,QAAM,QAAQ,GAAG,mBAAmB,EAApC;AAEA,QAAM,MAAM,GAAG;AAAE,MAAA,SAAS,EAAE,WAAW,CAAC,WAAzB;AAAsC,MAAA,WAAW,EAAE,WAAW,CAAC,WAA/D;AAA4E,MAAA,UAAU,EAAA,UAAtF;AAAwF,MAAA,aAAa,EAAA;AAArG,KAAf;AAEA,QAAM,uBAAuB,GAAG,QAAQ,CAAC,KAAT,CAAe,WAAW,CAAC,cAA3B,CAAhC;AACA,QAAM,cAAc,GAAG,gCAAgC,CAAC,uBAAD,EAA0B,SAAS,CAAC,UAAV,CAAqB,GAArB,CAAyB,KAAnD,EAA0D,aAA1D,CAAvD;AAEA,WAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA,QAAA,CAAA;AACI,MAAA,UAAU,EAAE,WAAW,CAAC,aAD5B;AAEI,MAAA,SAAS,EAAE,WAAW,CAAC,aAF3B;AAGI,MAAA,MAAM,EAAE,WAAW,CAAC,YAHxB;AAII,MAAA,OAAO,EAAE,WAAW,CAAC,aAJzB;AAMI,MAAA,cAAc,EAAE,SAAS,CAAC,MAAV,CAAiB,cAAjB,CANpB;AAOI,MAAA,uBAAuB,EAAE,SAAS,CAAC,MAAV,CAAiB,uBAAjB,CAP7B;AAQI,MAAA,wBAAwB,EAAE,SAAS,CAAC,MAAV,CAAiB,IAAI,CAAC,QAAL,CAAc,uBAAd,CAAjB;AAR9B,KAAA,EAUO,KAVP,CAAA,EAWO,MAXP,CAAA,EAYO,SAZP,CAAA,EAaO,YAbP,CAAA,EAcO,QAdP,CAAA,EAeO,SAfP,CAAA,EAiBO,YAAY,CAAC,YAAb,CAA0B,KAA1B,EAAiC,MAAjC,CAjBP,CAAA,EAiB+C;AAC3C,MAAA,YAAY,EAAE,SAAS,CAAC,MAAV,CAAiB,KAAK,CAAC,WAAvB,CAD6B;AAE3C,MAAA,WAAW,EAAE,SAAS,CAAC,MAAV,CAAiB,KAAK,CAAC,UAAvB,CAF8B;AAG3C,MAAA,UAAU,EAAE,SAAS,CAAC,MAAV,CAAiB,KAAK,CAAC,SAAvB,CAH+B;AAI3C,MAAA,YAAY,EAAE,SAAS,CAAC,MAAV,CAAiB,KAAK,CAAC,WAAvB,CAJ6B;AAK3C,MAAA,WAAW,EAAE,SAAS,CAAC,MAAV,CAAiB,KAAK,CAAC,UAAvB,CAL8B;AAM3C,MAAA,WAAW,EAAE,SAAS,CAAC,MAAV,CAAiB,IAAjB;AAN8B,KAjB/C,CAAA;AAyBH;;AAED,WAAS,kBAAT,CAA4B,WAA5B,EAAsD,KAAtD,EAAyF,UAAzF,EAA4G,SAA5G,EAA+H,SAA/H,EAAwJ;AACpJ,QAAM,CAAC,GAAG,YAAY,CAAC,YAAb,CAA0B,UAA1B,EAAsC,SAAtC,EAAiD,SAAjD,CAAV;;AACA,QAAM,CAAC,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,EAAE,CAAC,gBAAH,CAAoB,WAAA,CAAA,MAApB,CAAR,CAAA,EAAwC,KAAxC,CAAP;;AACA,WAAO,YAAY,CAAC,WAAD,EAAc,CAAC,CAAC,SAAhB,EAA2B,CAAC,CAAC,gBAA7B,EAA+C,CAAC,CAAC,KAAjD,EAAwD,CAAxD,CAAnB;AACH;;AAED,WAAS,YAAT,CAAsB,MAAtB,EAAiD,KAAjD,EAAyE;AACrE,IAAA,YAAY,CAAC,YAAb,CAA0B,MAA1B,EAAkC,KAAlC;AACA,IAAA,SAAS,CAAC,eAAV,CAA0B,MAAM,CAAC,YAAjC,EAA+C,KAAK,CAAC,WAArD;AACA,IAAA,SAAS,CAAC,eAAV,CAA0B,MAAM,CAAC,WAAjC,EAA8C,KAAK,CAAC,UAApD;AACA,IAAA,SAAS,CAAC,eAAV,CAA0B,MAAM,CAAC,UAAjC,EAA6C,KAAK,CAAC,SAAnD;AACA,IAAA,SAAS,CAAC,eAAV,CAA0B,MAAM,CAAC,YAAjC,EAA+C,KAAK,CAAC,WAArD;AACA,IAAA,SAAS,CAAC,eAAV,CAA0B,MAAM,CAAC,WAAjC,EAA8C,KAAK,CAAC,UAApD;AACH;;AAED,WAAS,oBAAT,CAA8B,MAA9B,EAAyD,WAAzD,EAAiF;AAC7E,QAAM,uBAAuB,GAAG,QAAQ,CAAC,KAAT,CAAe,WAAW,CAAC,cAA3B,CAAhC;AACA,QAAM,cAAc,GAAG,gCAAgC,CAAC,uBAAD,EAA0B,MAAM,CAAC,UAAP,CAAkB,GAAlB,CAAsB,KAAhD,EAAuD,MAAM,CAAC,aAAP,CAAqB,GAArB,CAAyB,KAAhF,CAAvD;;AAEA,QAAI,CAAC,QAAQ,CAAC,MAAT,CAAgB,cAAhB,EAAgC,MAAM,CAAC,cAAP,CAAsB,GAAtB,CAA0B,KAA1D,CAAL,EAAuE;AACnE,MAAA,SAAS,CAAC,MAAV,CAAiB,MAAM,CAAC,cAAxB,EAAwC,cAAxC;AACH;;AACD,QAAI,CAAC,QAAQ,CAAC,MAAT,CAAgB,uBAAhB,EAAyC,MAAM,CAAC,uBAAP,CAA+B,GAA/B,CAAmC,KAA5E,CAAL,EAAyF;AACrF,MAAA,SAAS,CAAC,MAAV,CAAiB,MAAM,CAAC,uBAAxB,EAAiD,uBAAjD;AACA,MAAA,SAAS,CAAC,MAAV,CAAiB,MAAM,CAAC,wBAAxB,EAAkD,IAAI,CAAC,UAAL,CAAgB,MAAM,CAAC,wBAAP,CAAgC,GAAhC,CAAoC,KAApD,EAA2D,uBAA3D,CAAlD;AACH;AACJ;AACJ,CAxJD,EAAiB,WAAW,KAAX,WAAW,GAAA,EAAA,CAA5B","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2021 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { ValueCell } from '../../../mol-util';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { LocationIterator } from '../../../mol-geo/util/location-iterator';\r\nimport { createColors } from '../color-data';\r\nimport { createMarkers } from '../marker-data';\r\nimport { BaseGeometry } from '../base';\r\nimport { createEmptyOverpaint } from '../overpaint-data';\r\nimport { createEmptyTransparency } from '../transparency-data';\r\nimport { calculateTransformBoundingSphere } from '../../../mol-gl/renderable/util';\r\nimport { createNullTexture } from '../../../mol-gl/webgl/texture';\r\nimport { Vec2, Vec4 } from '../../../mol-math/linear-algebra';\r\nimport { createEmptyClipping } from '../clipping-data';\r\nimport { NullLocation } from '../../../mol-model/location';\r\nexport var TextureMesh;\r\n(function (TextureMesh) {\r\n    var DoubleBuffer = /** @class */ (function () {\r\n        function DoubleBuffer() {\r\n            this.index = 0;\r\n            this.textures = [];\r\n        }\r\n        DoubleBuffer.prototype.get = function () {\r\n            return this.textures[this.index];\r\n        };\r\n        DoubleBuffer.prototype.set = function (vertex, group, normal) {\r\n            this.textures[this.index] = Object.assign(this.textures[this.index] || {}, {\r\n                vertex: vertex,\r\n                group: group,\r\n                normal: normal\r\n            });\r\n            this.index = (this.index + 1) % 2;\r\n        };\r\n        DoubleBuffer.prototype.destroy = function () {\r\n            for (var _i = 0, _a = this.textures; _i < _a.length; _i++) {\r\n                var buffer = _a[_i];\r\n                buffer.vertex.destroy();\r\n                buffer.group.destroy();\r\n                buffer.normal.destroy();\r\n            }\r\n        };\r\n        return DoubleBuffer;\r\n    }());\r\n    TextureMesh.DoubleBuffer = DoubleBuffer;\r\n    function create(vertexCount, groupCount, vertexTexture, groupTexture, normalTexture, boundingSphere, textureMesh) {\r\n        var width = vertexTexture.getWidth();\r\n        var height = vertexTexture.getHeight();\r\n        if (textureMesh) {\r\n            textureMesh.vertexCount = vertexCount;\r\n            textureMesh.groupCount = groupCount;\r\n            ValueCell.update(textureMesh.geoTextureDim, Vec2.set(textureMesh.geoTextureDim.ref.value, width, height));\r\n            ValueCell.update(textureMesh.vertexTexture, vertexTexture);\r\n            ValueCell.update(textureMesh.groupTexture, groupTexture);\r\n            ValueCell.update(textureMesh.normalTexture, normalTexture);\r\n            textureMesh.doubleBuffer.set(vertexTexture, groupTexture, normalTexture);\r\n            Sphere3D.copy(textureMesh.boundingSphere, boundingSphere);\r\n            return textureMesh;\r\n        }\r\n        else {\r\n            return {\r\n                kind: 'texture-mesh',\r\n                vertexCount: vertexCount,\r\n                groupCount: groupCount,\r\n                geoTextureDim: ValueCell.create(Vec2.create(width, height)),\r\n                vertexTexture: ValueCell.create(vertexTexture),\r\n                groupTexture: ValueCell.create(groupTexture),\r\n                normalTexture: ValueCell.create(normalTexture),\r\n                doubleBuffer: new DoubleBuffer(),\r\n                boundingSphere: Sphere3D.clone(boundingSphere),\r\n            };\r\n        }\r\n    }\r\n    TextureMesh.create = create;\r\n    function createEmpty(textureMesh) {\r\n        var vt = textureMesh ? textureMesh.vertexTexture.ref.value : createNullTexture();\r\n        var gt = textureMesh ? textureMesh.groupTexture.ref.value : createNullTexture();\r\n        var nt = textureMesh ? textureMesh.normalTexture.ref.value : createNullTexture();\r\n        var bs = textureMesh ? textureMesh.boundingSphere : Sphere3D();\r\n        return create(0, 0, vt, gt, nt, bs, textureMesh);\r\n    }\r\n    TextureMesh.createEmpty = createEmpty;\r\n    TextureMesh.Params = __assign(__assign({}, BaseGeometry.Params), { doubleSided: PD.Boolean(false, BaseGeometry.CustomQualityParamInfo), flipSided: PD.Boolean(false, BaseGeometry.ShadingCategory), flatShaded: PD.Boolean(false, BaseGeometry.ShadingCategory), ignoreLight: PD.Boolean(false, BaseGeometry.ShadingCategory), xrayShaded: PD.Boolean(false, BaseGeometry.ShadingCategory) });\r\n    TextureMesh.Utils = {\r\n        Params: TextureMesh.Params,\r\n        createEmpty: createEmpty,\r\n        createValues: createValues,\r\n        createValuesSimple: createValuesSimple,\r\n        updateValues: updateValues,\r\n        updateBoundingSphere: updateBoundingSphere,\r\n        createRenderableState: BaseGeometry.createRenderableState,\r\n        updateRenderableState: BaseGeometry.updateRenderableState,\r\n        createPositionIterator: function () { return LocationIterator(1, 1, 1, function () { return NullLocation; }); }\r\n    };\r\n    function createValues(textureMesh, transform, locationIt, theme, props) {\r\n        var instanceCount = locationIt.instanceCount, groupCount = locationIt.groupCount;\r\n        var positionIt = TextureMesh.Utils.createPositionIterator(textureMesh, transform);\r\n        var color = createColors(locationIt, positionIt, theme.color);\r\n        var marker = createMarkers(instanceCount * groupCount);\r\n        var overpaint = createEmptyOverpaint();\r\n        var transparency = createEmptyTransparency();\r\n        var clipping = createEmptyClipping();\r\n        var counts = { drawCount: textureMesh.vertexCount, vertexCount: textureMesh.vertexCount, groupCount: groupCount, instanceCount: instanceCount };\r\n        var invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, transform.aTransform.ref.value, instanceCount);\r\n        return __assign(__assign(__assign(__assign(__assign(__assign(__assign(__assign({ uGeoTexDim: textureMesh.geoTextureDim, tPosition: textureMesh.vertexTexture, tGroup: textureMesh.groupTexture, tNormal: textureMesh.normalTexture, boundingSphere: ValueCell.create(boundingSphere), invariantBoundingSphere: ValueCell.create(invariantBoundingSphere), uInvariantBoundingSphere: ValueCell.create(Vec4.ofSphere(invariantBoundingSphere)) }, color), marker), overpaint), transparency), clipping), transform), BaseGeometry.createValues(props, counts)), { dDoubleSided: ValueCell.create(props.doubleSided), dFlatShaded: ValueCell.create(props.flatShaded), dFlipSided: ValueCell.create(props.flipSided), dIgnoreLight: ValueCell.create(props.ignoreLight), dXrayShaded: ValueCell.create(props.xrayShaded), dGeoTexture: ValueCell.create(true) });\r\n    }\r\n    function createValuesSimple(textureMesh, props, colorValue, sizeValue, transform) {\r\n        var s = BaseGeometry.createSimple(colorValue, sizeValue, transform);\r\n        var p = __assign(__assign({}, PD.getDefaultValues(TextureMesh.Params)), props);\r\n        return createValues(textureMesh, s.transform, s.locationIterator, s.theme, p);\r\n    }\r\n    function updateValues(values, props) {\r\n        BaseGeometry.updateValues(values, props);\r\n        ValueCell.updateIfChanged(values.dDoubleSided, props.doubleSided);\r\n        ValueCell.updateIfChanged(values.dFlatShaded, props.flatShaded);\r\n        ValueCell.updateIfChanged(values.dFlipSided, props.flipSided);\r\n        ValueCell.updateIfChanged(values.dIgnoreLight, props.ignoreLight);\r\n        ValueCell.updateIfChanged(values.dXrayShaded, props.xrayShaded);\r\n    }\r\n    function updateBoundingSphere(values, textureMesh) {\r\n        var invariantBoundingSphere = Sphere3D.clone(textureMesh.boundingSphere);\r\n        var boundingSphere = calculateTransformBoundingSphere(invariantBoundingSphere, values.aTransform.ref.value, values.instanceCount.ref.value);\r\n        if (!Sphere3D.equals(boundingSphere, values.boundingSphere.ref.value)) {\r\n            ValueCell.update(values.boundingSphere, boundingSphere);\r\n        }\r\n        if (!Sphere3D.equals(invariantBoundingSphere, values.invariantBoundingSphere.ref.value)) {\r\n            ValueCell.update(values.invariantBoundingSphere, invariantBoundingSphere);\r\n            ValueCell.update(values.uInvariantBoundingSphere, Vec4.fromSphere(values.uInvariantBoundingSphere.ref.value, invariantBoundingSphere));\r\n        }\r\n    }\r\n})(TextureMesh || (TextureMesh = {}));\r\n//# sourceMappingURL=texture-mesh.js.map"]},"metadata":{},"sourceType":"module"}