/**
 * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author David Sehnal <david.sehnal@gmail.com>
 * @author Alexander Rose <alexander.rose@weirdbyte.de>
 */
import { __assign } from "tslib";
import { Structure } from '../../structure';
import { Unit } from '../../unit';
import { getElementIdx, getElementPairThreshold, getElementThreshold, isHydrogen, MetalsSet, DefaultBondComputationProps } from './common';
import { InterUnitBonds } from './data';
import { SortedArray } from '../../../../../mol-data/int';
import { Vec3, Mat4 } from '../../../../../mol-math/linear-algebra';
import { getInterBondOrderFromTable } from '../../../model/properties/atomic/bonds';
import { IndexPairBonds } from '../../../../../mol-model-formats/structure/property/bonds/index-pair';
import { InterUnitGraph } from '../../../../../mol-math/graph/inter-unit-graph';
import { StructConn } from '../../../../../mol-model-formats/structure/property/bonds/struct_conn';
import { equalEps } from '../../../../../mol-math/linear-algebra/3d/common';
import { Model } from '../../../model';
var tmpDistVecA = Vec3();
var tmpDistVecB = Vec3();
function getDistance(unitA, indexA, unitB, indexB) {
    unitA.conformation.position(indexA, tmpDistVecA);
    unitB.conformation.position(indexB, tmpDistVecB);
    return Vec3.distance(tmpDistVecA, tmpDistVecB);
}
var _imageTransform = Mat4();
var _imageA = Vec3();
function findPairBonds(unitA, unitB, props, builder) {
    var maxRadius = props.maxRadius;
    var atomsA = unitA.elements, residueIndexA = unitA.residueIndex;
    var _a = unitA.model.atomicConformation, xA = _a.x, yA = _a.y, zA = _a.z;
    var atomsB = unitB.elements, residueIndexB = unitB.residueIndex;
    var atomCount = unitA.elements.length;
    var _b = unitA.model.atomicHierarchy.atoms, type_symbolA = _b.type_symbol, label_alt_idA = _b.label_alt_id, label_atom_idA = _b.label_atom_id, label_comp_idA = _b.label_comp_id;
    var _c = unitB.model.atomicHierarchy.atoms, type_symbolB = _c.type_symbol, label_alt_idB = _c.label_alt_id, label_atom_idB = _c.label_atom_id, label_comp_idB = _c.label_comp_id;
    var auth_seq_idA = unitA.model.atomicHierarchy.residues.auth_seq_id;
    var auth_seq_idB = unitB.model.atomicHierarchy.residues.auth_seq_id;
    var occupancyA = unitA.model.atomicConformation.occupancy;
    var occupancyB = unitB.model.atomicConformation.occupancy;
    var hasOccupancy = occupancyA.isDefined && occupancyB.isDefined;
    var structConn = unitA.model === unitB.model && StructConn.Provider.get(unitA.model);
    var indexPairs = !props.forceCompute && unitA.model === unitB.model && IndexPairBonds.Provider.get(unitA.model);
    var sourceIndex = unitA.model.atomicHierarchy.atomSourceIndex;
    var invertedIndex = (indexPairs ? Model.getInvertedAtomSourceIndex(unitB.model) : { invertedIndex: void 0 }).invertedIndex;
    var structConnExhaustive = unitA.model === unitB.model && StructConn.isExhaustive(unitA.model);
    // the lookup queries need to happen in the "unitB space".
    // that means _imageA = inverseOperB(operA(aI))
    var imageTransform = Mat4.mul(_imageTransform, unitB.conformation.operator.inverse, unitA.conformation.operator.matrix);
    var isNotIdentity = !Mat4.isIdentity(imageTransform);
    var _d = unitB.boundary.sphere, bCenter = _d.center, bRadius = _d.radius;
    var testDistanceSq = (bRadius + maxRadius) * (bRadius + maxRadius);
    builder.startUnitPair(unitA.id, unitB.id);
    for (var _aI = 0; _aI < atomCount; _aI++) {
        var aI = atomsA[_aI];
        Vec3.set(_imageA, xA[aI], yA[aI], zA[aI]);
        if (isNotIdentity)
            Vec3.transformMat4(_imageA, _imageA, imageTransform);
        if (Vec3.squaredDistance(_imageA, bCenter) > testDistanceSq)
            continue;
        if (!props.forceCompute && indexPairs) {
            var maxDistance = indexPairs.maxDistance;
            var _e = indexPairs.bonds, offset = _e.offset, b = _e.b, _f = _e.edgeProps, order = _f.order, distance = _f.distance, flag = _f.flag;
            var srcA = sourceIndex.value(aI);
            for (var i = offset[srcA], il = offset[srcA + 1]; i < il; ++i) {
                var bI = invertedIndex[b[i]];
                var _bI = SortedArray.indexOf(unitB.elements, bI);
                if (_bI < 0)
                    continue;
                if (type_symbolA.value(aI) === 'H' && type_symbolB.value(bI) === 'H')
                    continue;
                var d = distance[i];
                var dist = getDistance(unitA, aI, unitB, bI);
                if ((d !== -1 && equalEps(dist, d, 0.5)) || dist < maxDistance) {
                    builder.add(_aI, _bI, { order: order[i], flag: flag[i] });
                }
            }
            continue; // assume `indexPairs` supplies all bonds
        }
        var structConnEntries = props.forceCompute ? void 0 : structConn && structConn.byAtomIndex.get(aI);
        if (structConnEntries && structConnEntries.length) {
            var added = false;
            for (var _i = 0, structConnEntries_1 = structConnEntries; _i < structConnEntries_1.length; _i++) {
                var se = structConnEntries_1[_i];
                var partnerA = se.partnerA, partnerB = se.partnerB;
                var p = partnerA.atomIndex === aI ? partnerB : partnerA;
                var _bI = SortedArray.indexOf(unitB.elements, p.atomIndex);
                if (_bI < 0)
                    continue;
                // check if the bond is within MAX_RADIUS for this pair of units
                if (getDistance(unitA, aI, unitB, p.atomIndex) > maxRadius)
                    continue;
                builder.add(_aI, _bI, { order: se.order, flag: se.flags });
                added = true;
            }
            // assume, for an atom, that if any inter unit bond is given
            // all are given and thus we don't need to compute any other
            if (added)
                continue;
        }
        if (structConnExhaustive)
            continue;
        var occA = occupancyA.value(aI);
        var lookup3d = unitB.lookup3d;
        var _g = lookup3d.find(_imageA[0], _imageA[1], _imageA[2], maxRadius), indices = _g.indices, count = _g.count, squaredDistances = _g.squaredDistances;
        if (count === 0)
            continue;
        var aeI = getElementIdx(type_symbolA.value(aI));
        var isHa = isHydrogen(aeI);
        var thresholdA = getElementThreshold(aeI);
        var altA = label_alt_idA.value(aI);
        var metalA = MetalsSet.has(aeI);
        var atomIdA = label_atom_idA.value(aI);
        var compIdA = label_comp_idA.value(residueIndexA[aI]);
        for (var ni = 0; ni < count; ni++) {
            var _bI = indices[ni];
            var bI = atomsB[_bI];
            var altB = label_alt_idB.value(bI);
            if (altA && altB && altA !== altB)
                continue;
            // Do not include bonds between images of the same residue with partial occupancy.
            // TODO: is this condition good enough?
            // - It works for cases like 3WQJ (label_asym_id: I) which have partial occupancy.
            // - Does NOT work for cases like 1RB8 (DC 7) with full occupancy.
            if (hasOccupancy && occupancyB.value(bI) < 1 && occA < 1) {
                if (auth_seq_idA.value(aI) === auth_seq_idB.value(bI)) {
                    continue;
                }
            }
            var beI = getElementIdx(type_symbolB.value(bI));
            var isHb = isHydrogen(beI);
            if (isHa && isHb)
                continue;
            var isMetal = (metalA || MetalsSet.has(beI)) && !(isHa || isHb);
            var dist = Math.sqrt(squaredDistances[ni]);
            if (dist === 0)
                continue;
            var thresholdAB = getElementPairThreshold(aeI, beI);
            var pairingThreshold = thresholdAB > 0
                ? thresholdAB
                : beI < 0
                    ? thresholdA
                    : (thresholdA + getElementThreshold(beI)) / 1.95; // not sure if avg or min but max is too big
            if (dist <= pairingThreshold) {
                var atomIdB = label_atom_idB.value(bI);
                var compIdB = label_comp_idB.value(residueIndexB[bI]);
                builder.add(_aI, _bI, {
                    order: getInterBondOrderFromTable(compIdA, compIdB, atomIdA, atomIdB),
                    flag: (isMetal ? 2 /* MetallicCoordination */ : 1 /* Covalent */) | 32 /* Computed */
                });
            }
        }
    }
    builder.finishUnitPair();
}
var DefaultInterBondComputationProps = __assign(__assign({}, DefaultBondComputationProps), { ignoreWater: true });
function findBonds(structure, props) {
    var builder = new InterUnitGraph.Builder();
    var hasIndexPairBonds = structure.models.some(function (m) { return IndexPairBonds.Provider.get(m); });
    if (props.noCompute || (structure.isCoarseGrained && !hasIndexPairBonds)) {
        // TODO add function that only adds bonds defined in structConn and avoids using
        //      structure.lookup and unit.lookup (expensive for large structure and not
        //      needed for archival files or files with an MD topology)
        return new InterUnitBonds(builder.getMap());
    }
    Structure.eachUnitPair(structure, function (unitA, unitB) {
        findPairBonds(unitA, unitB, props, builder);
    }, {
        maxRadius: props.maxRadius,
        validUnit: function (unit) { return Unit.isAtomic(unit); },
        validUnitPair: function (unitA, unitB) { return props.validUnitPair(structure, unitA, unitB); }
    });
    return new InterUnitBonds(builder.getMap());
}
function computeInterUnitBonds(structure, props) {
    var p = __assign(__assign({}, DefaultInterBondComputationProps), props);
    return findBonds(structure, __assign(__assign({}, p), { validUnitPair: (props && props.validUnitPair) || (function (s, a, b) {
            var mtA = a.model.atomicHierarchy.derived.residue.moleculeType;
            var mtB = b.model.atomicHierarchy.derived.residue.moleculeType;
            var notWater = ((!Unit.isAtomic(a) || mtA[a.residueIndex[a.elements[0]]] !== 2 /* Water */) &&
                (!Unit.isAtomic(b) || mtB[b.residueIndex[b.elements[0]]] !== 2 /* Water */));
            return Structure.validUnitPair(s, a, b) && (notWater || !p.ignoreWater);
        }) }));
}
export { computeInterUnitBonds };
//# sourceMappingURL=inter-compute.js.map