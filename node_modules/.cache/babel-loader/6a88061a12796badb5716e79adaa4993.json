{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __awaiter, __generator } from \"tslib\";\nimport { Model } from '../../../../mol-model/structure';\nimport { MmcifFormat } from '../../../../mol-model-formats/structure/mmcif';\nimport { PluginConfig } from '../../../config';\nexport function getStreamingMethod(s, defaultKind) {\n  if (defaultKind === void 0) {\n    defaultKind = 'x-ray';\n  }\n\n  if (!s) return defaultKind;\n  var model = s.models[0];\n  if (!MmcifFormat.is(model.sourceData)) return defaultKind; // Prefer EMDB entries over structure-factors (SF) e.g. for 'ELECTRON CRYSTALLOGRAPHY' entries\n  // like 6AXZ or 6KJ3 for which EMDB entries are available but map calculation from SF is hard.\n\n  if (Model.hasEmMap(model)) return 'em';\n  if (Model.hasXrayMap(model)) return 'x-ray'; // Fallbacks based on experimental method\n\n  if (Model.isFromEm(model)) return 'em';\n  if (Model.isFromXray(model)) return 'x-ray';\n  return defaultKind;\n}\n/** Returns EMD ID when available, otherwise falls back to PDB ID */\n\nexport function getEmIds(model) {\n  var ids = [];\n  if (!MmcifFormat.is(model.sourceData)) return [model.entryId];\n  var _a = model.sourceData.data.db.pdbx_database_related,\n      db_id = _a.db_id,\n      db_name = _a.db_name,\n      content_type = _a.content_type;\n  if (!db_name.isDefined) return [model.entryId];\n\n  for (var i = 0, il = db_name.rowCount; i < il; ++i) {\n    if (db_name.value(i).toUpperCase() === 'EMDB' && content_type.value(i) === 'associated EM volume') {\n      ids.push(db_id.value(i));\n    }\n  }\n\n  return ids;\n}\nexport function getXrayIds(model) {\n  return [model.entryId];\n}\nexport function getIds(method, s) {\n  if (!s || !s.models.length) return [];\n  var model = s.models[0];\n\n  switch (method) {\n    case 'em':\n      return getEmIds(model);\n\n    case 'x-ray':\n      return getXrayIds(model);\n  }\n}\nexport function getContourLevel(provider, plugin, taskCtx, emdbId) {\n  return __awaiter(this, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n      switch (provider) {\n        case 'emdb':\n          return [2\n          /*return*/\n          , getContourLevelEmdb(plugin, taskCtx, emdbId)];\n\n        case 'pdbe':\n          return [2\n          /*return*/\n          , getContourLevelPdbe(plugin, taskCtx, emdbId)];\n      }\n\n      return [2\n      /*return*/\n      ];\n    });\n  });\n}\nexport function getContourLevelEmdb(plugin, taskCtx, emdbId) {\n  return __awaiter(this, void 0, void 0, function () {\n    var emdbHeaderServer, header, map, contourLevel;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          emdbHeaderServer = plugin.config.get(PluginConfig.VolumeStreaming.EmdbHeaderServer);\n          return [4\n          /*yield*/\n          , plugin.fetch({\n            url: emdbHeaderServer + \"/\" + emdbId.toUpperCase() + \"/header/\" + emdbId.toLowerCase() + \".xml\",\n            type: 'xml'\n          }).runInContext(taskCtx)];\n\n        case 1:\n          header = _a.sent();\n          map = header.getElementsByTagName('map')[0];\n          contourLevel = parseFloat(map.getElementsByTagName('contourLevel')[0].textContent);\n          return [2\n          /*return*/\n          , contourLevel];\n      }\n    });\n  });\n}\nexport function getContourLevelPdbe(plugin, taskCtx, emdbId) {\n  var _a, _b, _c, _d;\n\n  return __awaiter(this, void 0, void 0, function () {\n    var header, contours;\n    return __generator(this, function (_e) {\n      switch (_e.label) {\n        case 0:\n          // TODO: parametrize URL in plugin settings?\n          emdbId = emdbId.toUpperCase();\n          return [4\n          /*yield*/\n          , plugin.fetch({\n            url: \"https://www.ebi.ac.uk/emdb/api/entry/map/\" + emdbId,\n            type: 'json'\n          }).runInContext(taskCtx)];\n\n        case 1:\n          header = _e.sent();\n          contours = (_b = (_a = header === null || header === void 0 ? void 0 : header.map) === null || _a === void 0 ? void 0 : _a.contour_list) === null || _b === void 0 ? void 0 : _b.contour;\n\n          if (!contours || contours.length === 0) {\n            // try fallback to the old API\n            return [2\n            /*return*/\n            , getContourLevelPdbeLegacy(plugin, taskCtx, emdbId)];\n          }\n\n          return [2\n          /*return*/\n          , (_d = (_c = contours.find(function (c) {\n            return c.primary;\n          })) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : contours[0].level];\n      }\n    });\n  });\n}\n\nfunction getContourLevelPdbeLegacy(plugin, taskCtx, emdbId) {\n  var _a, _b, _c;\n\n  return __awaiter(this, void 0, void 0, function () {\n    var header, emdbEntry, contourLevel;\n    return __generator(this, function (_d) {\n      switch (_d.label) {\n        case 0:\n          // TODO: parametrize URL in plugin settings?\n          emdbId = emdbId.toUpperCase();\n          return [4\n          /*yield*/\n          , plugin.fetch({\n            url: \"https://www.ebi.ac.uk/pdbe/api/emdb/entry/map/\" + emdbId,\n            type: 'json'\n          }).runInContext(taskCtx)];\n\n        case 1:\n          header = _d.sent();\n          emdbEntry = header === null || header === void 0 ? void 0 : header[emdbId];\n          contourLevel = void 0;\n\n          if (((_c = (_b = (_a = emdbEntry === null || emdbEntry === void 0 ? void 0 : emdbEntry[0]) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.contour_level) === null || _c === void 0 ? void 0 : _c.value) !== void 0) {\n            contourLevel = +emdbEntry[0].map.contour_level.value;\n          }\n\n          return [2\n          /*return*/\n          , contourLevel];\n      }\n    });\n  });\n}\n\nexport function getEmdbIds(plugin, taskCtx, pdbId) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function () {\n    var summary, summaryEntry, emdbIds, emdb;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , plugin.fetch({\n            url: \"https://www.ebi.ac.uk/pdbe/api/pdb/entry/summary/\" + pdbId,\n            type: 'json'\n          }).runInContext(taskCtx)];\n\n        case 1:\n          summary = _b.sent();\n          summaryEntry = summary === null || summary === void 0 ? void 0 : summary[pdbId];\n          emdbIds = [];\n\n          if ((_a = summaryEntry === null || summaryEntry === void 0 ? void 0 : summaryEntry[0]) === null || _a === void 0 ? void 0 : _a.related_structures) {\n            emdb = summaryEntry[0].related_structures.filter(function (s) {\n              return s.resource === 'EMDB' && s.relationship === 'associated EM volume';\n            });\n\n            if (!emdb.length) {\n              throw new Error(\"No related EMDB entry found for '\" + pdbId + \"'.\");\n            }\n\n            emdbIds.push.apply(emdbIds, emdb.map(function (e) {\n              return e.accession;\n            }));\n          } else {\n            throw new Error(\"No related EMDB entry found for '\" + pdbId + \"'.\");\n          }\n\n          return [2\n          /*return*/\n          , emdbIds];\n      }\n    });\n  });\n}","map":{"version":3,"sources":["../../../../../src/mol-plugin/behavior/dynamic/volume-streaming/util.ts"],"names":[],"mappings":"AAAA;;;;;AAKG;;AAEH,SAAoB,KAApB,QAAiC,iCAAjC;AAIA,SAAS,WAAT,QAA4B,+CAA5B;AACA,SAAS,YAAT,QAA6B,iBAA7B;AAEA,OAAM,SAAU,kBAAV,CAA6B,CAA7B,EAA4C,WAA5C,EAAwF;AAA5C,MAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,WAAA,GAAA,OAAA;AAA4C;;AAC1F,MAAI,CAAC,CAAL,EAAQ,OAAO,WAAP;AAER,MAAM,KAAK,GAAG,CAAC,CAAC,MAAF,CAAS,CAAT,CAAd;AACA,MAAI,CAAC,WAAW,CAAC,EAAZ,CAAe,KAAK,CAAC,UAArB,CAAL,EAAuC,OAAO,WAAP,CAJmD,CAM1F;AACA;;AACA,MAAI,KAAK,CAAC,QAAN,CAAe,KAAf,CAAJ,EAA2B,OAAO,IAAP;AAC3B,MAAI,KAAK,CAAC,UAAN,CAAiB,KAAjB,CAAJ,EAA6B,OAAO,OAAP,CAT6D,CAW1F;;AACA,MAAI,KAAK,CAAC,QAAN,CAAe,KAAf,CAAJ,EAA2B,OAAO,IAAP;AAC3B,MAAI,KAAK,CAAC,UAAN,CAAiB,KAAjB,CAAJ,EAA6B,OAAO,OAAP;AAC7B,SAAO,WAAP;AACH;AAED;;AACA,OAAM,SAAU,QAAV,CAAmB,KAAnB,EAA+B;AACjC,MAAM,GAAG,GAAa,EAAtB;AACA,MAAI,CAAC,WAAW,CAAC,EAAZ,CAAe,KAAK,CAAC,UAArB,CAAL,EAAuC,OAAO,CAAC,KAAK,CAAC,OAAP,CAAP;AAEjC,MAAA,EAAA,GAAmC,KAAK,CAAC,UAAN,CAAiB,IAAjB,CAAsB,EAAtB,CAAyB,qBAA5D;AAAA,MAAE,KAAK,GAAA,EAAA,CAAA,KAAP;AAAA,MAAS,OAAO,GAAA,EAAA,CAAA,OAAhB;AAAA,MAAkB,YAAY,GAAA,EAAA,CAAA,YAA9B;AACN,MAAI,CAAC,OAAO,CAAC,SAAb,EAAwB,OAAO,CAAC,KAAK,CAAC,OAAP,CAAP;;AAExB,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,OAAO,CAAC,QAA7B,EAAuC,CAAC,GAAG,EAA3C,EAA+C,EAAE,CAAjD,EAAoD;AAChD,QAAI,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,WAAjB,OAAmC,MAAnC,IAA6C,YAAY,CAAC,KAAb,CAAmB,CAAnB,MAA0B,sBAA3E,EAAmG;AAC/F,MAAA,GAAG,CAAC,IAAJ,CAAS,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAT;AACH;AACJ;;AAED,SAAO,GAAP;AACH;AAED,OAAM,SAAU,UAAV,CAAqB,KAArB,EAAiC;AACnC,SAAO,CAAC,KAAK,CAAC,OAAP,CAAP;AACH;AAED,OAAM,SAAU,MAAV,CAAiB,MAAjB,EAAgD,CAAhD,EAA6D;AAC/D,MAAI,CAAC,CAAD,IAAM,CAAC,CAAC,CAAC,MAAF,CAAS,MAApB,EAA4B,OAAO,EAAP;AAC5B,MAAM,KAAK,GAAG,CAAC,CAAC,MAAF,CAAS,CAAT,CAAd;;AACA,UAAQ,MAAR;AACI,SAAK,IAAL;AAAW,aAAO,QAAQ,CAAC,KAAD,CAAf;;AACX,SAAK,OAAL;AAAc,aAAO,UAAU,CAAC,KAAD,CAAjB;AAFlB;AAIH;AAED,OAAM,SAAgB,eAAhB,CAAgC,QAAhC,EAA2D,MAA3D,EAAkF,OAAlF,EAA2G,MAA3G,EAAyH;;;AAC3H,cAAQ,QAAR;AACI,aAAK,MAAL;AAAa,iBAAA,CAAA;AAAA;AAAA,YAAO,mBAAmB,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAA1B,CAAA;;AACb,aAAK,MAAL;AAAa,iBAAA,CAAA;AAAA;AAAA,YAAO,mBAAmB,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAA1B,CAAA;AAFjB;;;;;;;AAIH;AAED,OAAM,SAAgB,mBAAhB,CAAoC,MAApC,EAA2D,OAA3D,EAAoF,MAApF,EAAkG;;;;;;AAC9F,UAAA,gBAAgB,GAAG,MAAM,CAAC,MAAP,CAAc,GAAd,CAAkB,YAAY,CAAC,eAAb,CAA6B,gBAA/C,CAAnB;AACS,iBAAA,CAAA;AAAA;AAAA,YAAM,MAAM,CAAC,KAAP,CAAa;AAAE,YAAA,GAAG,EAAK,gBAAgB,GAAA,GAAhB,GAAoB,MAAM,CAAC,WAAP,EAApB,GAAwC,UAAxC,GAAmD,MAAM,CAAC,WAAP,EAAnD,GAAuE,MAAjF;AAAyF,YAAA,IAAI,EAAE;AAA/F,WAAb,EAAqH,YAArH,CAAkI,OAAlI,CAAN,CAAA;;;AAAT,UAAA,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT;AACA,UAAA,GAAG,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAA5B,EAAmC,CAAnC,CAAN;AACA,UAAA,YAAY,GAAG,UAAU,CAAC,GAAG,CAAC,oBAAJ,CAAyB,cAAzB,EAAyC,CAAzC,EAA4C,WAA7C,CAAzB;AAEN,iBAAA,CAAA;AAAA;AAAA,YAAO,YAAP,CAAA;;;;AACH;AAED,OAAM,SAAgB,mBAAhB,CAAoC,MAApC,EAA2D,OAA3D,EAAoF,MAApF,EAAkG;;;;;;;;AACpG;AACA,UAAA,MAAM,GAAG,MAAM,CAAC,WAAP,EAAT;AACe,iBAAA,CAAA;AAAA;AAAA,YAAM,MAAM,CAAC,KAAP,CAAa;AAAE,YAAA,GAAG,EAAE,8CAA4C,MAAnD;AAA6D,YAAA,IAAI,EAAE;AAAnE,WAAb,EAA0F,YAA1F,CAAuG,OAAvG,CAAN,CAAA;;;AAAT,UAAA,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT;AACA,UAAA,QAAQ,GAAG,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAE,GAAR,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,YAAb,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,KAAA,CAAzB,GAAyB,EAAA,CAAE,OAAtC;;AAEN,cAAI,CAAC,QAAD,IAAa,QAAQ,CAAC,MAAT,KAAoB,CAArC,EAAwC;AACpC;AACA,mBAAA,CAAA;AAAA;AAAA,cAAO,yBAAyB,CAAC,MAAD,EAAS,OAAT,EAAkB,MAAlB,CAAhC,CAAA;AACH;;AAED,iBAAA,CAAA;AAAA;AAAA,YAAO,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,QAAQ,CAAC,IAAT,CAAc,UAAC,CAAD,EAAO;AAAK,mBAAA,CAAC,CAAD,OAAA;AAAS,WAAnC,CAAA,MAAoC,IAApC,IAAoC,EAAA,KAAA,KAAA,CAApC,GAAoC,KAAA,CAApC,GAAoC,EAAA,CAAE,KAAtC,MAA2C,IAA3C,IAA2C,EAAA,KAAA,KAAA,CAA3C,GAA2C,EAA3C,GAA+C,QAAQ,CAAC,CAAD,CAAR,CAAY,KAAlE,CAAA;;;;AACH;;AAED,SAAe,yBAAf,CAAyC,MAAzC,EAAgE,OAAhE,EAAyF,MAAzF,EAAuG;;;;;;;;AACnG;AACA,UAAA,MAAM,GAAG,MAAM,CAAC,WAAP,EAAT;AACe,iBAAA,CAAA;AAAA;AAAA,YAAM,MAAM,CAAC,KAAP,CAAa;AAAE,YAAA,GAAG,EAAE,mDAAiD,MAAxD;AAAkE,YAAA,IAAI,EAAE;AAAxE,WAAb,EAA+F,YAA/F,CAA4G,OAA5G,CAAN,CAAA;;;AAAT,UAAA,MAAM,GAAG,EAAA,CAAA,IAAA,EAAT;AACA,UAAA,SAAS,GAAG,MAAM,KAAA,IAAN,IAAA,MAAM,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAA,MAAM,CAAG,MAAH,CAAlB;AACF,UAAA,YAAY,GAAuB,KAAK,CAAxC;;AACJ,cAAI,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,SAAS,KAAA,IAAT,IAAA,SAAS,KAAA,KAAA,CAAT,GAAS,KAAA,CAAT,GAAA,SAAS,CAAG,CAAH,CAAT,MAAc,IAAd,IAAc,EAAA,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAc,EAAA,CAAE,GAAhB,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,KAAA,CAAnB,GAAmB,EAAA,CAAE,aAArB,MAAkC,IAAlC,IAAkC,EAAA,KAAA,KAAA,CAAlC,GAAkC,KAAA,CAAlC,GAAkC,EAAA,CAAE,KAApC,MAA8C,KAAK,CAAvD,EAA0D;AACtD,YAAA,YAAY,GAAG,CAAC,SAAS,CAAC,CAAD,CAAT,CAAa,GAAb,CAAiB,aAAjB,CAA+B,KAA/C;AACH;;AAED,iBAAA,CAAA;AAAA;AAAA,YAAO,YAAP,CAAA;;;;AACH;;AAED,OAAM,SAAgB,UAAhB,CAA2B,MAA3B,EAAkD,OAAlD,EAA2E,KAA3E,EAAwF;;;;;;;;AAE1E,iBAAA,CAAA;AAAA;AAAA,YAAM,MAAM,CAAC,KAAP,CAAa;AAAE,YAAA,GAAG,EAAE,sDAAoD,KAA3D;AAAoE,YAAA,IAAI,EAAE;AAA1E,WAAb,EAAiG,YAAjG,CAA8G,OAA9G,CAAN,CAAA;;;AAAV,UAAA,OAAO,GAAG,EAAA,CAAA,IAAA,EAAV;AAEA,UAAA,YAAY,GAAG,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAG,KAAH,CAAtB;AACA,UAAA,OAAO,GAAa,EAApB;;AACN,cAAI,CAAA,EAAA,GAAA,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAY,KAAA,CAAZ,GAAA,YAAY,CAAG,CAAH,CAAZ,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,KAAA,CAAjB,GAAiB,EAAA,CAAE,kBAAvB,EAA2C;AACjC,YAAA,IAAI,GAAG,YAAY,CAAC,CAAD,CAAZ,CAAgB,kBAAhB,CAAmC,MAAnC,CAA0C,UAAC,CAAD,EAAO;AAAK,qBAAA,CAAC,CAAC,QAAF,KAAe,MAAf,IAAyB,CAAC,CAAC,YAAF,KAAzB,sBAAA;AAAkE,aAAxH,CAAP;;AACN,gBAAI,CAAC,IAAI,CAAC,MAAV,EAAkB;AACd,oBAAM,IAAI,KAAJ,CAAU,sCAAoC,KAApC,GAAyC,IAAnD,CAAN;AACH;;AACD,YAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAgB,IAAI,CAAC,GAAL,CAAS,UAAC,CAAD,EAAyB;AAAK,qBAAA,CAAC,CAAD,SAAA;AAAW,aAAlD,CAAhB;AACH,WAND,MAMO;AACH,kBAAM,IAAI,KAAJ,CAAU,sCAAoC,KAApC,GAAyC,IAAnD,CAAN;AACH;;AAED,iBAAA,CAAA;AAAA;AAAA,YAAO,OAAP,CAAA;;;;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __awaiter, __generator } from \"tslib\";\r\nimport { Model } from '../../../../mol-model/structure';\r\nimport { MmcifFormat } from '../../../../mol-model-formats/structure/mmcif';\r\nimport { PluginConfig } from '../../../config';\r\nexport function getStreamingMethod(s, defaultKind) {\r\n    if (defaultKind === void 0) { defaultKind = 'x-ray'; }\r\n    if (!s)\r\n        return defaultKind;\r\n    var model = s.models[0];\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return defaultKind;\r\n    // Prefer EMDB entries over structure-factors (SF) e.g. for 'ELECTRON CRYSTALLOGRAPHY' entries\r\n    // like 6AXZ or 6KJ3 for which EMDB entries are available but map calculation from SF is hard.\r\n    if (Model.hasEmMap(model))\r\n        return 'em';\r\n    if (Model.hasXrayMap(model))\r\n        return 'x-ray';\r\n    // Fallbacks based on experimental method\r\n    if (Model.isFromEm(model))\r\n        return 'em';\r\n    if (Model.isFromXray(model))\r\n        return 'x-ray';\r\n    return defaultKind;\r\n}\r\n/** Returns EMD ID when available, otherwise falls back to PDB ID */\r\nexport function getEmIds(model) {\r\n    var ids = [];\r\n    if (!MmcifFormat.is(model.sourceData))\r\n        return [model.entryId];\r\n    var _a = model.sourceData.data.db.pdbx_database_related, db_id = _a.db_id, db_name = _a.db_name, content_type = _a.content_type;\r\n    if (!db_name.isDefined)\r\n        return [model.entryId];\r\n    for (var i = 0, il = db_name.rowCount; i < il; ++i) {\r\n        if (db_name.value(i).toUpperCase() === 'EMDB' && content_type.value(i) === 'associated EM volume') {\r\n            ids.push(db_id.value(i));\r\n        }\r\n    }\r\n    return ids;\r\n}\r\nexport function getXrayIds(model) {\r\n    return [model.entryId];\r\n}\r\nexport function getIds(method, s) {\r\n    if (!s || !s.models.length)\r\n        return [];\r\n    var model = s.models[0];\r\n    switch (method) {\r\n        case 'em': return getEmIds(model);\r\n        case 'x-ray': return getXrayIds(model);\r\n    }\r\n}\r\nexport function getContourLevel(provider, plugin, taskCtx, emdbId) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (provider) {\r\n                case 'emdb': return [2 /*return*/, getContourLevelEmdb(plugin, taskCtx, emdbId)];\r\n                case 'pdbe': return [2 /*return*/, getContourLevelPdbe(plugin, taskCtx, emdbId)];\r\n            }\r\n            return [2 /*return*/];\r\n        });\r\n    });\r\n}\r\nexport function getContourLevelEmdb(plugin, taskCtx, emdbId) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var emdbHeaderServer, header, map, contourLevel;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    emdbHeaderServer = plugin.config.get(PluginConfig.VolumeStreaming.EmdbHeaderServer);\r\n                    return [4 /*yield*/, plugin.fetch({ url: emdbHeaderServer + \"/\" + emdbId.toUpperCase() + \"/header/\" + emdbId.toLowerCase() + \".xml\", type: 'xml' }).runInContext(taskCtx)];\r\n                case 1:\r\n                    header = _a.sent();\r\n                    map = header.getElementsByTagName('map')[0];\r\n                    contourLevel = parseFloat(map.getElementsByTagName('contourLevel')[0].textContent);\r\n                    return [2 /*return*/, contourLevel];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function getContourLevelPdbe(plugin, taskCtx, emdbId) {\r\n    var _a, _b, _c, _d;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var header, contours;\r\n        return __generator(this, function (_e) {\r\n            switch (_e.label) {\r\n                case 0:\r\n                    // TODO: parametrize URL in plugin settings?\r\n                    emdbId = emdbId.toUpperCase();\r\n                    return [4 /*yield*/, plugin.fetch({ url: \"https://www.ebi.ac.uk/emdb/api/entry/map/\" + emdbId, type: 'json' }).runInContext(taskCtx)];\r\n                case 1:\r\n                    header = _e.sent();\r\n                    contours = (_b = (_a = header === null || header === void 0 ? void 0 : header.map) === null || _a === void 0 ? void 0 : _a.contour_list) === null || _b === void 0 ? void 0 : _b.contour;\r\n                    if (!contours || contours.length === 0) {\r\n                        // try fallback to the old API\r\n                        return [2 /*return*/, getContourLevelPdbeLegacy(plugin, taskCtx, emdbId)];\r\n                    }\r\n                    return [2 /*return*/, (_d = (_c = contours.find(function (c) { return c.primary; })) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : contours[0].level];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction getContourLevelPdbeLegacy(plugin, taskCtx, emdbId) {\r\n    var _a, _b, _c;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var header, emdbEntry, contourLevel;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0:\r\n                    // TODO: parametrize URL in plugin settings?\r\n                    emdbId = emdbId.toUpperCase();\r\n                    return [4 /*yield*/, plugin.fetch({ url: \"https://www.ebi.ac.uk/pdbe/api/emdb/entry/map/\" + emdbId, type: 'json' }).runInContext(taskCtx)];\r\n                case 1:\r\n                    header = _d.sent();\r\n                    emdbEntry = header === null || header === void 0 ? void 0 : header[emdbId];\r\n                    contourLevel = void 0;\r\n                    if (((_c = (_b = (_a = emdbEntry === null || emdbEntry === void 0 ? void 0 : emdbEntry[0]) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.contour_level) === null || _c === void 0 ? void 0 : _c.value) !== void 0) {\r\n                        contourLevel = +emdbEntry[0].map.contour_level.value;\r\n                    }\r\n                    return [2 /*return*/, contourLevel];\r\n            }\r\n        });\r\n    });\r\n}\r\nexport function getEmdbIds(plugin, taskCtx, pdbId) {\r\n    var _a;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var summary, summaryEntry, emdbIds, emdb;\r\n        return __generator(this, function (_b) {\r\n            switch (_b.label) {\r\n                case 0: return [4 /*yield*/, plugin.fetch({ url: \"https://www.ebi.ac.uk/pdbe/api/pdb/entry/summary/\" + pdbId, type: 'json' }).runInContext(taskCtx)];\r\n                case 1:\r\n                    summary = _b.sent();\r\n                    summaryEntry = summary === null || summary === void 0 ? void 0 : summary[pdbId];\r\n                    emdbIds = [];\r\n                    if ((_a = summaryEntry === null || summaryEntry === void 0 ? void 0 : summaryEntry[0]) === null || _a === void 0 ? void 0 : _a.related_structures) {\r\n                        emdb = summaryEntry[0].related_structures.filter(function (s) { return s.resource === 'EMDB' && s.relationship === 'associated EM volume'; });\r\n                        if (!emdb.length) {\r\n                            throw new Error(\"No related EMDB entry found for '\" + pdbId + \"'.\");\r\n                        }\r\n                        emdbIds.push.apply(emdbIds, emdb.map(function (e) { return e.accession; }));\r\n                    }\r\n                    else {\r\n                        throw new Error(\"No related EMDB entry found for '\" + pdbId + \"'.\");\r\n                    }\r\n                    return [2 /*return*/, emdbIds];\r\n            }\r\n        });\r\n    });\r\n}\r\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}