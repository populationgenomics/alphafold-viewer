{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { UniqueArray } from '../../../../mol-data/generic';\nimport { Segmentation, SortedArray } from '../../../../mol-data/int';\nimport { StructureProperties as P, Unit } from '../../structure';\nimport { Structure } from '../../structure/structure';\nimport { StructureSelection } from '../selection';\nimport { LinearGroupingBuilder } from '../utils/builders';\nimport { structureSubtract } from '../utils/structure-set';\nexport var none = function (ctx) {\n  return StructureSelection.Sequence(ctx.inputStructure, []);\n};\nexport var all = function (ctx) {\n  return StructureSelection.Singletons(ctx.inputStructure, ctx.inputStructure);\n};\nexport function residues(params) {\n  return atoms(__assign(__assign({}, params), {\n    groupBy: function (ctx) {\n      return P.residue.key(ctx.element);\n    }\n  }));\n}\nexport function chains(params) {\n  return atoms(__assign(__assign({}, params), {\n    groupBy: function (ctx) {\n      return P.chain.key(ctx.element);\n    }\n  }));\n}\n\nfunction _true(ctx) {\n  return true;\n}\n\nfunction _zero(ctx) {\n  return 0;\n}\n\nexport function atoms(params) {\n  if (!params || !params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy) return all;\n  if (!!params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy) return atomGroupsLinear(params.atomTest);\n  var normalized = {\n    unitTest: params.unitTest || _true,\n    entityTest: params.entityTest || _true,\n    chainTest: params.chainTest || _true,\n    residueTest: params.residueTest || _true,\n    atomTest: params.atomTest || _true,\n    groupBy: params.groupBy || _zero\n  };\n  if (!params.groupBy) return atomGroupsSegmented(normalized);\n  return atomGroupsGrouped(normalized);\n}\n\nfunction atomGroupsLinear(atomTest) {\n  return function query_atomGroupsLinear(ctx) {\n    var inputStructure = ctx.inputStructure;\n    var units = inputStructure.units;\n    var l = ctx.pushCurrentElement();\n    var builder = inputStructure.subsetBuilder(true);\n    l.structure = inputStructure;\n\n    for (var _a = 0, units_1 = units; _a < units_1.length; _a++) {\n      var unit = units_1[_a];\n      l.unit = unit;\n      var elements = unit.elements;\n      builder.beginUnit(unit.id);\n\n      for (var j = 0, _j = elements.length; j < _j; j++) {\n        l.element = elements[j];\n        if (atomTest(ctx)) builder.addElement(l.element);\n      }\n\n      builder.commitUnit();\n      ctx.throwIfTimedOut();\n    }\n\n    ctx.popCurrentElement();\n    return StructureSelection.Singletons(inputStructure, builder.getStructure());\n  };\n}\n\nfunction atomGroupsSegmented(_a) {\n  var unitTest = _a.unitTest,\n      entityTest = _a.entityTest,\n      chainTest = _a.chainTest,\n      residueTest = _a.residueTest,\n      atomTest = _a.atomTest;\n  return function query_atomGroupsSegmented(ctx) {\n    var inputStructure = ctx.inputStructure;\n    var units = inputStructure.units;\n    var l = ctx.pushCurrentElement();\n    var builder = inputStructure.subsetBuilder(true);\n    var chainLevel = residueTest === _true && atomTest === _true;\n    var residueLevel = atomTest === _true;\n    l.structure = inputStructure;\n\n    for (var _a = 0, units_2 = units; _a < units_2.length; _a++) {\n      var unit = units_2[_a];\n      l.unit = unit;\n      if (!unitTest(ctx)) continue;\n      var elements = unit.elements,\n          model = unit.model;\n      builder.beginUnit(unit.id);\n\n      if (unit.kind === 0\n      /* Atomic */\n      ) {\n        var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\n        var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\n\n        while (chainsIt.hasNext) {\n          var chainSegment = chainsIt.move();\n          l.element = elements[chainSegment.start]; // test entity and chain\n\n          if (!entityTest(ctx) || !chainTest(ctx)) continue;\n\n          if (chainLevel) {\n            builder.addElementRange(elements, chainSegment.start, chainSegment.end);\n            continue;\n          }\n\n          residuesIt.setSegment(chainSegment);\n\n          while (residuesIt.hasNext) {\n            var residueSegment = residuesIt.move();\n            l.element = elements[residueSegment.start]; // test residue\n\n            if (!residueTest(ctx)) continue;\n\n            if (residueLevel) {\n              builder.addElementRange(elements, residueSegment.start, residueSegment.end);\n              continue;\n            }\n\n            for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\n              l.element = elements[j]; // test atom\n\n              if (atomTest(ctx)) {\n                builder.addElement(l.element);\n              }\n            }\n          }\n        }\n      } else {\n        var chainElementSegments = (1\n        /* Spheres */\n        ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians).chainElementSegments;\n        var chainsIt = Segmentation.transientSegments(chainElementSegments, elements);\n\n        while (chainsIt.hasNext) {\n          var chainSegment = chainsIt.move();\n          l.element = elements[chainSegment.start]; // test entity and chain\n\n          if (!entityTest(ctx) || !chainTest(ctx)) continue;\n\n          if (chainLevel) {\n            builder.addElementRange(elements, chainSegment.start, chainSegment.end);\n            continue;\n          }\n\n          for (var j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {\n            l.element = elements[j]; // test residue/coarse element\n\n            if (residueTest(ctx)) {\n              builder.addElement(l.element);\n            }\n          }\n        }\n      }\n\n      builder.commitUnit();\n      ctx.throwIfTimedOut();\n    }\n\n    ctx.popCurrentElement();\n    return StructureSelection.Singletons(inputStructure, builder.getStructure());\n  };\n}\n\nfunction atomGroupsGrouped(_a) {\n  var unitTest = _a.unitTest,\n      entityTest = _a.entityTest,\n      chainTest = _a.chainTest,\n      residueTest = _a.residueTest,\n      atomTest = _a.atomTest,\n      groupBy = _a.groupBy;\n  return function query_atomGroupsGrouped(ctx) {\n    var inputStructure = ctx.inputStructure;\n    var units = inputStructure.units;\n    var l = ctx.pushCurrentElement();\n    var builder = new LinearGroupingBuilder(inputStructure);\n    l.structure = inputStructure;\n\n    for (var _a = 0, units_3 = units; _a < units_3.length; _a++) {\n      var unit = units_3[_a];\n      l.unit = unit;\n      if (!unitTest(ctx)) continue;\n      var elements = unit.elements,\n          model = unit.model;\n\n      if (unit.kind === 0\n      /* Atomic */\n      ) {\n        var chainsIt = Segmentation.transientSegments(model.atomicHierarchy.chainAtomSegments, elements);\n        var residuesIt = Segmentation.transientSegments(model.atomicHierarchy.residueAtomSegments, elements);\n\n        while (chainsIt.hasNext) {\n          var chainSegment = chainsIt.move();\n          l.element = elements[chainSegment.start]; // test entity and chain\n\n          if (!entityTest(ctx) || !chainTest(ctx)) continue;\n          residuesIt.setSegment(chainSegment);\n\n          while (residuesIt.hasNext) {\n            var residueSegment = residuesIt.move();\n            l.element = elements[residueSegment.start]; // test residue\n\n            if (!residueTest(ctx)) continue;\n\n            for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\n              l.element = elements[j]; // test atom\n\n              if (atomTest(ctx)) {\n                builder.add(groupBy(ctx), unit.id, l.element);\n              }\n            }\n          }\n        }\n      } else {\n        var chainElementSegments = (1\n        /* Spheres */\n        ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians).chainElementSegments;\n        var chainsIt = Segmentation.transientSegments(chainElementSegments, elements);\n\n        while (chainsIt.hasNext) {\n          var chainSegment = chainsIt.move();\n          l.element = elements[chainSegment.start]; // test entity and chain\n\n          if (!entityTest(ctx) || !chainTest(ctx)) continue;\n\n          for (var j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {\n            l.element = elements[j]; // test residue/coarse element\n\n            if (residueTest(ctx)) {\n              builder.add(groupBy(ctx), unit.id, l.element);\n            }\n          }\n        }\n      }\n\n      ctx.throwIfTimedOut();\n    }\n\n    ctx.popCurrentElement();\n    return builder.getSelection();\n  };\n}\n\nfunction getRingStructure(unit, ring, inputStructure) {\n  var elements = new Int32Array(ring.length);\n\n  for (var i = 0, _i = ring.length; i < _i; i++) elements[i] = unit.elements[ring[i]];\n\n  return Structure.create([unit.getChild(SortedArray.ofSortedArray(elements))], {\n    parent: inputStructure\n  });\n}\n\nexport function rings(fingerprints, onlyAromatic) {\n  return function query_rings(ctx) {\n    var units = ctx.inputStructure.units;\n    var ret = StructureSelection.LinearBuilder(ctx.inputStructure);\n\n    if (!fingerprints || fingerprints.length === 0) {\n      for (var _a = 0, units_4 = units; _a < units_4.length; _a++) {\n        var u = units_4[_a];\n        if (!Unit.isAtomic(u)) continue;\n\n        if (onlyAromatic) {\n          for (var _b = 0, _c = u.rings.aromaticRings; _b < _c.length; _b++) {\n            var r = _c[_b];\n            ret.add(getRingStructure(u, u.rings.all[r], ctx.inputStructure));\n          }\n        } else {\n          for (var _d = 0, _e = u.rings.all; _d < _e.length; _d++) {\n            var r = _e[_d];\n            ret.add(getRingStructure(u, r, ctx.inputStructure));\n          }\n        }\n      }\n    } else {\n      var uniqueFps = UniqueArray.create();\n\n      for (var i = 0; i < fingerprints.length; i++) UniqueArray.add(uniqueFps, fingerprints[i], fingerprints[i]);\n\n      for (var _f = 0, units_5 = units; _f < units_5.length; _f++) {\n        var u = units_5[_f];\n        if (!Unit.isAtomic(u)) continue;\n        var rings_1 = u.rings;\n\n        for (var _g = 0, _h = uniqueFps.array; _g < _h.length; _g++) {\n          var fp = _h[_g];\n          if (!rings_1.byFingerprint.has(fp)) continue;\n\n          for (var _k = 0, _l = rings_1.byFingerprint.get(fp); _k < _l.length; _k++) {\n            var r = _l[_k];\n            if (onlyAromatic && !rings_1.aromaticRings.includes(r)) continue;\n            ret.add(getRingStructure(u, rings_1.all[r], ctx.inputStructure));\n          }\n        }\n      }\n    }\n\n    return ret.getSelection();\n  };\n}\nexport function querySelection(selection, query, inComplement) {\n  if (inComplement === void 0) {\n    inComplement = false;\n  }\n\n  return function query_querySelection(ctx) {\n    var targetSel = selection(ctx);\n    if (StructureSelection.structureCount(targetSel) === 0) return targetSel;\n    var target = inComplement ? structureSubtract(ctx.inputStructure, StructureSelection.unionStructure(targetSel)) : StructureSelection.unionStructure(targetSel);\n    if (target.elementCount === 0) return StructureSelection.Empty(ctx.inputStructure);\n    ctx.throwIfTimedOut();\n    ctx.pushInputStructure(target);\n    var result = query(ctx);\n    ctx.popInputStructure();\n    return StructureSelection.withInputStructure(result, ctx.inputStructure);\n  };\n}\nexport function bondedAtomicPairs(bondTest) {\n  return function query_bondedAtomicPairs(ctx) {\n    var structure = ctx.inputStructure;\n    var interBonds = structure.interUnitBonds; // Note: each bond is called twice, that's why we need the unique builder.\n\n    var ret = StructureSelection.UniqueBuilder(ctx.inputStructure);\n    ctx.pushCurrentBond();\n    var atomicBond = ctx.atomicBond;\n    atomicBond.setTestFn(bondTest);\n    atomicBond.setStructure(structure); // Process intra unit bonds\n\n    for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\n      var unit = _b[_a];\n      if (unit.kind !== 0\n      /* Atomic */\n      ) continue;\n      var _c = unit.bonds,\n          intraBondOffset = _c.offset,\n          intraBondB = _c.b,\n          _d = _c.edgeProps,\n          flags = _d.flags,\n          order = _d.order;\n      atomicBond.a.unit = unit;\n      atomicBond.b.unit = unit;\n\n      for (var i = 0, _i = unit.elements.length; i < _i; i++) {\n        atomicBond.aIndex = i;\n        atomicBond.a.element = unit.elements[i]; // check intra unit bonds\n\n        for (var lI = intraBondOffset[i], _lI = intraBondOffset[i + 1]; lI < _lI; lI++) {\n          atomicBond.bIndex = intraBondB[lI];\n          atomicBond.b.element = unit.elements[intraBondB[lI]];\n          atomicBond.type = flags[lI];\n          atomicBond.order = order[lI]; // No need to \"swap test\" because each bond direction will be visited eventually.\n\n          if (atomicBond.test(ctx, false)) {\n            var b = structure.subsetBuilder(false);\n            b.beginUnit(unit.id);\n            b.addElement(atomicBond.a.element);\n            b.addElement(atomicBond.b.element);\n            b.commitUnit();\n            ret.add(b.getStructure());\n          }\n        }\n      }\n    } // Process inter unit bonds\n\n\n    for (var _e = 0, _f = interBonds.edges; _e < _f.length; _e++) {\n      var bond = _f[_e];\n      atomicBond.a.unit = structure.unitMap.get(bond.unitA);\n      atomicBond.a.element = atomicBond.a.unit.elements[bond.indexA];\n      atomicBond.aIndex = bond.indexA;\n      atomicBond.b.unit = structure.unitMap.get(bond.unitA);\n      atomicBond.b.element = atomicBond.b.unit.elements[bond.indexB];\n      atomicBond.bIndex = bond.indexB;\n      atomicBond.order = bond.props.order;\n      atomicBond.type = bond.props.flag; // No need to \"swap test\" because each bond direction will be visited eventually.\n\n      if (atomicBond.test(ctx, false)) {\n        var b = structure.subsetBuilder(false);\n        b.addToUnit(atomicBond.a.unit.id, atomicBond.a.element);\n        b.addToUnit(atomicBond.b.unit.id, atomicBond.b.element);\n        ret.add(b.getStructure());\n      }\n    }\n\n    ctx.popCurrentBond();\n    return ret.getSelection();\n  };\n}","map":{"version":3,"sources":["../../../../../src/mol-model/structure/query/queries/generators.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { UniqueArray } from '../../../../mol-data/generic';\r\nimport { Segmentation, SortedArray } from '../../../../mol-data/int';\r\nimport { StructureProperties as P, Unit } from '../../structure';\r\nimport { Structure } from '../../structure/structure';\r\nimport { StructureSelection } from '../selection';\r\nimport { LinearGroupingBuilder } from '../utils/builders';\r\nimport { structureSubtract } from '../utils/structure-set';\r\nexport var none = function (ctx) { return StructureSelection.Sequence(ctx.inputStructure, []); };\r\nexport var all = function (ctx) { return StructureSelection.Singletons(ctx.inputStructure, ctx.inputStructure); };\r\nexport function residues(params) { return atoms(__assign(__assign({}, params), { groupBy: function (ctx) { return P.residue.key(ctx.element); } })); }\r\nexport function chains(params) { return atoms(__assign(__assign({}, params), { groupBy: function (ctx) { return P.chain.key(ctx.element); } })); }\r\nfunction _true(ctx) { return true; }\r\nfunction _zero(ctx) { return 0; }\r\nexport function atoms(params) {\r\n    if (!params || (!params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy))\r\n        return all;\r\n    if (!!params.atomTest && !params.residueTest && !params.chainTest && !params.entityTest && !params.unitTest && !params.groupBy)\r\n        return atomGroupsLinear(params.atomTest);\r\n    var normalized = {\r\n        unitTest: params.unitTest || _true,\r\n        entityTest: params.entityTest || _true,\r\n        chainTest: params.chainTest || _true,\r\n        residueTest: params.residueTest || _true,\r\n        atomTest: params.atomTest || _true,\r\n        groupBy: params.groupBy || _zero,\r\n    };\r\n    if (!params.groupBy)\r\n        return atomGroupsSegmented(normalized);\r\n    return atomGroupsGrouped(normalized);\r\n}\r\nfunction atomGroupsLinear(atomTest) {\r\n    return function query_atomGroupsLinear(ctx) {\r\n        var inputStructure = ctx.inputStructure;\r\n        var units = inputStructure.units;\r\n        var l = ctx.pushCurrentElement();\r\n        var builder = inputStructure.subsetBuilder(true);\r\n        l.structure = inputStructure;\r\n        for (var _a = 0, units_1 = units; _a < units_1.length; _a++) {\r\n            var unit = units_1[_a];\r\n            l.unit = unit;\r\n            var elements = unit.elements;\r\n            builder.beginUnit(unit.id);\r\n            for (var j = 0, _j = elements.length; j < _j; j++) {\r\n                l.element = elements[j];\r\n                if (atomTest(ctx))\r\n                    builder.addElement(l.element);\r\n            }\r\n            builder.commitUnit();\r\n            ctx.throwIfTimedOut();\r\n        }\r\n        ctx.popCurrentElement();\r\n        return StructureSelection.Singletons(inputStructure, builder.getStructure());\r\n    };\r\n}\r\nfunction atomGroupsSegmented(_a) {\r\n    var unitTest = _a.unitTest, entityTest = _a.entityTest, chainTest = _a.chainTest, residueTest = _a.residueTest, atomTest = _a.atomTest;\r\n    return function query_atomGroupsSegmented(ctx) {\r\n        var inputStructure = ctx.inputStructure;\r\n        var units = inputStructure.units;\r\n        var l = ctx.pushCurrentElement();\r\n        var builder = inputStructure.subsetBuilder(true);\r\n        var chainLevel = residueTest === _true && atomTest === _true;\r\n        var residueLevel = atomTest === _true;\r\n        l.structure = inputStructure;\r\n        for (var _a = 0, units_2 = units; _a < units_2.length; _a++) {\r\n            var unit = units_2[_a];\r\n            l.unit = unit;\r\n            if (!unitTest(ctx))\r\n                continue;\r\n            var elements = unit.elements, model = unit.model;\r\n            builder.beginUnit(unit.id);\r\n            if (unit.kind === 0 /* Atomic */) {\r\n                var chainsIt = Segmentation.transientSegments(unit.model.atomicHierarchy.chainAtomSegments, elements);\r\n                var residuesIt = Segmentation.transientSegments(unit.model.atomicHierarchy.residueAtomSegments, elements);\r\n                while (chainsIt.hasNext) {\r\n                    var chainSegment = chainsIt.move();\r\n                    l.element = elements[chainSegment.start];\r\n                    // test entity and chain\r\n                    if (!entityTest(ctx) || !chainTest(ctx))\r\n                        continue;\r\n                    if (chainLevel) {\r\n                        builder.addElementRange(elements, chainSegment.start, chainSegment.end);\r\n                        continue;\r\n                    }\r\n                    residuesIt.setSegment(chainSegment);\r\n                    while (residuesIt.hasNext) {\r\n                        var residueSegment = residuesIt.move();\r\n                        l.element = elements[residueSegment.start];\r\n                        // test residue\r\n                        if (!residueTest(ctx))\r\n                            continue;\r\n                        if (residueLevel) {\r\n                            builder.addElementRange(elements, residueSegment.start, residueSegment.end);\r\n                            continue;\r\n                        }\r\n                        for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\r\n                            l.element = elements[j];\r\n                            // test atom\r\n                            if (atomTest(ctx)) {\r\n                                builder.addElement(l.element);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var chainElementSegments = (1 /* Spheres */ ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians).chainElementSegments;\r\n                var chainsIt = Segmentation.transientSegments(chainElementSegments, elements);\r\n                while (chainsIt.hasNext) {\r\n                    var chainSegment = chainsIt.move();\r\n                    l.element = elements[chainSegment.start];\r\n                    // test entity and chain\r\n                    if (!entityTest(ctx) || !chainTest(ctx))\r\n                        continue;\r\n                    if (chainLevel) {\r\n                        builder.addElementRange(elements, chainSegment.start, chainSegment.end);\r\n                        continue;\r\n                    }\r\n                    for (var j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {\r\n                        l.element = elements[j];\r\n                        // test residue/coarse element\r\n                        if (residueTest(ctx)) {\r\n                            builder.addElement(l.element);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            builder.commitUnit();\r\n            ctx.throwIfTimedOut();\r\n        }\r\n        ctx.popCurrentElement();\r\n        return StructureSelection.Singletons(inputStructure, builder.getStructure());\r\n    };\r\n}\r\nfunction atomGroupsGrouped(_a) {\r\n    var unitTest = _a.unitTest, entityTest = _a.entityTest, chainTest = _a.chainTest, residueTest = _a.residueTest, atomTest = _a.atomTest, groupBy = _a.groupBy;\r\n    return function query_atomGroupsGrouped(ctx) {\r\n        var inputStructure = ctx.inputStructure;\r\n        var units = inputStructure.units;\r\n        var l = ctx.pushCurrentElement();\r\n        var builder = new LinearGroupingBuilder(inputStructure);\r\n        l.structure = inputStructure;\r\n        for (var _a = 0, units_3 = units; _a < units_3.length; _a++) {\r\n            var unit = units_3[_a];\r\n            l.unit = unit;\r\n            if (!unitTest(ctx))\r\n                continue;\r\n            var elements = unit.elements, model = unit.model;\r\n            if (unit.kind === 0 /* Atomic */) {\r\n                var chainsIt = Segmentation.transientSegments(model.atomicHierarchy.chainAtomSegments, elements);\r\n                var residuesIt = Segmentation.transientSegments(model.atomicHierarchy.residueAtomSegments, elements);\r\n                while (chainsIt.hasNext) {\r\n                    var chainSegment = chainsIt.move();\r\n                    l.element = elements[chainSegment.start];\r\n                    // test entity and chain\r\n                    if (!entityTest(ctx) || !chainTest(ctx))\r\n                        continue;\r\n                    residuesIt.setSegment(chainSegment);\r\n                    while (residuesIt.hasNext) {\r\n                        var residueSegment = residuesIt.move();\r\n                        l.element = elements[residueSegment.start];\r\n                        // test residue\r\n                        if (!residueTest(ctx))\r\n                            continue;\r\n                        for (var j = residueSegment.start, _j = residueSegment.end; j < _j; j++) {\r\n                            l.element = elements[j];\r\n                            // test atom\r\n                            if (atomTest(ctx)) {\r\n                                builder.add(groupBy(ctx), unit.id, l.element);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                var chainElementSegments = (1 /* Spheres */ ? model.coarseHierarchy.spheres : model.coarseHierarchy.gaussians).chainElementSegments;\r\n                var chainsIt = Segmentation.transientSegments(chainElementSegments, elements);\r\n                while (chainsIt.hasNext) {\r\n                    var chainSegment = chainsIt.move();\r\n                    l.element = elements[chainSegment.start];\r\n                    // test entity and chain\r\n                    if (!entityTest(ctx) || !chainTest(ctx))\r\n                        continue;\r\n                    for (var j = chainSegment.start, _j = chainSegment.end; j < _j; j++) {\r\n                        l.element = elements[j];\r\n                        // test residue/coarse element\r\n                        if (residueTest(ctx)) {\r\n                            builder.add(groupBy(ctx), unit.id, l.element);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            ctx.throwIfTimedOut();\r\n        }\r\n        ctx.popCurrentElement();\r\n        return builder.getSelection();\r\n    };\r\n}\r\nfunction getRingStructure(unit, ring, inputStructure) {\r\n    var elements = new Int32Array(ring.length);\r\n    for (var i = 0, _i = ring.length; i < _i; i++)\r\n        elements[i] = unit.elements[ring[i]];\r\n    return Structure.create([unit.getChild(SortedArray.ofSortedArray(elements))], { parent: inputStructure });\r\n}\r\nexport function rings(fingerprints, onlyAromatic) {\r\n    return function query_rings(ctx) {\r\n        var units = ctx.inputStructure.units;\r\n        var ret = StructureSelection.LinearBuilder(ctx.inputStructure);\r\n        if (!fingerprints || fingerprints.length === 0) {\r\n            for (var _a = 0, units_4 = units; _a < units_4.length; _a++) {\r\n                var u = units_4[_a];\r\n                if (!Unit.isAtomic(u))\r\n                    continue;\r\n                if (onlyAromatic) {\r\n                    for (var _b = 0, _c = u.rings.aromaticRings; _b < _c.length; _b++) {\r\n                        var r = _c[_b];\r\n                        ret.add(getRingStructure(u, u.rings.all[r], ctx.inputStructure));\r\n                    }\r\n                }\r\n                else {\r\n                    for (var _d = 0, _e = u.rings.all; _d < _e.length; _d++) {\r\n                        var r = _e[_d];\r\n                        ret.add(getRingStructure(u, r, ctx.inputStructure));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var uniqueFps = UniqueArray.create();\r\n            for (var i = 0; i < fingerprints.length; i++)\r\n                UniqueArray.add(uniqueFps, fingerprints[i], fingerprints[i]);\r\n            for (var _f = 0, units_5 = units; _f < units_5.length; _f++) {\r\n                var u = units_5[_f];\r\n                if (!Unit.isAtomic(u))\r\n                    continue;\r\n                var rings_1 = u.rings;\r\n                for (var _g = 0, _h = uniqueFps.array; _g < _h.length; _g++) {\r\n                    var fp = _h[_g];\r\n                    if (!rings_1.byFingerprint.has(fp))\r\n                        continue;\r\n                    for (var _k = 0, _l = rings_1.byFingerprint.get(fp); _k < _l.length; _k++) {\r\n                        var r = _l[_k];\r\n                        if (onlyAromatic && !rings_1.aromaticRings.includes(r))\r\n                            continue;\r\n                        ret.add(getRingStructure(u, rings_1.all[r], ctx.inputStructure));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ret.getSelection();\r\n    };\r\n}\r\nexport function querySelection(selection, query, inComplement) {\r\n    if (inComplement === void 0) { inComplement = false; }\r\n    return function query_querySelection(ctx) {\r\n        var targetSel = selection(ctx);\r\n        if (StructureSelection.structureCount(targetSel) === 0)\r\n            return targetSel;\r\n        var target = inComplement\r\n            ? structureSubtract(ctx.inputStructure, StructureSelection.unionStructure(targetSel))\r\n            : StructureSelection.unionStructure(targetSel);\r\n        if (target.elementCount === 0)\r\n            return StructureSelection.Empty(ctx.inputStructure);\r\n        ctx.throwIfTimedOut();\r\n        ctx.pushInputStructure(target);\r\n        var result = query(ctx);\r\n        ctx.popInputStructure();\r\n        return StructureSelection.withInputStructure(result, ctx.inputStructure);\r\n    };\r\n}\r\nexport function bondedAtomicPairs(bondTest) {\r\n    return function query_bondedAtomicPairs(ctx) {\r\n        var structure = ctx.inputStructure;\r\n        var interBonds = structure.interUnitBonds;\r\n        // Note: each bond is called twice, that's why we need the unique builder.\r\n        var ret = StructureSelection.UniqueBuilder(ctx.inputStructure);\r\n        ctx.pushCurrentBond();\r\n        var atomicBond = ctx.atomicBond;\r\n        atomicBond.setTestFn(bondTest);\r\n        atomicBond.setStructure(structure);\r\n        // Process intra unit bonds\r\n        for (var _a = 0, _b = structure.units; _a < _b.length; _a++) {\r\n            var unit = _b[_a];\r\n            if (unit.kind !== 0 /* Atomic */)\r\n                continue;\r\n            var _c = unit.bonds, intraBondOffset = _c.offset, intraBondB = _c.b, _d = _c.edgeProps, flags = _d.flags, order = _d.order;\r\n            atomicBond.a.unit = unit;\r\n            atomicBond.b.unit = unit;\r\n            for (var i = 0, _i = unit.elements.length; i < _i; i++) {\r\n                atomicBond.aIndex = i;\r\n                atomicBond.a.element = unit.elements[i];\r\n                // check intra unit bonds\r\n                for (var lI = intraBondOffset[i], _lI = intraBondOffset[i + 1]; lI < _lI; lI++) {\r\n                    atomicBond.bIndex = intraBondB[lI];\r\n                    atomicBond.b.element = unit.elements[intraBondB[lI]];\r\n                    atomicBond.type = flags[lI];\r\n                    atomicBond.order = order[lI];\r\n                    // No need to \"swap test\" because each bond direction will be visited eventually.\r\n                    if (atomicBond.test(ctx, false)) {\r\n                        var b = structure.subsetBuilder(false);\r\n                        b.beginUnit(unit.id);\r\n                        b.addElement(atomicBond.a.element);\r\n                        b.addElement(atomicBond.b.element);\r\n                        b.commitUnit();\r\n                        ret.add(b.getStructure());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Process inter unit bonds\r\n        for (var _e = 0, _f = interBonds.edges; _e < _f.length; _e++) {\r\n            var bond = _f[_e];\r\n            atomicBond.a.unit = structure.unitMap.get(bond.unitA);\r\n            atomicBond.a.element = atomicBond.a.unit.elements[bond.indexA];\r\n            atomicBond.aIndex = bond.indexA;\r\n            atomicBond.b.unit = structure.unitMap.get(bond.unitA);\r\n            atomicBond.b.element = atomicBond.b.unit.elements[bond.indexB];\r\n            atomicBond.bIndex = bond.indexB;\r\n            atomicBond.order = bond.props.order;\r\n            atomicBond.type = bond.props.flag;\r\n            // No need to \"swap test\" because each bond direction will be visited eventually.\r\n            if (atomicBond.test(ctx, false)) {\r\n                var b = structure.subsetBuilder(false);\r\n                b.addToUnit(atomicBond.a.unit.id, atomicBond.a.element);\r\n                b.addToUnit(atomicBond.b.unit.id, atomicBond.b.element);\r\n                ret.add(b.getStructure());\r\n            }\r\n        }\r\n        ctx.popCurrentBond();\r\n        return ret.getSelection();\r\n    };\r\n}\r\n//# sourceMappingURL=generators.js.map"]},"metadata":{},"sourceType":"module"}