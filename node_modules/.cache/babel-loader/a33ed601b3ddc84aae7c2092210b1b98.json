{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { hash2 } from '../util';\nvar IntTuple;\n\n(function (IntTuple) {\n  IntTuple.Zero = 0;\n\n  var _a = function () {\n    var data = new ArrayBuffer(8);\n    var data_1 = new ArrayBuffer(8);\n    return {\n      _int32: new Int32Array(data),\n      _float64: new Float64Array(data),\n      _int32_1: new Int32Array(data_1),\n      _float64_1: new Float64Array(data_1)\n    };\n  }(),\n      _int32 = _a._int32,\n      _float64 = _a._float64,\n      _int32_1 = _a._int32_1,\n      _float64_1 = _a._float64_1;\n\n  function is(x) {\n    return typeof x === 'number';\n  }\n\n  IntTuple.is = is;\n\n  function create(fst, snd) {\n    _int32[0] = fst;\n    _int32[1] = snd;\n    return _float64[0];\n  }\n\n  IntTuple.create = create;\n  /** snd - fst */\n\n  function diff(t) {\n    _float64[0] = t;\n    return _int32[1] - _int32[0];\n  }\n\n  IntTuple.diff = diff;\n\n  function fst(t) {\n    _float64[0] = t;\n    return _int32[0];\n  }\n\n  IntTuple.fst = fst;\n\n  function snd(t) {\n    _float64[0] = t;\n    return _int32[1];\n  }\n\n  IntTuple.snd = snd;\n  /** Normal equality does not work, because NaN === NaN ~> false */\n\n  function areEqual(a, b) {\n    _float64[0] = a;\n    _float64_1[0] = b;\n    return _int32[0] === _int32_1[0] && _int32[1] === _int32_1[1];\n  }\n\n  IntTuple.areEqual = areEqual;\n\n  function compare(a, b) {\n    _float64[0] = a;\n    _float64_1[0] = b;\n    var x = _int32[0] - _int32_1[0];\n    if (x !== 0) return x;\n    return _int32[1] - _int32_1[1];\n  }\n\n  IntTuple.compare = compare;\n\n  function compareInArray(xs, i, j) {\n    _float64[0] = xs[i];\n    _float64_1[0] = xs[j];\n    var x = _int32[0] - _int32_1[0];\n    if (x !== 0) return x;\n    return _int32[1] - _int32_1[1];\n  }\n\n  IntTuple.compareInArray = compareInArray;\n\n  function hashCode(t) {\n    _float64[0] = t;\n    return hash2(_int32[0], _int32[1]);\n  }\n\n  IntTuple.hashCode = hashCode;\n\n  function toString(t) {\n    _float64[0] = t;\n    return \"(\" + _int32[0] + \", \" + _int32[1] + \")\";\n  }\n\n  IntTuple.toString = toString;\n})(IntTuple || (IntTuple = {}));\n\nexport { IntTuple };","map":{"version":3,"sources":["../../../src/mol-data/int/tuple.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { hash2 } from '../util';\r\nvar IntTuple;\r\n(function (IntTuple) {\r\n    IntTuple.Zero = 0;\r\n    var _a = (function () {\r\n        var data = new ArrayBuffer(8);\r\n        var data_1 = new ArrayBuffer(8);\r\n        return {\r\n            _int32: new Int32Array(data),\r\n            _float64: new Float64Array(data),\r\n            _int32_1: new Int32Array(data_1),\r\n            _float64_1: new Float64Array(data_1)\r\n        };\r\n    }()), _int32 = _a._int32, _float64 = _a._float64, _int32_1 = _a._int32_1, _float64_1 = _a._float64_1;\r\n    function is(x) {\r\n        return typeof x === 'number';\r\n    }\r\n    IntTuple.is = is;\r\n    function create(fst, snd) {\r\n        _int32[0] = fst;\r\n        _int32[1] = snd;\r\n        return _float64[0];\r\n    }\r\n    IntTuple.create = create;\r\n    /** snd - fst */\r\n    function diff(t) {\r\n        _float64[0] = t;\r\n        return _int32[1] - _int32[0];\r\n    }\r\n    IntTuple.diff = diff;\r\n    function fst(t) {\r\n        _float64[0] = t;\r\n        return _int32[0];\r\n    }\r\n    IntTuple.fst = fst;\r\n    function snd(t) {\r\n        _float64[0] = t;\r\n        return _int32[1];\r\n    }\r\n    IntTuple.snd = snd;\r\n    /** Normal equality does not work, because NaN === NaN ~> false */\r\n    function areEqual(a, b) {\r\n        _float64[0] = a;\r\n        _float64_1[0] = b;\r\n        return _int32[0] === _int32_1[0] && _int32[1] === _int32_1[1];\r\n    }\r\n    IntTuple.areEqual = areEqual;\r\n    function compare(a, b) {\r\n        _float64[0] = a;\r\n        _float64_1[0] = b;\r\n        var x = _int32[0] - _int32_1[0];\r\n        if (x !== 0)\r\n            return x;\r\n        return _int32[1] - _int32_1[1];\r\n    }\r\n    IntTuple.compare = compare;\r\n    function compareInArray(xs, i, j) {\r\n        _float64[0] = xs[i];\r\n        _float64_1[0] = xs[j];\r\n        var x = _int32[0] - _int32_1[0];\r\n        if (x !== 0)\r\n            return x;\r\n        return _int32[1] - _int32_1[1];\r\n    }\r\n    IntTuple.compareInArray = compareInArray;\r\n    function hashCode(t) {\r\n        _float64[0] = t;\r\n        return hash2(_int32[0], _int32[1]);\r\n    }\r\n    IntTuple.hashCode = hashCode;\r\n    function toString(t) {\r\n        _float64[0] = t;\r\n        return \"(\" + _int32[0] + \", \" + _int32[1] + \")\";\r\n    }\r\n    IntTuple.toString = toString;\r\n})(IntTuple || (IntTuple = {}));\r\nexport { IntTuple };\r\n//# sourceMappingURL=tuple.js.map"]},"metadata":{},"sourceType":"module"}