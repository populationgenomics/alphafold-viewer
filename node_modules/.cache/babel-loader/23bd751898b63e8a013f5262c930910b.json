{"ast":null,"code":"/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * From CIFTools.js\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { IsNativeEndianLittle, flipByteOrder } from '../binary';\n/**\r\n * Fixed point, delta, RLE, integer packing adopted from https://github.com/rcsb/mmtf-javascript/\r\n * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016\r\n */\n\nexport function decode(data) {\n  var current = data.data;\n\n  for (var i = data.encoding.length - 1; i >= 0; i--) {\n    current = decodeStep(current, data.encoding[i]);\n  }\n\n  return current;\n}\n\nfunction decodeStep(data, encoding) {\n  switch (encoding.kind) {\n    case 'ByteArray':\n      {\n        switch (encoding.type) {\n          case 4\n          /* Uint8 */\n          :\n            return data;\n\n          case 1\n          /* Int8 */\n          :\n            return int8(data);\n\n          case 2\n          /* Int16 */\n          :\n            return int16(data);\n\n          case 5\n          /* Uint16 */\n          :\n            return uint16(data);\n\n          case 3\n          /* Int32 */\n          :\n            return int32(data);\n\n          case 6\n          /* Uint32 */\n          :\n            return uint32(data);\n\n          case 32\n          /* Float32 */\n          :\n            return float32(data);\n\n          case 33\n          /* Float64 */\n          :\n            return float64(data);\n\n          default:\n            throw new Error('Unsupported ByteArray type.');\n        }\n      }\n\n    case 'FixedPoint':\n      return fixedPoint(data, encoding);\n\n    case 'IntervalQuantization':\n      return intervalQuantization(data, encoding);\n\n    case 'RunLength':\n      return runLength(data, encoding);\n\n    case 'Delta':\n      return delta(data, encoding);\n\n    case 'IntegerPacking':\n      return integerPacking(data, encoding);\n\n    case 'StringArray':\n      return stringArray(data, encoding);\n  }\n}\n\nfunction getIntArray(type, size) {\n  switch (type) {\n    case 1\n    /* Int8 */\n    :\n      return new Int8Array(size);\n\n    case 2\n    /* Int16 */\n    :\n      return new Int16Array(size);\n\n    case 3\n    /* Int32 */\n    :\n      return new Int32Array(size);\n\n    case 4\n    /* Uint8 */\n    :\n      return new Uint8Array(size);\n\n    case 5\n    /* Uint16 */\n    :\n      return new Uint16Array(size);\n\n    case 6\n    /* Uint32 */\n    :\n      return new Uint32Array(size);\n\n    default:\n      throw new Error('Unsupported integer data type.');\n  }\n}\n\nfunction getFloatArray(type, size) {\n  switch (type) {\n    case 32\n    /* Float32 */\n    :\n      return new Float32Array(size);\n\n    case 33\n    /* Float64 */\n    :\n      return new Float64Array(size);\n\n    default:\n      throw new Error('Unsupported floating data type.');\n  }\n}\n\nfunction int8(data) {\n  return new Int8Array(data.buffer, data.byteOffset);\n}\n\nfunction view(data, byteSize, c) {\n  if (IsNativeEndianLittle) return new c(data.buffer);\n  return new c(flipByteOrder(data, byteSize));\n}\n\nfunction int16(data) {\n  return view(data, 2, Int16Array);\n}\n\nfunction uint16(data) {\n  return view(data, 2, Uint16Array);\n}\n\nfunction int32(data) {\n  return view(data, 4, Int32Array);\n}\n\nfunction uint32(data) {\n  return view(data, 4, Uint32Array);\n}\n\nfunction float32(data) {\n  return view(data, 4, Float32Array);\n}\n\nfunction float64(data) {\n  return view(data, 8, Float64Array);\n}\n\nfunction fixedPoint(data, encoding) {\n  var n = data.length;\n  var output = getFloatArray(encoding.srcType, n);\n  var f = 1 / encoding.factor;\n\n  for (var i = 0; i < n; i++) {\n    output[i] = f * data[i];\n  }\n\n  return output;\n}\n\nfunction intervalQuantization(data, encoding) {\n  var n = data.length;\n  var output = getFloatArray(encoding.srcType, n);\n  var delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);\n  var min = encoding.min;\n\n  for (var i = 0; i < n; i++) {\n    output[i] = min + delta * data[i];\n  }\n\n  return output;\n}\n\nfunction runLength(data, encoding) {\n  var output = getIntArray(encoding.srcType, encoding.srcSize);\n  var dataOffset = 0;\n\n  for (var i = 0, il = data.length; i < il; i += 2) {\n    var value = data[i]; // value to be repeated\n\n    var length_1 = data[i + 1]; // number of repeats\n\n    for (var j = 0; j < length_1; ++j) {\n      output[dataOffset++] = value;\n    }\n  }\n\n  return output;\n}\n\nfunction delta(data, encoding) {\n  var n = data.length;\n  var output = getIntArray(encoding.srcType, n);\n  if (!n) return data;\n  output[0] = data[0] + (encoding.origin | 0);\n\n  for (var i = 1; i < n; ++i) {\n    output[i] = data[i] + output[i - 1];\n  }\n\n  return output;\n}\n\nfunction integerPackingSigned(data, encoding) {\n  var upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;\n  var lowerLimit = -upperLimit - 1;\n  var n = data.length;\n  var output = new Int32Array(encoding.srcSize);\n  var i = 0;\n  var j = 0;\n\n  while (i < n) {\n    var value = 0,\n        t = data[i];\n\n    while (t === upperLimit || t === lowerLimit) {\n      value += t;\n      i++;\n      t = data[i];\n    }\n\n    value += t;\n    output[j] = value;\n    i++;\n    j++;\n  }\n\n  return output;\n}\n\nfunction integerPackingUnsigned(data, encoding) {\n  var upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;\n  var n = data.length;\n  var output = new Int32Array(encoding.srcSize);\n  var i = 0;\n  var j = 0;\n\n  while (i < n) {\n    var value = 0,\n        t = data[i];\n\n    while (t === upperLimit) {\n      value += t;\n      i++;\n      t = data[i];\n    }\n\n    value += t;\n    output[j] = value;\n    i++;\n    j++;\n  }\n\n  return output;\n}\n\nfunction integerPacking(data, encoding) {\n  if (data.length === encoding.srcSize) return data;\n  return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);\n}\n\nfunction stringArray(data, encoding) {\n  var offsets = decode({\n    encoding: encoding.offsetEncoding,\n    data: encoding.offsets\n  });\n  var indices = decode({\n    encoding: encoding.dataEncoding,\n    data: data\n  });\n  var str = encoding.stringData;\n  var strings = new Array(offsets.length);\n  strings[0] = '';\n\n  for (var i = 1, _i = offsets.length; i < _i; i++) {\n    strings[i] = str.substring(offsets[i - 1], offsets[i]);\n  }\n\n  var offset = 0;\n  var result = new Array(indices.length);\n\n  for (var i = 0, _i = indices.length; i < _i; i++) {\n    result[offset++] = strings[indices[i] + 1];\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../../src/mol-io/common/binary-cif/decoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * From CIFTools.js\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { IsNativeEndianLittle, flipByteOrder } from '../binary';\r\n/**\r\n * Fixed point, delta, RLE, integer packing adopted from https://github.com/rcsb/mmtf-javascript/\r\n * by Alexander Rose <alexander.rose@weirdbyte.de>, MIT License, Copyright (c) 2016\r\n */\r\nexport function decode(data) {\r\n    var current = data.data;\r\n    for (var i = data.encoding.length - 1; i >= 0; i--) {\r\n        current = decodeStep(current, data.encoding[i]);\r\n    }\r\n    return current;\r\n}\r\nfunction decodeStep(data, encoding) {\r\n    switch (encoding.kind) {\r\n        case 'ByteArray': {\r\n            switch (encoding.type) {\r\n                case 4 /* Uint8 */: return data;\r\n                case 1 /* Int8 */: return int8(data);\r\n                case 2 /* Int16 */: return int16(data);\r\n                case 5 /* Uint16 */: return uint16(data);\r\n                case 3 /* Int32 */: return int32(data);\r\n                case 6 /* Uint32 */: return uint32(data);\r\n                case 32 /* Float32 */: return float32(data);\r\n                case 33 /* Float64 */: return float64(data);\r\n                default: throw new Error('Unsupported ByteArray type.');\r\n            }\r\n        }\r\n        case 'FixedPoint': return fixedPoint(data, encoding);\r\n        case 'IntervalQuantization': return intervalQuantization(data, encoding);\r\n        case 'RunLength': return runLength(data, encoding);\r\n        case 'Delta': return delta(data, encoding);\r\n        case 'IntegerPacking': return integerPacking(data, encoding);\r\n        case 'StringArray': return stringArray(data, encoding);\r\n    }\r\n}\r\nfunction getIntArray(type, size) {\r\n    switch (type) {\r\n        case 1 /* Int8 */: return new Int8Array(size);\r\n        case 2 /* Int16 */: return new Int16Array(size);\r\n        case 3 /* Int32 */: return new Int32Array(size);\r\n        case 4 /* Uint8 */: return new Uint8Array(size);\r\n        case 5 /* Uint16 */: return new Uint16Array(size);\r\n        case 6 /* Uint32 */: return new Uint32Array(size);\r\n        default: throw new Error('Unsupported integer data type.');\r\n    }\r\n}\r\nfunction getFloatArray(type, size) {\r\n    switch (type) {\r\n        case 32 /* Float32 */: return new Float32Array(size);\r\n        case 33 /* Float64 */: return new Float64Array(size);\r\n        default: throw new Error('Unsupported floating data type.');\r\n    }\r\n}\r\nfunction int8(data) { return new Int8Array(data.buffer, data.byteOffset); }\r\nfunction view(data, byteSize, c) {\r\n    if (IsNativeEndianLittle)\r\n        return new c(data.buffer);\r\n    return new c(flipByteOrder(data, byteSize));\r\n}\r\nfunction int16(data) { return view(data, 2, Int16Array); }\r\nfunction uint16(data) { return view(data, 2, Uint16Array); }\r\nfunction int32(data) { return view(data, 4, Int32Array); }\r\nfunction uint32(data) { return view(data, 4, Uint32Array); }\r\nfunction float32(data) { return view(data, 4, Float32Array); }\r\nfunction float64(data) { return view(data, 8, Float64Array); }\r\nfunction fixedPoint(data, encoding) {\r\n    var n = data.length;\r\n    var output = getFloatArray(encoding.srcType, n);\r\n    var f = 1 / encoding.factor;\r\n    for (var i = 0; i < n; i++) {\r\n        output[i] = f * data[i];\r\n    }\r\n    return output;\r\n}\r\nfunction intervalQuantization(data, encoding) {\r\n    var n = data.length;\r\n    var output = getFloatArray(encoding.srcType, n);\r\n    var delta = (encoding.max - encoding.min) / (encoding.numSteps - 1);\r\n    var min = encoding.min;\r\n    for (var i = 0; i < n; i++) {\r\n        output[i] = min + delta * data[i];\r\n    }\r\n    return output;\r\n}\r\nfunction runLength(data, encoding) {\r\n    var output = getIntArray(encoding.srcType, encoding.srcSize);\r\n    var dataOffset = 0;\r\n    for (var i = 0, il = data.length; i < il; i += 2) {\r\n        var value = data[i]; // value to be repeated\r\n        var length_1 = data[i + 1]; // number of repeats\r\n        for (var j = 0; j < length_1; ++j) {\r\n            output[dataOffset++] = value;\r\n        }\r\n    }\r\n    return output;\r\n}\r\nfunction delta(data, encoding) {\r\n    var n = data.length;\r\n    var output = getIntArray(encoding.srcType, n);\r\n    if (!n)\r\n        return data;\r\n    output[0] = data[0] + (encoding.origin | 0);\r\n    for (var i = 1; i < n; ++i) {\r\n        output[i] = data[i] + output[i - 1];\r\n    }\r\n    return output;\r\n}\r\nfunction integerPackingSigned(data, encoding) {\r\n    var upperLimit = encoding.byteCount === 1 ? 0x7F : 0x7FFF;\r\n    var lowerLimit = -upperLimit - 1;\r\n    var n = data.length;\r\n    var output = new Int32Array(encoding.srcSize);\r\n    var i = 0;\r\n    var j = 0;\r\n    while (i < n) {\r\n        var value = 0, t = data[i];\r\n        while (t === upperLimit || t === lowerLimit) {\r\n            value += t;\r\n            i++;\r\n            t = data[i];\r\n        }\r\n        value += t;\r\n        output[j] = value;\r\n        i++;\r\n        j++;\r\n    }\r\n    return output;\r\n}\r\nfunction integerPackingUnsigned(data, encoding) {\r\n    var upperLimit = encoding.byteCount === 1 ? 0xFF : 0xFFFF;\r\n    var n = data.length;\r\n    var output = new Int32Array(encoding.srcSize);\r\n    var i = 0;\r\n    var j = 0;\r\n    while (i < n) {\r\n        var value = 0, t = data[i];\r\n        while (t === upperLimit) {\r\n            value += t;\r\n            i++;\r\n            t = data[i];\r\n        }\r\n        value += t;\r\n        output[j] = value;\r\n        i++;\r\n        j++;\r\n    }\r\n    return output;\r\n}\r\nfunction integerPacking(data, encoding) {\r\n    if (data.length === encoding.srcSize)\r\n        return data;\r\n    return encoding.isUnsigned ? integerPackingUnsigned(data, encoding) : integerPackingSigned(data, encoding);\r\n}\r\nfunction stringArray(data, encoding) {\r\n    var offsets = decode({ encoding: encoding.offsetEncoding, data: encoding.offsets });\r\n    var indices = decode({ encoding: encoding.dataEncoding, data: data });\r\n    var str = encoding.stringData;\r\n    var strings = new Array(offsets.length);\r\n    strings[0] = '';\r\n    for (var i = 1, _i = offsets.length; i < _i; i++) {\r\n        strings[i] = str.substring(offsets[i - 1], offsets[i]);\r\n    }\r\n    var offset = 0;\r\n    var result = new Array(indices.length);\r\n    for (var i = 0, _i = indices.length; i < _i; i++) {\r\n        result[offset++] = strings[indices[i] + 1];\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=decoder.js.map"]},"metadata":{},"sourceType":"module"}