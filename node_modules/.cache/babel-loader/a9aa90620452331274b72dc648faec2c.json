{"ast":null,"code":"/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { Unit } from '../../structure/structure';\nimport { align } from './alignment';\nimport { OrderedSet } from '../../../mol-data/int';\nexport { AlignSequences };\nvar AlignSequences;\n\n(function (AlignSequences) {\n  function createSeqIdIndicesMap(element) {\n    var seqIds = new Map();\n\n    if (Unit.isAtomic(element.unit)) {\n      var label_seq_id = element.unit.model.atomicHierarchy.residues.label_seq_id;\n      var residueIndex = element.unit.residueIndex;\n\n      for (var i = 0, il = OrderedSet.size(element.indices); i < il; ++i) {\n        var uI = OrderedSet.getAt(element.indices, i);\n        var eI = element.unit.elements[uI];\n        var seqId = label_seq_id.value(residueIndex[eI]);\n        if (seqIds.has(seqId)) seqIds.get(seqId).push(uI);else seqIds.set(seqId, [uI]);\n      }\n    } else if (Unit.isCoarse(element.unit)) {\n      var seq_id_begin = (Unit.isSpheres(element.unit) ? element.unit.model.coarseHierarchy.spheres : element.unit.model.coarseHierarchy.gaussians).seq_id_begin;\n\n      for (var i = 0, il = OrderedSet.size(element.indices); i < il; ++i) {\n        var uI = OrderedSet.getAt(element.indices, i);\n        var eI = element.unit.elements[uI];\n        var seqId = seq_id_begin.value(eI);\n        seqIds.set(seqId, [uI]);\n      }\n    }\n\n    return seqIds;\n  }\n\n  function compute(input, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var seqA = getSequence(input.a.unit);\n    var seqB = getSequence(input.b.unit);\n    var seqIdIndicesA = createSeqIdIndicesMap(input.a);\n    var seqIdIndicesB = createSeqIdIndicesMap(input.b);\n    var indicesA = [];\n    var indicesB = [];\n\n    var _a = align(seqA.code.toArray(), seqB.code.toArray(), options),\n        aliA = _a.aliA,\n        aliB = _a.aliB,\n        score = _a.score;\n\n    var seqIdxA = 0,\n        seqIdxB = 0;\n\n    for (var i = 0, il = aliA.length; i < il; ++i) {\n      if (aliA[i] === '-' || aliB[i] === '-') {\n        if (aliA[i] !== '-') seqIdxA += 1;\n        if (aliB[i] !== '-') seqIdxB += 1;\n        continue;\n      }\n\n      var seqIdA = seqA.seqId.value(seqIdxA);\n      var seqIdB = seqB.seqId.value(seqIdxB);\n\n      if (seqIdIndicesA.has(seqIdA) && seqIdIndicesB.has(seqIdB)) {\n        var iA = seqIdIndicesA.get(seqIdA);\n        var iB = seqIdIndicesB.get(seqIdB); // use min length to guard against alternate locations\n\n        for (var j = 0, jl = Math.min(iA.length, iB.length); j < jl; ++j) {\n          indicesA.push(iA[j]);\n          indicesB.push(iB[j]);\n        }\n      }\n\n      seqIdxA += 1, seqIdxB += 1;\n    }\n\n    var outA = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesA), input.a.indices);\n    var outB = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesB), input.b.indices);\n    return {\n      a: {\n        unit: input.a.unit,\n        indices: outA\n      },\n      b: {\n        unit: input.b.unit,\n        indices: outB\n      },\n      score: score\n    };\n  }\n\n  AlignSequences.compute = compute;\n})(AlignSequences || (AlignSequences = {}));\n\nfunction entityKey(unit) {\n  switch (unit.kind) {\n    case 0\n    /* Atomic */\n    :\n      return unit.model.atomicHierarchy.index.getEntityFromChain(unit.chainIndex[unit.elements[0]]);\n\n    case 1\n    /* Spheres */\n    :\n      return unit.model.coarseHierarchy.spheres.entityKey[unit.elements[0]];\n\n    case 2\n    /* Gaussians */\n    :\n      return unit.model.coarseHierarchy.gaussians.entityKey[unit.elements[0]];\n  }\n}\n\nfunction getSequence(unit) {\n  return unit.model.sequence.byEntityKey[entityKey(unit)].sequence;\n}","map":{"version":3,"sources":["../../../../src/mol-model/sequence/alignment/sequence.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { Unit } from '../../structure/structure';\r\nimport { align } from './alignment';\r\nimport { OrderedSet } from '../../../mol-data/int';\r\nexport { AlignSequences };\r\nvar AlignSequences;\r\n(function (AlignSequences) {\r\n    function createSeqIdIndicesMap(element) {\r\n        var seqIds = new Map();\r\n        if (Unit.isAtomic(element.unit)) {\r\n            var label_seq_id = element.unit.model.atomicHierarchy.residues.label_seq_id;\r\n            var residueIndex = element.unit.residueIndex;\r\n            for (var i = 0, il = OrderedSet.size(element.indices); i < il; ++i) {\r\n                var uI = OrderedSet.getAt(element.indices, i);\r\n                var eI = element.unit.elements[uI];\r\n                var seqId = label_seq_id.value(residueIndex[eI]);\r\n                if (seqIds.has(seqId))\r\n                    seqIds.get(seqId).push(uI);\r\n                else\r\n                    seqIds.set(seqId, [uI]);\r\n            }\r\n        }\r\n        else if (Unit.isCoarse(element.unit)) {\r\n            var seq_id_begin = (Unit.isSpheres(element.unit)\r\n                ? element.unit.model.coarseHierarchy.spheres\r\n                : element.unit.model.coarseHierarchy.gaussians).seq_id_begin;\r\n            for (var i = 0, il = OrderedSet.size(element.indices); i < il; ++i) {\r\n                var uI = OrderedSet.getAt(element.indices, i);\r\n                var eI = element.unit.elements[uI];\r\n                var seqId = seq_id_begin.value(eI);\r\n                seqIds.set(seqId, [uI]);\r\n            }\r\n        }\r\n        return seqIds;\r\n    }\r\n    function compute(input, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var seqA = getSequence(input.a.unit);\r\n        var seqB = getSequence(input.b.unit);\r\n        var seqIdIndicesA = createSeqIdIndicesMap(input.a);\r\n        var seqIdIndicesB = createSeqIdIndicesMap(input.b);\r\n        var indicesA = [];\r\n        var indicesB = [];\r\n        var _a = align(seqA.code.toArray(), seqB.code.toArray(), options), aliA = _a.aliA, aliB = _a.aliB, score = _a.score;\r\n        var seqIdxA = 0, seqIdxB = 0;\r\n        for (var i = 0, il = aliA.length; i < il; ++i) {\r\n            if (aliA[i] === '-' || aliB[i] === '-') {\r\n                if (aliA[i] !== '-')\r\n                    seqIdxA += 1;\r\n                if (aliB[i] !== '-')\r\n                    seqIdxB += 1;\r\n                continue;\r\n            }\r\n            var seqIdA = seqA.seqId.value(seqIdxA);\r\n            var seqIdB = seqB.seqId.value(seqIdxB);\r\n            if (seqIdIndicesA.has(seqIdA) && seqIdIndicesB.has(seqIdB)) {\r\n                var iA = seqIdIndicesA.get(seqIdA);\r\n                var iB = seqIdIndicesB.get(seqIdB);\r\n                // use min length to guard against alternate locations\r\n                for (var j = 0, jl = Math.min(iA.length, iB.length); j < jl; ++j) {\r\n                    indicesA.push(iA[j]);\r\n                    indicesB.push(iB[j]);\r\n                }\r\n            }\r\n            seqIdxA += 1, seqIdxB += 1;\r\n        }\r\n        var outA = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesA), input.a.indices);\r\n        var outB = OrderedSet.intersect(OrderedSet.ofSortedArray(indicesB), input.b.indices);\r\n        return {\r\n            a: { unit: input.a.unit, indices: outA },\r\n            b: { unit: input.b.unit, indices: outB },\r\n            score: score\r\n        };\r\n    }\r\n    AlignSequences.compute = compute;\r\n})(AlignSequences || (AlignSequences = {}));\r\nfunction entityKey(unit) {\r\n    switch (unit.kind) {\r\n        case 0 /* Atomic */:\r\n            return unit.model.atomicHierarchy.index.getEntityFromChain(unit.chainIndex[unit.elements[0]]);\r\n        case 1 /* Spheres */:\r\n            return unit.model.coarseHierarchy.spheres.entityKey[unit.elements[0]];\r\n        case 2 /* Gaussians */:\r\n            return unit.model.coarseHierarchy.gaussians.entityKey[unit.elements[0]];\r\n    }\r\n}\r\nfunction getSequence(unit) {\r\n    return unit.model.sequence.byEntityKey[entityKey(unit)].sequence;\r\n}\r\n//# sourceMappingURL=sequence.js.map"]},"metadata":{},"sourceType":"module"}