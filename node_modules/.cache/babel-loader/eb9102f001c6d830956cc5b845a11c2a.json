{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { clamp } from '../mol-math/interpolate';\nimport { fasterExp, fasterLog } from '../mol-math/approx';\nimport { Vec3, Vec4 } from '../mol-math/linear-algebra';\nvar maxFloat = 10000.0; // NOTE same constant is set in shaders\n\nvar floatLogFactor = fasterLog(maxFloat + 1);\n/** encode float logarithmically */\n\nexport function encodeFloatLog(value) {\n  return fasterLog(value + 1) / floatLogFactor;\n}\n/** decode logarithmically encoded float */\n\nexport function decodeFloatLog(value) {\n  return fasterExp(value * floatLogFactor) - 1;\n}\n/** encode float as rgb triplet into array at offset */\n\nexport function encodeFloatRGBtoArray(value, array, offset) {\n  value = clamp(value, 0, 16777216 - 1) + 1;\n  array[offset + 2] = value % 256;\n  value = Math.floor(value / 256);\n  array[offset + 1] = value % 256;\n  value = Math.floor(value / 256);\n  array[offset] = value % 256;\n  return array;\n}\n/** decode float encoded as rgb triplet */\n\nexport function decodeFloatRGB(r, g, b) {\n  return Math.floor(r) * 256 * 256 + Math.floor(g) * 256 + Math.floor(b) - 1;\n}\nvar UnpackDownscale = 255 / 256; // 0..1 -> fraction (excluding 1)\n\nvar PackFactors = Vec3.create(256 * 256 * 256, 256 * 256, 256);\nvar UnpackFactors = Vec4.create(UnpackDownscale / PackFactors[0], UnpackDownscale / PackFactors[1], UnpackDownscale / PackFactors[2], UnpackDownscale / 1);\nvar tmpDepthRGBA = Vec4();\nexport function unpackRGBAToDepth(r, g, b, a) {\n  Vec4.set(tmpDepthRGBA, r / 255, g / 255, b / 255, a / 255);\n  return Vec4.dot(tmpDepthRGBA, UnpackFactors);\n}","map":{"version":3,"sources":["../../src/mol-util/float-packing.ts"],"names":[],"mappings":"AAAA;;;;AAIG;AAEH,SAAS,KAAT,QAAsB,yBAAtB;AACA,SAAS,SAAT,EAAoB,SAApB,QAAqC,oBAArC;AACA,SAAS,IAAT,EAAe,IAAf,QAA2B,4BAA3B;AAGA,IAAM,QAAQ,GAAG,OAAjB,C,CAA0B;;AAC1B,IAAM,cAAc,GAAG,SAAS,CAAC,QAAQ,GAAG,CAAZ,CAAhC;AAEA;;AACA,OAAM,SAAU,cAAV,CAAyB,KAAzB,EAAsC;AAAI,SAAO,SAAS,CAAC,KAAK,GAAG,CAAT,CAAT,GAAuB,cAA9B;AAA+C;AAE/F;;AACA,OAAM,SAAU,cAAV,CAAyB,KAAzB,EAAsC;AAAI,SAAO,SAAS,CAAC,KAAK,GAAG,cAAT,CAAT,GAAoC,CAA3C;AAA+C;AAE/F;;AACA,OAAM,SAAU,qBAAV,CAAgC,KAAhC,EAA+C,KAA/C,EAAmE,MAAnE,EAAiF;AACnF,EAAA,KAAK,GAAG,KAAK,CAAC,KAAD,EAAQ,CAAR,EAAW,WAAW,CAAtB,CAAL,GAAgC,CAAxC;AACA,EAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,KAAK,GAAG,GAA5B;AACA,EAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,GAAnB,CAAR;AACA,EAAA,KAAK,CAAC,MAAM,GAAG,CAAV,CAAL,GAAoB,KAAK,GAAG,GAA5B;AACA,EAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,GAAnB,CAAR;AACA,EAAA,KAAK,CAAC,MAAD,CAAL,GAAgB,KAAK,GAAG,GAAxB;AACA,SAAO,KAAP;AACH;AAED;;AACA,OAAM,SAAU,cAAV,CAAyB,CAAzB,EAAoC,CAApC,EAA+C,CAA/C,EAAwD;AAC1D,SAAQ,IAAI,CAAC,KAAL,CAAW,CAAX,IAAgB,GAAhB,GAAsB,GAAtB,GAA4B,IAAI,CAAC,KAAL,CAAW,CAAX,IAAgB,GAA5C,GAAkD,IAAI,CAAC,KAAL,CAAW,CAAX,CAAnD,GAAoE,CAA3E;AACH;AAED,IAAM,eAAe,GAAG,MAAM,GAA9B,C,CAAmC;;AACnC,IAAM,WAAW,GAAG,IAAI,CAAC,MAAL,CAAY,MAAM,GAAN,GAAY,GAAxB,EAA6B,MAAM,GAAnC,EAAwC,GAAxC,CAApB;AACA,IAAM,aAAa,GAAG,IAAI,CAAC,MAAL,CAClB,eAAe,GAAG,WAAW,CAAC,CAAD,CADX,EAElB,eAAe,GAAG,WAAW,CAAC,CAAD,CAFX,EAGlB,eAAe,GAAG,WAAW,CAAC,CAAD,CAHX,EAIlB,eAAe,GAAG,CAJA,CAAtB;AAOA,IAAM,YAAY,GAAG,IAAI,EAAzB;AACA,OAAM,SAAU,iBAAV,CAA4B,CAA5B,EAAuC,CAAvC,EAAkD,CAAlD,EAA6D,CAA7D,EAAsE;AACxE,EAAA,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,CAAC,GAAG,GAA3B,EAAgC,CAAC,GAAG,GAApC,EAAyC,CAAC,GAAG,GAA7C,EAAkD,CAAC,GAAG,GAAtD;AACA,SAAO,IAAI,CAAC,GAAL,CAAS,YAAT,EAAuB,aAAvB,CAAP;AACH","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { clamp } from '../mol-math/interpolate';\r\nimport { fasterExp, fasterLog } from '../mol-math/approx';\r\nimport { Vec3, Vec4 } from '../mol-math/linear-algebra';\r\nvar maxFloat = 10000.0; // NOTE same constant is set in shaders\r\nvar floatLogFactor = fasterLog(maxFloat + 1);\r\n/** encode float logarithmically */\r\nexport function encodeFloatLog(value) { return fasterLog(value + 1) / floatLogFactor; }\r\n/** decode logarithmically encoded float */\r\nexport function decodeFloatLog(value) { return fasterExp(value * floatLogFactor) - 1; }\r\n/** encode float as rgb triplet into array at offset */\r\nexport function encodeFloatRGBtoArray(value, array, offset) {\r\n    value = clamp(value, 0, 16777216 - 1) + 1;\r\n    array[offset + 2] = value % 256;\r\n    value = Math.floor(value / 256);\r\n    array[offset + 1] = value % 256;\r\n    value = Math.floor(value / 256);\r\n    array[offset] = value % 256;\r\n    return array;\r\n}\r\n/** decode float encoded as rgb triplet */\r\nexport function decodeFloatRGB(r, g, b) {\r\n    return (Math.floor(r) * 256 * 256 + Math.floor(g) * 256 + Math.floor(b)) - 1;\r\n}\r\nvar UnpackDownscale = 255 / 256; // 0..1 -> fraction (excluding 1)\r\nvar PackFactors = Vec3.create(256 * 256 * 256, 256 * 256, 256);\r\nvar UnpackFactors = Vec4.create(UnpackDownscale / PackFactors[0], UnpackDownscale / PackFactors[1], UnpackDownscale / PackFactors[2], UnpackDownscale / 1);\r\nvar tmpDepthRGBA = Vec4();\r\nexport function unpackRGBAToDepth(r, g, b, a) {\r\n    Vec4.set(tmpDepthRGBA, r / 255, g / 255, b / 255, a / 255);\r\n    return Vec4.dot(tmpDepthRGBA, UnpackFactors);\r\n}\r\n//# sourceMappingURL=float-packing.js.map"]},"metadata":{},"sourceType":"module"}