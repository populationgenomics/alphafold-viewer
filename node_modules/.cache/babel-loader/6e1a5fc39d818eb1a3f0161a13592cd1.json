{"ast":null,"code":"/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { Model, Symmetry } from '../../../mol-model/structure';\nimport { ShapeRepresentation } from '../representation';\nimport { Shape } from '../../../mol-model/shape';\nimport { ColorNames } from '../../../mol-util/color/names';\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\nimport { BoxCage } from '../../../mol-geo/primitive/box';\nimport { Mat4, Vec3 } from '../../../mol-math/linear-algebra';\nimport { transformCage, cloneCage } from '../../../mol-geo/primitive/cage';\nimport { Sphere3D } from '../../../mol-math/geometry';\nimport { Representation } from '../../representation';\nvar translate05 = Mat4.fromTranslation(Mat4(), Vec3.create(0.5, 0.5, 0.5));\nvar unitCage = transformCage(cloneCage(BoxCage()), translate05);\nvar tmpRef = Vec3();\nvar tmpTranslate = Mat4();\nvar CellRef = {\n  origin: 'Origin',\n  model: 'Model'\n};\nvar CellAttachment = {\n  corner: 'Corner',\n  center: 'Center'\n};\n\nvar CellParams = __assign(__assign({}, Mesh.Params), {\n  cellColor: PD.Color(ColorNames.orange),\n  cellScale: PD.Numeric(2, {\n    min: 0.1,\n    max: 5,\n    step: 0.1\n  }),\n  ref: PD.Select('model', PD.objectToOptions(CellRef), {\n    isEssential: true\n  }),\n  attachment: PD.Select('corner', PD.objectToOptions(CellAttachment), {\n    isEssential: true\n  })\n});\n\nvar UnitcellVisuals = {\n  'mesh': function (ctx, getParams) {\n    return ShapeRepresentation(getUnitcellShape, Mesh.Utils);\n  }\n};\nexport var UnitcellParams = __assign({}, CellParams);\n\nfunction getUnitcellMesh(data, props, mesh) {\n  var state = MeshBuilder.createState(256, 128, mesh);\n  var fromFractional = data.symmetry.spacegroup.cell.fromFractional;\n  Vec3.copy(tmpRef, data.ref);\n\n  if (props.attachment === 'center') {\n    Vec3.trunc(tmpRef, tmpRef);\n    Vec3.subScalar(tmpRef, tmpRef, 0.5);\n  } else {\n    Vec3.floor(tmpRef, tmpRef);\n  }\n\n  Mat4.fromTranslation(tmpTranslate, tmpRef);\n  var cellCage = transformCage(cloneCage(unitCage), tmpTranslate);\n  var radius = Math.cbrt(data.symmetry.spacegroup.cell.volume) / 300 * props.cellScale;\n  state.currentGroup = 1;\n  MeshBuilder.addCage(state, fromFractional, cellCage, radius, 2, 20);\n  var sphere = Sphere3D.fromDimensionsAndTransform(Sphere3D(), Vec3.unit, fromFractional);\n  Vec3.transformMat4(tmpRef, tmpRef, fromFractional);\n  Sphere3D.translate(sphere, sphere, tmpRef);\n  Sphere3D.expand(sphere, sphere, radius);\n  var m = MeshBuilder.getMesh(state);\n  m.setBoundingSphere(sphere);\n  return m;\n}\n\nfunction getUnitcellShape(ctx, data, props, shape) {\n  var geo = getUnitcellMesh(data, props, shape && shape.geometry);\n  var label = Symmetry.getUnitcellLabel(data.symmetry);\n  return Shape.create(label, data, geo, function () {\n    return props.cellColor;\n  }, function () {\n    return 1;\n  }, function () {\n    return label;\n  });\n} //\n\n\nexport function getUnitcellData(model, symmetry, props) {\n  var ref = Vec3();\n\n  if (props.ref === 'model') {\n    Vec3.transformMat4(ref, Model.getCenter(model), symmetry.spacegroup.cell.toFractional);\n  }\n\n  return {\n    symmetry: symmetry,\n    ref: ref\n  };\n}\nexport function UnitcellRepresentation(ctx, getParams) {\n  return Representation.createMulti('Unit Cell', ctx, getParams, Representation.StateBuilder, UnitcellVisuals);\n}","map":{"version":3,"sources":["../../../../src/mol-repr/shape/model/unitcell.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { Model, Symmetry } from '../../../mol-model/structure';\r\nimport { ShapeRepresentation } from '../representation';\r\nimport { Shape } from '../../../mol-model/shape';\r\nimport { ColorNames } from '../../../mol-util/color/names';\r\nimport { ParamDefinition as PD } from '../../../mol-util/param-definition';\r\nimport { Mesh } from '../../../mol-geo/geometry/mesh/mesh';\r\nimport { MeshBuilder } from '../../../mol-geo/geometry/mesh/mesh-builder';\r\nimport { BoxCage } from '../../../mol-geo/primitive/box';\r\nimport { Mat4, Vec3 } from '../../../mol-math/linear-algebra';\r\nimport { transformCage, cloneCage } from '../../../mol-geo/primitive/cage';\r\nimport { Sphere3D } from '../../../mol-math/geometry';\r\nimport { Representation } from '../../representation';\r\nvar translate05 = Mat4.fromTranslation(Mat4(), Vec3.create(0.5, 0.5, 0.5));\r\nvar unitCage = transformCage(cloneCage(BoxCage()), translate05);\r\nvar tmpRef = Vec3();\r\nvar tmpTranslate = Mat4();\r\nvar CellRef = {\r\n    origin: 'Origin',\r\n    model: 'Model'\r\n};\r\nvar CellAttachment = {\r\n    corner: 'Corner',\r\n    center: 'Center'\r\n};\r\nvar CellParams = __assign(__assign({}, Mesh.Params), { cellColor: PD.Color(ColorNames.orange), cellScale: PD.Numeric(2, { min: 0.1, max: 5, step: 0.1 }), ref: PD.Select('model', PD.objectToOptions(CellRef), { isEssential: true }), attachment: PD.Select('corner', PD.objectToOptions(CellAttachment), { isEssential: true }) });\r\nvar UnitcellVisuals = {\r\n    'mesh': function (ctx, getParams) { return ShapeRepresentation(getUnitcellShape, Mesh.Utils); },\r\n};\r\nexport var UnitcellParams = __assign({}, CellParams);\r\nfunction getUnitcellMesh(data, props, mesh) {\r\n    var state = MeshBuilder.createState(256, 128, mesh);\r\n    var fromFractional = data.symmetry.spacegroup.cell.fromFractional;\r\n    Vec3.copy(tmpRef, data.ref);\r\n    if (props.attachment === 'center') {\r\n        Vec3.trunc(tmpRef, tmpRef);\r\n        Vec3.subScalar(tmpRef, tmpRef, 0.5);\r\n    }\r\n    else {\r\n        Vec3.floor(tmpRef, tmpRef);\r\n    }\r\n    Mat4.fromTranslation(tmpTranslate, tmpRef);\r\n    var cellCage = transformCage(cloneCage(unitCage), tmpTranslate);\r\n    var radius = (Math.cbrt(data.symmetry.spacegroup.cell.volume) / 300) * props.cellScale;\r\n    state.currentGroup = 1;\r\n    MeshBuilder.addCage(state, fromFractional, cellCage, radius, 2, 20);\r\n    var sphere = Sphere3D.fromDimensionsAndTransform(Sphere3D(), Vec3.unit, fromFractional);\r\n    Vec3.transformMat4(tmpRef, tmpRef, fromFractional);\r\n    Sphere3D.translate(sphere, sphere, tmpRef);\r\n    Sphere3D.expand(sphere, sphere, radius);\r\n    var m = MeshBuilder.getMesh(state);\r\n    m.setBoundingSphere(sphere);\r\n    return m;\r\n}\r\nfunction getUnitcellShape(ctx, data, props, shape) {\r\n    var geo = getUnitcellMesh(data, props, shape && shape.geometry);\r\n    var label = Symmetry.getUnitcellLabel(data.symmetry);\r\n    return Shape.create(label, data, geo, function () { return props.cellColor; }, function () { return 1; }, function () { return label; });\r\n}\r\n//\r\nexport function getUnitcellData(model, symmetry, props) {\r\n    var ref = Vec3();\r\n    if (props.ref === 'model') {\r\n        Vec3.transformMat4(ref, Model.getCenter(model), symmetry.spacegroup.cell.toFractional);\r\n    }\r\n    return { symmetry: symmetry, ref: ref };\r\n}\r\nexport function UnitcellRepresentation(ctx, getParams) {\r\n    return Representation.createMulti('Unit Cell', ctx, getParams, Representation.StateBuilder, UnitcellVisuals);\r\n}\r\n//# sourceMappingURL=unitcell.js.map"]},"metadata":{},"sourceType":"module"}