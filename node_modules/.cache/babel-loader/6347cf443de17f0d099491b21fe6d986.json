{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __spreadArray } from \"tslib\";\nimport { Iterator } from '../../../mol-data/iterator';\nimport { ArrayEncoding } from '../../common/binary-cif';\nexport var Field;\n\n(function (Field) {\n  function str(name, value, params) {\n    return {\n      name: name,\n      type: 0\n      /* Str */\n      ,\n      value: value,\n      valueKind: params && params.valueKind,\n      defaultFormat: params && params.encoder ? {\n        encoder: params.encoder\n      } : void 0,\n      shouldInclude: params && params.shouldInclude\n    };\n  }\n\n  Field.str = str;\n\n  function int(name, value, params) {\n    return {\n      name: name,\n      type: 1\n      /* Int */\n      ,\n      value: value,\n      valueKind: params && params.valueKind,\n      defaultFormat: params ? {\n        encoder: params.encoder,\n        typedArray: params.typedArray\n      } : void 0,\n      shouldInclude: params && params.shouldInclude\n    };\n  }\n\n  Field.int = int;\n\n  function float(name, value, params) {\n    return {\n      name: name,\n      type: 2\n      /* Float */\n      ,\n      value: value,\n      valueKind: params && params.valueKind,\n      defaultFormat: params ? {\n        encoder: params.encoder,\n        typedArray: params.typedArray,\n        digitCount: typeof params.digitCount !== 'undefined' ? params.digitCount : void 0\n      } : void 0,\n      shouldInclude: params && params.shouldInclude\n    };\n  }\n\n  Field.float = float;\n\n  function index(name) {\n    return int(name, function (e, d, i) {\n      return i + 1;\n    }, {\n      typedArray: Int32Array,\n      encoder: ArrayEncoding.by(ArrayEncoding.delta).and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking)\n    });\n  }\n\n  Field.index = index;\n\n  var Builder =\n  /** @class */\n  function () {\n    function Builder() {\n      this.fields = [];\n    }\n\n    Builder.prototype.index = function (name) {\n      this.fields.push(Field.index(name));\n      return this;\n    };\n\n    Builder.prototype.str = function (name, value, params) {\n      this.fields.push(Field.str(name, value, params));\n      return this;\n    };\n\n    Builder.prototype.int = function (name, value, params) {\n      this.fields.push(Field.int(name, value, params));\n      return this;\n    };\n\n    Builder.prototype.vec = function (name, values, params) {\n      for (var i = 0; i < values.length; i++) {\n        this.fields.push(Field.int(name + \"[\" + (i + 1) + \"]\", values[i], params));\n      }\n\n      return this;\n    };\n\n    Builder.prototype.float = function (name, value, params) {\n      this.fields.push(Field.float(name, value, params));\n      return this;\n    };\n\n    Builder.prototype.many = function (fields) {\n      for (var i = 0; i < fields.length; i++) this.fields.push(fields[i]);\n\n      return this;\n    };\n\n    Builder.prototype.add = function (field) {\n      this.fields.push(field);\n      return this;\n    };\n\n    Builder.prototype.getFields = function () {\n      return this.fields;\n    };\n\n    return Builder;\n  }();\n\n  Field.Builder = Builder;\n\n  function build() {\n    return new Builder();\n  }\n\n  Field.build = build;\n})(Field || (Field = {}));\n\nexport var Category;\n\n(function (Category) {\n  Category.Empty = {\n    fields: [],\n    source: []\n  };\n\n  function filterOf(directives) {\n    var cat_whitelist = [];\n    var cat_blacklist = [];\n    var field_whitelist = [];\n    var field_blacklist = [];\n\n    for (var _i = 0, _a = directives.split(/[\\r\\n]+/); _i < _a.length; _i++) {\n      var d = _a[_i];\n      d = d.trim(); // allow for empty lines in config\n\n      if (d.length === 0) continue; // let ! denote blacklisted entries\n\n      var blacklist = /^!/.test(d);\n      if (blacklist) d = d.substr(1);\n      var split = d.split(/\\./);\n      var field = split[1];\n      var list = blacklist ? field ? field_blacklist : cat_blacklist : field ? field_whitelist : cat_whitelist;\n      list[list.length] = d; // ensure categories are aware about whitelisted columns\n\n      if (field && !cat_whitelist.includes(split[0])) {\n        cat_whitelist[cat_whitelist.length] = split[0];\n      }\n    }\n\n    var wlcatcol = field_whitelist.map(function (it) {\n      return it.split('.')[0];\n    }); // blacklist has higher priority\n\n    return {\n      includeCategory: function (cat) {\n        // block if category in black\n        if (cat_blacklist.includes(cat)) {\n          return false;\n        } else {\n          // if there is a whitelist, the category has to be explicitly allowed\n          return cat_whitelist.length <= 0 || // otherwise include if whitelist contains category\n          cat_whitelist.indexOf(cat) !== -1;\n        }\n      },\n      includeField: function (cat, field) {\n        // column names are assumed to follow the pattern 'category_name.column_name'\n        var full = cat + '.' + field;\n\n        if (field_blacklist.includes(full)) {\n          return false;\n        } else {\n          // if for this category no whitelist entries exist\n          return !wlcatcol.includes(cat) || // otherwise must be specifically allowed\n          field_whitelist.includes(full);\n        }\n      }\n    };\n  }\n\n  Category.filterOf = filterOf;\n  Category.DefaultFilter = {\n    includeCategory: function (cat) {\n      return true;\n    },\n    includeField: function (cat, field) {\n      return true;\n    }\n  };\n  Category.DefaultFormatter = {\n    getFormat: function (cat, field) {\n      return void 0;\n    }\n  };\n\n  function ofTable(table, indices) {\n    if (indices) {\n      return {\n        fields: cifFieldsFromTableSchema(table._schema),\n        source: [{\n          data: table,\n          rowCount: indices.length,\n          keys: function () {\n            return Iterator.Array(indices);\n          }\n        }]\n      };\n    }\n\n    return {\n      fields: cifFieldsFromTableSchema(table._schema),\n      source: [{\n        data: table,\n        rowCount: table._rowCount\n      }]\n    };\n  }\n\n  Category.ofTable = ofTable;\n})(Category || (Category = {}));\n\nexport var Encoder;\n\n(function (Encoder) {\n  function writeDatabase(encoder, name, database) {\n    encoder.startDataBlock(name);\n\n    var _loop_1 = function (table) {\n      encoder.writeCategory({\n        name: table,\n        instance: function () {\n          return Category.ofTable(database[table]);\n        }\n      });\n    };\n\n    for (var _i = 0, _a = database._tableNames; _i < _a.length; _i++) {\n      var table = _a[_i];\n\n      _loop_1(table);\n    }\n  }\n\n  Encoder.writeDatabase = writeDatabase;\n\n  function writeDatabaseCollection(encoder, collection) {\n    for (var _i = 0, _a = Object.keys(collection); _i < _a.length; _i++) {\n      var name_1 = _a[_i];\n      writeDatabase(encoder, name_1, collection[name_1]);\n    }\n  }\n\n  Encoder.writeDatabaseCollection = writeDatabaseCollection;\n})(Encoder || (Encoder = {}));\n\nfunction columnValue(k) {\n  return function (i, d) {\n    return d[k].value(i);\n  };\n}\n\nfunction columnListValue(k) {\n  return function (i, d) {\n    return d[k].value(i).join(d[k].schema.separator);\n  };\n}\n\nfunction columnTensorValue(k) {\n  var coords = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    coords[_i - 1] = arguments[_i];\n  }\n\n  return function (i, d) {\n    var _a;\n\n    return (_a = d[k].schema.space).get.apply(_a, __spreadArray([d[k].value(i)], coords, false));\n  };\n}\n\nfunction columnValueKind(k) {\n  return function (i, d) {\n    return d[k].valueKind(i);\n  };\n}\n\nfunction getTensorDefinitions(field, space) {\n  var fieldDefinitions = [];\n  var type = 2\n  /* Float */\n  ;\n  var valueKind = columnValueKind(field);\n\n  if (space.rank === 1) {\n    var rows = space.dimensions[0];\n\n    for (var i = 0; i < rows; i++) {\n      var name_2 = field + \"[\" + (i + 1) + \"]\";\n      fieldDefinitions.push({\n        name: name_2,\n        type: type,\n        value: columnTensorValue(field, i),\n        valueKind: valueKind\n      });\n    }\n  } else if (space.rank === 2) {\n    var rows = space.dimensions[0],\n        cols = space.dimensions[1];\n\n    for (var i = 0; i < rows; i++) {\n      for (var j = 0; j < cols; j++) {\n        var name_3 = field + \"[\" + (i + 1) + \"][\" + (j + 1) + \"]\";\n        fieldDefinitions.push({\n          name: name_3,\n          type: type,\n          value: columnTensorValue(field, i, j),\n          valueKind: valueKind\n        });\n      }\n    }\n  } else if (space.rank === 3) {\n    var d0 = space.dimensions[0],\n        d1 = space.dimensions[1],\n        d2 = space.dimensions[2];\n\n    for (var i = 0; i < d0; i++) {\n      for (var j = 0; j < d1; j++) {\n        for (var k = 0; k < d2; k++) {\n          var name_4 = field + \"[\" + (i + 1) + \"][\" + (j + 1) + \"][\" + (k + 1) + \"]\";\n          fieldDefinitions.push({\n            name: name_4,\n            type: type,\n            value: columnTensorValue(field, i, j, k),\n            valueKind: valueKind\n          });\n        }\n      }\n    }\n  } else {\n    throw new Error('Tensors with rank > 3 or rank 0 are currently not supported.');\n  }\n\n  return fieldDefinitions;\n}\n\nfunction cifFieldsFromTableSchema(schema) {\n  var fields = [];\n\n  for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\n    var k = _a[_i];\n    var t = schema[k];\n\n    if (t.valueType === 'int') {\n      fields.push({\n        name: k,\n        type: 1\n        /* Int */\n        ,\n        value: columnValue(k),\n        valueKind: columnValueKind(k)\n      });\n    } else if (t.valueType === 'float') {\n      fields.push({\n        name: k,\n        type: 2\n        /* Float */\n        ,\n        value: columnValue(k),\n        valueKind: columnValueKind(k)\n      });\n    } else if (t.valueType === 'str') {\n      fields.push({\n        name: k,\n        type: 0\n        /* Str */\n        ,\n        value: columnValue(k),\n        valueKind: columnValueKind(k)\n      });\n    } else if (t.valueType === 'list') {\n      fields.push({\n        name: k,\n        type: 0\n        /* Str */\n        ,\n        value: columnListValue(k),\n        valueKind: columnValueKind(k)\n      });\n    } else if (t.valueType === 'tensor') {\n      fields.push.apply(fields, getTensorDefinitions(k, t.space));\n    } else {\n      throw new Error(\"Unknown valueType \" + t.valueType);\n    }\n  }\n\n  return fields;\n}","map":{"version":3,"sources":["../../../../src/mol-io/writer/cif/encoder.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2018 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __spreadArray } from \"tslib\";\r\nimport { Iterator } from '../../../mol-data/iterator';\r\nimport { ArrayEncoding } from '../../common/binary-cif';\r\nexport var Field;\r\n(function (Field) {\r\n    function str(name, value, params) {\r\n        return { name: name, type: 0 /* Str */, value: value, valueKind: params && params.valueKind, defaultFormat: params && params.encoder ? { encoder: params.encoder } : void 0, shouldInclude: params && params.shouldInclude };\r\n    }\r\n    Field.str = str;\r\n    function int(name, value, params) {\r\n        return {\r\n            name: name,\r\n            type: 1 /* Int */,\r\n            value: value,\r\n            valueKind: params && params.valueKind,\r\n            defaultFormat: params ? { encoder: params.encoder, typedArray: params.typedArray } : void 0,\r\n            shouldInclude: params && params.shouldInclude\r\n        };\r\n    }\r\n    Field.int = int;\r\n    function float(name, value, params) {\r\n        return {\r\n            name: name,\r\n            type: 2 /* Float */,\r\n            value: value,\r\n            valueKind: params && params.valueKind,\r\n            defaultFormat: params ? { encoder: params.encoder, typedArray: params.typedArray, digitCount: typeof params.digitCount !== 'undefined' ? params.digitCount : void 0 } : void 0,\r\n            shouldInclude: params && params.shouldInclude\r\n        };\r\n    }\r\n    Field.float = float;\r\n    function index(name) {\r\n        return int(name, function (e, d, i) { return i + 1; }, { typedArray: Int32Array, encoder: ArrayEncoding.by(ArrayEncoding.delta).and(ArrayEncoding.runLength).and(ArrayEncoding.integerPacking) });\r\n    }\r\n    Field.index = index;\r\n    var Builder = /** @class */ (function () {\r\n        function Builder() {\r\n            this.fields = [];\r\n        }\r\n        Builder.prototype.index = function (name) {\r\n            this.fields.push(Field.index(name));\r\n            return this;\r\n        };\r\n        Builder.prototype.str = function (name, value, params) {\r\n            this.fields.push(Field.str(name, value, params));\r\n            return this;\r\n        };\r\n        Builder.prototype.int = function (name, value, params) {\r\n            this.fields.push(Field.int(name, value, params));\r\n            return this;\r\n        };\r\n        Builder.prototype.vec = function (name, values, params) {\r\n            for (var i = 0; i < values.length; i++) {\r\n                this.fields.push(Field.int(name + \"[\" + (i + 1) + \"]\", values[i], params));\r\n            }\r\n            return this;\r\n        };\r\n        Builder.prototype.float = function (name, value, params) {\r\n            this.fields.push(Field.float(name, value, params));\r\n            return this;\r\n        };\r\n        Builder.prototype.many = function (fields) {\r\n            for (var i = 0; i < fields.length; i++)\r\n                this.fields.push(fields[i]);\r\n            return this;\r\n        };\r\n        Builder.prototype.add = function (field) {\r\n            this.fields.push(field);\r\n            return this;\r\n        };\r\n        Builder.prototype.getFields = function () { return this.fields; };\r\n        return Builder;\r\n    }());\r\n    Field.Builder = Builder;\r\n    function build() {\r\n        return new Builder();\r\n    }\r\n    Field.build = build;\r\n})(Field || (Field = {}));\r\nexport var Category;\r\n(function (Category) {\r\n    Category.Empty = { fields: [], source: [] };\r\n    function filterOf(directives) {\r\n        var cat_whitelist = [];\r\n        var cat_blacklist = [];\r\n        var field_whitelist = [];\r\n        var field_blacklist = [];\r\n        for (var _i = 0, _a = directives.split(/[\\r\\n]+/); _i < _a.length; _i++) {\r\n            var d = _a[_i];\r\n            d = d.trim();\r\n            // allow for empty lines in config\r\n            if (d.length === 0)\r\n                continue;\r\n            // let ! denote blacklisted entries\r\n            var blacklist = /^!/.test(d);\r\n            if (blacklist)\r\n                d = d.substr(1);\r\n            var split = d.split(/\\./);\r\n            var field = split[1];\r\n            var list = blacklist ? (field ? field_blacklist : cat_blacklist) : (field ? field_whitelist : cat_whitelist);\r\n            list[list.length] = d;\r\n            // ensure categories are aware about whitelisted columns\r\n            if (field && !cat_whitelist.includes(split[0])) {\r\n                cat_whitelist[cat_whitelist.length] = split[0];\r\n            }\r\n        }\r\n        var wlcatcol = field_whitelist.map(function (it) { return it.split('.')[0]; });\r\n        // blacklist has higher priority\r\n        return {\r\n            includeCategory: function (cat) {\r\n                // block if category in black\r\n                if (cat_blacklist.includes(cat)) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    // if there is a whitelist, the category has to be explicitly allowed\r\n                    return cat_whitelist.length <= 0 ||\r\n                        // otherwise include if whitelist contains category\r\n                        cat_whitelist.indexOf(cat) !== -1;\r\n                }\r\n            },\r\n            includeField: function (cat, field) {\r\n                // column names are assumed to follow the pattern 'category_name.column_name'\r\n                var full = cat + '.' + field;\r\n                if (field_blacklist.includes(full)) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    // if for this category no whitelist entries exist\r\n                    return !wlcatcol.includes(cat) ||\r\n                        // otherwise must be specifically allowed\r\n                        field_whitelist.includes(full);\r\n                }\r\n            }\r\n        };\r\n    }\r\n    Category.filterOf = filterOf;\r\n    Category.DefaultFilter = {\r\n        includeCategory: function (cat) { return true; },\r\n        includeField: function (cat, field) { return true; }\r\n    };\r\n    Category.DefaultFormatter = {\r\n        getFormat: function (cat, field) { return void 0; }\r\n    };\r\n    function ofTable(table, indices) {\r\n        if (indices) {\r\n            return {\r\n                fields: cifFieldsFromTableSchema(table._schema),\r\n                source: [{ data: table, rowCount: indices.length, keys: function () { return Iterator.Array(indices); } }]\r\n            };\r\n        }\r\n        return {\r\n            fields: cifFieldsFromTableSchema(table._schema),\r\n            source: [{ data: table, rowCount: table._rowCount }]\r\n        };\r\n    }\r\n    Category.ofTable = ofTable;\r\n})(Category || (Category = {}));\r\nexport var Encoder;\r\n(function (Encoder) {\r\n    function writeDatabase(encoder, name, database) {\r\n        encoder.startDataBlock(name);\r\n        var _loop_1 = function (table) {\r\n            encoder.writeCategory({ name: table, instance: function () { return Category.ofTable(database[table]); } });\r\n        };\r\n        for (var _i = 0, _a = database._tableNames; _i < _a.length; _i++) {\r\n            var table = _a[_i];\r\n            _loop_1(table);\r\n        }\r\n    }\r\n    Encoder.writeDatabase = writeDatabase;\r\n    function writeDatabaseCollection(encoder, collection) {\r\n        for (var _i = 0, _a = Object.keys(collection); _i < _a.length; _i++) {\r\n            var name_1 = _a[_i];\r\n            writeDatabase(encoder, name_1, collection[name_1]);\r\n        }\r\n    }\r\n    Encoder.writeDatabaseCollection = writeDatabaseCollection;\r\n})(Encoder || (Encoder = {}));\r\nfunction columnValue(k) {\r\n    return function (i, d) { return d[k].value(i); };\r\n}\r\nfunction columnListValue(k) {\r\n    return function (i, d) { return d[k].value(i).join(d[k].schema.separator); };\r\n}\r\nfunction columnTensorValue(k) {\r\n    var coords = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        coords[_i - 1] = arguments[_i];\r\n    }\r\n    return function (i, d) {\r\n        var _a;\r\n        return (_a = d[k].schema.space).get.apply(_a, __spreadArray([d[k].value(i)], coords, false));\r\n    };\r\n}\r\nfunction columnValueKind(k) {\r\n    return function (i, d) { return d[k].valueKind(i); };\r\n}\r\nfunction getTensorDefinitions(field, space) {\r\n    var fieldDefinitions = [];\r\n    var type = 2 /* Float */;\r\n    var valueKind = columnValueKind(field);\r\n    if (space.rank === 1) {\r\n        var rows = space.dimensions[0];\r\n        for (var i = 0; i < rows; i++) {\r\n            var name_2 = field + \"[\" + (i + 1) + \"]\";\r\n            fieldDefinitions.push({ name: name_2, type: type, value: columnTensorValue(field, i), valueKind: valueKind });\r\n        }\r\n    }\r\n    else if (space.rank === 2) {\r\n        var rows = space.dimensions[0], cols = space.dimensions[1];\r\n        for (var i = 0; i < rows; i++) {\r\n            for (var j = 0; j < cols; j++) {\r\n                var name_3 = field + \"[\" + (i + 1) + \"][\" + (j + 1) + \"]\";\r\n                fieldDefinitions.push({ name: name_3, type: type, value: columnTensorValue(field, i, j), valueKind: valueKind });\r\n            }\r\n        }\r\n    }\r\n    else if (space.rank === 3) {\r\n        var d0 = space.dimensions[0], d1 = space.dimensions[1], d2 = space.dimensions[2];\r\n        for (var i = 0; i < d0; i++) {\r\n            for (var j = 0; j < d1; j++) {\r\n                for (var k = 0; k < d2; k++) {\r\n                    var name_4 = field + \"[\" + (i + 1) + \"][\" + (j + 1) + \"][\" + (k + 1) + \"]\";\r\n                    fieldDefinitions.push({ name: name_4, type: type, value: columnTensorValue(field, i, j, k), valueKind: valueKind });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        throw new Error('Tensors with rank > 3 or rank 0 are currently not supported.');\r\n    }\r\n    return fieldDefinitions;\r\n}\r\nfunction cifFieldsFromTableSchema(schema) {\r\n    var fields = [];\r\n    for (var _i = 0, _a = Object.keys(schema); _i < _a.length; _i++) {\r\n        var k = _a[_i];\r\n        var t = schema[k];\r\n        if (t.valueType === 'int') {\r\n            fields.push({ name: k, type: 1 /* Int */, value: columnValue(k), valueKind: columnValueKind(k) });\r\n        }\r\n        else if (t.valueType === 'float') {\r\n            fields.push({ name: k, type: 2 /* Float */, value: columnValue(k), valueKind: columnValueKind(k) });\r\n        }\r\n        else if (t.valueType === 'str') {\r\n            fields.push({ name: k, type: 0 /* Str */, value: columnValue(k), valueKind: columnValueKind(k) });\r\n        }\r\n        else if (t.valueType === 'list') {\r\n            fields.push({ name: k, type: 0 /* Str */, value: columnListValue(k), valueKind: columnValueKind(k) });\r\n        }\r\n        else if (t.valueType === 'tensor') {\r\n            fields.push.apply(fields, getTensorDefinitions(k, t.space));\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown valueType \" + t.valueType);\r\n        }\r\n    }\r\n    return fields;\r\n}\r\n//# sourceMappingURL=encoder.js.map"]},"metadata":{},"sourceType":"module"}