{"ast":null,"code":"/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { SortedArray } from '../../../../mol-data/int';\nimport { CifWriter } from '../../../../mol-io/writer/cif';\nimport { getInterBondOrderFromTable } from '../../../../mol-model/structure/model/properties/atomic/bonds';\nimport { FormatPropertyProvider } from '../../common/property';\nexport var StructConn;\n\n(function (StructConn) {\n  StructConn.Descriptor = {\n    name: 'struct_conn',\n    cifExport: {\n      prefix: '',\n      categories: [{\n        name: 'struct_conn',\n        instance: function (ctx) {\n          var p = StructConn.Provider.get(ctx.firstModel);\n          if (!p || p.entries.length === 0) return CifWriter.Category.Empty;\n          var structure = ctx.structures[0];\n          var indices = [];\n\n          for (var _a = 0, _b = p.entries; _a < _b.length; _a++) {\n            var e = _b[_a];\n\n            if (hasAtom(structure, e.partnerA.atomIndex) && hasAtom(structure, e.partnerB.atomIndex)) {\n              indices[indices.length] = e.rowIndex;\n            }\n          }\n\n          return CifWriter.Category.ofTable(p.data, indices);\n        }\n      }]\n    }\n  };\n  StructConn.Provider = FormatPropertyProvider.create(StructConn.Descriptor);\n  /**\r\n   * Heuristic to test if StructConn likely provides all atomic bonds by\r\n   * checking if the fraction of bonds and atoms is high (> 0.95).\r\n   */\n\n  function isExhaustive(model) {\n    var structConn = StructConn.Provider.get(model);\n    return !!structConn && structConn.data.id.rowCount / model.atomicConformation.atomId.rowCount > 0.95;\n  }\n\n  StructConn.isExhaustive = isExhaustive;\n\n  function hasAtom(_a, element) {\n    var units = _a.units;\n\n    for (var i = 0, _i = units.length; i < _i; i++) {\n      if (SortedArray.indexOf(units[i].elements, element) >= 0) return true;\n    }\n\n    return false;\n  }\n\n  function getAtomIndexFromEntries(entries) {\n    var m = new Map();\n\n    for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\n      var e = entries_1[_a];\n      var iA = e.partnerA.atomIndex,\n          iB = e.partnerB.atomIndex;\n      if (m.has(iA)) m.get(iA).push(e);else m.set(iA, [e]);\n      if (m.has(iB)) m.get(iB).push(e);else m.set(iB, [e]);\n    }\n\n    return m;\n  }\n\n  StructConn.getAtomIndexFromEntries = getAtomIndexFromEntries;\n\n  function getEntriesFromStructConn(struct_conn, model) {\n    var conn_type_id = struct_conn.conn_type_id,\n        pdbx_dist_value = struct_conn.pdbx_dist_value,\n        pdbx_value_order = struct_conn.pdbx_value_order;\n    var p1 = {\n      label_asym_id: struct_conn.ptnr1_label_asym_id,\n      label_seq_id: struct_conn.ptnr1_label_seq_id,\n      auth_seq_id: struct_conn.ptnr1_auth_seq_id,\n      label_atom_id: struct_conn.ptnr1_label_atom_id,\n      label_alt_id: struct_conn.pdbx_ptnr1_label_alt_id,\n      ins_code: struct_conn.pdbx_ptnr1_PDB_ins_code,\n      symmetry: struct_conn.ptnr1_symmetry\n    };\n    var p2 = {\n      label_asym_id: struct_conn.ptnr2_label_asym_id,\n      label_seq_id: struct_conn.ptnr2_label_seq_id,\n      auth_seq_id: struct_conn.ptnr2_auth_seq_id,\n      label_atom_id: struct_conn.ptnr2_label_atom_id,\n      label_alt_id: struct_conn.pdbx_ptnr2_label_alt_id,\n      ins_code: struct_conn.pdbx_ptnr2_PDB_ins_code,\n      symmetry: struct_conn.ptnr2_symmetry\n    };\n\n    var _p = function (row, ps) {\n      if (ps.label_asym_id.valueKind(row) !== 0\n      /* Present */\n      ) return void 0;\n      var asymId = ps.label_asym_id.value(row);\n      var entityIndex = model.atomicHierarchy.index.findEntity(asymId);\n      if (entityIndex < 0) return void 0;\n      var residueIndex = model.atomicHierarchy.index.findResidue(model.entities.data.id.value(entityIndex), asymId, ps.auth_seq_id.value(row), ps.ins_code.value(row));\n      if (residueIndex < 0) return void 0;\n      var atomName = ps.label_atom_id.value(row); // turns out \"mismat\" records might not have atom name value\n\n      if (!atomName) return void 0;\n      var atomIndex = model.atomicHierarchy.index.findAtomOnResidue(residueIndex, atomName, ps.label_alt_id.value(row));\n      if (atomIndex < 0) return void 0;\n      return {\n        residueIndex: residueIndex,\n        atomIndex: atomIndex,\n        symmetry: ps.symmetry.value(row)\n      };\n    };\n\n    var entries = [];\n\n    for (var i = 0; i < struct_conn._rowCount; i++) {\n      var partnerA = _p(i, p1);\n\n      var partnerB = _p(i, p2);\n\n      if (partnerA === undefined || partnerB === undefined) continue;\n      var type = conn_type_id.value(i);\n      var orderType = (pdbx_value_order.value(i) || '').toLowerCase();\n      var flags = 0\n      /* None */\n      ;\n      var order = 1;\n\n      switch (orderType) {\n        case 'sing':\n          order = 1;\n          break;\n\n        case 'doub':\n          order = 2;\n          break;\n\n        case 'trip':\n          order = 3;\n          break;\n\n        case 'quad':\n          order = 4;\n          break;\n\n        default:\n          order = getInterBondOrderFromTable(struct_conn.ptnr1_label_comp_id.value(i), struct_conn.ptnr1_label_atom_id.value(i), struct_conn.ptnr2_label_comp_id.value(i), struct_conn.ptnr2_label_atom_id.value(i));\n      }\n\n      switch (type) {\n        case 'covale':\n          flags = 1\n          /* Covalent */\n          ;\n          break;\n\n        case 'disulf':\n          flags = 1\n          /* Covalent */\n          | 8\n          /* Disulfide */\n          ;\n          break;\n\n        case 'hydrog':\n          flags = 4\n          /* HydrogenBond */\n          ;\n          break;\n\n        case 'metalc':\n          flags = 2\n          /* MetallicCoordination */\n          ;\n          break;\n      }\n\n      entries.push({\n        rowIndex: i,\n        flags: flags,\n        order: order,\n        distance: pdbx_dist_value.value(i),\n        partnerA: partnerA,\n        partnerB: partnerB\n      });\n    }\n\n    return entries;\n  }\n\n  StructConn.getEntriesFromStructConn = getEntriesFromStructConn;\n})(StructConn || (StructConn = {}));","map":{"version":3,"sources":["../../../../../src/mol-model-formats/structure/property/bonds/struct_conn.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2017-2021 Mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { SortedArray } from '../../../../mol-data/int';\r\nimport { CifWriter } from '../../../../mol-io/writer/cif';\r\nimport { getInterBondOrderFromTable } from '../../../../mol-model/structure/model/properties/atomic/bonds';\r\nimport { FormatPropertyProvider } from '../../common/property';\r\nexport var StructConn;\r\n(function (StructConn) {\r\n    StructConn.Descriptor = {\r\n        name: 'struct_conn',\r\n        cifExport: {\r\n            prefix: '',\r\n            categories: [{\r\n                    name: 'struct_conn',\r\n                    instance: function (ctx) {\r\n                        var p = StructConn.Provider.get(ctx.firstModel);\r\n                        if (!p || p.entries.length === 0)\r\n                            return CifWriter.Category.Empty;\r\n                        var structure = ctx.structures[0];\r\n                        var indices = [];\r\n                        for (var _a = 0, _b = p.entries; _a < _b.length; _a++) {\r\n                            var e = _b[_a];\r\n                            if (hasAtom(structure, e.partnerA.atomIndex) &&\r\n                                hasAtom(structure, e.partnerB.atomIndex)) {\r\n                                indices[indices.length] = e.rowIndex;\r\n                            }\r\n                        }\r\n                        return CifWriter.Category.ofTable(p.data, indices);\r\n                    }\r\n                }]\r\n        }\r\n    };\r\n    StructConn.Provider = FormatPropertyProvider.create(StructConn.Descriptor);\r\n    /**\r\n     * Heuristic to test if StructConn likely provides all atomic bonds by\r\n     * checking if the fraction of bonds and atoms is high (> 0.95).\r\n     */\r\n    function isExhaustive(model) {\r\n        var structConn = StructConn.Provider.get(model);\r\n        return !!structConn && (structConn.data.id.rowCount / model.atomicConformation.atomId.rowCount) > 0.95;\r\n    }\r\n    StructConn.isExhaustive = isExhaustive;\r\n    function hasAtom(_a, element) {\r\n        var units = _a.units;\r\n        for (var i = 0, _i = units.length; i < _i; i++) {\r\n            if (SortedArray.indexOf(units[i].elements, element) >= 0)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getAtomIndexFromEntries(entries) {\r\n        var m = new Map();\r\n        for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {\r\n            var e = entries_1[_a];\r\n            var iA = e.partnerA.atomIndex, iB = e.partnerB.atomIndex;\r\n            if (m.has(iA))\r\n                m.get(iA).push(e);\r\n            else\r\n                m.set(iA, [e]);\r\n            if (m.has(iB))\r\n                m.get(iB).push(e);\r\n            else\r\n                m.set(iB, [e]);\r\n        }\r\n        return m;\r\n    }\r\n    StructConn.getAtomIndexFromEntries = getAtomIndexFromEntries;\r\n    function getEntriesFromStructConn(struct_conn, model) {\r\n        var conn_type_id = struct_conn.conn_type_id, pdbx_dist_value = struct_conn.pdbx_dist_value, pdbx_value_order = struct_conn.pdbx_value_order;\r\n        var p1 = {\r\n            label_asym_id: struct_conn.ptnr1_label_asym_id,\r\n            label_seq_id: struct_conn.ptnr1_label_seq_id,\r\n            auth_seq_id: struct_conn.ptnr1_auth_seq_id,\r\n            label_atom_id: struct_conn.ptnr1_label_atom_id,\r\n            label_alt_id: struct_conn.pdbx_ptnr1_label_alt_id,\r\n            ins_code: struct_conn.pdbx_ptnr1_PDB_ins_code,\r\n            symmetry: struct_conn.ptnr1_symmetry\r\n        };\r\n        var p2 = {\r\n            label_asym_id: struct_conn.ptnr2_label_asym_id,\r\n            label_seq_id: struct_conn.ptnr2_label_seq_id,\r\n            auth_seq_id: struct_conn.ptnr2_auth_seq_id,\r\n            label_atom_id: struct_conn.ptnr2_label_atom_id,\r\n            label_alt_id: struct_conn.pdbx_ptnr2_label_alt_id,\r\n            ins_code: struct_conn.pdbx_ptnr2_PDB_ins_code,\r\n            symmetry: struct_conn.ptnr2_symmetry\r\n        };\r\n        var _p = function (row, ps) {\r\n            if (ps.label_asym_id.valueKind(row) !== 0 /* Present */)\r\n                return void 0;\r\n            var asymId = ps.label_asym_id.value(row);\r\n            var entityIndex = model.atomicHierarchy.index.findEntity(asymId);\r\n            if (entityIndex < 0)\r\n                return void 0;\r\n            var residueIndex = model.atomicHierarchy.index.findResidue(model.entities.data.id.value(entityIndex), asymId, ps.auth_seq_id.value(row), ps.ins_code.value(row));\r\n            if (residueIndex < 0)\r\n                return void 0;\r\n            var atomName = ps.label_atom_id.value(row);\r\n            // turns out \"mismat\" records might not have atom name value\r\n            if (!atomName)\r\n                return void 0;\r\n            var atomIndex = model.atomicHierarchy.index.findAtomOnResidue(residueIndex, atomName, ps.label_alt_id.value(row));\r\n            if (atomIndex < 0)\r\n                return void 0;\r\n            return { residueIndex: residueIndex, atomIndex: atomIndex, symmetry: ps.symmetry.value(row) };\r\n        };\r\n        var entries = [];\r\n        for (var i = 0; i < struct_conn._rowCount; i++) {\r\n            var partnerA = _p(i, p1);\r\n            var partnerB = _p(i, p2);\r\n            if (partnerA === undefined || partnerB === undefined)\r\n                continue;\r\n            var type = conn_type_id.value(i);\r\n            var orderType = (pdbx_value_order.value(i) || '').toLowerCase();\r\n            var flags = 0 /* None */;\r\n            var order = 1;\r\n            switch (orderType) {\r\n                case 'sing':\r\n                    order = 1;\r\n                    break;\r\n                case 'doub':\r\n                    order = 2;\r\n                    break;\r\n                case 'trip':\r\n                    order = 3;\r\n                    break;\r\n                case 'quad':\r\n                    order = 4;\r\n                    break;\r\n                default:\r\n                    order = getInterBondOrderFromTable(struct_conn.ptnr1_label_comp_id.value(i), struct_conn.ptnr1_label_atom_id.value(i), struct_conn.ptnr2_label_comp_id.value(i), struct_conn.ptnr2_label_atom_id.value(i));\r\n            }\r\n            switch (type) {\r\n                case 'covale':\r\n                    flags = 1 /* Covalent */;\r\n                    break;\r\n                case 'disulf':\r\n                    flags = 1 /* Covalent */ | 8 /* Disulfide */;\r\n                    break;\r\n                case 'hydrog':\r\n                    flags = 4 /* HydrogenBond */;\r\n                    break;\r\n                case 'metalc':\r\n                    flags = 2 /* MetallicCoordination */;\r\n                    break;\r\n            }\r\n            entries.push({\r\n                rowIndex: i,\r\n                flags: flags,\r\n                order: order,\r\n                distance: pdbx_dist_value.value(i),\r\n                partnerA: partnerA,\r\n                partnerB: partnerB\r\n            });\r\n        }\r\n        return entries;\r\n    }\r\n    StructConn.getEntriesFromStructConn = getEntriesFromStructConn;\r\n})(StructConn || (StructConn = {}));\r\n//# sourceMappingURL=struct_conn.js.map"]},"metadata":{},"sourceType":"module"}