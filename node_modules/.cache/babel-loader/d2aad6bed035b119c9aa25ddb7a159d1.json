{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\nimport { __assign } from \"tslib\";\nimport { Color } from '../../mol-util/color';\nimport { StructureElement, Bond } from '../../mol-model/structure';\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\nimport { getPaletteParams, getPalette } from '../../mol-util/color/palette';\nimport { integerDigitCount } from '../../mol-util/number';\nimport { ColorLists, getColorListFromName } from '../../mol-util/color/lists';\nvar DefaultList = 'dark-2';\nvar DefaultColor = Color(0xCCCCCC);\nvar Description = \"Assigns a color based on the operator HKL value of a transformed chain.\";\nexport var OperatorHklColorThemeParams = __assign({}, getPaletteParams({\n  type: 'colors',\n  colorList: DefaultList\n}));\nexport function getOperatorHklColorThemeParams(ctx) {\n  var params = PD.clone(OperatorHklColorThemeParams);\n\n  if (ctx.structure) {\n    if (getOperatorHklSerialMap(ctx.structure.root).map.size > ColorLists[DefaultList].list.length) {\n      params.palette.defaultValue.name = 'colors';\n      params.palette.defaultValue.params = __assign(__assign({}, params.palette.defaultValue.params), {\n        list: {\n          kind: 'interpolate',\n          colors: getColorListFromName(DefaultList).list\n        }\n      });\n    }\n  }\n\n  return params;\n}\nvar hklOffset = 10000;\n\nfunction hklKey(hkl) {\n  return hkl.map(function (v) {\n    return (\"\" + (v + hklOffset)).padStart(5, '0');\n  }).join('');\n}\n\nfunction hklKeySplit(key) {\n  var len = integerDigitCount(hklOffset, 0);\n  var h = parseInt(key.substr(0, len));\n  var k = parseInt(key.substr(len, len));\n  var l = parseInt(key.substr(len + len, len));\n  return [h - hklOffset, k - hklOffset, l - hklOffset];\n}\n\nfunction formatHkl(hkl) {\n  return hkl.map(function (v) {\n    return v + 5;\n  }).join('');\n}\n\nfunction getOperatorHklSerialMap(structure) {\n  var map = new Map();\n  var set = new Set();\n\n  for (var i = 0, il = structure.units.length; i < il; ++i) {\n    var k = hklKey(structure.units[i].conformation.operator.hkl);\n    set.add(k);\n  }\n\n  var arr = Array.from(set.values()).sort();\n  arr.forEach(function (k) {\n    return map.set(k, map.size);\n  });\n  var min = hklKeySplit(arr[0]);\n  var max = hklKeySplit(arr[arr.length - 1]);\n  return {\n    min: min,\n    max: max,\n    map: map\n  };\n}\n\nexport function OperatorHklColorTheme(ctx, props) {\n  var color;\n  var legend;\n\n  if (ctx.structure) {\n    var _a = getOperatorHklSerialMap(ctx.structure.root),\n        min = _a.min,\n        max = _a.max,\n        map_1 = _a.map;\n\n    var labelTable_1 = [];\n    map_1.forEach(function (v, k) {\n      var i = v % map_1.size;\n      var label = formatHkl(hklKeySplit(k));\n      if (labelTable_1[i] === undefined) labelTable_1[i] = label;else labelTable_1[i] += \", \" + label;\n    });\n    var labelOptions = {\n      minLabel: formatHkl(min),\n      maxLabel: formatHkl(max),\n      valueLabel: function (i) {\n        return labelTable_1[i];\n      }\n    };\n    var palette_1 = getPalette(map_1.size, props, labelOptions);\n    legend = palette_1.legend;\n\n    color = function (location) {\n      var serial = undefined;\n\n      if (StructureElement.Location.is(location)) {\n        var k = hklKey(location.unit.conformation.operator.hkl);\n        serial = map_1.get(k);\n      } else if (Bond.isLocation(location)) {\n        var k = hklKey(location.aUnit.conformation.operator.hkl);\n        serial = map_1.get(k);\n      }\n\n      return serial === undefined ? DefaultColor : palette_1.color(serial);\n    };\n  } else {\n    color = function () {\n      return DefaultColor;\n    };\n  }\n\n  return {\n    factory: OperatorHklColorTheme,\n    granularity: 'instance',\n    color: color,\n    props: props,\n    description: Description,\n    legend: legend\n  };\n}\nexport var OperatorHklColorThemeProvider = {\n  name: 'operator-hkl',\n  label: 'Operator HKL',\n  category: \"Symmetry\"\n  /* Symmetry */\n  ,\n  factory: OperatorHklColorTheme,\n  getParams: getOperatorHklColorThemeParams,\n  defaultValues: PD.getDefaultValues(OperatorHklColorThemeParams),\n  isApplicable: function (ctx) {\n    return !!ctx.structure;\n  }\n};","map":{"version":3,"sources":["../../../src/mol-theme/color/operator-hkl.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author Alexander Rose <alexander.rose@weirdbyte.de>\r\n */\r\nimport { __assign } from \"tslib\";\r\nimport { Color } from '../../mol-util/color';\r\nimport { StructureElement, Bond } from '../../mol-model/structure';\r\nimport { ParamDefinition as PD } from '../../mol-util/param-definition';\r\nimport { getPaletteParams, getPalette } from '../../mol-util/color/palette';\r\nimport { integerDigitCount } from '../../mol-util/number';\r\nimport { ColorLists, getColorListFromName } from '../../mol-util/color/lists';\r\nvar DefaultList = 'dark-2';\r\nvar DefaultColor = Color(0xCCCCCC);\r\nvar Description = \"Assigns a color based on the operator HKL value of a transformed chain.\";\r\nexport var OperatorHklColorThemeParams = __assign({}, getPaletteParams({ type: 'colors', colorList: DefaultList }));\r\nexport function getOperatorHklColorThemeParams(ctx) {\r\n    var params = PD.clone(OperatorHklColorThemeParams);\r\n    if (ctx.structure) {\r\n        if (getOperatorHklSerialMap(ctx.structure.root).map.size > ColorLists[DefaultList].list.length) {\r\n            params.palette.defaultValue.name = 'colors';\r\n            params.palette.defaultValue.params = __assign(__assign({}, params.palette.defaultValue.params), { list: { kind: 'interpolate', colors: getColorListFromName(DefaultList).list } });\r\n        }\r\n    }\r\n    return params;\r\n}\r\nvar hklOffset = 10000;\r\nfunction hklKey(hkl) {\r\n    return hkl.map(function (v) { return (\"\" + (v + hklOffset)).padStart(5, '0'); }).join('');\r\n}\r\nfunction hklKeySplit(key) {\r\n    var len = integerDigitCount(hklOffset, 0);\r\n    var h = parseInt(key.substr(0, len));\r\n    var k = parseInt(key.substr(len, len));\r\n    var l = parseInt(key.substr(len + len, len));\r\n    return [h - hklOffset, k - hklOffset, l - hklOffset];\r\n}\r\nfunction formatHkl(hkl) {\r\n    return hkl.map(function (v) { return v + 5; }).join('');\r\n}\r\nfunction getOperatorHklSerialMap(structure) {\r\n    var map = new Map();\r\n    var set = new Set();\r\n    for (var i = 0, il = structure.units.length; i < il; ++i) {\r\n        var k = hklKey(structure.units[i].conformation.operator.hkl);\r\n        set.add(k);\r\n    }\r\n    var arr = Array.from(set.values()).sort();\r\n    arr.forEach(function (k) { return map.set(k, map.size); });\r\n    var min = hklKeySplit(arr[0]);\r\n    var max = hklKeySplit(arr[arr.length - 1]);\r\n    return { min: min, max: max, map: map };\r\n}\r\nexport function OperatorHklColorTheme(ctx, props) {\r\n    var color;\r\n    var legend;\r\n    if (ctx.structure) {\r\n        var _a = getOperatorHklSerialMap(ctx.structure.root), min = _a.min, max = _a.max, map_1 = _a.map;\r\n        var labelTable_1 = [];\r\n        map_1.forEach(function (v, k) {\r\n            var i = v % map_1.size;\r\n            var label = formatHkl(hklKeySplit(k));\r\n            if (labelTable_1[i] === undefined)\r\n                labelTable_1[i] = label;\r\n            else\r\n                labelTable_1[i] += \", \" + label;\r\n        });\r\n        var labelOptions = {\r\n            minLabel: formatHkl(min),\r\n            maxLabel: formatHkl(max),\r\n            valueLabel: function (i) { return labelTable_1[i]; }\r\n        };\r\n        var palette_1 = getPalette(map_1.size, props, labelOptions);\r\n        legend = palette_1.legend;\r\n        color = function (location) {\r\n            var serial = undefined;\r\n            if (StructureElement.Location.is(location)) {\r\n                var k = hklKey(location.unit.conformation.operator.hkl);\r\n                serial = map_1.get(k);\r\n            }\r\n            else if (Bond.isLocation(location)) {\r\n                var k = hklKey(location.aUnit.conformation.operator.hkl);\r\n                serial = map_1.get(k);\r\n            }\r\n            return serial === undefined ? DefaultColor : palette_1.color(serial);\r\n        };\r\n    }\r\n    else {\r\n        color = function () { return DefaultColor; };\r\n    }\r\n    return {\r\n        factory: OperatorHklColorTheme,\r\n        granularity: 'instance',\r\n        color: color,\r\n        props: props,\r\n        description: Description,\r\n        legend: legend\r\n    };\r\n}\r\nexport var OperatorHklColorThemeProvider = {\r\n    name: 'operator-hkl',\r\n    label: 'Operator HKL',\r\n    category: \"Symmetry\" /* Symmetry */,\r\n    factory: OperatorHklColorTheme,\r\n    getParams: getOperatorHklColorThemeParams,\r\n    defaultValues: PD.getDefaultValues(OperatorHklColorThemeParams),\r\n    isApplicable: function (ctx) { return !!ctx.structure; }\r\n};\r\n//# sourceMappingURL=operator-hkl.js.map"]},"metadata":{},"sourceType":"module"}