{"ast":null,"code":"/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\nimport { StateTransform } from '../transform';\nexport { StateTreeSpine };\nvar StateTreeSpine;\n\n(function (StateTreeSpine) {\n  var Impl =\n  /** @class */\n  function () {\n    function Impl(cells) {\n      this.cells = cells;\n      this._current = void 0;\n    }\n\n    Object.defineProperty(Impl.prototype, \"current\", {\n      get: function () {\n        return this._current;\n      },\n      set: function (cell) {\n        this._current = cell;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    Impl.prototype.getAncestorOfType = function (t) {\n      if (!this._current) return void 0;\n      var cell = this._current;\n\n      while (true) {\n        cell = this.cells.get(cell.transform.parent);\n        if (!cell.obj) return void 0;\n        if (cell.obj.type === t.type) return cell.obj;\n        if (cell.transform.ref === StateTransform.RootRef) return void 0;\n      }\n    };\n\n    Impl.prototype.getRootOfType = function (t) {\n      if (!this._current) return void 0;\n      var cell = this._current; // check current first\n\n      var ret = void 0;\n\n      while (true) {\n        if (!cell.obj) return void 0;\n\n        if (cell.obj.type === t.type) {\n          ret = cell;\n        }\n\n        if (cell.transform.ref === StateTransform.RootRef) return ret ? ret.obj : void 0;\n        cell = this.cells.get(cell.transform.parent); // assign parent for next check\n      }\n    };\n\n    return Impl;\n  }();\n\n  StateTreeSpine.Impl = Impl;\n\n  function getDecoratorChain(state, currentRef) {\n    var cells = state.cells;\n    var current = cells.get(currentRef);\n    var ret = [current];\n\n    while (current === null || current === void 0 ? void 0 : current.transform.transformer.definition.isDecorator) {\n      current = cells.get(current.transform.parent);\n      ret.push(current);\n    }\n\n    return ret;\n  }\n\n  StateTreeSpine.getDecoratorChain = getDecoratorChain;\n\n  function getRootOfType(state, t, ref) {\n    var ret = void 0;\n    var cell = state.cells.get(ref);\n    if (!cell) return void 0;\n\n    while (true) {\n      if (!cell.obj) return void 0;\n\n      if (cell.obj.type === t.type) {\n        ret = cell;\n      }\n\n      if (cell.transform.ref === StateTransform.RootRef) return ret ? ret.obj : void 0;\n      cell = state.cells.get(cell.transform.parent); // assign parent for next check\n    }\n  }\n\n  StateTreeSpine.getRootOfType = getRootOfType;\n})(StateTreeSpine || (StateTreeSpine = {}));","map":{"version":3,"sources":["../../../src/mol-state/tree/spine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * Copyright (c) 2019 mol* contributors, licensed under MIT, See LICENSE file for more info.\r\n *\r\n * @author David Sehnal <david.sehnal@gmail.com>\r\n */\r\nimport { StateTransform } from '../transform';\r\nexport { StateTreeSpine };\r\nvar StateTreeSpine;\r\n(function (StateTreeSpine) {\r\n    var Impl = /** @class */ (function () {\r\n        function Impl(cells) {\r\n            this.cells = cells;\r\n            this._current = void 0;\r\n        }\r\n        Object.defineProperty(Impl.prototype, \"current\", {\r\n            get: function () { return this._current; },\r\n            set: function (cell) { this._current = cell; },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Impl.prototype.getAncestorOfType = function (t) {\r\n            if (!this._current)\r\n                return void 0;\r\n            var cell = this._current;\r\n            while (true) {\r\n                cell = this.cells.get(cell.transform.parent);\r\n                if (!cell.obj)\r\n                    return void 0;\r\n                if (cell.obj.type === t.type)\r\n                    return cell.obj;\r\n                if (cell.transform.ref === StateTransform.RootRef)\r\n                    return void 0;\r\n            }\r\n        };\r\n        Impl.prototype.getRootOfType = function (t) {\r\n            if (!this._current)\r\n                return void 0;\r\n            var cell = this._current; // check current first\r\n            var ret = void 0;\r\n            while (true) {\r\n                if (!cell.obj)\r\n                    return void 0;\r\n                if (cell.obj.type === t.type) {\r\n                    ret = cell;\r\n                }\r\n                if (cell.transform.ref === StateTransform.RootRef)\r\n                    return ret ? ret.obj : void 0;\r\n                cell = this.cells.get(cell.transform.parent); // assign parent for next check\r\n            }\r\n        };\r\n        return Impl;\r\n    }());\r\n    StateTreeSpine.Impl = Impl;\r\n    function getDecoratorChain(state, currentRef) {\r\n        var cells = state.cells;\r\n        var current = cells.get(currentRef);\r\n        var ret = [current];\r\n        while (current === null || current === void 0 ? void 0 : current.transform.transformer.definition.isDecorator) {\r\n            current = cells.get(current.transform.parent);\r\n            ret.push(current);\r\n        }\r\n        return ret;\r\n    }\r\n    StateTreeSpine.getDecoratorChain = getDecoratorChain;\r\n    function getRootOfType(state, t, ref) {\r\n        var ret = void 0;\r\n        var cell = state.cells.get(ref);\r\n        if (!cell)\r\n            return void 0;\r\n        while (true) {\r\n            if (!cell.obj)\r\n                return void 0;\r\n            if (cell.obj.type === t.type) {\r\n                ret = cell;\r\n            }\r\n            if (cell.transform.ref === StateTransform.RootRef)\r\n                return ret ? ret.obj : void 0;\r\n            cell = state.cells.get(cell.transform.parent); // assign parent for next check\r\n        }\r\n    }\r\n    StateTreeSpine.getRootOfType = getRootOfType;\r\n})(StateTreeSpine || (StateTreeSpine = {}));\r\n//# sourceMappingURL=spine.js.map"]},"metadata":{},"sourceType":"module"}