"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.test = exports.readCIF = void 0;
var tslib_1 = require("tslib");
var util = (0, tslib_1.__importStar)(require("util"));
var fs = (0, tslib_1.__importStar)(require("fs"));
var cif_1 = require("../mol-io/reader/cif");
var structure_1 = require("../mol-model/structure");
var geometry_1 = require("../mol-math/geometry");
// import { sortArray } from 'mol-data/util';
var int_1 = require("../mol-data/int");
var mmcif_1 = require("../mol-model-formats/structure/mmcif");
var boundary_1 = require("../mol-math/geometry/boundary");
require('util.promisify').shim();
var readFileAsync = util.promisify(fs.readFile);
function readData(path) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var input, data, i;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!path.match(/\.bcif$/)) return [3 /*break*/, 2];
                    return [4 /*yield*/, readFileAsync(path)];
                case 1:
                    input = _a.sent();
                    data = new Uint8Array(input.byteLength);
                    for (i = 0; i < input.byteLength; i++)
                        data[i] = input[i];
                    return [2 /*return*/, data];
                case 2: return [2 /*return*/, readFileAsync(path, 'utf8')];
            }
        });
    });
}
function readCIF(path) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var input, comp, parsed, models, structures;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, readData(path)];
                case 1:
                    input = _a.sent();
                    comp = typeof input === 'string' ? cif_1.CIF.parseText(input) : cif_1.CIF.parseBinary(input);
                    return [4 /*yield*/, comp.run()];
                case 2:
                    parsed = _a.sent();
                    if (parsed.isError) {
                        throw parsed;
                    }
                    return [4 /*yield*/, (0, mmcif_1.trajectoryFromMmCIF)(parsed.result.blocks[0]).run()];
                case 3:
                    models = _a.sent();
                    structures = [structure_1.Structure.ofModel(models.representative)];
                    return [2 /*return*/, { mmcif: models.representative.sourceData.data, models: models, structures: structures }];
            }
        });
    });
}
exports.readCIF = readCIF;
function test() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var _a, mmcif, structures, position, lookup, result;
        return (0, tslib_1.__generator)(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, readCIF('e:/test/quick/1tqn_updated.cif')];
                case 1:
                    _a = _b.sent(), mmcif = _a.mmcif, structures = _a.structures;
                    position = { x: mmcif.db.atom_site.Cartn_x.toArray(), y: mmcif.db.atom_site.Cartn_y.toArray(), z: mmcif.db.atom_site.Cartn_z.toArray(),
                        indices: int_1.OrderedSet.ofBounds(0, mmcif.db.atom_site._rowCount),
                        // radius: [1, 1, 1, 1]
                        // indices: [1]
                    };
                    lookup = (0, geometry_1.GridLookup3D)(position, (0, boundary_1.getBoundary)(position));
                    console.log(lookup.boundary.box, lookup.boundary.sphere);
                    result = lookup.find(-30.07, 8.178, -13.897, 10);
                    console.log(result.count); // , sortArray(result.indices));
                    // const sl = structures[0].lookup3d;
                    // const result1 = sl.find(-30.07, 8.178, -13.897, 10);
                    // console.log(result1.count);//, result1.indices);
                    console.log(structures[0].boundary);
                    console.log(lookup.boundary);
                    return [2 /*return*/];
            }
        });
    });
}
exports.test = test;
test();
//# sourceMappingURL=lookup3d.js.map